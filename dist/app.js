webpackJsonp(
    [0],
    [
        /* 0 */
        /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ (function(process) {
                'use strict';
                var platform_browser_dynamic_1 = __webpack_require__(6);
                var core_1 = __webpack_require__(8);
                var app_module_1 = __webpack_require__(28);
                /*
	 Our application code
	*/
                // Turns off assertions and other checks within the framework if we are in production
                if (process.env.ENV === 'prod') {
                    core_1.enableProdMode();
                }
                // Bootstrap
                platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);

                /* WEBPACK VAR INJECTION */
            }.call(exports, __webpack_require__(5)));

            /***/
        },
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        /* 1 */ /* 2 */ /* 3 */ /* 4 */ /* 5 */ /* 6 */ /* 7 */ /* 8 */ /* 9 */ /* 10 */ /* 11 */ /* 12 */ /* 13 */ /* 14 */ /* 15 */ /* 16 */ /* 17 */ /* 18 */ /* 19 */ /* 20 */ /* 21 */ /* 22 */ /* 23 */ /* 24 */ /* 25 */ /* 26 */ /* 27 */ /* 28 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var common_1 = __webpack_require__(27);
            var platform_browser_1 = __webpack_require__(26);
            var http_1 = __webpack_require__(29);
            var forms_1 = __webpack_require__(30);
            var home_component_1 = __webpack_require__(34);
            var about_component_1 = __webpack_require__(40);
            var prospective_players_component_1 = __webpack_require__(44);
            var contact_component_1 = __webpack_require__(50);
            var app_component_1 = __webpack_require__(54);
            var team_module_1 = __webpack_require__(62);
            var history_module_1 = __webpack_require__(152);
            var page_frame_module_1 = __webpack_require__(153);
            var AppModule = (function() {
                function AppModule() {}
                return AppModule;
            })();
            AppModule = __decorate(
                [
                    core_1.NgModule({
                        imports: [
                            platform_browser_1.BrowserModule,
                            http_1.HttpModule,
                            forms_1.FormsModule,
                            // AgmCoreModule.forRoot({
                            //     apiKey: 'AIzaSyBRIXAk5xdvn3ezypsSe55f8dZhcHheAZ8'
                            // }),
                            page_frame_module_1.PageFrameModule,
                            team_module_1.TeamModule,
                            history_module_1.HistoryModule
                        ],
                        declarations: [
                            app_component_1.AppComponent,
                            home_component_1.HomeComponent,
                            about_component_1.AboutComponent,
                            prospective_players_component_1.ProspectivePlayersComponent,
                            contact_component_1.ContactComponent
                        ],
                        // Use hash strategy so page refreshes on Github pages route correctly
                        providers: [{ provide: common_1.LocationStrategy, useClass: common_1.HashLocationStrategy }],
                        bootstrap: [app_component_1.AppComponent]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                AppModule
            );
            exports.AppModule = AppModule;

            /***/
        },
        ,
        /* 29 */ /* 30 */
        /***/ function(module, exports, __webpack_require__) {
            /**
             * @license Angular v2.2.4
             * (c) 2010-2016 Google, Inc. https://angular.io/
             * License: MIT
             */
            (function(global, factory) {
                true
                    ? factory(
                          exports,
                          __webpack_require__(8),
                          __webpack_require__(31),
                          __webpack_require__(9),
                          __webpack_require__(10),
                          __webpack_require__(32)
                      )
                    : typeof define === 'function' && define.amd
                    ? define([
                          'exports',
                          '@angular/core',
                          'rxjs/operator/toPromise',
                          'rxjs/Subject',
                          'rxjs/Observable',
                          'rxjs/observable/fromPromise'
                      ], factory)
                    : factory(
                          ((global.ng = global.ng || {}), (global.ng.forms = global.ng.forms || {})),
                          global.ng.core,
                          global.Rx.Observable.prototype,
                          global.Rx,
                          global.Rx,
                          global.Rx.Observable
                      );
            })(this, function(exports, _angular_core, rxjs_operator_toPromise, rxjs_Subject, rxjs_Observable, rxjs_observable_fromPromise) {
                'use strict';

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * Base class for control directives.
                 *
                 * Only used internally in the forms module.
                 *
                 * @stable
                 */
                var AbstractControlDirective = (function() {
                    function AbstractControlDirective() {}
                    Object.defineProperty(AbstractControlDirective.prototype, 'control', {
                        get: function() {
                            throw new Error('unimplemented');
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'value', {
                        get: function() {
                            return this.control ? this.control.value : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'valid', {
                        get: function() {
                            return this.control ? this.control.valid : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'invalid', {
                        get: function() {
                            return this.control ? this.control.invalid : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'pending', {
                        get: function() {
                            return this.control ? this.control.pending : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'errors', {
                        get: function() {
                            return this.control ? this.control.errors : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'pristine', {
                        get: function() {
                            return this.control ? this.control.pristine : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'dirty', {
                        get: function() {
                            return this.control ? this.control.dirty : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'touched', {
                        get: function() {
                            return this.control ? this.control.touched : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'untouched', {
                        get: function() {
                            return this.control ? this.control.untouched : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'disabled', {
                        get: function() {
                            return this.control ? this.control.disabled : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'enabled', {
                        get: function() {
                            return this.control ? this.control.enabled : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'statusChanges', {
                        get: function() {
                            return this.control ? this.control.statusChanges : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'valueChanges', {
                        get: function() {
                            return this.control ? this.control.valueChanges : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlDirective.prototype, 'path', {
                        get: function() {
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    AbstractControlDirective.prototype.reset = function(value) {
                        if (value === void 0) {
                            value = undefined;
                        }
                        if (this.control) this.control.reset(value);
                    };
                    AbstractControlDirective.prototype.hasError = function(errorCode, path) {
                        if (path === void 0) {
                            path = null;
                        }
                        return this.control ? this.control.hasError(errorCode, path) : false;
                    };
                    AbstractControlDirective.prototype.getError = function(errorCode, path) {
                        if (path === void 0) {
                            path = null;
                        }
                        return this.control ? this.control.getError(errorCode, path) : null;
                    };
                    return AbstractControlDirective;
                })();

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$1 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                /**
                 * A directive that contains multiple {@link NgControl}s.
                 *
                 * Only used by the forms module.
                 *
                 * @stable
                 */
                var ControlContainer = (function(_super) {
                    __extends$1(ControlContainer, _super);
                    function ControlContainer() {
                        _super.apply(this, arguments);
                    }
                    Object.defineProperty(ControlContainer.prototype, 'formDirective', {
                        /**
                         * Get the form to which this container belongs.
                         */
                        get: function() {
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(ControlContainer.prototype, 'path', {
                        /**
                         * Get the path to this container.
                         */
                        get: function() {
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return ControlContainer;
                })(AbstractControlDirective);

                function isPresent(obj) {
                    return obj != null;
                }
                function isBlank(obj) {
                    return obj == null;
                }
                // JS has NaN !== NaN
                function looseIdentical(a, b) {
                    return a === b || (typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b));
                }
                function isJsObject(o) {
                    return o !== null && (typeof o === 'function' || typeof o === 'object');
                }
                function isPrimitive(obj) {
                    return !isJsObject(obj);
                }

                /**
                 * Wraps Javascript Objects
                 */
                var StringMapWrapper = (function() {
                    function StringMapWrapper() {}
                    StringMapWrapper.merge = function(m1, m2) {
                        var m = {};
                        for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
                            var k = _a[_i];
                            m[k] = m1[k];
                        }
                        for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
                            var k = _c[_b];
                            m[k] = m2[k];
                        }
                        return m;
                    };
                    StringMapWrapper.equals = function(m1, m2) {
                        var k1 = Object.keys(m1);
                        var k2 = Object.keys(m2);
                        if (k1.length != k2.length) {
                            return false;
                        }
                        for (var i = 0; i < k1.length; i++) {
                            var key = k1[i];
                            if (m1[key] !== m2[key]) {
                                return false;
                            }
                        }
                        return true;
                    };
                    return StringMapWrapper;
                })();
                var ListWrapper = (function() {
                    function ListWrapper() {}
                    ListWrapper.removeAll = function(list, items) {
                        for (var i = 0; i < items.length; ++i) {
                            var index = list.indexOf(items[i]);
                            if (index > -1) {
                                list.splice(index, 1);
                            }
                        }
                    };
                    ListWrapper.remove = function(list, el) {
                        var index = list.indexOf(el);
                        if (index > -1) {
                            list.splice(index, 1);
                            return true;
                        }
                        return false;
                    };
                    ListWrapper.equals = function(a, b) {
                        if (a.length != b.length) return false;
                        for (var i = 0; i < a.length; ++i) {
                            if (a[i] !== b[i]) return false;
                        }
                        return true;
                    };
                    ListWrapper.flatten = function(list) {
                        return list.reduce(function(flat, item) {
                            var flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;
                            return flat.concat(flatItem);
                        }, []);
                    };
                    return ListWrapper;
                })();

                var isPromise = _angular_core.__core_private__.isPromise;

                function isEmptyInputValue(value) {
                    return value == null || (typeof value === 'string' && value.length === 0);
                }
                /**
                 * Providers for validators to be used for {@link FormControl}s in a form.
                 *
                 * Provide this using `multi: true` to add validators.
                 *
                 * ### Example
                 *
                 * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
                 * @stable
                 */
                var NG_VALIDATORS = new _angular_core.OpaqueToken('NgValidators');
                /**
                 * Providers for asynchronous validators to be used for {@link FormControl}s
                 * in a form.
                 *
                 * Provide this using `multi: true` to add validators.
                 *
                 * See {@link NG_VALIDATORS} for more details.
                 *
                 * @stable
                 */
                var NG_ASYNC_VALIDATORS = new _angular_core.OpaqueToken('NgAsyncValidators');
                /**
                 * Provides a set of validators used by form controls.
                 *
                 * A validator is a function that processes a {@link FormControl} or collection of
                 * controls and returns a map of errors. A null map means that validation has passed.
                 *
                 * ### Example
                 *
                 * ```typescript
                 * var loginControl = new FormControl("", Validators.required)
                 * ```
                 *
                 * @stable
                 */
                var Validators = (function() {
                    function Validators() {}
                    /**
                     * Validator that requires controls to have a non-empty value.
                     */
                    Validators.required = function(control) {
                        return isEmptyInputValue(control.value) ? { required: true } : null;
                    };
                    /**
                     * Validator that requires controls to have a value of a minimum length.
                     */
                    Validators.minLength = function(minLength) {
                        return function(control) {
                            if (isEmptyInputValue(control.value)) {
                                return null; // don't validate empty values to allow optional controls
                            }
                            var length = typeof control.value === 'string' ? control.value.length : 0;
                            return length < minLength ? { minlength: { requiredLength: minLength, actualLength: length } } : null;
                        };
                    };
                    /**
                     * Validator that requires controls to have a value of a maximum length.
                     */
                    Validators.maxLength = function(maxLength) {
                        return function(control) {
                            var length = typeof control.value === 'string' ? control.value.length : 0;
                            return length > maxLength ? { maxlength: { requiredLength: maxLength, actualLength: length } } : null;
                        };
                    };
                    /**
                     * Validator that requires a control to match a regex to its value.
                     */
                    Validators.pattern = function(pattern) {
                        if (!pattern) return Validators.nullValidator;
                        var regex;
                        var regexStr;
                        if (typeof pattern === 'string') {
                            regexStr = '^' + pattern + '$';
                            regex = new RegExp(regexStr);
                        } else {
                            regexStr = pattern.toString();
                            regex = pattern;
                        }
                        return function(control) {
                            if (isEmptyInputValue(control.value)) {
                                return null; // don't validate empty values to allow optional controls
                            }
                            var value = control.value;
                            return regex.test(value) ? null : { pattern: { requiredPattern: regexStr, actualValue: value } };
                        };
                    };
                    /**
                     * No-op validator.
                     */
                    Validators.nullValidator = function(c) {
                        return null;
                    };
                    /**
                     * Compose multiple validators into a single function that returns the union
                     * of the individual error maps.
                     */
                    Validators.compose = function(validators) {
                        if (!validators) return null;
                        var presentValidators = validators.filter(isPresent);
                        if (presentValidators.length == 0) return null;
                        return function(control) {
                            return _mergeErrors(_executeValidators(control, presentValidators));
                        };
                    };
                    Validators.composeAsync = function(validators) {
                        if (!validators) return null;
                        var presentValidators = validators.filter(isPresent);
                        if (presentValidators.length == 0) return null;
                        return function(control) {
                            var promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
                            return Promise.all(promises).then(_mergeErrors);
                        };
                    };
                    return Validators;
                })();
                function _convertToPromise(obj) {
                    return isPromise(obj) ? obj : rxjs_operator_toPromise.toPromise.call(obj);
                }
                function _executeValidators(control, validators) {
                    return validators.map(function(v) {
                        return v(control);
                    });
                }
                function _executeAsyncValidators(control, validators) {
                    return validators.map(function(v) {
                        return v(control);
                    });
                }
                function _mergeErrors(arrayOfErrors) {
                    var res = arrayOfErrors.reduce(function(res, errors) {
                        return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
                    }, {});
                    return Object.keys(res).length === 0 ? null : res;
                }

                /**
                 * Used to provide a {@link ControlValueAccessor} for form controls.
                 *
                 * See {@link DefaultValueAccessor} for how to implement one.
                 * @stable
                 */
                var NG_VALUE_ACCESSOR = new _angular_core.OpaqueToken('NgValueAccessor');

                var CHECKBOX_VALUE_ACCESSOR = {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: _angular_core.forwardRef(function() {
                        return CheckboxControlValueAccessor;
                    }),
                    multi: true
                };
                /**
                 * The accessor for writing a value and listening to changes on a checkbox input element.
                 *
                 *  ### Example
                 *  ```
                 *  <input type="checkbox" name="rememberLogin" ngModel>
                 *  ```
                 *
                 *  @stable
                 */
                var CheckboxControlValueAccessor = (function() {
                    function CheckboxControlValueAccessor(_renderer, _elementRef) {
                        this._renderer = _renderer;
                        this._elementRef = _elementRef;
                        this.onChange = function(_) {};
                        this.onTouched = function() {};
                    }
                    CheckboxControlValueAccessor.prototype.writeValue = function(value) {
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
                    };
                    CheckboxControlValueAccessor.prototype.registerOnChange = function(fn) {
                        this.onChange = fn;
                    };
                    CheckboxControlValueAccessor.prototype.registerOnTouched = function(fn) {
                        this.onTouched = fn;
                    };
                    CheckboxControlValueAccessor.prototype.setDisabledState = function(isDisabled) {
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
                    };
                    CheckboxControlValueAccessor.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',
                                    host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
                                    providers: [CHECKBOX_VALUE_ACCESSOR]
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    CheckboxControlValueAccessor.ctorParameters = [{ type: _angular_core.Renderer }, { type: _angular_core.ElementRef }];
                    return CheckboxControlValueAccessor;
                })();

                var DEFAULT_VALUE_ACCESSOR = {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: _angular_core.forwardRef(function() {
                        return DefaultValueAccessor;
                    }),
                    multi: true
                };
                /**
                 * The default accessor for writing a value and listening to changes that is used by the
                 * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.
                 *
                 *  ### Example
                 *  ```
                 *  <input type="text" name="searchQuery" ngModel>
                 *  ```
                 *
                 *  @stable
                 */
                var DefaultValueAccessor = (function() {
                    function DefaultValueAccessor(_renderer, _elementRef) {
                        this._renderer = _renderer;
                        this._elementRef = _elementRef;
                        this.onChange = function(_) {};
                        this.onTouched = function() {};
                    }
                    DefaultValueAccessor.prototype.writeValue = function(value) {
                        var normalizedValue = value == null ? '' : value;
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
                    };
                    DefaultValueAccessor.prototype.registerOnChange = function(fn) {
                        this.onChange = fn;
                    };
                    DefaultValueAccessor.prototype.registerOnTouched = function(fn) {
                        this.onTouched = fn;
                    };
                    DefaultValueAccessor.prototype.setDisabledState = function(isDisabled) {
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
                    };
                    DefaultValueAccessor.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector:
                                        'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
                                    // TODO: vsavkin replace the above selector with the one below it once
                                    // https://github.com/angular/angular/issues/3011 is implemented
                                    // selector: '[ngControl],[ngModel],[ngFormControl]',
                                    host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
                                    providers: [DEFAULT_VALUE_ACCESSOR]
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    DefaultValueAccessor.ctorParameters = [{ type: _angular_core.Renderer }, { type: _angular_core.ElementRef }];
                    return DefaultValueAccessor;
                })();

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function normalizeValidator(validator) {
                    if (validator.validate) {
                        return function(c) {
                            return validator.validate(c);
                        };
                    } else {
                        return validator;
                    }
                }
                function normalizeAsyncValidator(validator) {
                    if (validator.validate) {
                        return function(c) {
                            return validator.validate(c);
                        };
                    } else {
                        return validator;
                    }
                }

                var NUMBER_VALUE_ACCESSOR = {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: _angular_core.forwardRef(function() {
                        return NumberValueAccessor;
                    }),
                    multi: true
                };
                /**
                 * The accessor for writing a number value and listening to changes that is used by the
                 * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.
                 *
                 *  ### Example
                 *  ```
                 *  <input type="number" [(ngModel)]="age">
                 *  ```
                 */
                var NumberValueAccessor = (function() {
                    function NumberValueAccessor(_renderer, _elementRef) {
                        this._renderer = _renderer;
                        this._elementRef = _elementRef;
                        this.onChange = function(_) {};
                        this.onTouched = function() {};
                    }
                    NumberValueAccessor.prototype.writeValue = function(value) {
                        // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
                        var normalizedValue = value == null ? '' : value;
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
                    };
                    NumberValueAccessor.prototype.registerOnChange = function(fn) {
                        this.onChange = function(value) {
                            fn(value == '' ? null : parseFloat(value));
                        };
                    };
                    NumberValueAccessor.prototype.registerOnTouched = function(fn) {
                        this.onTouched = fn;
                    };
                    NumberValueAccessor.prototype.setDisabledState = function(isDisabled) {
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
                    };
                    NumberValueAccessor.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',
                                    host: {
                                        '(change)': 'onChange($event.target.value)',
                                        '(input)': 'onChange($event.target.value)',
                                        '(blur)': 'onTouched()'
                                    },
                                    providers: [NUMBER_VALUE_ACCESSOR]
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    NumberValueAccessor.ctorParameters = [{ type: _angular_core.Renderer }, { type: _angular_core.ElementRef }];
                    return NumberValueAccessor;
                })();

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$2 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                function unimplemented() {
                    throw new Error('unimplemented');
                }
                /**
                 * A base class that all control directive extend.
                 * It binds a {@link FormControl} object to a DOM element.
                 *
                 * Used internally by Angular forms.
                 *
                 * @stable
                 */
                var NgControl = (function(_super) {
                    __extends$2(NgControl, _super);
                    function NgControl() {
                        _super.apply(this, arguments);
                        /** @internal */
                        this._parent = null;
                        this.name = null;
                        this.valueAccessor = null;
                        /** @internal */
                        this._rawValidators = [];
                        /** @internal */
                        this._rawAsyncValidators = [];
                    }
                    Object.defineProperty(NgControl.prototype, 'validator', {
                        get: function() {
                            return unimplemented();
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgControl.prototype, 'asyncValidator', {
                        get: function() {
                            return unimplemented();
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return NgControl;
                })(AbstractControlDirective);

                var RADIO_VALUE_ACCESSOR = {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: _angular_core.forwardRef(function() {
                        return RadioControlValueAccessor;
                    }),
                    multi: true
                };
                /**
                 * Internal class used by Angular to uncheck radio buttons with the matching name.
                 */
                var RadioControlRegistry = (function() {
                    function RadioControlRegistry() {
                        this._accessors = [];
                    }
                    RadioControlRegistry.prototype.add = function(control, accessor) {
                        this._accessors.push([control, accessor]);
                    };
                    RadioControlRegistry.prototype.remove = function(accessor) {
                        for (var i = this._accessors.length - 1; i >= 0; --i) {
                            if (this._accessors[i][1] === accessor) {
                                this._accessors.splice(i, 1);
                                return;
                            }
                        }
                    };
                    RadioControlRegistry.prototype.select = function(accessor) {
                        var _this = this;
                        this._accessors.forEach(function(c) {
                            if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {
                                c[1].fireUncheck(accessor.value);
                            }
                        });
                    };
                    RadioControlRegistry.prototype._isSameGroup = function(controlPair, accessor) {
                        if (!controlPair[0].control) return false;
                        return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
                    };
                    RadioControlRegistry.decorators = [{ type: _angular_core.Injectable }];
                    /** @nocollapse */
                    RadioControlRegistry.ctorParameters = [];
                    return RadioControlRegistry;
                })();
                /**
                 * @whatItDoes  Writes radio control values and listens to radio control changes.
                 *
                 * Used by {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName}
                 * to keep the view synced with the {@link FormControl} model.
                 *
                 * @howToUse
                 *
                 * If you have imported the {@link FormsModule} or the {@link ReactiveFormsModule}, this
                 * value accessor will be active on any radio control that has a form directive. You do
                 * **not** need to add a special selector to activate it.
                 *
                 * ### How to use radio buttons with form directives
                 *
                 * To use radio buttons in a template-driven form, you'll want to ensure that radio buttons
                 * in the same group have the same `name` attribute.  Radio buttons with different `name`
                 * attributes do not affect each other.
                 *
                 * {@example forms/ts/radioButtons/radio_button_example.ts region='TemplateDriven'}
                 *
                 * When using radio buttons in a reactive form, radio buttons in the same group should have the
                 * same `formControlName`. You can also add a `name` attribute, but it's optional.
                 *
                 * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}
                 *
                 *  * **npm package**: `@angular/forms`
                 *
                 *  @stable
                 */
                var RadioControlValueAccessor = (function() {
                    function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
                        this._renderer = _renderer;
                        this._elementRef = _elementRef;
                        this._registry = _registry;
                        this._injector = _injector;
                        this.onChange = function() {};
                        this.onTouched = function() {};
                    }
                    RadioControlValueAccessor.prototype.ngOnInit = function() {
                        this._control = this._injector.get(NgControl);
                        this._checkName();
                        this._registry.add(this._control, this);
                    };
                    RadioControlValueAccessor.prototype.ngOnDestroy = function() {
                        this._registry.remove(this);
                    };
                    RadioControlValueAccessor.prototype.writeValue = function(value) {
                        this._state = value === this.value;
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', this._state);
                    };
                    RadioControlValueAccessor.prototype.registerOnChange = function(fn) {
                        var _this = this;
                        this._fn = fn;
                        this.onChange = function() {
                            fn(_this.value);
                            _this._registry.select(_this);
                        };
                    };
                    RadioControlValueAccessor.prototype.fireUncheck = function(value) {
                        this.writeValue(value);
                    };
                    RadioControlValueAccessor.prototype.registerOnTouched = function(fn) {
                        this.onTouched = fn;
                    };
                    RadioControlValueAccessor.prototype.setDisabledState = function(isDisabled) {
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
                    };
                    RadioControlValueAccessor.prototype._checkName = function() {
                        if (this.name && this.formControlName && this.name !== this.formControlName) {
                            this._throwNameError();
                        }
                        if (!this.name && this.formControlName) this.name = this.formControlName;
                    };
                    RadioControlValueAccessor.prototype._throwNameError = function() {
                        throw new Error(
                            '\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type="radio" formControlName="food" name="food">\n    '
                        );
                    };
                    RadioControlValueAccessor.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',
                                    host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
                                    providers: [RADIO_VALUE_ACCESSOR]
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    RadioControlValueAccessor.ctorParameters = [
                        { type: _angular_core.Renderer },
                        { type: _angular_core.ElementRef },
                        { type: RadioControlRegistry },
                        { type: _angular_core.Injector }
                    ];
                    RadioControlValueAccessor.propDecorators = {
                        name: [{ type: _angular_core.Input }],
                        formControlName: [{ type: _angular_core.Input }],
                        value: [{ type: _angular_core.Input }]
                    };
                    return RadioControlValueAccessor;
                })();

                var RANGE_VALUE_ACCESSOR = {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: _angular_core.forwardRef(function() {
                        return RangeValueAccessor;
                    }),
                    multi: true
                };
                /**
                 * The accessor for writing a range value and listening to changes that is used by the
                 * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.
                 *
                 *  ### Example
                 *  ```
                 *  <input type="range" [(ngModel)]="age" >
                 *  ```
                 */
                var RangeValueAccessor = (function() {
                    function RangeValueAccessor(_renderer, _elementRef) {
                        this._renderer = _renderer;
                        this._elementRef = _elementRef;
                        this.onChange = function(_) {};
                        this.onTouched = function() {};
                    }
                    RangeValueAccessor.prototype.writeValue = function(value) {
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', parseFloat(value));
                    };
                    RangeValueAccessor.prototype.registerOnChange = function(fn) {
                        this.onChange = function(value) {
                            fn(value == '' ? null : parseFloat(value));
                        };
                    };
                    RangeValueAccessor.prototype.registerOnTouched = function(fn) {
                        this.onTouched = fn;
                    };
                    RangeValueAccessor.prototype.setDisabledState = function(isDisabled) {
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
                    };
                    RangeValueAccessor.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: 'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',
                                    host: {
                                        '(change)': 'onChange($event.target.value)',
                                        '(input)': 'onChange($event.target.value)',
                                        '(blur)': 'onTouched()'
                                    },
                                    providers: [RANGE_VALUE_ACCESSOR]
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    RangeValueAccessor.ctorParameters = [{ type: _angular_core.Renderer }, { type: _angular_core.ElementRef }];
                    return RangeValueAccessor;
                })();

                var SELECT_VALUE_ACCESSOR = {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: _angular_core.forwardRef(function() {
                        return SelectControlValueAccessor;
                    }),
                    multi: true
                };
                function _buildValueString(id, value) {
                    if (id == null) return '' + value;
                    if (!isPrimitive(value)) value = 'Object';
                    return (id + ': ' + value).slice(0, 50);
                }
                function _extractId(valueString) {
                    return valueString.split(':')[0];
                }
                /**
                 * @whatItDoes Writes values and listens to changes on a select element.
                 *
                 * Used by {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName}
                 * to keep the view synced with the {@link FormControl} model.
                 *
                 * @howToUse
                 *
                 * If you have imported the {@link FormsModule} or the {@link ReactiveFormsModule}, this
                 * value accessor will be active on any select control that has a form directive. You do
                 * **not** need to add a special selector to activate it.
                 *
                 * ### How to use select controls with form directives
                 *
                 * To use a select in a template-driven form, simply add an `ngModel` and a `name`
                 * attribute to the main `<select>` tag.
                 *
                 * If your option values are simple strings, you can bind to the normal `value` property
                 * on the option.  If your option values happen to be objects (and you'd like to save the
                 * selection in your form as an object), use `ngValue` instead:
                 *
                 * {@example forms/ts/selectControl/select_control_example.ts region='Component'}
                 *
                 * In reactive forms, you'll also want to add your form directive (`formControlName` or
                 * `formControl`) on the main `<select>` tag. Like in the former example, you have the
                 * choice of binding to the  `value` or `ngValue` property on the select's options.
                 *
                 * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}
                 *
                 * Note: We listen to the 'change' event because 'input' events aren't fired
                 * for selects in Firefox and IE:
                 * https://bugzilla.mozilla.org/show_bug.cgi?id=1024350
                 * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4660045/
                 *
                 * * **npm package**: `@angular/forms`
                 *
                 * @stable
                 */
                var SelectControlValueAccessor = (function() {
                    function SelectControlValueAccessor(_renderer, _elementRef) {
                        this._renderer = _renderer;
                        this._elementRef = _elementRef;
                        /** @internal */
                        this._optionMap = new Map();
                        /** @internal */
                        this._idCounter = 0;
                        this.onChange = function(_) {};
                        this.onTouched = function() {};
                    }
                    SelectControlValueAccessor.prototype.writeValue = function(value) {
                        this.value = value;
                        var valueString = _buildValueString(this._getOptionId(value), value);
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
                    };
                    SelectControlValueAccessor.prototype.registerOnChange = function(fn) {
                        var _this = this;
                        this.onChange = function(valueString) {
                            _this.value = valueString;
                            fn(_this._getOptionValue(valueString));
                        };
                    };
                    SelectControlValueAccessor.prototype.registerOnTouched = function(fn) {
                        this.onTouched = fn;
                    };
                    SelectControlValueAccessor.prototype.setDisabledState = function(isDisabled) {
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
                    };
                    /** @internal */
                    SelectControlValueAccessor.prototype._registerOption = function() {
                        return (this._idCounter++).toString();
                    };
                    /** @internal */
                    SelectControlValueAccessor.prototype._getOptionId = function(value) {
                        for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
                            var id = _a[_i];
                            if (looseIdentical(this._optionMap.get(id), value)) return id;
                        }
                        return null;
                    };
                    /** @internal */
                    SelectControlValueAccessor.prototype._getOptionValue = function(valueString) {
                        var id = _extractId(valueString);
                        return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
                    };
                    SelectControlValueAccessor.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector:
                                        'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',
                                    host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
                                    providers: [SELECT_VALUE_ACCESSOR]
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    SelectControlValueAccessor.ctorParameters = [{ type: _angular_core.Renderer }, { type: _angular_core.ElementRef }];
                    return SelectControlValueAccessor;
                })();
                /**
                 * @whatItDoes Marks `<option>` as dynamic, so Angular can be notified when options change.
                 *
                 * @howToUse
                 *
                 * See docs for {@link SelectControlValueAccessor} for usage examples.
                 *
                 * @stable
                 */
                var NgSelectOption = (function() {
                    function NgSelectOption(_element, _renderer, _select) {
                        this._element = _element;
                        this._renderer = _renderer;
                        this._select = _select;
                        if (this._select) this.id = this._select._registerOption();
                    }
                    Object.defineProperty(NgSelectOption.prototype, 'ngValue', {
                        set: function(value) {
                            if (this._select == null) return;
                            this._select._optionMap.set(this.id, value);
                            this._setElementValue(_buildValueString(this.id, value));
                            this._select.writeValue(this._select.value);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgSelectOption.prototype, 'value', {
                        set: function(value) {
                            this._setElementValue(value);
                            if (this._select) this._select.writeValue(this._select.value);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /** @internal */
                    NgSelectOption.prototype._setElementValue = function(value) {
                        this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
                    };
                    NgSelectOption.prototype.ngOnDestroy = function() {
                        if (this._select) {
                            this._select._optionMap.delete(this.id);
                            this._select.writeValue(this._select.value);
                        }
                    };
                    NgSelectOption.decorators = [{ type: _angular_core.Directive, args: [{ selector: 'option' }] }];
                    /** @nocollapse */
                    NgSelectOption.ctorParameters = [
                        { type: _angular_core.ElementRef },
                        { type: _angular_core.Renderer },
                        { type: SelectControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }] }
                    ];
                    NgSelectOption.propDecorators = {
                        ngValue: [{ type: _angular_core.Input, args: ['ngValue'] }],
                        value: [{ type: _angular_core.Input, args: ['value'] }]
                    };
                    return NgSelectOption;
                })();

                var SELECT_MULTIPLE_VALUE_ACCESSOR = {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: _angular_core.forwardRef(function() {
                        return SelectMultipleControlValueAccessor;
                    }),
                    multi: true
                };
                function _buildValueString$1(id, value) {
                    if (id == null) return '' + value;
                    if (typeof value === 'string') value = "'" + value + "'";
                    if (!isPrimitive(value)) value = 'Object';
                    return (id + ': ' + value).slice(0, 50);
                }
                function _extractId$1(valueString) {
                    return valueString.split(':')[0];
                }
                /**
                 * The accessor for writing a value and listening to changes on a select element.
                 *
                 * @stable
                 */
                var SelectMultipleControlValueAccessor = (function() {
                    function SelectMultipleControlValueAccessor(_renderer, _elementRef) {
                        this._renderer = _renderer;
                        this._elementRef = _elementRef;
                        /** @internal */
                        this._optionMap = new Map();
                        /** @internal */
                        this._idCounter = 0;
                        this.onChange = function(_) {};
                        this.onTouched = function() {};
                    }
                    SelectMultipleControlValueAccessor.prototype.writeValue = function(value) {
                        var _this = this;
                        this.value = value;
                        if (value == null) return;
                        var values = value;
                        // convert values to ids
                        var ids = values.map(function(v) {
                            return _this._getOptionId(v);
                        });
                        this._optionMap.forEach(function(opt, o) {
                            opt._setSelected(ids.indexOf(o.toString()) > -1);
                        });
                    };
                    SelectMultipleControlValueAccessor.prototype.registerOnChange = function(fn) {
                        var _this = this;
                        this.onChange = function(_) {
                            var selected = [];
                            if (_.hasOwnProperty('selectedOptions')) {
                                var options = _.selectedOptions;
                                for (var i = 0; i < options.length; i++) {
                                    var opt = options.item(i);
                                    var val = _this._getOptionValue(opt.value);
                                    selected.push(val);
                                }
                            } else {
                                var options = _.options;
                                for (var i = 0; i < options.length; i++) {
                                    var opt = options.item(i);
                                    if (opt.selected) {
                                        var val = _this._getOptionValue(opt.value);
                                        selected.push(val);
                                    }
                                }
                            }
                            fn(selected);
                        };
                    };
                    SelectMultipleControlValueAccessor.prototype.registerOnTouched = function(fn) {
                        this.onTouched = fn;
                    };
                    SelectMultipleControlValueAccessor.prototype.setDisabledState = function(isDisabled) {
                        this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
                    };
                    /** @internal */
                    SelectMultipleControlValueAccessor.prototype._registerOption = function(value) {
                        var id = (this._idCounter++).toString();
                        this._optionMap.set(id, value);
                        return id;
                    };
                    /** @internal */
                    SelectMultipleControlValueAccessor.prototype._getOptionId = function(value) {
                        for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
                            var id = _a[_i];
                            if (looseIdentical(this._optionMap.get(id)._value, value)) return id;
                        }
                        return null;
                    };
                    /** @internal */
                    SelectMultipleControlValueAccessor.prototype._getOptionValue = function(valueString) {
                        var id = _extractId$1(valueString);
                        return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
                    };
                    SelectMultipleControlValueAccessor.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
                                    host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },
                                    providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    SelectMultipleControlValueAccessor.ctorParameters = [{ type: _angular_core.Renderer }, { type: _angular_core.ElementRef }];
                    return SelectMultipleControlValueAccessor;
                })();
                /**
                 * Marks `<option>` as dynamic, so Angular can be notified when options change.
                 *
                 * ### Example
                 *
                 * ```
                 * <select multiple name="city" ngModel>
                 *   <option *ngFor="let c of cities" [value]="c"></option>
                 * </select>
                 * ```
                 */
                var NgSelectMultipleOption = (function() {
                    function NgSelectMultipleOption(_element, _renderer, _select) {
                        this._element = _element;
                        this._renderer = _renderer;
                        this._select = _select;
                        if (this._select) {
                            this.id = this._select._registerOption(this);
                        }
                    }
                    Object.defineProperty(NgSelectMultipleOption.prototype, 'ngValue', {
                        set: function(value) {
                            if (this._select == null) return;
                            this._value = value;
                            this._setElementValue(_buildValueString$1(this.id, value));
                            this._select.writeValue(this._select.value);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgSelectMultipleOption.prototype, 'value', {
                        set: function(value) {
                            if (this._select) {
                                this._value = value;
                                this._setElementValue(_buildValueString$1(this.id, value));
                                this._select.writeValue(this._select.value);
                            } else {
                                this._setElementValue(value);
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /** @internal */
                    NgSelectMultipleOption.prototype._setElementValue = function(value) {
                        this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
                    };
                    /** @internal */
                    NgSelectMultipleOption.prototype._setSelected = function(selected) {
                        this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);
                    };
                    NgSelectMultipleOption.prototype.ngOnDestroy = function() {
                        if (this._select) {
                            this._select._optionMap.delete(this.id);
                            this._select.writeValue(this._select.value);
                        }
                    };
                    NgSelectMultipleOption.decorators = [{ type: _angular_core.Directive, args: [{ selector: 'option' }] }];
                    /** @nocollapse */
                    NgSelectMultipleOption.ctorParameters = [
                        { type: _angular_core.ElementRef },
                        { type: _angular_core.Renderer },
                        { type: SelectMultipleControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }] }
                    ];
                    NgSelectMultipleOption.propDecorators = {
                        ngValue: [{ type: _angular_core.Input, args: ['ngValue'] }],
                        value: [{ type: _angular_core.Input, args: ['value'] }]
                    };
                    return NgSelectMultipleOption;
                })();

                function controlPath(name, parent) {
                    return parent.path.concat([name]);
                }
                function setUpControl(control, dir) {
                    if (!control) _throwError(dir, 'Cannot find control with');
                    if (!dir.valueAccessor) _throwError(dir, 'No value accessor for form control with');
                    control.validator = Validators.compose([control.validator, dir.validator]);
                    control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
                    dir.valueAccessor.writeValue(control.value);
                    // view -> model
                    dir.valueAccessor.registerOnChange(function(newValue) {
                        dir.viewToModelUpdate(newValue);
                        control.markAsDirty();
                        control.setValue(newValue, { emitModelToViewChange: false });
                    });
                    // touched
                    dir.valueAccessor.registerOnTouched(function() {
                        return control.markAsTouched();
                    });
                    control.registerOnChange(function(newValue, emitModelEvent) {
                        // control -> view
                        dir.valueAccessor.writeValue(newValue);
                        // control -> ngModel
                        if (emitModelEvent) dir.viewToModelUpdate(newValue);
                    });
                    if (dir.valueAccessor.setDisabledState) {
                        control.registerOnDisabledChange(function(isDisabled) {
                            dir.valueAccessor.setDisabledState(isDisabled);
                        });
                    }
                    // re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4
                    dir._rawValidators.forEach(function(validator) {
                        if (validator.registerOnValidatorChange)
                            validator.registerOnValidatorChange(function() {
                                return control.updateValueAndValidity();
                            });
                    });
                    dir._rawAsyncValidators.forEach(function(validator) {
                        if (validator.registerOnValidatorChange)
                            validator.registerOnValidatorChange(function() {
                                return control.updateValueAndValidity();
                            });
                    });
                }
                function cleanUpControl(control, dir) {
                    dir.valueAccessor.registerOnChange(function() {
                        return _noControlError(dir);
                    });
                    dir.valueAccessor.registerOnTouched(function() {
                        return _noControlError(dir);
                    });
                    dir._rawValidators.forEach(function(validator) {
                        if (validator.registerOnValidatorChange) {
                            validator.registerOnValidatorChange(null);
                        }
                    });
                    dir._rawAsyncValidators.forEach(function(validator) {
                        if (validator.registerOnValidatorChange) {
                            validator.registerOnValidatorChange(null);
                        }
                    });
                    if (control) control._clearChangeFns();
                }
                function setUpFormContainer(control, dir) {
                    if (isBlank(control)) _throwError(dir, 'Cannot find control with');
                    control.validator = Validators.compose([control.validator, dir.validator]);
                    control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
                }
                function _noControlError(dir) {
                    return _throwError(dir, 'There is no FormControl instance attached to form control element with');
                }
                function _throwError(dir, message) {
                    var messageEnd;
                    if (dir.path.length > 1) {
                        messageEnd = "path: '" + dir.path.join(' -> ') + "'";
                    } else if (dir.path[0]) {
                        messageEnd = "name: '" + dir.path + "'";
                    } else {
                        messageEnd = 'unspecified name attribute';
                    }
                    throw new Error(message + ' ' + messageEnd);
                }
                function composeValidators(validators) {
                    return isPresent(validators) ? Validators.compose(validators.map(normalizeValidator)) : null;
                }
                function composeAsyncValidators(validators) {
                    return isPresent(validators) ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) : null;
                }
                function isPropertyUpdated(changes, viewModel) {
                    if (!changes.hasOwnProperty('model')) return false;
                    var change = changes['model'];
                    if (change.isFirstChange()) return true;
                    return !looseIdentical(viewModel, change.currentValue);
                }
                var BUILTIN_ACCESSORS = [
                    CheckboxControlValueAccessor,
                    RangeValueAccessor,
                    NumberValueAccessor,
                    SelectControlValueAccessor,
                    SelectMultipleControlValueAccessor,
                    RadioControlValueAccessor
                ];
                function isBuiltInAccessor(valueAccessor) {
                    return BUILTIN_ACCESSORS.some(function(a) {
                        return valueAccessor.constructor === a;
                    });
                }
                // TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
                function selectValueAccessor(dir, valueAccessors) {
                    if (!valueAccessors) return null;
                    var defaultAccessor;
                    var builtinAccessor;
                    var customAccessor;
                    valueAccessors.forEach(function(v) {
                        if (v.constructor === DefaultValueAccessor) {
                            defaultAccessor = v;
                        } else if (isBuiltInAccessor(v)) {
                            if (builtinAccessor) _throwError(dir, 'More than one built-in value accessor matches form control with');
                            builtinAccessor = v;
                        } else {
                            if (customAccessor) _throwError(dir, 'More than one custom value accessor matches form control with');
                            customAccessor = v;
                        }
                    });
                    if (customAccessor) return customAccessor;
                    if (builtinAccessor) return builtinAccessor;
                    if (defaultAccessor) return defaultAccessor;
                    _throwError(dir, 'No valid value accessor for form control with');
                    return null;
                }

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                /**
                 * This is a base class for code shared between {@link NgModelGroup} and {@link FormGroupName}.
                 *
                 * @stable
                 */
                var AbstractFormGroupDirective = (function(_super) {
                    __extends(AbstractFormGroupDirective, _super);
                    function AbstractFormGroupDirective() {
                        _super.apply(this, arguments);
                    }
                    AbstractFormGroupDirective.prototype.ngOnInit = function() {
                        this._checkParentType();
                        this.formDirective.addFormGroup(this);
                    };
                    AbstractFormGroupDirective.prototype.ngOnDestroy = function() {
                        if (this.formDirective) {
                            this.formDirective.removeFormGroup(this);
                        }
                    };
                    Object.defineProperty(AbstractFormGroupDirective.prototype, 'control', {
                        /**
                         * Get the {@link FormGroup} backing this binding.
                         */
                        get: function() {
                            return this.formDirective.getFormGroup(this);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractFormGroupDirective.prototype, 'path', {
                        /**
                         * Get the path to this control group.
                         */
                        get: function() {
                            return controlPath(this.name, this._parent);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractFormGroupDirective.prototype, 'formDirective', {
                        /**
                         * Get the {@link Form} to which this group belongs.
                         */
                        get: function() {
                            return this._parent ? this._parent.formDirective : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractFormGroupDirective.prototype, 'validator', {
                        get: function() {
                            return composeValidators(this._validators);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractFormGroupDirective.prototype, 'asyncValidator', {
                        get: function() {
                            return composeAsyncValidators(this._asyncValidators);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /** @internal */
                    AbstractFormGroupDirective.prototype._checkParentType = function() {};
                    return AbstractFormGroupDirective;
                })(ControlContainer);

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$3 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                var AbstractControlStatus = (function() {
                    function AbstractControlStatus(cd) {
                        this._cd = cd;
                    }
                    Object.defineProperty(AbstractControlStatus.prototype, 'ngClassUntouched', {
                        get: function() {
                            return this._cd.control ? this._cd.control.untouched : false;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlStatus.prototype, 'ngClassTouched', {
                        get: function() {
                            return this._cd.control ? this._cd.control.touched : false;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlStatus.prototype, 'ngClassPristine', {
                        get: function() {
                            return this._cd.control ? this._cd.control.pristine : false;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlStatus.prototype, 'ngClassDirty', {
                        get: function() {
                            return this._cd.control ? this._cd.control.dirty : false;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlStatus.prototype, 'ngClassValid', {
                        get: function() {
                            return this._cd.control ? this._cd.control.valid : false;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlStatus.prototype, 'ngClassInvalid', {
                        get: function() {
                            return this._cd.control ? this._cd.control.invalid : false;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControlStatus.prototype, 'ngClassPending', {
                        get: function() {
                            return this._cd.control ? this._cd.control.pending : false;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return AbstractControlStatus;
                })();
                var ngControlStatusHost = {
                    '[class.ng-untouched]': 'ngClassUntouched',
                    '[class.ng-touched]': 'ngClassTouched',
                    '[class.ng-pristine]': 'ngClassPristine',
                    '[class.ng-dirty]': 'ngClassDirty',
                    '[class.ng-valid]': 'ngClassValid',
                    '[class.ng-invalid]': 'ngClassInvalid',
                    '[class.ng-pending]': 'ngClassPending'
                };
                /**
                 * Directive automatically applied to Angular form controls that sets CSS classes
                 * based on control status (valid/invalid/dirty/etc).
                 *
                 * @stable
                 */
                var NgControlStatus = (function(_super) {
                    __extends$3(NgControlStatus, _super);
                    function NgControlStatus(cd) {
                        _super.call(this, cd);
                    }
                    NgControlStatus.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [{ selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost }]
                        }
                    ];
                    /** @nocollapse */
                    NgControlStatus.ctorParameters = [{ type: NgControl, decorators: [{ type: _angular_core.Self }] }];
                    return NgControlStatus;
                })(AbstractControlStatus);
                /**
                 * Directive automatically applied to Angular form groups that sets CSS classes
                 * based on control status (valid/invalid/dirty/etc).
                 *
                 * @stable
                 */
                var NgControlStatusGroup = (function(_super) {
                    __extends$3(NgControlStatusGroup, _super);
                    function NgControlStatusGroup(cd) {
                        _super.call(this, cd);
                    }
                    NgControlStatusGroup.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',
                                    host: ngControlStatusHost
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    NgControlStatusGroup.ctorParameters = [{ type: ControlContainer, decorators: [{ type: _angular_core.Self }] }];
                    return NgControlStatusGroup;
                })(AbstractControlStatus);

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$5 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                /**
                 * Use by directives and components to emit custom Events.
                 *
                 * ### Examples
                 *
                 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
                 * title gets clicked:
                 *
                 * ```
                 * @Component({
                 *   selector: 'zippy',
                 *   template: `
                 *   <div class="zippy">
                 *     <div (click)="toggle()">Toggle</div>
                 *     <div [hidden]="!visible">
                 *       <ng-content></ng-content>
                 *     </div>
                 *  </div>`})
                 * export class Zippy {
                 *   visible: boolean = true;
                 *   @Output() open: EventEmitter<any> = new EventEmitter();
                 *   @Output() close: EventEmitter<any> = new EventEmitter();
                 *
                 *   toggle() {
                 *     this.visible = !this.visible;
                 *     if (this.visible) {
                 *       this.open.emit(null);
                 *     } else {
                 *       this.close.emit(null);
                 *     }
                 *   }
                 * }
                 * ```
                 *
                 * The events payload can be accessed by the parameter `$event` on the components output event
                 * handler:
                 *
                 * ```
                 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
                 * ```
                 *
                 * Uses Rx.Observable but provides an adapter to make it work as specified here:
                 * https://github.com/jhusain/observable-spec
                 *
                 * Once a reference implementation of the spec is available, switch to it.
                 * @stable
                 */
                var EventEmitter = (function(_super) {
                    __extends$5(EventEmitter, _super);
                    /**
                     * Creates an instance of [EventEmitter], which depending on [isAsync],
                     * delivers events synchronously or asynchronously.
                     */
                    function EventEmitter(isAsync) {
                        if (isAsync === void 0) {
                            isAsync = false;
                        }
                        _super.call(this);
                        this.__isAsync = isAsync;
                    }
                    EventEmitter.prototype.emit = function(value) {
                        _super.prototype.next.call(this, value);
                    };
                    EventEmitter.prototype.subscribe = function(generatorOrNext, error, complete) {
                        var schedulerFn;
                        var errorFn = function(err) {
                            return null;
                        };
                        var completeFn = function() {
                            return null;
                        };
                        if (generatorOrNext && typeof generatorOrNext === 'object') {
                            schedulerFn = this.__isAsync
                                ? function(value) {
                                      setTimeout(function() {
                                          return generatorOrNext.next(value);
                                      });
                                  }
                                : function(value) {
                                      generatorOrNext.next(value);
                                  };
                            if (generatorOrNext.error) {
                                errorFn = this.__isAsync
                                    ? function(err) {
                                          setTimeout(function() {
                                              return generatorOrNext.error(err);
                                          });
                                      }
                                    : function(err) {
                                          generatorOrNext.error(err);
                                      };
                            }
                            if (generatorOrNext.complete) {
                                completeFn = this.__isAsync
                                    ? function() {
                                          setTimeout(function() {
                                              return generatorOrNext.complete();
                                          });
                                      }
                                    : function() {
                                          generatorOrNext.complete();
                                      };
                            }
                        } else {
                            schedulerFn = this.__isAsync
                                ? function(value) {
                                      setTimeout(function() {
                                          return generatorOrNext(value);
                                      });
                                  }
                                : function(value) {
                                      generatorOrNext(value);
                                  };
                            if (error) {
                                errorFn = this.__isAsync
                                    ? function(err) {
                                          setTimeout(function() {
                                              return error(err);
                                          });
                                      }
                                    : function(err) {
                                          error(err);
                                      };
                            }
                            if (complete) {
                                completeFn = this.__isAsync
                                    ? function() {
                                          setTimeout(function() {
                                              return complete();
                                          });
                                      }
                                    : function() {
                                          complete();
                                      };
                            }
                        }
                        return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
                    };
                    return EventEmitter;
                })(rxjs_Subject.Subject);

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$6 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                /**
                 * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.
                 */
                var VALID = 'VALID';
                /**
                 * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.
                 */
                var INVALID = 'INVALID';
                /**
                 * Indicates that a FormControl is pending, i.e. that async validation is occurring and
                 * errors are not yet available for the input value.
                 */
                var PENDING = 'PENDING';
                /**
                 * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor
                 * calculations of validity or value.
                 */
                var DISABLED = 'DISABLED';
                function _find(control, path, delimiter) {
                    if (path == null) return null;
                    if (!(path instanceof Array)) {
                        path = path.split(delimiter);
                    }
                    if (path instanceof Array && path.length === 0) return null;
                    return path.reduce(function(v, name) {
                        if (v instanceof FormGroup) {
                            return v.controls[name] || null;
                        }
                        if (v instanceof FormArray) {
                            return v.at(name) || null;
                        }
                        return null;
                    }, control);
                }
                function toObservable(r) {
                    return isPromise(r) ? rxjs_observable_fromPromise.fromPromise(r) : r;
                }
                function coerceToValidator(validator) {
                    return Array.isArray(validator) ? composeValidators(validator) : validator;
                }
                function coerceToAsyncValidator(asyncValidator) {
                    return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator;
                }
                /**
                 * @whatItDoes This is the base class for {@link FormControl}, {@link FormGroup}, and
                 * {@link FormArray}.
                 *
                 * It provides some of the shared behavior that all controls and groups of controls have, like
                 * running validators, calculating status, and resetting state. It also defines the properties
                 * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
                 * instantiated directly.
                 *
                 * @stable
                 */
                var AbstractControl = (function() {
                    function AbstractControl(validator, asyncValidator) {
                        this.validator = validator;
                        this.asyncValidator = asyncValidator;
                        /** @internal */
                        this._onCollectionChange = function() {};
                        this._pristine = true;
                        this._touched = false;
                        /** @internal */
                        this._onDisabledChange = [];
                    }
                    Object.defineProperty(AbstractControl.prototype, 'value', {
                        /**
                         * The value of the control.
                         */
                        get: function() {
                            return this._value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'parent', {
                        /**
                         * The parent control.
                         */
                        get: function() {
                            return this._parent;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'status', {
                        /**
                         * The validation status of the control. There are four possible
                         * validation statuses:
                         *
                         * * **VALID**:  control has passed all validation checks
                         * * **INVALID**: control has failed at least one validation check
                         * * **PENDING**: control is in the midst of conducting a validation check
                         * * **DISABLED**: control is exempt from validation checks
                         *
                         * These statuses are mutually exclusive, so a control cannot be
                         * both valid AND invalid or invalid AND disabled.
                         */
                        get: function() {
                            return this._status;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'valid', {
                        /**
                         * A control is `valid` when its `status === VALID`.
                         *
                         * In order to have this status, the control must have passed all its
                         * validation checks.
                         */
                        get: function() {
                            return this._status === VALID;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'invalid', {
                        /**
                         * A control is `invalid` when its `status === INVALID`.
                         *
                         * In order to have this status, the control must have failed
                         * at least one of its validation checks.
                         */
                        get: function() {
                            return this._status === INVALID;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'pending', {
                        /**
                         * A control is `pending` when its `status === PENDING`.
                         *
                         * In order to have this status, the control must be in the
                         * middle of conducting a validation check.
                         */
                        get: function() {
                            return this._status == PENDING;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'disabled', {
                        /**
                         * A control is `disabled` when its `status === DISABLED`.
                         *
                         * Disabled controls are exempt from validation checks and
                         * are not included in the aggregate value of their ancestor
                         * controls.
                         */
                        get: function() {
                            return this._status === DISABLED;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'enabled', {
                        /**
                         * A control is `enabled` as long as its `status !== DISABLED`.
                         *
                         * In other words, it has a status of `VALID`, `INVALID`, or
                         * `PENDING`.
                         */
                        get: function() {
                            return this._status !== DISABLED;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'errors', {
                        /**
                         * Returns any errors generated by failing validation. If there
                         * are no errors, it will return null.
                         */
                        get: function() {
                            return this._errors;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'pristine', {
                        /**
                         * A control is `pristine` if the user has not yet changed
                         * the value in the UI.
                         *
                         * Note that programmatic changes to a control's value will
                         * *not* mark it dirty.
                         */
                        get: function() {
                            return this._pristine;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'dirty', {
                        /**
                         * A control is `dirty` if the user has changed the value
                         * in the UI.
                         *
                         * Note that programmatic changes to a control's value will
                         * *not* mark it dirty.
                         */
                        get: function() {
                            return !this.pristine;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'touched', {
                        /**
                         * A control is marked `touched` once the user has triggered
                         * a `blur` event on it.
                         */
                        get: function() {
                            return this._touched;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'untouched', {
                        /**
                         * A control is `untouched` if the user has not yet triggered
                         * a `blur` event on it.
                         */
                        get: function() {
                            return !this._touched;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'valueChanges', {
                        /**
                         * Emits an event every time the value of the control changes, in
                         * the UI or programmatically.
                         */
                        get: function() {
                            return this._valueChanges;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(AbstractControl.prototype, 'statusChanges', {
                        /**
                         * Emits an event every time the validation status of the control
                         * is re-calculated.
                         */
                        get: function() {
                            return this._statusChanges;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Sets the synchronous validators that are active on this control.  Calling
                     * this will overwrite any existing sync validators.
                     */
                    AbstractControl.prototype.setValidators = function(newValidator) {
                        this.validator = coerceToValidator(newValidator);
                    };
                    /**
                     * Sets the async validators that are active on this control. Calling this
                     * will overwrite any existing async validators.
                     */
                    AbstractControl.prototype.setAsyncValidators = function(newValidator) {
                        this.asyncValidator = coerceToAsyncValidator(newValidator);
                    };
                    /**
                     * Empties out the sync validator list.
                     */
                    AbstractControl.prototype.clearValidators = function() {
                        this.validator = null;
                    };
                    /**
                     * Empties out the async validator list.
                     */
                    AbstractControl.prototype.clearAsyncValidators = function() {
                        this.asyncValidator = null;
                    };
                    /**
                     * Marks the control as `touched`.
                     *
                     * This will also mark all direct ancestors as `touched` to maintain
                     * the model.
                     */
                    AbstractControl.prototype.markAsTouched = function(_a) {
                        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
                        this._touched = true;
                        if (this._parent && !onlySelf) {
                            this._parent.markAsTouched({ onlySelf: onlySelf });
                        }
                    };
                    /**
                     * Marks the control as `untouched`.
                     *
                     * If the control has any children, it will also mark all children as `untouched`
                     * to maintain the model, and re-calculate the `touched` status of all parent
                     * controls.
                     */
                    AbstractControl.prototype.markAsUntouched = function(_a) {
                        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
                        this._touched = false;
                        this._forEachChild(function(control) {
                            control.markAsUntouched({ onlySelf: true });
                        });
                        if (this._parent && !onlySelf) {
                            this._parent._updateTouched({ onlySelf: onlySelf });
                        }
                    };
                    /**
                     * Marks the control as `dirty`.
                     *
                     * This will also mark all direct ancestors as `dirty` to maintain
                     * the model.
                     */
                    AbstractControl.prototype.markAsDirty = function(_a) {
                        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
                        this._pristine = false;
                        if (this._parent && !onlySelf) {
                            this._parent.markAsDirty({ onlySelf: onlySelf });
                        }
                    };
                    /**
                     * Marks the control as `pristine`.
                     *
                     * If the control has any children, it will also mark all children as `pristine`
                     * to maintain the model, and re-calculate the `pristine` status of all parent
                     * controls.
                     */
                    AbstractControl.prototype.markAsPristine = function(_a) {
                        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
                        this._pristine = true;
                        this._forEachChild(function(control) {
                            control.markAsPristine({ onlySelf: true });
                        });
                        if (this._parent && !onlySelf) {
                            this._parent._updatePristine({ onlySelf: onlySelf });
                        }
                    };
                    /**
                     * Marks the control as `pending`.
                     */
                    AbstractControl.prototype.markAsPending = function(_a) {
                        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
                        this._status = PENDING;
                        if (this._parent && !onlySelf) {
                            this._parent.markAsPending({ onlySelf: onlySelf });
                        }
                    };
                    /**
                     * Disables the control. This means the control will be exempt from validation checks and
                     * excluded from the aggregate value of any parent. Its status is `DISABLED`.
                     *
                     * If the control has children, all children will be disabled to maintain the model.
                     */
                    AbstractControl.prototype.disable = function(_a) {
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent;
                        this._status = DISABLED;
                        this._errors = null;
                        this._forEachChild(function(control) {
                            control.disable({ onlySelf: true });
                        });
                        this._updateValue();
                        if (emitEvent !== false) {
                            this._valueChanges.emit(this._value);
                            this._statusChanges.emit(this._status);
                        }
                        this._updateAncestors(onlySelf);
                        this._onDisabledChange.forEach(function(changeFn) {
                            return changeFn(true);
                        });
                    };
                    /**
                     * Enables the control. This means the control will be included in validation checks and
                     * the aggregate value of its parent. Its status is re-calculated based on its value and
                     * its validators.
                     *
                     * If the control has children, all children will be enabled.
                     */
                    AbstractControl.prototype.enable = function(_a) {
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent;
                        this._status = VALID;
                        this._forEachChild(function(control) {
                            control.enable({ onlySelf: true });
                        });
                        this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
                        this._updateAncestors(onlySelf);
                        this._onDisabledChange.forEach(function(changeFn) {
                            return changeFn(false);
                        });
                    };
                    AbstractControl.prototype._updateAncestors = function(onlySelf) {
                        if (this._parent && !onlySelf) {
                            this._parent.updateValueAndValidity();
                            this._parent._updatePristine();
                            this._parent._updateTouched();
                        }
                    };
                    AbstractControl.prototype.setParent = function(parent) {
                        this._parent = parent;
                    };
                    /**
                     * Re-calculates the value and validation status of the control.
                     *
                     * By default, it will also update the value and validity of its ancestors.
                     */
                    AbstractControl.prototype.updateValueAndValidity = function(_a) {
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent;
                        this._setInitialStatus();
                        this._updateValue();
                        if (this.enabled) {
                            this._errors = this._runValidator();
                            this._status = this._calculateStatus();
                            if (this._status === VALID || this._status === PENDING) {
                                this._runAsyncValidator(emitEvent);
                            }
                        }
                        if (emitEvent !== false) {
                            this._valueChanges.emit(this._value);
                            this._statusChanges.emit(this._status);
                        }
                        if (this._parent && !onlySelf) {
                            this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
                        }
                    };
                    /** @internal */
                    AbstractControl.prototype._updateTreeValidity = function(_a) {
                        var emitEvent = (_a === void 0 ? { emitEvent: true } : _a).emitEvent;
                        this._forEachChild(function(ctrl) {
                            return ctrl._updateTreeValidity({ emitEvent: emitEvent });
                        });
                        this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
                    };
                    AbstractControl.prototype._setInitialStatus = function() {
                        this._status = this._allControlsDisabled() ? DISABLED : VALID;
                    };
                    AbstractControl.prototype._runValidator = function() {
                        return this.validator ? this.validator(this) : null;
                    };
                    AbstractControl.prototype._runAsyncValidator = function(emitEvent) {
                        var _this = this;
                        if (this.asyncValidator) {
                            this._status = PENDING;
                            this._cancelExistingSubscription();
                            var obs = toObservable(this.asyncValidator(this));
                            this._asyncValidationSubscription = obs.subscribe({
                                next: function(res) {
                                    return _this.setErrors(res, { emitEvent: emitEvent });
                                }
                            });
                        }
                    };
                    AbstractControl.prototype._cancelExistingSubscription = function() {
                        if (this._asyncValidationSubscription) {
                            this._asyncValidationSubscription.unsubscribe();
                        }
                    };
                    /**
                     * Sets errors on a form control.
                     *
                     * This is used when validations are run manually by the user, rather than automatically.
                     *
                     * Calling `setErrors` will also update the validity of the parent control.
                     *
                     * ### Example
                     *
                     * ```
                     * const login = new FormControl("someLogin");
                     * login.setErrors({
                     *   "notUnique": true
                     * });
                     *
                     * expect(login.valid).toEqual(false);
                     * expect(login.errors).toEqual({"notUnique": true});
                     *
                     * login.setValue("someOtherLogin");
                     *
                     * expect(login.valid).toEqual(true);
                     * ```
                     */
                    AbstractControl.prototype.setErrors = function(errors, _a) {
                        var emitEvent = (_a === void 0 ? {} : _a).emitEvent;
                        this._errors = errors;
                        this._updateControlsErrors(emitEvent !== false);
                    };
                    /**
                     * Retrieves a child control given the control's name or path.
                     *
                     * Paths can be passed in as an array or a string delimited by a dot.
                     *
                     * To get a control nested within a `person` sub-group:
                     *
                     * * `this.form.get('person.name');`
                     *
                     * -OR-
                     *
                     * * `this.form.get(['person', 'name']);`
                     */
                    AbstractControl.prototype.get = function(path) {
                        return _find(this, path, '.');
                    };
                    /**
                     * Returns true if the control with the given path has the error specified. Otherwise
                     * returns null or undefined.
                     *
                     * If no path is given, it checks for the error on the present control.
                     */
                    AbstractControl.prototype.getError = function(errorCode, path) {
                        if (path === void 0) {
                            path = null;
                        }
                        var control = path ? this.get(path) : this;
                        return control && control._errors ? control._errors[errorCode] : null;
                    };
                    /**
                     * Returns true if the control with the given path has the error specified. Otherwise
                     * returns false.
                     *
                     * If no path is given, it checks for the error on the present control.
                     */
                    AbstractControl.prototype.hasError = function(errorCode, path) {
                        if (path === void 0) {
                            path = null;
                        }
                        return !!this.getError(errorCode, path);
                    };
                    Object.defineProperty(AbstractControl.prototype, 'root', {
                        /**
                         * Retrieves the top-level ancestor of this control.
                         */
                        get: function() {
                            var x = this;
                            while (x._parent) {
                                x = x._parent;
                            }
                            return x;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /** @internal */
                    AbstractControl.prototype._updateControlsErrors = function(emitEvent) {
                        this._status = this._calculateStatus();
                        if (emitEvent) {
                            this._statusChanges.emit(this._status);
                        }
                        if (this._parent) {
                            this._parent._updateControlsErrors(emitEvent);
                        }
                    };
                    /** @internal */
                    AbstractControl.prototype._initObservables = function() {
                        this._valueChanges = new EventEmitter();
                        this._statusChanges = new EventEmitter();
                    };
                    AbstractControl.prototype._calculateStatus = function() {
                        if (this._allControlsDisabled()) return DISABLED;
                        if (this._errors) return INVALID;
                        if (this._anyControlsHaveStatus(PENDING)) return PENDING;
                        if (this._anyControlsHaveStatus(INVALID)) return INVALID;
                        return VALID;
                    };
                    /** @internal */
                    AbstractControl.prototype._anyControlsHaveStatus = function(status) {
                        return this._anyControls(function(control) {
                            return control.status === status;
                        });
                    };
                    /** @internal */
                    AbstractControl.prototype._anyControlsDirty = function() {
                        return this._anyControls(function(control) {
                            return control.dirty;
                        });
                    };
                    /** @internal */
                    AbstractControl.prototype._anyControlsTouched = function() {
                        return this._anyControls(function(control) {
                            return control.touched;
                        });
                    };
                    /** @internal */
                    AbstractControl.prototype._updatePristine = function(_a) {
                        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
                        this._pristine = !this._anyControlsDirty();
                        if (this._parent && !onlySelf) {
                            this._parent._updatePristine({ onlySelf: onlySelf });
                        }
                    };
                    /** @internal */
                    AbstractControl.prototype._updateTouched = function(_a) {
                        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
                        this._touched = this._anyControlsTouched();
                        if (this._parent && !onlySelf) {
                            this._parent._updateTouched({ onlySelf: onlySelf });
                        }
                    };
                    /** @internal */
                    AbstractControl.prototype._isBoxedValue = function(formState) {
                        return (
                            typeof formState === 'object' &&
                            formState !== null &&
                            Object.keys(formState).length === 2 &&
                            'value' in formState &&
                            'disabled' in formState
                        );
                    };
                    /** @internal */
                    AbstractControl.prototype._registerOnCollectionChange = function(fn) {
                        this._onCollectionChange = fn;
                    };
                    return AbstractControl;
                })();
                /**
                 * @whatItDoes Tracks the value and validation status of an individual form control.
                 *
                 * It is one of the three fundamental building blocks of Angular forms, along with
                 * {@link FormGroup} and {@link FormArray}.
                 *
                 * @howToUse
                 *
                 * When instantiating a {@link FormControl}, you can pass in an initial value as the
                 * first argument. Example:
                 *
                 * ```ts
                 * const ctrl = new FormControl('some value');
                 * console.log(ctrl.value);     // 'some value'
                 *```
                 *
                 * You can also initialize the control with a form state object on instantiation,
                 * which includes both the value and whether or not the control is disabled.
                 * You can't use the value key without the disabled key; both are required
                 * to use this way of initialization.
                 *
                 * ```ts
                 * const ctrl = new FormControl({value: 'n/a', disabled: true});
                 * console.log(ctrl.value);     // 'n/a'
                 * console.log(ctrl.status);   // 'DISABLED'
                 * ```
                 *
                 * To include a sync validator (or an array of sync validators) with the control,
                 * pass it in as the second argument. Async validators are also supported, but
                 * have to be passed in separately as the third arg.
                 *
                 * ```ts
                 * const ctrl = new FormControl('', Validators.required);
                 * console.log(ctrl.value);     // ''
                 * console.log(ctrl.status);   // 'INVALID'
                 * ```
                 *
                 * See its superclass, {@link AbstractControl}, for more properties and methods.
                 *
                 * * **npm package**: `@angular/forms`
                 *
                 * @stable
                 */
                var FormControl = (function(_super) {
                    __extends$6(FormControl, _super);
                    function FormControl(formState, validator, asyncValidator) {
                        if (formState === void 0) {
                            formState = null;
                        }
                        if (validator === void 0) {
                            validator = null;
                        }
                        if (asyncValidator === void 0) {
                            asyncValidator = null;
                        }
                        _super.call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator));
                        /** @internal */
                        this._onChange = [];
                        this._applyFormState(formState);
                        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
                        this._initObservables();
                    }
                    /**
                     * Set the value of the form control to `value`.
                     *
                     * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`
                     * and not its parent component. This defaults to false.
                     *
                     * If `emitEvent` is `true`, this
                     * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults
                     * to true (as it falls through to `updateValueAndValidity`).
                     *
                     * If `emitModelToViewChange` is `true`, the view will be notified about the new value
                     * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
                     * specified.
                     *
                     * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the
                     * model.  This is the default behavior if `emitViewToModelChange` is not specified.
                     */
                    FormControl.prototype.setValue = function(value, _a) {
                        var _this = this;
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent,
                            emitModelToViewChange = _b.emitModelToViewChange,
                            emitViewToModelChange = _b.emitViewToModelChange;
                        this._value = value;
                        if (this._onChange.length && emitModelToViewChange !== false) {
                            this._onChange.forEach(function(changeFn) {
                                return changeFn(_this._value, emitViewToModelChange !== false);
                            });
                        }
                        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
                    };
                    /**
                     * Patches the value of a control.
                     *
                     * This function is functionally the same as {@link FormControl.setValue} at this level.
                     * It exists for symmetry with {@link FormGroup.patchValue} on `FormGroups` and `FormArrays`,
                     * where it does behave differently.
                     */
                    FormControl.prototype.patchValue = function(value, options) {
                        if (options === void 0) {
                            options = {};
                        }
                        this.setValue(value, options);
                    };
                    /**
                     * Resets the form control. This means by default:
                     *
                     * * it is marked as `pristine`
                     * * it is marked as `untouched`
                     * * value is set to null
                     *
                     * You can also reset to a specific form state by passing through a standalone
                     * value or a form state object that contains both a value and a disabled state
                     * (these are the only two properties that cannot be calculated).
                     *
                     * Ex:
                     *
                     * ```ts
                     * this.control.reset('Nancy');
                     *
                     * console.log(this.control.value);  // 'Nancy'
                     * ```
                     *
                     * OR
                     *
                     * ```
                     * this.control.reset({value: 'Nancy', disabled: true});
                     *
                     * console.log(this.control.value);  // 'Nancy'
                     * console.log(this.control.status);  // 'DISABLED'
                     * ```
                     */
                    FormControl.prototype.reset = function(formState, _a) {
                        if (formState === void 0) {
                            formState = null;
                        }
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent;
                        this._applyFormState(formState);
                        this.markAsPristine({ onlySelf: onlySelf });
                        this.markAsUntouched({ onlySelf: onlySelf });
                        this.setValue(this._value, { onlySelf: onlySelf, emitEvent: emitEvent });
                    };
                    /**
                     * @internal
                     */
                    FormControl.prototype._updateValue = function() {};
                    /**
                     * @internal
                     */
                    FormControl.prototype._anyControls = function(condition) {
                        return false;
                    };
                    /**
                     * @internal
                     */
                    FormControl.prototype._allControlsDisabled = function() {
                        return this.disabled;
                    };
                    /**
                     * Register a listener for change events.
                     */
                    FormControl.prototype.registerOnChange = function(fn) {
                        this._onChange.push(fn);
                    };
                    /**
                     * @internal
                     */
                    FormControl.prototype._clearChangeFns = function() {
                        this._onChange = [];
                        this._onDisabledChange = [];
                        this._onCollectionChange = function() {};
                    };
                    /**
                     * Register a listener for disabled events.
                     */
                    FormControl.prototype.registerOnDisabledChange = function(fn) {
                        this._onDisabledChange.push(fn);
                    };
                    /**
                     * @internal
                     */
                    FormControl.prototype._forEachChild = function(cb) {};
                    FormControl.prototype._applyFormState = function(formState) {
                        if (this._isBoxedValue(formState)) {
                            this._value = formState.value;
                            formState.disabled
                                ? this.disable({ onlySelf: true, emitEvent: false })
                                : this.enable({ onlySelf: true, emitEvent: false });
                        } else {
                            this._value = formState;
                        }
                    };
                    return FormControl;
                })(AbstractControl);
                /**
                 * @whatItDoes Tracks the value and validity state of a group of {@link FormControl}
                 * instances.
                 *
                 * A `FormGroup` aggregates the values of each child {@link FormControl} into one object,
                 * with each control name as the key.  It calculates its status by reducing the statuses
                 * of its children. For example, if one of the controls in a group is invalid, the entire
                 * group becomes invalid.
                 *
                 * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,
                 * along with {@link FormControl} and {@link FormArray}.
                 *
                 * @howToUse
                 *
                 * When instantiating a {@link FormGroup}, pass in a collection of child controls as the first
                 * argument. The key for each child will be the name under which it is registered.
                 *
                 * ### Example
                 *
                 * ```
                 * const form = new FormGroup({
                 *   first: new FormControl('Nancy', Validators.minLength(2)),
                 *   last: new FormControl('Drew'),
                 * });
                 *
                 * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
                 * console.log(form.status);  // 'VALID'
                 * ```
                 *
                 * You can also include group-level validators as the second arg, or group-level async
                 * validators as the third arg. These come in handy when you want to perform validation
                 * that considers the value of more than one child control.
                 *
                 * ### Example
                 *
                 * ```
                 * const form = new FormGroup({
                 *   password: new FormControl('', Validators.minLength(2)),
                 *   passwordConfirm: new FormControl('', Validators.minLength(2)),
                 * }, passwordMatchValidator);
                 *
                 *
                 * function passwordMatchValidator(g: FormGroup) {
                 *    return g.get('password').value === g.get('passwordConfirm').value
                 *       ? null : {'mismatch': true};
                 * }
                 * ```
                 *
                 * * **npm package**: `@angular/forms`
                 *
                 * @stable
                 */
                var FormGroup = (function(_super) {
                    __extends$6(FormGroup, _super);
                    function FormGroup(controls, validator, asyncValidator) {
                        if (validator === void 0) {
                            validator = null;
                        }
                        if (asyncValidator === void 0) {
                            asyncValidator = null;
                        }
                        _super.call(this, validator, asyncValidator);
                        this.controls = controls;
                        this._initObservables();
                        this._setUpControls();
                        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
                    }
                    /**
                     * Registers a control with the group's list of controls.
                     *
                     * This method does not update value or validity of the control, so for
                     * most cases you'll want to use {@link FormGroup.addControl} instead.
                     */
                    FormGroup.prototype.registerControl = function(name, control) {
                        if (this.controls[name]) return this.controls[name];
                        this.controls[name] = control;
                        control.setParent(this);
                        control._registerOnCollectionChange(this._onCollectionChange);
                        return control;
                    };
                    /**
                     * Add a control to this group.
                     */
                    FormGroup.prototype.addControl = function(name, control) {
                        this.registerControl(name, control);
                        this.updateValueAndValidity();
                        this._onCollectionChange();
                    };
                    /**
                     * Remove a control from this group.
                     */
                    FormGroup.prototype.removeControl = function(name) {
                        if (this.controls[name]) this.controls[name]._registerOnCollectionChange(function() {});
                        delete this.controls[name];
                        this.updateValueAndValidity();
                        this._onCollectionChange();
                    };
                    /**
                     * Replace an existing control.
                     */
                    FormGroup.prototype.setControl = function(name, control) {
                        if (this.controls[name]) this.controls[name]._registerOnCollectionChange(function() {});
                        delete this.controls[name];
                        if (control) this.registerControl(name, control);
                        this.updateValueAndValidity();
                        this._onCollectionChange();
                    };
                    /**
                     * Check whether there is an enabled control with the given name in the group.
                     *
                     * It will return false for disabled controls. If you'd like to check for
                     * existence in the group only, use {@link AbstractControl.get} instead.
                     */
                    FormGroup.prototype.contains = function(controlName) {
                        return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
                    };
                    /**
                     *  Sets the value of the {@link FormGroup}. It accepts an object that matches
                     *  the structure of the group, with control names as keys.
                     *
                     * This method performs strict checks, so it will throw an error if you try
                     * to set the value of a control that doesn't exist or if you exclude the
                     * value of a control.
                     *
                     *  ### Example
                     *
                     *  ```
                     *  const form = new FormGroup({
                     *     first: new FormControl(),
                     *     last: new FormControl()
                     *  });
                     *  console.log(form.value);   // {first: null, last: null}
                     *
                     *  form.setValue({first: 'Nancy', last: 'Drew'});
                     *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
                     *
                     *  ```
                     */
                    FormGroup.prototype.setValue = function(value, _a) {
                        var _this = this;
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent;
                        this._checkAllValuesPresent(value);
                        Object.keys(value).forEach(function(name) {
                            _this._throwIfControlMissing(name);
                            _this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: emitEvent });
                        });
                        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
                    };
                    /**
                     *  Patches the value of the {@link FormGroup}. It accepts an object with control
                     *  names as keys, and will do its best to match the values to the correct controls
                     *  in the group.
                     *
                     *  It accepts both super-sets and sub-sets of the group without throwing an error.
                     *
                     *  ### Example
                     *
                     *  ```
                     *  const form = new FormGroup({
                     *     first: new FormControl(),
                     *     last: new FormControl()
                     *  });
                     *  console.log(form.value);   // {first: null, last: null}
                     *
                     *  form.patchValue({first: 'Nancy'});
                     *  console.log(form.value);   // {first: 'Nancy', last: null}
                     *
                     *  ```
                     */
                    FormGroup.prototype.patchValue = function(value, _a) {
                        var _this = this;
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent;
                        Object.keys(value).forEach(function(name) {
                            if (_this.controls[name]) {
                                _this.controls[name].patchValue(value[name], { onlySelf: true, emitEvent: emitEvent });
                            }
                        });
                        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
                    };
                    /**
                     * Resets the {@link FormGroup}. This means by default:
                     *
                     * * The group and all descendants are marked `pristine`
                     * * The group and all descendants are marked `untouched`
                     * * The value of all descendants will be null or null maps
                     *
                     * You can also reset to a specific form state by passing in a map of states
                     * that matches the structure of your form, with control names as keys. The state
                     * can be a standalone value or a form state object with both a value and a disabled
                     * status.
                     *
                     * ### Example
                     *
                     * ```ts
                     * this.form.reset({first: 'name', last: 'last name'});
                     *
                     * console.log(this.form.value);  // {first: 'name', last: 'last name'}
                     * ```
                     *
                     * - OR -
                     *
                     * ```
                     * this.form.reset({
                     *   first: {value: 'name', disabled: true},
                     *   last: 'last'
                     * });
                     *
                     * console.log(this.form.value);  // {first: 'name', last: 'last name'}
                     * console.log(this.form.get('first').status);  // 'DISABLED'
                     * ```
                     */
                    FormGroup.prototype.reset = function(value, _a) {
                        if (value === void 0) {
                            value = {};
                        }
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent;
                        this._forEachChild(function(control, name) {
                            control.reset(value[name], { onlySelf: true, emitEvent: emitEvent });
                        });
                        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
                        this._updatePristine({ onlySelf: onlySelf });
                        this._updateTouched({ onlySelf: onlySelf });
                    };
                    /**
                     * The aggregate value of the {@link FormGroup}, including any disabled controls.
                     *
                     * If you'd like to include all values regardless of disabled status, use this method.
                     * Otherwise, the `value` property is the best way to get the value of the group.
                     */
                    FormGroup.prototype.getRawValue = function() {
                        return this._reduceChildren({}, function(acc, control, name) {
                            acc[name] = control.value;
                            return acc;
                        });
                    };
                    /** @internal */
                    FormGroup.prototype._throwIfControlMissing = function(name) {
                        if (!Object.keys(this.controls).length) {
                            throw new Error(
                                "\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "
                            );
                        }
                        if (!this.controls[name]) {
                            throw new Error('Cannot find form control with name: ' + name + '.');
                        }
                    };
                    /** @internal */
                    FormGroup.prototype._forEachChild = function(cb) {
                        var _this = this;
                        Object.keys(this.controls).forEach(function(k) {
                            return cb(_this.controls[k], k);
                        });
                    };
                    /** @internal */
                    FormGroup.prototype._setUpControls = function() {
                        var _this = this;
                        this._forEachChild(function(control) {
                            control.setParent(_this);
                            control._registerOnCollectionChange(_this._onCollectionChange);
                        });
                    };
                    /** @internal */
                    FormGroup.prototype._updateValue = function() {
                        this._value = this._reduceValue();
                    };
                    /** @internal */
                    FormGroup.prototype._anyControls = function(condition) {
                        var _this = this;
                        var res = false;
                        this._forEachChild(function(control, name) {
                            res = res || (_this.contains(name) && condition(control));
                        });
                        return res;
                    };
                    /** @internal */
                    FormGroup.prototype._reduceValue = function() {
                        var _this = this;
                        return this._reduceChildren({}, function(acc, control, name) {
                            if (control.enabled || _this.disabled) {
                                acc[name] = control.value;
                            }
                            return acc;
                        });
                    };
                    /** @internal */
                    FormGroup.prototype._reduceChildren = function(initValue, fn) {
                        var res = initValue;
                        this._forEachChild(function(control, name) {
                            res = fn(res, control, name);
                        });
                        return res;
                    };
                    /** @internal */
                    FormGroup.prototype._allControlsDisabled = function() {
                        for (var _i = 0, _a = Object.keys(this.controls); _i < _a.length; _i++) {
                            var controlName = _a[_i];
                            if (this.controls[controlName].enabled) {
                                return false;
                            }
                        }
                        return Object.keys(this.controls).length > 0 || this.disabled;
                    };
                    /** @internal */
                    FormGroup.prototype._checkAllValuesPresent = function(value) {
                        this._forEachChild(function(control, name) {
                            if (value[name] === undefined) {
                                throw new Error("Must supply a value for form control with name: '" + name + "'.");
                            }
                        });
                    };
                    return FormGroup;
                })(AbstractControl);
                /**
                 * @whatItDoes Tracks the value and validity state of an array of {@link FormControl}
                 * instances.
                 *
                 * A `FormArray` aggregates the values of each child {@link FormControl} into an array.
                 * It calculates its status by reducing the statuses of its children. For example, if one of
                 * the controls in a `FormArray` is invalid, the entire array becomes invalid.
                 *
                 * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,
                 * along with {@link FormControl} and {@link FormGroup}.
                 *
                 * @howToUse
                 *
                 * When instantiating a {@link FormArray}, pass in an array of child controls as the first
                 * argument.
                 *
                 * ### Example
                 *
                 * ```
                 * const arr = new FormArray([
                 *   new FormControl('Nancy', Validators.minLength(2)),
                 *   new FormControl('Drew'),
                 * ]);
                 *
                 * console.log(arr.value);   // ['Nancy', 'Drew']
                 * console.log(arr.status);  // 'VALID'
                 * ```
                 *
                 * You can also include array-level validators as the second arg, or array-level async
                 * validators as the third arg. These come in handy when you want to perform validation
                 * that considers the value of more than one child control.
                 *
                 * ### Adding or removing controls
                 *
                 * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
                 * in `FormArray` itself. These methods ensure the controls are properly tracked in the
                 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
                 * the `FormArray` directly, as that will result in strange and unexpected behavior such
                 * as broken change detection.
                 *
                 * * **npm package**: `@angular/forms`
                 *
                 * @stable
                 */
                var FormArray = (function(_super) {
                    __extends$6(FormArray, _super);
                    function FormArray(controls, validator, asyncValidator) {
                        if (validator === void 0) {
                            validator = null;
                        }
                        if (asyncValidator === void 0) {
                            asyncValidator = null;
                        }
                        _super.call(this, validator, asyncValidator);
                        this.controls = controls;
                        this._initObservables();
                        this._setUpControls();
                        this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
                    }
                    /**
                     * Get the {@link AbstractControl} at the given `index` in the array.
                     */
                    FormArray.prototype.at = function(index) {
                        return this.controls[index];
                    };
                    /**
                     * Insert a new {@link AbstractControl} at the end of the array.
                     */
                    FormArray.prototype.push = function(control) {
                        this.controls.push(control);
                        this._registerControl(control);
                        this.updateValueAndValidity();
                        this._onCollectionChange();
                    };
                    /**
                     * Insert a new {@link AbstractControl} at the given `index` in the array.
                     */
                    FormArray.prototype.insert = function(index, control) {
                        this.controls.splice(index, 0, control);
                        this._registerControl(control);
                        this.updateValueAndValidity();
                        this._onCollectionChange();
                    };
                    /**
                     * Remove the control at the given `index` in the array.
                     */
                    FormArray.prototype.removeAt = function(index) {
                        if (this.controls[index]) this.controls[index]._registerOnCollectionChange(function() {});
                        this.controls.splice(index, 1);
                        this.updateValueAndValidity();
                        this._onCollectionChange();
                    };
                    /**
                     * Replace an existing control.
                     */
                    FormArray.prototype.setControl = function(index, control) {
                        if (this.controls[index]) this.controls[index]._registerOnCollectionChange(function() {});
                        this.controls.splice(index, 1);
                        if (control) {
                            this.controls.splice(index, 0, control);
                            this._registerControl(control);
                        }
                        this.updateValueAndValidity();
                        this._onCollectionChange();
                    };
                    Object.defineProperty(FormArray.prototype, 'length', {
                        /**
                         * Length of the control array.
                         */
                        get: function() {
                            return this.controls.length;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     *  Sets the value of the {@link FormArray}. It accepts an array that matches
                     *  the structure of the control.
                     *
                     * This method performs strict checks, so it will throw an error if you try
                     * to set the value of a control that doesn't exist or if you exclude the
                     * value of a control.
                     *
                     *  ### Example
                     *
                     *  ```
                     *  const arr = new FormArray([
                     *     new FormControl(),
                     *     new FormControl()
                     *  ]);
                     *  console.log(arr.value);   // [null, null]
                     *
                     *  arr.setValue(['Nancy', 'Drew']);
                     *  console.log(arr.value);   // ['Nancy', 'Drew']
                     *  ```
                     */
                    FormArray.prototype.setValue = function(value, _a) {
                        var _this = this;
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent;
                        this._checkAllValuesPresent(value);
                        value.forEach(function(newValue, index) {
                            _this._throwIfControlMissing(index);
                            _this.at(index).setValue(newValue, { onlySelf: true, emitEvent: emitEvent });
                        });
                        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
                    };
                    /**
                     *  Patches the value of the {@link FormArray}. It accepts an array that matches the
                     *  structure of the control, and will do its best to match the values to the correct
                     *  controls in the group.
                     *
                     *  It accepts both super-sets and sub-sets of the array without throwing an error.
                     *
                     *  ### Example
                     *
                     *  ```
                     *  const arr = new FormArray([
                     *     new FormControl(),
                     *     new FormControl()
                     *  ]);
                     *  console.log(arr.value);   // [null, null]
                     *
                     *  arr.patchValue(['Nancy']);
                     *  console.log(arr.value);   // ['Nancy', null]
                     *  ```
                     */
                    FormArray.prototype.patchValue = function(value, _a) {
                        var _this = this;
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent;
                        value.forEach(function(newValue, index) {
                            if (_this.at(index)) {
                                _this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: emitEvent });
                            }
                        });
                        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
                    };
                    /**
                     * Resets the {@link FormArray}. This means by default:
                     *
                     * * The array and all descendants are marked `pristine`
                     * * The array and all descendants are marked `untouched`
                     * * The value of all descendants will be null or null maps
                     *
                     * You can also reset to a specific form state by passing in an array of states
                     * that matches the structure of the control. The state can be a standalone value
                     * or a form state object with both a value and a disabled status.
                     *
                     * ### Example
                     *
                     * ```ts
                     * this.arr.reset(['name', 'last name']);
                     *
                     * console.log(this.arr.value);  // ['name', 'last name']
                     * ```
                     *
                     * - OR -
                     *
                     * ```
                     * this.arr.reset([
                     *   {value: 'name', disabled: true},
                     *   'last'
                     * ]);
                     *
                     * console.log(this.arr.value);  // ['name', 'last name']
                     * console.log(this.arr.get(0).status);  // 'DISABLED'
                     * ```
                     */
                    FormArray.prototype.reset = function(value, _a) {
                        if (value === void 0) {
                            value = [];
                        }
                        var _b = _a === void 0 ? {} : _a,
                            onlySelf = _b.onlySelf,
                            emitEvent = _b.emitEvent;
                        this._forEachChild(function(control, index) {
                            control.reset(value[index], { onlySelf: true, emitEvent: emitEvent });
                        });
                        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
                        this._updatePristine({ onlySelf: onlySelf });
                        this._updateTouched({ onlySelf: onlySelf });
                    };
                    /**
                     * The aggregate value of the array, including any disabled controls.
                     *
                     * If you'd like to include all values regardless of disabled status, use this method.
                     * Otherwise, the `value` property is the best way to get the value of the array.
                     */
                    FormArray.prototype.getRawValue = function() {
                        return this.controls.map(function(control) {
                            return control.value;
                        });
                    };
                    /** @internal */
                    FormArray.prototype._throwIfControlMissing = function(index) {
                        if (!this.controls.length) {
                            throw new Error(
                                "\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "
                            );
                        }
                        if (!this.at(index)) {
                            throw new Error('Cannot find form control at index ' + index);
                        }
                    };
                    /** @internal */
                    FormArray.prototype._forEachChild = function(cb) {
                        this.controls.forEach(function(control, index) {
                            cb(control, index);
                        });
                    };
                    /** @internal */
                    FormArray.prototype._updateValue = function() {
                        var _this = this;
                        this._value = this.controls
                            .filter(function(control) {
                                return control.enabled || _this.disabled;
                            })
                            .map(function(control) {
                                return control.value;
                            });
                    };
                    /** @internal */
                    FormArray.prototype._anyControls = function(condition) {
                        return this.controls.some(function(control) {
                            return control.enabled && condition(control);
                        });
                    };
                    /** @internal */
                    FormArray.prototype._setUpControls = function() {
                        var _this = this;
                        this._forEachChild(function(control) {
                            return _this._registerControl(control);
                        });
                    };
                    /** @internal */
                    FormArray.prototype._checkAllValuesPresent = function(value) {
                        this._forEachChild(function(control, i) {
                            if (value[i] === undefined) {
                                throw new Error('Must supply a value for form control at index: ' + i + '.');
                            }
                        });
                    };
                    /** @internal */
                    FormArray.prototype._allControlsDisabled = function() {
                        for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {
                            var control = _a[_i];
                            if (control.enabled) return false;
                        }
                        return this.controls.length > 0 || this.disabled;
                    };
                    FormArray.prototype._registerControl = function(control) {
                        control.setParent(this);
                        control._registerOnCollectionChange(this._onCollectionChange);
                    };
                    return FormArray;
                })(AbstractControl);

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$4 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                var formDirectiveProvider = {
                    provide: ControlContainer,
                    useExisting: _angular_core.forwardRef(function() {
                        return NgForm;
                    })
                };
                var resolvedPromise = Promise.resolve(null);
                /**
                 * @whatItDoes Creates a top-level {@link FormGroup} instance and binds it to a form
                 * to track aggregate form value and validation status.
                 *
                 * @howToUse
                 *
                 * As soon as you import the `FormsModule`, this directive becomes active by default on
                 * all `<form>` tags.  You don't need to add a special selector.
                 *
                 * You can export the directive into a local template variable using `ngForm` as the key
                 * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
                 * {@link FormGroup} instance are duplicated on the directive itself, so a reference to it
                 * will give you access to the aggregate value and validity status of the form, as well as
                 * user interaction properties like `dirty` and `touched`.
                 *
                 * To register child controls with the form, you'll want to use {@link NgModel} with a
                 * `name` attribute.  You can also use {@link NgModelGroup} if you'd like to create
                 * sub-groups within the form.
                 *
                 * You can listen to the directive's `ngSubmit` event to be notified when the user has
                 * triggered a form submission. The `ngSubmit` event will be emitted with the original form
                 * submission event.
                 *
                 * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
                 *
                 * * **npm package**: `@angular/forms`
                 *
                 * * **NgModule**: `FormsModule`
                 *
                 *  @stable
                 */
                var NgForm = (function(_super) {
                    __extends$4(NgForm, _super);
                    function NgForm(validators, asyncValidators) {
                        _super.call(this);
                        this._submitted = false;
                        this.ngSubmit = new EventEmitter();
                        this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
                    }
                    Object.defineProperty(NgForm.prototype, 'submitted', {
                        get: function() {
                            return this._submitted;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgForm.prototype, 'formDirective', {
                        get: function() {
                            return this;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgForm.prototype, 'control', {
                        get: function() {
                            return this.form;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgForm.prototype, 'path', {
                        get: function() {
                            return [];
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgForm.prototype, 'controls', {
                        get: function() {
                            return this.form.controls;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    NgForm.prototype.addControl = function(dir) {
                        var _this = this;
                        resolvedPromise.then(function() {
                            var container = _this._findContainer(dir.path);
                            dir._control = container.registerControl(dir.name, dir.control);
                            setUpControl(dir.control, dir);
                            dir.control.updateValueAndValidity({ emitEvent: false });
                        });
                    };
                    NgForm.prototype.getControl = function(dir) {
                        return this.form.get(dir.path);
                    };
                    NgForm.prototype.removeControl = function(dir) {
                        var _this = this;
                        resolvedPromise.then(function() {
                            var container = _this._findContainer(dir.path);
                            if (container) {
                                container.removeControl(dir.name);
                            }
                        });
                    };
                    NgForm.prototype.addFormGroup = function(dir) {
                        var _this = this;
                        resolvedPromise.then(function() {
                            var container = _this._findContainer(dir.path);
                            var group = new FormGroup({});
                            setUpFormContainer(group, dir);
                            container.registerControl(dir.name, group);
                            group.updateValueAndValidity({ emitEvent: false });
                        });
                    };
                    NgForm.prototype.removeFormGroup = function(dir) {
                        var _this = this;
                        resolvedPromise.then(function() {
                            var container = _this._findContainer(dir.path);
                            if (container) {
                                container.removeControl(dir.name);
                            }
                        });
                    };
                    NgForm.prototype.getFormGroup = function(dir) {
                        return this.form.get(dir.path);
                    };
                    NgForm.prototype.updateModel = function(dir, value) {
                        var _this = this;
                        resolvedPromise.then(function() {
                            var ctrl = _this.form.get(dir.path);
                            ctrl.setValue(value);
                        });
                    };
                    NgForm.prototype.setValue = function(value) {
                        this.control.setValue(value);
                    };
                    NgForm.prototype.onSubmit = function($event) {
                        this._submitted = true;
                        this.ngSubmit.emit($event);
                        return false;
                    };
                    NgForm.prototype.onReset = function() {
                        this.resetForm();
                    };
                    NgForm.prototype.resetForm = function(value) {
                        if (value === void 0) {
                            value = undefined;
                        }
                        this.form.reset(value);
                        this._submitted = false;
                    };
                    /** @internal */
                    NgForm.prototype._findContainer = function(path) {
                        path.pop();
                        return path.length ? this.form.get(path) : this.form;
                    };
                    NgForm.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',
                                    providers: [formDirectiveProvider],
                                    host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
                                    outputs: ['ngSubmit'],
                                    exportAs: 'ngForm'
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    NgForm.ctorParameters = [
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS] }
                            ]
                        }
                    ];
                    return NgForm;
                })(ControlContainer);

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var Examples = {
                    formControlName:
                        '\n    <div [formGroup]="myGroup">\n      <input formControlName="firstName">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });',
                    formGroupName:
                        '\n    <div [formGroup]="myGroup">\n       <div formGroupName="person">\n          <input formControlName="firstName">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });',
                    formArrayName:
                        '\n    <div [formGroup]="myGroup">\n      <div formArrayName="cities">\n        <div *ngFor="let city of cityArray.controls; let i=index">\n          <input [formControlName]="i">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl(\'SF\')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });',
                    ngModelGroup:
                        '\n    <form>\n       <div ngModelGroup="person">\n          <input [(ngModel)]="person.name" name="firstName">\n       </div>\n    </form>',
                    ngModelWithFormGroup:
                        '\n    <div [formGroup]="myGroup">\n       <input formControlName="firstName">\n       <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">\n    </div>\n  '
                };

                var TemplateDrivenErrors = (function() {
                    function TemplateDrivenErrors() {}
                    TemplateDrivenErrors.modelParentException = function() {
                        throw new Error(
                            '\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup\'s partner directive "formControlName" instead.  Example:\n\n      ' +
                                Examples.formControlName +
                                "\n\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n      Example:\n\n      " +
                                Examples.ngModelWithFormGroup
                        );
                    };
                    TemplateDrivenErrors.formGroupNameException = function() {
                        throw new Error(
                            '\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      ' +
                                Examples.formGroupName +
                                "\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      " +
                                Examples.ngModelGroup
                        );
                    };
                    TemplateDrivenErrors.missingNameException = function() {
                        throw new Error(
                            'If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as \'standalone\' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]="person.firstName" name="first">\n      Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">'
                        );
                    };
                    TemplateDrivenErrors.modelGroupParentException = function() {
                        throw new Error(
                            '\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      ' +
                                Examples.formGroupName +
                                '\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      ' +
                                Examples.ngModelGroup
                        );
                    };
                    return TemplateDrivenErrors;
                })();

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$8 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                var modelGroupProvider = {
                    provide: ControlContainer,
                    useExisting: _angular_core.forwardRef(function() {
                        return NgModelGroup;
                    })
                };
                /**
                 * @whatItDoes Creates and binds a {@link FormGroup} instance to a DOM element.
                 *
                 * @howToUse
                 *
                 * This directive can only be used as a child of {@link NgForm} (or in other words,
                 * within `<form>` tags).
                 *
                 * Use this directive if you'd like to create a sub-group within a form. This can
                 * come in handy if you want to validate a sub-group of your form separately from
                 * the rest of your form, or if some values in your domain model make more sense to
                 * consume together in a nested object.
                 *
                 * Pass in the name you'd like this sub-group to have and it will become the key
                 * for the sub-group in the form's full value. You can also export the directive into
                 * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
                 *
                 * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
                 *
                 * * **npm package**: `@angular/forms`
                 *
                 * * **NgModule**: `FormsModule`
                 *
                 * @stable
                 */
                var NgModelGroup = (function(_super) {
                    __extends$8(NgModelGroup, _super);
                    function NgModelGroup(parent, validators, asyncValidators) {
                        _super.call(this);
                        this._parent = parent;
                        this._validators = validators;
                        this._asyncValidators = asyncValidators;
                    }
                    /** @internal */
                    NgModelGroup.prototype._checkParentType = function() {
                        if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
                            TemplateDrivenErrors.modelGroupParentException();
                        }
                    };
                    NgModelGroup.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' }]
                        }
                    ];
                    /** @nocollapse */
                    NgModelGroup.ctorParameters = [
                        { type: ControlContainer, decorators: [{ type: _angular_core.Host }, { type: _angular_core.SkipSelf }] },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS] }
                            ]
                        }
                    ];
                    NgModelGroup.propDecorators = {
                        name: [{ type: _angular_core.Input, args: ['ngModelGroup'] }]
                    };
                    return NgModelGroup;
                })(AbstractFormGroupDirective);

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$7 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                var formControlBinding = {
                    provide: NgControl,
                    useExisting: _angular_core.forwardRef(function() {
                        return NgModel;
                    })
                };
                /**
                 * `ngModel` forces an additional change detection run when its inputs change:
                 * E.g.:
                 * ```
                 * <div>{{myModel.valid}}</div>
                 * <input [(ngModel)]="myValue" #myModel="ngModel">
                 * ```
                 * I.e. `ngModel` can export itself on the element and then be used in the template.
                 * Normally, this would result in expressions before the `input` that use the exported directive
                 * to have and old value as they have been
                 * dirty checked before. As this is a very common case for `ngModel`, we added this second change
                 * detection run.
                 *
                 * Notes:
                 * - this is just one extra run no matter how many `ngModel` have been changed.
                 * - this is a general problem when using `exportAs` for directives!
                 */
                var resolvedPromise$1 = Promise.resolve(null);
                /**
                 * @whatItDoes Creates a {@link FormControl} instance from a domain model and binds it
                 * to a form control element.
                 *
                 * The {@link FormControl} instance will track the value, user interaction, and
                 * validation status of the control and keep the view synced with the model. If used
                 * within a parent form, the directive will also register itself with the form as a child
                 * control.
                 *
                 * @howToUse
                 *
                 * This directive can be used by itself or as part of a larger form. All you need is the
                 * `ngModel` selector to activate it.
                 *
                 * It accepts a domain model as an optional {@link @Input}. If you have a one-way binding
                 * to `ngModel` with `[]` syntax, changing the value of the domain model in the component
                 * class will set the value in the view. If you have a two-way binding with `[()]` syntax
                 * (also known as 'banana-box syntax'), the value in the UI will always be synced back to
                 * the domain model in your class as well.
                 *
                 * If you wish to inspect the properties of the associated {@link FormControl} (like
                 * validity state), you can also export the directive into a local template variable using
                 * `ngModel` as the key (ex: `#myVar="ngModel"`). You can then access the control using the
                 * directive's `control` property, but most properties you'll need (like `valid` and `dirty`)
                 * will fall through to the control anyway, so you can access them directly. You can see a
                 * full list of properties directly available in {@link AbstractControlDirective}.
                 *
                 * The following is an example of a simple standalone control using `ngModel`:
                 *
                 * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
                 *
                 * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
                 * so that the control can be registered with the parent form under that name.
                 *
                 * It's worth noting that in the context of a parent form, you often can skip one-way or
                 * two-way binding because the parent form will sync the value for you. You can access
                 * its properties by exporting it into a local template variable using `ngForm` (ex:
                 * `#f="ngForm"`). Then you can pass it where it needs to go on submit.
                 *
                 * If you do need to populate initial values into your form, using a one-way binding for
                 * `ngModel` tends to be sufficient as long as you use the exported form's value rather
                 * than the domain model's value on submit.
                 *
                 * Take a look at an example of using `ngModel` within a form:
                 *
                 * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
                 *
                 * To see `ngModel` examples with different form control types, see:
                 *
                 * * Radio buttons: {@link RadioControlValueAccessor}
                 * * Selects: {@link SelectControlValueAccessor}
                 *
                 * **npm package**: `@angular/forms`
                 *
                 * **NgModule**: `FormsModule`
                 *
                 *  @stable
                 */
                var NgModel = (function(_super) {
                    __extends$7(NgModel, _super);
                    function NgModel(parent, validators, asyncValidators, valueAccessors) {
                        _super.call(this);
                        /** @internal */
                        this._control = new FormControl();
                        /** @internal */
                        this._registered = false;
                        this.update = new EventEmitter();
                        this._parent = parent;
                        this._rawValidators = validators || [];
                        this._rawAsyncValidators = asyncValidators || [];
                        this.valueAccessor = selectValueAccessor(this, valueAccessors);
                    }
                    NgModel.prototype.ngOnChanges = function(changes) {
                        this._checkForErrors();
                        if (!this._registered) this._setUpControl();
                        if ('isDisabled' in changes) {
                            this._updateDisabled(changes);
                        }
                        if (isPropertyUpdated(changes, this.viewModel)) {
                            this._updateValue(this.model);
                            this.viewModel = this.model;
                        }
                    };
                    NgModel.prototype.ngOnDestroy = function() {
                        this.formDirective && this.formDirective.removeControl(this);
                    };
                    Object.defineProperty(NgModel.prototype, 'control', {
                        get: function() {
                            return this._control;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgModel.prototype, 'path', {
                        get: function() {
                            return this._parent ? controlPath(this.name, this._parent) : [this.name];
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgModel.prototype, 'formDirective', {
                        get: function() {
                            return this._parent ? this._parent.formDirective : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgModel.prototype, 'validator', {
                        get: function() {
                            return composeValidators(this._rawValidators);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(NgModel.prototype, 'asyncValidator', {
                        get: function() {
                            return composeAsyncValidators(this._rawAsyncValidators);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    NgModel.prototype.viewToModelUpdate = function(newValue) {
                        this.viewModel = newValue;
                        this.update.emit(newValue);
                    };
                    NgModel.prototype._setUpControl = function() {
                        this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
                        this._registered = true;
                    };
                    NgModel.prototype._isStandalone = function() {
                        return !this._parent || (this.options && this.options.standalone);
                    };
                    NgModel.prototype._setUpStandalone = function() {
                        setUpControl(this._control, this);
                        this._control.updateValueAndValidity({ emitEvent: false });
                    };
                    NgModel.prototype._checkForErrors = function() {
                        if (!this._isStandalone()) {
                            this._checkParentType();
                        }
                        this._checkName();
                    };
                    NgModel.prototype._checkParentType = function() {
                        if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
                            TemplateDrivenErrors.formGroupNameException();
                        } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
                            TemplateDrivenErrors.modelParentException();
                        }
                    };
                    NgModel.prototype._checkName = function() {
                        if (this.options && this.options.name) this.name = this.options.name;
                        if (!this._isStandalone() && !this.name) {
                            TemplateDrivenErrors.missingNameException();
                        }
                    };
                    NgModel.prototype._updateValue = function(value) {
                        var _this = this;
                        resolvedPromise$1.then(function() {
                            _this.control.setValue(value, { emitViewToModelChange: false });
                        });
                    };
                    NgModel.prototype._updateDisabled = function(changes) {
                        var _this = this;
                        var disabledValue = changes['isDisabled'].currentValue;
                        var isDisabled = disabledValue === '' || (disabledValue && disabledValue !== 'false');
                        resolvedPromise$1.then(function() {
                            if (isDisabled && !_this.control.disabled) {
                                _this.control.disable();
                            } else if (!isDisabled && _this.control.disabled) {
                                _this.control.enable();
                            }
                        });
                    };
                    NgModel.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: '[ngModel]:not([formControlName]):not([formControl])',
                                    providers: [formControlBinding],
                                    exportAs: 'ngModel'
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    NgModel.ctorParameters = [
                        { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }] },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR] }
                            ]
                        }
                    ];
                    NgModel.propDecorators = {
                        name: [{ type: _angular_core.Input }],
                        isDisabled: [{ type: _angular_core.Input, args: ['disabled'] }],
                        model: [{ type: _angular_core.Input, args: ['ngModel'] }],
                        options: [{ type: _angular_core.Input, args: ['ngModelOptions'] }],
                        update: [{ type: _angular_core.Output, args: ['ngModelChange'] }]
                    };
                    return NgModel;
                })(NgControl);

                var ReactiveErrors = (function() {
                    function ReactiveErrors() {}
                    ReactiveErrors.controlParentException = function() {
                        throw new Error(
                            "formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " +
                                Examples.formControlName
                        );
                    };
                    ReactiveErrors.ngModelGroupException = function() {
                        throw new Error(
                            'formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a "form" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        ' +
                                Examples.formGroupName +
                                '\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        ' +
                                Examples.ngModelGroup
                        );
                    };
                    ReactiveErrors.missingFormException = function() {
                        throw new Error(
                            'formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       ' + Examples.formControlName
                        );
                    };
                    ReactiveErrors.groupParentException = function() {
                        throw new Error(
                            "formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " +
                                Examples.formGroupName
                        );
                    };
                    ReactiveErrors.arrayParentException = function() {
                        throw new Error(
                            "formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        " +
                                Examples.formArrayName
                        );
                    };
                    ReactiveErrors.disabledAttrWarning = function() {
                        console.warn(
                            "\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    "
                        );
                    };
                    return ReactiveErrors;
                })();

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$9 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                var formControlBinding$1 = {
                    provide: NgControl,
                    useExisting: _angular_core.forwardRef(function() {
                        return FormControlDirective;
                    })
                };
                /**
                 * @whatItDoes Syncs a standalone {@link FormControl} instance to a form control element.
                 *
                 * In other words, this directive ensures that any values written to the {@link FormControl}
                 * instance programmatically will be written to the DOM element (model -> view). Conversely,
                 * any values written to the DOM element through user input will be reflected in the
                 * {@link FormControl} instance (view -> model).
                 *
                 * @howToUse
                 *
                 * Use this directive if you'd like to create and manage a {@link FormControl} instance directly.
                 * Simply create a {@link FormControl}, save it to your component class, and pass it into the
                 * {@link FormControlDirective}.
                 *
                 * This directive is designed to be used as a standalone control.  Unlike {@link FormControlName},
                 * it does not require that your {@link FormControl} instance be part of any parent
                 * {@link FormGroup}, and it won't be registered to any {@link FormGroupDirective} that
                 * exists above it.
                 *
                 * **Get the value**: the `value` property is always synced and available on the
                 * {@link FormControl} instance. See a full list of available properties in
                 * {@link AbstractControl}.
                 *
                 * **Set the value**: You can pass in an initial value when instantiating the {@link FormControl},
                 * or you can set it programmatically later using {@link AbstractControl.setValue} or
                 * {@link AbstractControl.patchValue}.
                 *
                 * **Listen to value**: If you want to listen to changes in the value of the control, you can
                 * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to
                 * {@link AbstractControl.statusChanges} to be notified when the validation status is
                 * re-calculated.
                 *
                 * ### Example
                 *
                 * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
                 *
                 * * **npm package**: `@angular/forms`
                 *
                 * * **NgModule**: `ReactiveFormsModule`
                 *
                 *  @stable
                 */
                var FormControlDirective = (function(_super) {
                    __extends$9(FormControlDirective, _super);
                    function FormControlDirective(validators, asyncValidators, valueAccessors) {
                        _super.call(this);
                        this.update = new EventEmitter();
                        this._rawValidators = validators || [];
                        this._rawAsyncValidators = asyncValidators || [];
                        this.valueAccessor = selectValueAccessor(this, valueAccessors);
                    }
                    Object.defineProperty(FormControlDirective.prototype, 'isDisabled', {
                        set: function(isDisabled) {
                            ReactiveErrors.disabledAttrWarning();
                        },
                        enumerable: true,
                        configurable: true
                    });
                    FormControlDirective.prototype.ngOnChanges = function(changes) {
                        if (this._isControlChanged(changes)) {
                            setUpControl(this.form, this);
                            if (this.control.disabled && this.valueAccessor.setDisabledState) {
                                this.valueAccessor.setDisabledState(true);
                            }
                            this.form.updateValueAndValidity({ emitEvent: false });
                        }
                        if (isPropertyUpdated(changes, this.viewModel)) {
                            this.form.setValue(this.model);
                            this.viewModel = this.model;
                        }
                    };
                    Object.defineProperty(FormControlDirective.prototype, 'path', {
                        get: function() {
                            return [];
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormControlDirective.prototype, 'validator', {
                        get: function() {
                            return composeValidators(this._rawValidators);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormControlDirective.prototype, 'asyncValidator', {
                        get: function() {
                            return composeAsyncValidators(this._rawAsyncValidators);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormControlDirective.prototype, 'control', {
                        get: function() {
                            return this.form;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    FormControlDirective.prototype.viewToModelUpdate = function(newValue) {
                        this.viewModel = newValue;
                        this.update.emit(newValue);
                    };
                    FormControlDirective.prototype._isControlChanged = function(changes) {
                        return changes.hasOwnProperty('form');
                    };
                    FormControlDirective.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [{ selector: '[formControl]', providers: [formControlBinding$1], exportAs: 'ngForm' }]
                        }
                    ];
                    /** @nocollapse */
                    FormControlDirective.ctorParameters = [
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR] }
                            ]
                        }
                    ];
                    FormControlDirective.propDecorators = {
                        form: [{ type: _angular_core.Input, args: ['formControl'] }],
                        model: [{ type: _angular_core.Input, args: ['ngModel'] }],
                        update: [{ type: _angular_core.Output, args: ['ngModelChange'] }],
                        isDisabled: [{ type: _angular_core.Input, args: ['disabled'] }]
                    };
                    return FormControlDirective;
                })(NgControl);

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$11 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                var formDirectiveProvider$1 = {
                    provide: ControlContainer,
                    useExisting: _angular_core.forwardRef(function() {
                        return FormGroupDirective;
                    })
                };
                /**
                 * @whatItDoes Binds an existing {@link FormGroup} to a DOM element.
                 *
                 * @howToUse
                 *
                 * This directive accepts an existing {@link FormGroup} instance. It will then use this
                 * {@link FormGroup} instance to match any child {@link FormControl}, {@link FormGroup},
                 * and {@link FormArray} instances to child {@link FormControlName}, {@link FormGroupName},
                 * and {@link FormArrayName} directives.
                 *
                 * **Set value**: You can set the form's initial value when instantiating the
                 * {@link FormGroup}, or you can set it programmatically later using the {@link FormGroup}'s
                 * {@link AbstractControl.setValue} or {@link AbstractControl.patchValue} methods.
                 *
                 * **Listen to value**: If you want to listen to changes in the value of the form, you can subscribe
                 * to the {@link FormGroup}'s {@link AbstractControl.valueChanges} event.  You can also listen to
                 * its {@link AbstractControl.statusChanges} event to be notified when the validation status is
                 * re-calculated.
                 *
                 * Furthermore, you can listen to the directive's `ngSubmit` event to be notified when the user has
                 * triggered a form submission. The `ngSubmit` event will be emitted with the original form
                 * submission event.
                 *
                 * ### Example
                 *
                 * In this example, we create form controls for first name and last name.
                 *
                 * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
                 *
                 * **npm package**: `@angular/forms`
                 *
                 * **NgModule**: {@link ReactiveFormsModule}
                 *
                 *  @stable
                 */
                var FormGroupDirective = (function(_super) {
                    __extends$11(FormGroupDirective, _super);
                    function FormGroupDirective(_validators, _asyncValidators) {
                        _super.call(this);
                        this._validators = _validators;
                        this._asyncValidators = _asyncValidators;
                        this._submitted = false;
                        this.directives = [];
                        this.form = null;
                        this.ngSubmit = new EventEmitter();
                    }
                    FormGroupDirective.prototype.ngOnChanges = function(changes) {
                        this._checkFormPresent();
                        if (changes.hasOwnProperty('form')) {
                            this._updateValidators();
                            this._updateDomValue();
                            this._updateRegistrations();
                        }
                    };
                    Object.defineProperty(FormGroupDirective.prototype, 'submitted', {
                        get: function() {
                            return this._submitted;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormGroupDirective.prototype, 'formDirective', {
                        get: function() {
                            return this;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormGroupDirective.prototype, 'control', {
                        get: function() {
                            return this.form;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormGroupDirective.prototype, 'path', {
                        get: function() {
                            return [];
                        },
                        enumerable: true,
                        configurable: true
                    });
                    FormGroupDirective.prototype.addControl = function(dir) {
                        var ctrl = this.form.get(dir.path);
                        setUpControl(ctrl, dir);
                        ctrl.updateValueAndValidity({ emitEvent: false });
                        this.directives.push(dir);
                        return ctrl;
                    };
                    FormGroupDirective.prototype.getControl = function(dir) {
                        return this.form.get(dir.path);
                    };
                    FormGroupDirective.prototype.removeControl = function(dir) {
                        ListWrapper.remove(this.directives, dir);
                    };
                    FormGroupDirective.prototype.addFormGroup = function(dir) {
                        var ctrl = this.form.get(dir.path);
                        setUpFormContainer(ctrl, dir);
                        ctrl.updateValueAndValidity({ emitEvent: false });
                    };
                    FormGroupDirective.prototype.removeFormGroup = function(dir) {};
                    FormGroupDirective.prototype.getFormGroup = function(dir) {
                        return this.form.get(dir.path);
                    };
                    FormGroupDirective.prototype.addFormArray = function(dir) {
                        var ctrl = this.form.get(dir.path);
                        setUpFormContainer(ctrl, dir);
                        ctrl.updateValueAndValidity({ emitEvent: false });
                    };
                    FormGroupDirective.prototype.removeFormArray = function(dir) {};
                    FormGroupDirective.prototype.getFormArray = function(dir) {
                        return this.form.get(dir.path);
                    };
                    FormGroupDirective.prototype.updateModel = function(dir, value) {
                        var ctrl = this.form.get(dir.path);
                        ctrl.setValue(value);
                    };
                    FormGroupDirective.prototype.onSubmit = function($event) {
                        this._submitted = true;
                        this.ngSubmit.emit($event);
                        return false;
                    };
                    FormGroupDirective.prototype.onReset = function() {
                        this.resetForm();
                    };
                    FormGroupDirective.prototype.resetForm = function(value) {
                        if (value === void 0) {
                            value = undefined;
                        }
                        this.form.reset(value);
                        this._submitted = false;
                    };
                    /** @internal */
                    FormGroupDirective.prototype._updateDomValue = function() {
                        var _this = this;
                        this.directives.forEach(function(dir) {
                            var newCtrl = _this.form.get(dir.path);
                            if (dir._control !== newCtrl) {
                                cleanUpControl(dir._control, dir);
                                if (newCtrl) setUpControl(newCtrl, dir);
                                dir._control = newCtrl;
                            }
                        });
                        this.form._updateTreeValidity({ emitEvent: false });
                    };
                    FormGroupDirective.prototype._updateRegistrations = function() {
                        var _this = this;
                        this.form._registerOnCollectionChange(function() {
                            return _this._updateDomValue();
                        });
                        if (this._oldForm) this._oldForm._registerOnCollectionChange(function() {});
                        this._oldForm = this.form;
                    };
                    FormGroupDirective.prototype._updateValidators = function() {
                        var sync = composeValidators(this._validators);
                        this.form.validator = Validators.compose([this.form.validator, sync]);
                        var async = composeAsyncValidators(this._asyncValidators);
                        this.form.asyncValidator = Validators.composeAsync([this.form.asyncValidator, async]);
                    };
                    FormGroupDirective.prototype._checkFormPresent = function() {
                        if (!this.form) {
                            ReactiveErrors.missingFormException();
                        }
                    };
                    FormGroupDirective.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: '[formGroup]',
                                    providers: [formDirectiveProvider$1],
                                    host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
                                    exportAs: 'ngForm'
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    FormGroupDirective.ctorParameters = [
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS] }
                            ]
                        }
                    ];
                    FormGroupDirective.propDecorators = {
                        form: [{ type: _angular_core.Input, args: ['formGroup'] }],
                        ngSubmit: [{ type: _angular_core.Output }]
                    };
                    return FormGroupDirective;
                })(ControlContainer);

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$12 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                var formGroupNameProvider = {
                    provide: ControlContainer,
                    useExisting: _angular_core.forwardRef(function() {
                        return FormGroupName;
                    })
                };
                /**
                 * @whatItDoes Syncs a nested {@link FormGroup} to a DOM element.
                 *
                 * @howToUse
                 *
                 * This directive can only be used with a parent {@link FormGroupDirective} (selector:
                 * `[formGroup]`).
                 *
                 * It accepts the string name of the nested {@link FormGroup} you want to link, and
                 * will look for a {@link FormGroup} registered with that name in the parent
                 * {@link FormGroup} instance you passed into {@link FormGroupDirective}.
                 *
                 * Nested form groups can come in handy when you want to validate a sub-group of a
                 * form separately from the rest or when you'd like to group the values of certain
                 * controls into their own nested object.
                 *
                 * **Access the group**: You can access the associated {@link FormGroup} using the
                 * {@link AbstractControl.get} method. Ex: `this.form.get('name')`.
                 *
                 * You can also access individual controls within the group using dot syntax.
                 * Ex: `this.form.get('name.first')`
                 *
                 * **Get the value**: the `value` property is always synced and available on the
                 * {@link FormGroup}. See a full list of available properties in {@link AbstractControl}.
                 *
                 * **Set the value**: You can set an initial value for each child control when instantiating
                 * the {@link FormGroup}, or you can set it programmatically later using
                 * {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}.
                 *
                 * **Listen to value**: If you want to listen to changes in the value of the group, you can
                 * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to
                 * {@link AbstractControl.statusChanges} to be notified when the validation status is
                 * re-calculated.
                 *
                 * ### Example
                 *
                 * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
                 *
                 * * **npm package**: `@angular/forms`
                 *
                 * * **NgModule**: `ReactiveFormsModule`
                 *
                 * @stable
                 */
                var FormGroupName = (function(_super) {
                    __extends$12(FormGroupName, _super);
                    function FormGroupName(parent, validators, asyncValidators) {
                        _super.call(this);
                        this._parent = parent;
                        this._validators = validators;
                        this._asyncValidators = asyncValidators;
                    }
                    /** @internal */
                    FormGroupName.prototype._checkParentType = function() {
                        if (_hasInvalidParent(this._parent)) {
                            ReactiveErrors.groupParentException();
                        }
                    };
                    FormGroupName.decorators = [
                        { type: _angular_core.Directive, args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] }] }
                    ];
                    /** @nocollapse */
                    FormGroupName.ctorParameters = [
                        {
                            type: ControlContainer,
                            decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf }]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS] }
                            ]
                        }
                    ];
                    FormGroupName.propDecorators = {
                        name: [{ type: _angular_core.Input, args: ['formGroupName'] }]
                    };
                    return FormGroupName;
                })(AbstractFormGroupDirective);
                var formArrayNameProvider = {
                    provide: ControlContainer,
                    useExisting: _angular_core.forwardRef(function() {
                        return FormArrayName;
                    })
                };
                /**
                 * @whatItDoes Syncs a nested {@link FormArray} to a DOM element.
                 *
                 * @howToUse
                 *
                 * This directive is designed to be used with a parent {@link FormGroupDirective} (selector:
                 * `[formGroup]`).
                 *
                 * It accepts the string name of the nested {@link FormArray} you want to link, and
                 * will look for a {@link FormArray} registered with that name in the parent
                 * {@link FormGroup} instance you passed into {@link FormGroupDirective}.
                 *
                 * Nested form arrays can come in handy when you have a group of form controls but
                 * you're not sure how many there will be. Form arrays allow you to create new
                 * form controls dynamically.
                 *
                 * **Access the array**: You can access the associated {@link FormArray} using the
                 * {@link AbstractControl.get} method on the parent {@link FormGroup}.
                 * Ex: `this.form.get('cities')`.
                 *
                 * **Get the value**: the `value` property is always synced and available on the
                 * {@link FormArray}. See a full list of available properties in {@link AbstractControl}.
                 *
                 * **Set the value**: You can set an initial value for each child control when instantiating
                 * the {@link FormArray}, or you can set the value programmatically later using the
                 * {@link FormArray}'s {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}
                 * methods.
                 *
                 * **Listen to value**: If you want to listen to changes in the value of the array, you can
                 * subscribe to the {@link FormArray}'s {@link AbstractControl.valueChanges} event.  You can also
                 * listen to its {@link AbstractControl.statusChanges} event to be notified when the validation
                 * status is re-calculated.
                 *
                 * **Add new controls**: You can add new controls to the {@link FormArray} dynamically by
                 * calling its {@link FormArray.push} method.
                 *  Ex: `this.form.get('cities').push(new FormControl());`
                 *
                 * ### Example
                 *
                 * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
                 *
                 * * **npm package**: `@angular/forms`
                 *
                 * * **NgModule**: `ReactiveFormsModule`
                 *
                 * @stable
                 */
                var FormArrayName = (function(_super) {
                    __extends$12(FormArrayName, _super);
                    function FormArrayName(parent, validators, asyncValidators) {
                        _super.call(this);
                        this._parent = parent;
                        this._validators = validators;
                        this._asyncValidators = asyncValidators;
                    }
                    FormArrayName.prototype.ngOnInit = function() {
                        this._checkParentType();
                        this.formDirective.addFormArray(this);
                    };
                    FormArrayName.prototype.ngOnDestroy = function() {
                        if (this.formDirective) {
                            this.formDirective.removeFormArray(this);
                        }
                    };
                    Object.defineProperty(FormArrayName.prototype, 'control', {
                        get: function() {
                            return this.formDirective.getFormArray(this);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormArrayName.prototype, 'formDirective', {
                        get: function() {
                            return this._parent ? this._parent.formDirective : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormArrayName.prototype, 'path', {
                        get: function() {
                            return controlPath(this.name, this._parent);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormArrayName.prototype, 'validator', {
                        get: function() {
                            return composeValidators(this._validators);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormArrayName.prototype, 'asyncValidator', {
                        get: function() {
                            return composeAsyncValidators(this._asyncValidators);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    FormArrayName.prototype._checkParentType = function() {
                        if (_hasInvalidParent(this._parent)) {
                            ReactiveErrors.arrayParentException();
                        }
                    };
                    FormArrayName.decorators = [
                        { type: _angular_core.Directive, args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] }] }
                    ];
                    /** @nocollapse */
                    FormArrayName.ctorParameters = [
                        {
                            type: ControlContainer,
                            decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf }]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS] }
                            ]
                        }
                    ];
                    FormArrayName.propDecorators = {
                        name: [{ type: _angular_core.Input, args: ['formArrayName'] }]
                    };
                    return FormArrayName;
                })(ControlContainer);
                function _hasInvalidParent(parent) {
                    return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
                }

                /**
                 * @license
                 * Copyright Google Inc. All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var __extends$10 =
                    (this && this.__extends) ||
                    function(d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                    };
                var controlNameBinding = {
                    provide: NgControl,
                    useExisting: _angular_core.forwardRef(function() {
                        return FormControlName;
                    })
                };
                /**
                 * @whatItDoes  Syncs a {@link FormControl} in an existing {@link FormGroup} to a form control
                 * element by name.
                 *
                 * In other words, this directive ensures that any values written to the {@link FormControl}
                 * instance programmatically will be written to the DOM element (model -> view). Conversely,
                 * any values written to the DOM element through user input will be reflected in the
                 * {@link FormControl} instance (view -> model).
                 *
                 * @howToUse
                 *
                 * This directive is designed to be used with a parent {@link FormGroupDirective} (selector:
                 * `[formGroup]`).
                 *
                 * It accepts the string name of the {@link FormControl} instance you want to
                 * link, and will look for a {@link FormControl} registered with that name in the
                 * closest {@link FormGroup} or {@link FormArray} above it.
                 *
                 * **Access the control**: You can access the {@link FormControl} associated with
                 * this directive by using the {@link AbstractControl.get} method.
                 * Ex: `this.form.get('first');`
                 *
                 * **Get value**: the `value` property is always synced and available on the {@link FormControl}.
                 * See a full list of available properties in {@link AbstractControl}.
                 *
                 *  **Set value**: You can set an initial value for the control when instantiating the
                 *  {@link FormControl}, or you can set it programmatically later using
                 *  {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}.
                 *
                 * **Listen to value**: If you want to listen to changes in the value of the control, you can
                 * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to
                 * {@link AbstractControl.statusChanges} to be notified when the validation status is
                 * re-calculated.
                 *
                 * ### Example
                 *
                 * In this example, we create form controls for first name and last name.
                 *
                 * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
                 *
                 * To see `formControlName` examples with different form control types, see:
                 *
                 * * Radio buttons: {@link RadioControlValueAccessor}
                 * * Selects: {@link SelectControlValueAccessor}
                 *
                 * **npm package**: `@angular/forms`
                 *
                 * **NgModule**: {@link ReactiveFormsModule}
                 *
                 *  @stable
                 */
                var FormControlName = (function(_super) {
                    __extends$10(FormControlName, _super);
                    function FormControlName(parent, validators, asyncValidators, valueAccessors) {
                        _super.call(this);
                        this._added = false;
                        this.update = new EventEmitter();
                        this._parent = parent;
                        this._rawValidators = validators || [];
                        this._rawAsyncValidators = asyncValidators || [];
                        this.valueAccessor = selectValueAccessor(this, valueAccessors);
                    }
                    Object.defineProperty(FormControlName.prototype, 'isDisabled', {
                        set: function(isDisabled) {
                            ReactiveErrors.disabledAttrWarning();
                        },
                        enumerable: true,
                        configurable: true
                    });
                    FormControlName.prototype.ngOnChanges = function(changes) {
                        if (!this._added) this._setUpControl();
                        if (isPropertyUpdated(changes, this.viewModel)) {
                            this.viewModel = this.model;
                            this.formDirective.updateModel(this, this.model);
                        }
                    };
                    FormControlName.prototype.ngOnDestroy = function() {
                        if (this.formDirective) {
                            this.formDirective.removeControl(this);
                        }
                    };
                    FormControlName.prototype.viewToModelUpdate = function(newValue) {
                        this.viewModel = newValue;
                        this.update.emit(newValue);
                    };
                    Object.defineProperty(FormControlName.prototype, 'path', {
                        get: function() {
                            return controlPath(this.name, this._parent);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormControlName.prototype, 'formDirective', {
                        get: function() {
                            return this._parent ? this._parent.formDirective : null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormControlName.prototype, 'validator', {
                        get: function() {
                            return composeValidators(this._rawValidators);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormControlName.prototype, 'asyncValidator', {
                        get: function() {
                            return composeAsyncValidators(this._rawAsyncValidators);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(FormControlName.prototype, 'control', {
                        get: function() {
                            return this._control;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    FormControlName.prototype._checkParentType = function() {
                        if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
                            ReactiveErrors.ngModelGroupException();
                        } else if (
                            !(this._parent instanceof FormGroupName) &&
                            !(this._parent instanceof FormGroupDirective) &&
                            !(this._parent instanceof FormArrayName)
                        ) {
                            ReactiveErrors.controlParentException();
                        }
                    };
                    FormControlName.prototype._setUpControl = function() {
                        this._checkParentType();
                        this._control = this.formDirective.addControl(this);
                        if (this.control.disabled && this.valueAccessor.setDisabledState) {
                            this.valueAccessor.setDisabledState(true);
                        }
                        this._added = true;
                    };
                    FormControlName.decorators = [
                        { type: _angular_core.Directive, args: [{ selector: '[formControlName]', providers: [controlNameBinding] }] }
                    ];
                    /** @nocollapse */
                    FormControlName.ctorParameters = [
                        {
                            type: ControlContainer,
                            decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf }]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS] }
                            ]
                        },
                        {
                            type: Array,
                            decorators: [
                                { type: _angular_core.Optional },
                                { type: _angular_core.Self },
                                { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR] }
                            ]
                        }
                    ];
                    FormControlName.propDecorators = {
                        name: [{ type: _angular_core.Input, args: ['formControlName'] }],
                        model: [{ type: _angular_core.Input, args: ['ngModel'] }],
                        update: [{ type: _angular_core.Output, args: ['ngModelChange'] }],
                        isDisabled: [{ type: _angular_core.Input, args: ['disabled'] }]
                    };
                    return FormControlName;
                })(NgControl);

                var REQUIRED_VALIDATOR = {
                    provide: NG_VALIDATORS,
                    useExisting: _angular_core.forwardRef(function() {
                        return RequiredValidator;
                    }),
                    multi: true
                };
                /**
                 * A Directive that adds the `required` validator to any controls marked with the
                 * `required` attribute, via the {@link NG_VALIDATORS} binding.
                 *
                 * ### Example
                 *
                 * ```
                 * <input name="fullName" ngModel required>
                 * ```
                 *
                 * @stable
                 */
                var RequiredValidator = (function() {
                    function RequiredValidator() {}
                    Object.defineProperty(RequiredValidator.prototype, 'required', {
                        get: function() {
                            return this._required;
                        },
                        set: function(value) {
                            this._required = value != null && value !== false && '' + value !== 'false';
                            if (this._onChange) this._onChange();
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RequiredValidator.prototype.validate = function(c) {
                        return this.required ? Validators.required(c) : null;
                    };
                    RequiredValidator.prototype.registerOnValidatorChange = function(fn) {
                        this._onChange = fn;
                    };
                    RequiredValidator.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: '[required][formControlName],[required][formControl],[required][ngModel]',
                                    providers: [REQUIRED_VALIDATOR],
                                    host: { '[attr.required]': 'required ? "" : null' }
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    RequiredValidator.ctorParameters = [];
                    RequiredValidator.propDecorators = {
                        required: [{ type: _angular_core.Input }]
                    };
                    return RequiredValidator;
                })();
                /**
                 * Provider which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.
                 *
                 * ## Example:
                 *
                 * {@example common/forms/ts/validators/validators.ts region='min'}
                 */
                var MIN_LENGTH_VALIDATOR = {
                    provide: NG_VALIDATORS,
                    useExisting: _angular_core.forwardRef(function() {
                        return MinLengthValidator;
                    }),
                    multi: true
                };
                /**
                 * A directive which installs the {@link MinLengthValidator} for any `formControlName`,
                 * `formControl`, or control with `ngModel` that also has a `minlength` attribute.
                 *
                 * @stable
                 */
                var MinLengthValidator = (function() {
                    function MinLengthValidator() {}
                    MinLengthValidator.prototype.ngOnChanges = function(changes) {
                        if ('minlength' in changes) {
                            this._createValidator();
                            if (this._onChange) this._onChange();
                        }
                    };
                    MinLengthValidator.prototype.validate = function(c) {
                        return this.minlength == null ? null : this._validator(c);
                    };
                    MinLengthValidator.prototype.registerOnValidatorChange = function(fn) {
                        this._onChange = fn;
                    };
                    MinLengthValidator.prototype._createValidator = function() {
                        this._validator = Validators.minLength(parseInt(this.minlength, 10));
                    };
                    MinLengthValidator.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
                                    providers: [MIN_LENGTH_VALIDATOR],
                                    host: { '[attr.minlength]': 'minlength ? minlength : null' }
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    MinLengthValidator.ctorParameters = [];
                    MinLengthValidator.propDecorators = {
                        minlength: [{ type: _angular_core.Input }]
                    };
                    return MinLengthValidator;
                })();
                /**
                 * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.
                 *
                 * ## Example:
                 *
                 * {@example common/forms/ts/validators/validators.ts region='max'}
                 */
                var MAX_LENGTH_VALIDATOR = {
                    provide: NG_VALIDATORS,
                    useExisting: _angular_core.forwardRef(function() {
                        return MaxLengthValidator;
                    }),
                    multi: true
                };
                /**
                 * A directive which installs the {@link MaxLengthValidator} for any `formControlName,
                 * `formControl`,
                 * or control with `ngModel` that also has a `maxlength` attribute.
                 *
                 * @stable
                 */
                var MaxLengthValidator = (function() {
                    function MaxLengthValidator() {}
                    MaxLengthValidator.prototype.ngOnChanges = function(changes) {
                        if ('maxlength' in changes) {
                            this._createValidator();
                            if (this._onChange) this._onChange();
                        }
                    };
                    MaxLengthValidator.prototype.validate = function(c) {
                        return this.maxlength != null ? this._validator(c) : null;
                    };
                    MaxLengthValidator.prototype.registerOnValidatorChange = function(fn) {
                        this._onChange = fn;
                    };
                    MaxLengthValidator.prototype._createValidator = function() {
                        this._validator = Validators.maxLength(parseInt(this.maxlength, 10));
                    };
                    MaxLengthValidator.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
                                    providers: [MAX_LENGTH_VALIDATOR],
                                    host: { '[attr.maxlength]': 'maxlength ? maxlength : null' }
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    MaxLengthValidator.ctorParameters = [];
                    MaxLengthValidator.propDecorators = {
                        maxlength: [{ type: _angular_core.Input }]
                    };
                    return MaxLengthValidator;
                })();
                var PATTERN_VALIDATOR = {
                    provide: NG_VALIDATORS,
                    useExisting: _angular_core.forwardRef(function() {
                        return PatternValidator;
                    }),
                    multi: true
                };
                /**
                 * A Directive that adds the `pattern` validator to any controls marked with the
                 * `pattern` attribute, via the {@link NG_VALIDATORS} binding. Uses attribute value
                 * as the regex to validate Control value against.  Follows pattern attribute
                 * semantics; i.e. regex must match entire Control value.
                 *
                 * ### Example
                 *
                 * ```
                 * <input [name]="fullName" pattern="[a-zA-Z ]*" ngModel>
                 * ```
                 * @stable
                 */
                var PatternValidator = (function() {
                    function PatternValidator() {}
                    PatternValidator.prototype.ngOnChanges = function(changes) {
                        if ('pattern' in changes) {
                            this._createValidator();
                            if (this._onChange) this._onChange();
                        }
                    };
                    PatternValidator.prototype.validate = function(c) {
                        return this._validator(c);
                    };
                    PatternValidator.prototype.registerOnValidatorChange = function(fn) {
                        this._onChange = fn;
                    };
                    PatternValidator.prototype._createValidator = function() {
                        this._validator = Validators.pattern(this.pattern);
                    };
                    PatternValidator.decorators = [
                        {
                            type: _angular_core.Directive,
                            args: [
                                {
                                    selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
                                    providers: [PATTERN_VALIDATOR],
                                    host: { '[attr.pattern]': 'pattern ? pattern : null' }
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    PatternValidator.ctorParameters = [];
                    PatternValidator.propDecorators = {
                        pattern: [{ type: _angular_core.Input }]
                    };
                    return PatternValidator;
                })();

                /**
                 * @whatItDoes Creates an {@link AbstractControl} from a user-specified configuration.
                 *
                 * It is essentially syntactic sugar that shortens the `new FormGroup()`,
                 * `new FormControl()`, and `new FormArray()` boilerplate that can build up in larger
                 * forms.
                 *
                 * @howToUse
                 *
                 * To use, inject `FormBuilder` into your component class. You can then call its methods
                 * directly.
                 *
                 * {@example forms/ts/formBuilder/form_builder_example.ts region='Component'}
                 *
                 *  * **npm package**: `@angular/forms`
                 *
                 *  * **NgModule**: {@link ReactiveFormsModule}
                 *
                 * @stable
                 */
                var FormBuilder = (function() {
                    function FormBuilder() {}
                    /**
                     * Construct a new {@link FormGroup} with the given map of configuration.
                     * Valid keys for the `extra` parameter map are `validator` and `asyncValidator`.
                     *
                     * See the {@link FormGroup} constructor for more details.
                     */
                    FormBuilder.prototype.group = function(controlsConfig, extra) {
                        if (extra === void 0) {
                            extra = null;
                        }
                        var controls = this._reduceControls(controlsConfig);
                        var validator = isPresent(extra) ? extra['validator'] : null;
                        var asyncValidator = isPresent(extra) ? extra['asyncValidator'] : null;
                        return new FormGroup(controls, validator, asyncValidator);
                    };
                    /**
                     * Construct a new {@link FormControl} with the given `formState`,`validator`, and
                     * `asyncValidator`.
                     *
                     * `formState` can either be a standalone value for the form control or an object
                     * that contains both a value and a disabled status.
                     *
                     */
                    FormBuilder.prototype.control = function(formState, validator, asyncValidator) {
                        if (validator === void 0) {
                            validator = null;
                        }
                        if (asyncValidator === void 0) {
                            asyncValidator = null;
                        }
                        return new FormControl(formState, validator, asyncValidator);
                    };
                    /**
                     * Construct a {@link FormArray} from the given `controlsConfig` array of
                     * configuration, with the given optional `validator` and `asyncValidator`.
                     */
                    FormBuilder.prototype.array = function(controlsConfig, validator, asyncValidator) {
                        var _this = this;
                        if (validator === void 0) {
                            validator = null;
                        }
                        if (asyncValidator === void 0) {
                            asyncValidator = null;
                        }
                        var controls = controlsConfig.map(function(c) {
                            return _this._createControl(c);
                        });
                        return new FormArray(controls, validator, asyncValidator);
                    };
                    /** @internal */
                    FormBuilder.prototype._reduceControls = function(controlsConfig) {
                        var _this = this;
                        var controls = {};
                        Object.keys(controlsConfig).forEach(function(controlName) {
                            controls[controlName] = _this._createControl(controlsConfig[controlName]);
                        });
                        return controls;
                    };
                    /** @internal */
                    FormBuilder.prototype._createControl = function(controlConfig) {
                        if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup || controlConfig instanceof FormArray) {
                            return controlConfig;
                        } else if (Array.isArray(controlConfig)) {
                            var value = controlConfig[0];
                            var validator = controlConfig.length > 1 ? controlConfig[1] : null;
                            var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
                            return this.control(value, validator, asyncValidator);
                        } else {
                            return this.control(controlConfig);
                        }
                    };
                    FormBuilder.decorators = [{ type: _angular_core.Injectable }];
                    /** @nocollapse */
                    FormBuilder.ctorParameters = [];
                    return FormBuilder;
                })();

                var SHARED_FORM_DIRECTIVES = [
                    NgSelectOption,
                    NgSelectMultipleOption,
                    DefaultValueAccessor,
                    NumberValueAccessor,
                    RangeValueAccessor,
                    CheckboxControlValueAccessor,
                    SelectControlValueAccessor,
                    SelectMultipleControlValueAccessor,
                    RadioControlValueAccessor,
                    NgControlStatus,
                    NgControlStatusGroup,
                    RequiredValidator,
                    MinLengthValidator,
                    MaxLengthValidator,
                    PatternValidator
                ];
                var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
                var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
                /**
                 * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
                 */
                var InternalFormsSharedModule = (function() {
                    function InternalFormsSharedModule() {}
                    InternalFormsSharedModule.decorators = [
                        {
                            type: _angular_core.NgModule,
                            args: [
                                {
                                    declarations: SHARED_FORM_DIRECTIVES,
                                    exports: SHARED_FORM_DIRECTIVES
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    InternalFormsSharedModule.ctorParameters = [];
                    return InternalFormsSharedModule;
                })();

                /**
                 * The ng module for forms.
                 * @stable
                 */
                var FormsModule = (function() {
                    function FormsModule() {}
                    FormsModule.decorators = [
                        {
                            type: _angular_core.NgModule,
                            args: [
                                {
                                    declarations: TEMPLATE_DRIVEN_DIRECTIVES,
                                    providers: [RadioControlRegistry],
                                    exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    FormsModule.ctorParameters = [];
                    return FormsModule;
                })();
                /**
                 * The ng module for reactive forms.
                 * @stable
                 */
                var ReactiveFormsModule = (function() {
                    function ReactiveFormsModule() {}
                    ReactiveFormsModule.decorators = [
                        {
                            type: _angular_core.NgModule,
                            args: [
                                {
                                    declarations: [REACTIVE_DRIVEN_DIRECTIVES],
                                    providers: [FormBuilder, RadioControlRegistry],
                                    exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
                                }
                            ]
                        }
                    ];
                    /** @nocollapse */
                    ReactiveFormsModule.ctorParameters = [];
                    return ReactiveFormsModule;
                })();

                exports.AbstractControlDirective = AbstractControlDirective;
                exports.AbstractFormGroupDirective = AbstractFormGroupDirective;
                exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;
                exports.ControlContainer = ControlContainer;
                exports.NG_VALUE_ACCESSOR = NG_VALUE_ACCESSOR;
                exports.DefaultValueAccessor = DefaultValueAccessor;
                exports.NgControl = NgControl;
                exports.NgControlStatus = NgControlStatus;
                exports.NgControlStatusGroup = NgControlStatusGroup;
                exports.NgForm = NgForm;
                exports.NgModel = NgModel;
                exports.NgModelGroup = NgModelGroup;
                exports.RadioControlValueAccessor = RadioControlValueAccessor;
                exports.FormControlDirective = FormControlDirective;
                exports.FormControlName = FormControlName;
                exports.FormGroupDirective = FormGroupDirective;
                exports.FormArrayName = FormArrayName;
                exports.FormGroupName = FormGroupName;
                exports.NgSelectOption = NgSelectOption;
                exports.SelectControlValueAccessor = SelectControlValueAccessor;
                exports.SelectMultipleControlValueAccessor = SelectMultipleControlValueAccessor;
                exports.MaxLengthValidator = MaxLengthValidator;
                exports.MinLengthValidator = MinLengthValidator;
                exports.PatternValidator = PatternValidator;
                exports.RequiredValidator = RequiredValidator;
                exports.FormBuilder = FormBuilder;
                exports.AbstractControl = AbstractControl;
                exports.FormArray = FormArray;
                exports.FormControl = FormControl;
                exports.FormGroup = FormGroup;
                exports.NG_ASYNC_VALIDATORS = NG_ASYNC_VALIDATORS;
                exports.NG_VALIDATORS = NG_VALIDATORS;
                exports.Validators = Validators;
                exports.FormsModule = FormsModule;
                exports.ReactiveFormsModule = ReactiveFormsModule;
            });

            /***/
        },
        ,
        ,
        ,
        /* 31 */ /* 32 */ /* 33 */ /* 34 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var HomeComponent = (function() {
                function HomeComponent() {}
                HomeComponent.prototype.ngOnInit = function() {};
                return HomeComponent;
            })();
            HomeComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'home',
                        template: __webpack_require__(35),
                        styles: [__webpack_require__(37)],
                        encapsulation: core_1.ViewEncapsulation.None
                    }),
                    __metadata('design:paramtypes', [])
                ],
                HomeComponent
            );
            exports.HomeComponent = HomeComponent;

            /***/
        },
        /* 35 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports = '<img class="home-image" src="' + __webpack_require__(36) + '"/>';

            /***/
        },
        /* 36 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__.p + 'assets/home.jpg';

            /***/
        },
        /* 37 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(38);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 38 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([module.id, '.home-image{width:100%;box-shadow:0 1px 2px 0 rgba(34,36,38,.15);border:1px solid #00004d}', '']);

            // exports

            /***/
        },
        ,
        /* 39 */ /* 40 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var AboutComponent = (function() {
                function AboutComponent() {}
                AboutComponent.prototype.ngOnInit = function() {};
                return AboutComponent;
            })();
            AboutComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'about',
                        template: __webpack_require__(41),
                        styles: [__webpack_require__(42)]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                AboutComponent
            );
            exports.AboutComponent = AboutComponent;

            /***/
        },
        /* 41 */
        /***/ function(module, exports) {
            module.exports =
                '<h1 class="ui header">About Us</h1>\n<p>Illinois Ultimate is one of the premier ultimate programs in the Midwest and frequently ranks in the National top 25. We strive to contend with the best programs in the country and qualify to compete at Nationals regulary. We are a program that prides itself on developing players who come to Illinois with no experience playing competitive ultimate. We teach all levels of ultimate, from the basics of throwing a forehand all the way to throwing bombs in the worst of weather.</p>\n<h2 class="ui header">Mission Statement</h2>\n<p>We want to compete at the highest level possible in college ultimate while remaining respectful to our opponents.  We want to develop all our of players to become the best they can be at ultimate, as well as players who exemplify the true meaning of sportsmanship, which is pivotal to the progress of ultimate frisbee in its current state.</p>\n<h2 class="ui header">Team Structure/Affiliation with University</h2>\n<p>Our team is a Registered Student Organization (RSO) at the University of Illinois and we are classified as a club sport. We receive some funding from the University that helps pay for our travel costs and hotels while we are at tournaments.</p>\n<p>We are a member of the USAU  College Series and compete in a series of tournaments that  culminate in the College Championships held every year during Memorial Day weekend. Most, if not all, state schools have established ultimate teams and many smaller schools have teams as well.  We compete in the Illinois conference which is as you can guess, the schools in the state of Illinois. The next largest division is the Great Lakes Region, which includes the states of Illinois, Indiana, Michigan, and Kentucky. The final step is the aforementioned National Championships.</p>\n<p>Our program is split up into two teams, A and B. Our A team is a group of individuals who are very dedicated to the team and who put in a large amount of time for practices as well as training outside of practices. Our B team is more oriented towards the development of younger or inexperienced players. B team provides a much more relaxed atmosphere but still remains competitive with all other B teams in the region, and even beats some smaller schools\' A teams.</p>\n<p>A team has tryouts each year, consisting of three to four tournaments in the fall. The first round of cuts will usually be made after the second tournament. The tryout roster will then be narrowed down to one team before the final tournament of the fall, via cuts on a rolling basis. Players may be moved between the A and B team rosters as necessary.</p>\n';

            /***/
        },
        /* 42 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(43);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 43 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([module.id, 'p{text-align:left}', '']);

            // exports

            /***/
        },
        /* 44 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var google_spreadsheet_service_1 = __webpack_require__(45);
            var gtm_util_1 = __webpack_require__(46);
            var ProspectivePlayersComponent = (function() {
                // Constructor with our http service injected
                function ProspectivePlayersComponent(spreadsheetService) {
                    this.spreadsheetService = spreadsheetService;
                    // API url for our personal server
                    this.googleSheetsApiUrl =
                        'https://nick-proz-node-server.herokuapp.com/sheets/11ijrHoysiIwsFfEggbSNM9Y8VvzU65jeuhQ3vkV5FGw/sheetIndex/2/rows/';
                    // API url for our backup server (sheetsu API)
                    // private googleSheetsBackupApiUrl = 'https://sheetsu.com/apis/v1.0/7a030ae60b7d';
                    this.googleSheetsBackupApiUrl = '';
                    // Error messages
                    this.validationErrors = 'Please do not leave any required fields blank.';
                    this.submissionError = 'Could not submit the form  due to a server error. Please try again soon or contact the web admins.';
                    // Contact input
                    this.contact = 'Yes';
                    // Boolean indicating if our form is in the process of submitting (to show our loading icon)
                    this.formIsSubmitting = false;
                    // Boolean indicating if our form was successfully submitted (to show our success message)
                    this.submitSuccess = false;
                }
                ProspectivePlayersComponent.prototype.ngOnInit = function() {};
                ProspectivePlayersComponent.prototype.handleSubmit = function(event) {
                    event.preventDefault();
                    this.submitSuccess = false;
                    if (!this.formIsValid()) {
                        this.formErrors = this.validationErrors;
                    } else {
                        this.formIsSubmitting = true;
                        this.formErrors = null;
                        var date = new Date();
                        var data = {
                            Timestamp: date.toLocaleString(),
                            'First Name': this.firstName,
                            'Last Name': this.lastName,
                            'Email Address': this.emailAddress,
                            Hometown: this.hometown,
                            Highschool: this.highschool,
                            Major: this.major,
                            Experience: this.experience,
                            'Other Clubs': this.otherClubs,
                            'Contact Me': this.contact
                        };
                        this.submitPlayerForm(data);
                    }
                };
                /**
                 * Submits our form to the spreadsheet by calling our service method.
                 * On success, we show our success message.
                 * On failure, we hide our submitting dialog and show our submission error to the user.
                 *
                 * @param data - data to submit to our spreadsheet
                 */
                ProspectivePlayersComponent.prototype.submitPlayerForm = function(data) {
                    var _this = this;
                    // Push our form data to the data layer for Google Tag Manager to consume
                    gtm_util_1.GtmUtil.pushObjectToDataLayer(
                        ProspectivePlayersComponent.gtmEventName,
                        ProspectivePlayersComponent.gtmVariableName,
                        data
                    );
                    this.spreadsheetService
                        .postRowToSpreadsheet(this.googleSheetsApiUrl, this.googleSheetsBackupApiUrl, data)
                        .then(function() {
                            _this.resetForm();
                            _this.submitSuccess = true;
                        })
                        .catch(function() {
                            _this.formIsSubmitting = false;
                            _this.formErrors = _this.submissionError;
                        });
                };
                /**
                 * Clears our input fields, errors, and resets our form is submitting flag.
                 */
                ProspectivePlayersComponent.prototype.resetForm = function() {
                    this.firstName = null;
                    this.lastName = null;
                    this.emailAddress = null;
                    this.hometown = null;
                    this.highschool = null;
                    this.major = null;
                    this.experience = null;
                    this.otherClubs = null;
                    this.formErrors = null;
                    this.formIsSubmitting = false;
                };
                /**
                 * Front-end validation for our form.
                 * Our form is valid only if all fields are populated.
                 *
                 * @returns {boolean} - true if the form is valid, false otherwise
                 */
                ProspectivePlayersComponent.prototype.formIsValid = function() {
                    return (
                        this.firstName != null &&
                        this.firstName != '' &&
                        this.lastName != null &&
                        this.lastName != '' &&
                        this.emailAddress != null &&
                        this.emailAddress != '' &&
                        this.hometown != null &&
                        this.hometown != '' &&
                        this.highschool != null &&
                        this.highschool != '' &&
                        this.major != null &&
                        this.major != '' &&
                        this.experience != null &&
                        this.experience != '' &&
                        this.otherClubs != null &&
                        this.otherClubs != '' &&
                        this.contact != null &&
                        this.contact != ''
                    );
                };
                return ProspectivePlayersComponent;
            })();
            // GTM variables
            ProspectivePlayersComponent.gtmEventName = 'Prospect Form Submit';
            ProspectivePlayersComponent.gtmVariableName = 'prospect-form';
            ProspectivePlayersComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'prospective-players',
                        template: __webpack_require__(47),
                        styles: [__webpack_require__(48)]
                    }),
                    __metadata('design:paramtypes', [
                        (typeof (_a =
                            typeof google_spreadsheet_service_1.SpreadsheetService !== 'undefined' &&
                            google_spreadsheet_service_1.SpreadsheetService) === 'function' &&
                            _a) ||
                            Object
                    ])
                ],
                ProspectivePlayersComponent
            );
            exports.ProspectivePlayersComponent = ProspectivePlayersComponent;
            var _a;

            /***/
        },
        /* 45 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var http_1 = __webpack_require__(29);
            /**
             * Service to interact with our Google spreadsheet.
             */
            var SpreadsheetService = (function() {
                // Constructor with our http service injected
                function SpreadsheetService(http) {
                    this.http = http;
                    // HTTP headers
                    this.headers = new http_1.Headers({ 'Content-Type': 'application/json' });
                }
                /**
                 * Attempts to post the data passed in to our spreadsheet.
                 * Rejects the promise if there is an error.
                 *
                 * @param apiUrl - url of the google sheets API
                 * @param backupApiUrl - url of hte google sheets backup API
                 * @param data - data to add to our spreadsheet
                 * @returns {Promise<JSON>} - Promise holding the successfully posted object, or a rejected promise with an error
                 */
                SpreadsheetService.prototype.postRowToSpreadsheet = function(apiUrl, backupApiUrl, data) {
                    return this.http
                        .post(apiUrl, data, { headers: this.headers })
                        .toPromise()
                        .then(function(response) {
                            return response.json();
                        })
                        .catch(SpreadsheetService.handleError);
                    // .catch(() => this.postRowToSpreadsheetBackup(backupApiUrl, data));
                };
                /**
                 * Attempts to post the data passed in to our backup spreadsheet.
                 * This is a backup post in case our personal server fails.
                 * Rejects the promise if there is an error.
                 *
                 * @param backupApiUrl - url of hte google sheets backup API
                 * @param data - data to add to our spreadsheet
                 * @returns {Promise<JSON>} - Promise holding the successfully posted object, or a rejected promise with an error
                 */
                SpreadsheetService.prototype.postRowToSpreadsheetBackup = function(backupApiUrl, data) {
                    return this.http
                        .post(backupApiUrl, data, { headers: this.headers })
                        .toPromise()
                        .then(function(response) {
                            return response.json();
                        })
                        .catch(SpreadsheetService.handleError);
                };
                /**
                 * Handles all rsvp service errors (after our backup call) when interfacing
                 * with the google spreadsheet api. We log the error and reject the promise.
                 *
                 * @param error - Error to log and reject
                 * @returns {Promise<any>} - A rejected promise
                 */
                SpreadsheetService.handleError = function(error) {
                    console.error('An error occurred when attempting to send data to our spreadsheet: ', error);
                    return Promise.reject(error);
                };
                return SpreadsheetService;
            })();
            SpreadsheetService = __decorate(
                [
                    core_1.Injectable(),
                    __metadata('design:paramtypes', [
                        (typeof (_a = typeof http_1.Http !== 'undefined' && http_1.Http) === 'function' && _a) || Object
                    ])
                ],
                SpreadsheetService
            );
            exports.SpreadsheetService = SpreadsheetService;
            var _a;

            /***/
        },
        /* 46 */
        /***/ function(module, exports) {
            'use strict';
            /**
             * Util for interacting with Google Tag Manager (GTM).
             */
            var GtmUtil = (function() {
                function GtmUtil() {}
                /**
                 * Pushes custom GTM data to the data layer.
                 *
                 * @param eventName - name of the event. This is the Custom Event name specified in a GTM trigger
                 * @param variableName - data layer variable name. This is the Data Layer Variable name in a GTM custom variable
                 * @param data - data object to push to GTM. We stringify the object so that it is readable
                 */
                GtmUtil.pushObjectToDataLayer = function(eventName, variableName, data) {
                    // Initialize our data layer, if it doesn't already exist
                    window.dataLayer = window.dataLayer || [];
                    // Push our GTM object with the event data passed in
                    window.dataLayer.push(((_a = { event: eventName }), (_a[variableName] = JSON.stringify(data)), _a));
                    var _a;
                };
                return GtmUtil;
            })();
            exports.GtmUtil = GtmUtil;

            /***/
        },
        /* 47 */
        /***/ function(module, exports) {
            module.exports =
                '<!--Header-->\n<h1 class="ui header">Prospective Players</h1>\n<p>Illinois Ultimate has had a long history since its inception in the early 1990s and now consistently competes with best competition around the country. Illinois has qualified for national championships frequently behind our dedication, determination, and distinguished character on and off the field. Illinois alumni have gone on to play for nationals caliber club teams such as Chicago Machine, Minneapolis Drag \'n Thrust, Cincinnati Steamboat, Atlanta Chain Lightning, and San Francisco Blackbird. Alumni have played on professional AUDL teams such as the Chicago Wildfire, Minnesota Windchill, Cincinnati Revolution, and the San Jose Spiders. They have also created and captained club teams including Chicago Machine, Black Market Ultimate, and Beachfront Ultimate, and have gone on to coach college ultimate at the University of Illinois, the University of Chicago, Northwestern University, and the University of Kentucky. It\'s safe to say that once you play ultimate at Illinois you are opened up to a world of opportunity through our alumni network, who are more than willing to assist you on your journey though ultimate during and beyond your college years.</p>\n<p>While you are at Illinois you will enjoy a number of experiences. This ranges from team socials to study groups and from practices in Irwin Fieldhouse to playing games on the shores of San Diego. Your teammates won\'t only be your best friends, they will be family. You will learn the various ways ultimate is played, how to expand your throwing arsenal, how to improve your athleticism, and how to take your game to the next level. A majority of our team didn\'t play organized ultimate before coming to college, and are now some of the best players in the Great Lakes region (see our All-Regions honors page).</p>\n<p>We encourage prospective players to fill out our interest form and to reach out to the captains especially if you will be on campus. We are more than happy to meet up and discuss what Illinois can do for you, and to see what you can do to be ready for Illinois once you get on campus. Our contact information is below. Thank you for taking the time to visit our website, and we hope to hear from you soon.</p>\n<!--Form-->\n<form class="ui form">\n        <div class="two fields">\n            <div class="field">\n                <label>First Name <span class="required">*</span></label>\n                <input [(ngModel)]="firstName" type="text" name="first-name" placeholder="First Name">\n            </div>\n            <div class="field">\n                <label>Last Name <span class="required">*</span></label>\n                <input [(ngModel)]="lastName" type="text" name="last-name" placeholder="Last Name">\n            </div>\n        </div>\n        <div class="two fields">\n            <div class="field">\n                <label>Email Address <span class="required">*</span></label>\n                <input [(ngModel)]="emailAddress" type="text" name="email-address" placeholder="Email Address">\n            </div>\n            <div class="field">\n                <label>What is your Hometown? <span class="required">*</span></label>\n                <input [(ngModel)]="hometown" type="text" name="home-town" placeholder="Hometown">\n            </div>\n        </div>\n        <div class="two fields">\n            <div class="field">\n                <label>What high school did you attend? <span class="required">*</span></label>\n                <input [(ngModel)]="highschool" type="text" name="highschool" placeholder="High School">\n            </div>\n            <div class="field">\n                <label>What major are you planning on going into? <span class="required">*</span></label>\n                <input [(ngModel)]="major" type="text" name="major" placeholder="Major">\n            </div>\n        </div>\n        <div class="field">\n            <label>How long have you played ultimate/what kind of experience do you have? <span class="required">*</span></label>\n            <textarea [(ngModel)]="experience" name="experience" rows="2"></textarea>\n        </div>\n        <div class="field">\n            <label>What other clubs/organizations are you planning on joining when you arrive on campus? <span class="required">*</span></label>\n            <textarea [(ngModel)]="otherClubs" name="other-clubs" rows="2"></textarea>\n        </div>\n        <div class="inline fields">\n            <label>Would you be alright with a captain or coach reaching out to you? <span class="required">*</span></label>\n            <div class="field">\n                <div class="ui radio checkbox">\n                    <input id="contact-yes" [(ngModel)]="contact" type="radio" name="contact" value="Yes" checked="checked" tabindex="0" class="hidden">\n                    <label for="contact-yes">Yes</label>\n                </div>\n            </div>\n            <div class="field">\n                <div class="ui radio checkbox">\n                    <input id="contact-no" [(ngModel)]="contact" type="radio" name="contact" value="No" tabindex="0" class="hidden">\n                    <label for="contact-no">No</label>\n                </div>\n            </div>\n        </div>\n    <button (click)="handleSubmit($event)" class="ui button submit-button" type="submit">Submit</button>\n    <!--Error/Success Messages-->\n    <div class="ui error message" *ngIf="formErrors">\n        <p>{{formErrors}}</p>\n    </div>\n    <div class="ui success message" *ngIf="submitSuccess">\n        <div class="header">Form Submitted</div>\n        <p>The form was successfully submitted! Thanks for taking the time to fill it out.</p>\n    </div>\n    <!--Submitting Loader-->\n    <div *ngIf="formIsSubmitting" class="ui active inverted dimmer"><div class="ui text loader">Submitting</div></div>\n</form>\n';

            /***/
        },
        /* 48 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(49);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 49 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([
                module.id,
                '.submit-button{margin-bottom:45px}label,p{text-align:left}.ui.form{margin:20px auto}.ui.form .ui.error.message,.ui.form .ui.success.message{display:block}.ui.form .ui.error.message p,.ui.form .ui.success.message p{text-align:center}',
                ''
            ]);

            // exports

            /***/
        },
        /* 50 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var ContactComponent = (function() {
                function ContactComponent() {}
                ContactComponent.prototype.ngOnInit = function() {};
                return ContactComponent;
            })();
            ContactComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'contact',
                        template: __webpack_require__(51),
                        styles: [__webpack_require__(52)]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                ContactComponent
            );
            exports.ContactComponent = ContactComponent;

            /***/
        },
        /* 51 */
        /***/ function(module, exports) {
            module.exports =
                '<h1 class="ui header">Contact Us</h1>\n<p>For any communication directed at the entire program, particularly information regarding tournaments, please contact us at this email:</p>\n\n<p class="program"><a href = "mailto: illiniulti@gmail.com">illiniulti@gmail.com</a></p>\n\n\n<p>For any questions regarding practice or club details, feel free to contact any of the current captains:</p>\n\n<p class="captain"><a href = "mailto: joeykennedy333@gmail.com">Joey Kennedy</a></p>\n<p class="captain"><a href = "mailto: reidamartin@gmail.com">Reid Martin</a></p>\n<p class="captain"><a href = "mailto: aruzzo2@illinois.edu">Anthony Ruzzo</a></p>\n';

            /***/
        },
        /* 52 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(53);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 53 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([module.id, '.captain{margin-bottom:0}', '']);

            // exports

            /***/
        },
        /* 54 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            __webpack_require__(55);
            var AppComponent = (function() {
                function AppComponent() {}
                AppComponent.prototype.ngOnInit = function() {};
                return AppComponent;
            })();
            AppComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'app',
                        template: __webpack_require__(59),
                        styles: [__webpack_require__(60)]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                AppComponent
            );
            exports.AppComponent = AppComponent;

            /***/
        },
        /* 55 */
        /***/ function(module, exports, __webpack_require__) {
            // style-loader: Adds some css to the DOM by adding a <style> tag

            // load the styles
            var content = __webpack_require__(56);
            if (typeof content === 'string') content = [[module.id, content, '']];
            // add the styles to the DOM
            var update = __webpack_require__(58)(content, {});
            if (content.locals) module.exports = content.locals;
            // Hot Module Replacement
            if (false) {
                // When the styles change, update the <style> tags
                if (!content.locals) {
                    module.hot.accept(
                        '!!../../../node_modules/css-loader/index.js!../../../node_modules/postcss-loader/lib/index.js!./styles.css',
                        function() {
                            var newContent = require('!!../../../node_modules/css-loader/index.js!../../../node_modules/postcss-loader/lib/index.js!./styles.css');
                            if (typeof newContent === 'string') newContent = [[module.id, newContent, '']];
                            update(newContent);
                        }
                    );
                }
                // When the module is disposed, remove the <style> tags
                module.hot.dispose(function() {
                    update();
                });
            }

            /***/
        },
        /* 56 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([
                module.id,
                'body{background-image:url(' +
                    __webpack_require__(57) +
                    ');font-family:Quattrocento,serif;text-align:center;overflow-y:scroll}p{text-indent:25px;padding:5px}a{color:#ff6226}a:hover{color:#00004d}input{font-family:Quattrocento,serif!important}input:focus{border-color:#ff6226!important}.ui.header{font-family:Oswald,sans-serif;color:#00004d;letter-spacing:1px}.ui.table td,.ui.table tr{text-align:center;border-top:0}.ui.secondary.pointing.menu{-ms-flex-pack:center;justify-content:center}.ui.secondary.pointing.menu .item.active{border-color:#00004d}.button{background-color:#ff6226!important;color:#fff!important}.required{color:#ff6226}',
                ''
            ]);

            // exports

            /***/
        },
        /* 57 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__.p + 'assets/background.jpg';

            /***/
        },
        ,
        /* 58 */ /* 59 */
        /***/ function(module, exports) {
            module.exports = '<main class="main-container">\n    <page-frame></page-frame>\n</main>\n';

            /***/
        },
        /* 60 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(61);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 61 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([module.id, '.main-container{height:100%}', '']);

            // exports

            /***/
        },
        /* 62 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var core_2 = __webpack_require__(63);
            var platform_browser_1 = __webpack_require__(26);
            var forms_1 = __webpack_require__(30);
            var practice_component_1 = __webpack_require__(86);
            var tournaments_component_1 = __webpack_require__(91);
            var roster_component_1 = __webpack_require__(126);
            var absent_component_1 = __webpack_require__(131);
            var router_1 = __webpack_require__(92);
            var app_routes_1 = __webpack_require__(136);
            var google_spreadsheet_service_1 = __webpack_require__(45);
            var TeamModule = (function() {
                function TeamModule() {}
                return TeamModule;
            })();
            TeamModule = __decorate(
                [
                    core_1.NgModule({
                        imports: [
                            platform_browser_1.BrowserModule,
                            forms_1.FormsModule,
                            core_2.AgmCoreModule.forRoot({
                                apiKey: 'AIzaSyBRIXAk5xdvn3ezypsSe55f8dZhcHheAZ8'
                            }),
                            router_1.RouterModule.forRoot(app_routes_1.ROUTES)
                        ],
                        declarations: [
                            practice_component_1.PracticeComponent,
                            tournaments_component_1.TournamentsComponent,
                            roster_component_1.RosterComponent,
                            absent_component_1.AbsentComponent
                        ],
                        providers: [google_spreadsheet_service_1.SpreadsheetService]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                TeamModule
            );
            exports.TeamModule = TeamModule;

            /***/
        },
        /* 63 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            function __export(m) {
                for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
            }
            // main modules
            __export(__webpack_require__(64));
            __export(__webpack_require__(81));
            // Google Maps types
            // core module
            // we explicitly export the module here to prevent this Ionic 2 bug:
            // http://stevemichelotti.com/integrate-angular-2-google-maps-into-ionic-2/
            var core_module_1 = __webpack_require__(85);
            exports.AgmCoreModule = core_module_1.AgmCoreModule;
            //# sourceMappingURL=index.js.map

            /***/
        },
        /* 64 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var google_map_1 = __webpack_require__(65);
            exports.SebmGoogleMap = google_map_1.SebmGoogleMap;
            var google_map_circle_1 = __webpack_require__(74);
            exports.SebmGoogleMapCircle = google_map_circle_1.SebmGoogleMapCircle;
            var google_map_info_window_1 = __webpack_require__(75);
            exports.SebmGoogleMapInfoWindow = google_map_info_window_1.SebmGoogleMapInfoWindow;
            var google_map_kml_layer_1 = __webpack_require__(76);
            exports.SebmGoogleMapKmlLayer = google_map_kml_layer_1.SebmGoogleMapKmlLayer;
            var google_map_marker_1 = __webpack_require__(77);
            exports.SebmGoogleMapMarker = google_map_marker_1.SebmGoogleMapMarker;
            var google_map_polygon_1 = __webpack_require__(78);
            exports.SebmGoogleMapPolygon = google_map_polygon_1.SebmGoogleMapPolygon;
            var google_map_polyline_1 = __webpack_require__(79);
            exports.SebmGoogleMapPolyline = google_map_polyline_1.SebmGoogleMapPolyline;
            var google_map_polyline_point_1 = __webpack_require__(80);
            exports.SebmGoogleMapPolylinePoint = google_map_polyline_point_1.SebmGoogleMapPolylinePoint;
            //# sourceMappingURL=directives.js.map

            /***/
        },
        /* 65 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var google_maps_api_wrapper_1 = __webpack_require__(66);
            var circle_manager_1 = __webpack_require__(68);
            var info_window_manager_1 = __webpack_require__(69);
            var marker_manager_1 = __webpack_require__(70);
            var polygon_manager_1 = __webpack_require__(71);
            var polyline_manager_1 = __webpack_require__(72);
            var kml_layer_manager_1 = __webpack_require__(73);
            /**
             * SebMGoogleMap renders a Google Map.
             * **Important note**: To be able see a map in the browser, you have to define a height for the CSS
             * class `sebm-google-map-container`.
             *
             * ### Example
             * ```typescript
             * import { Component } from '@angular/core';
             * import { SebmGoogleMap } from 'angular2-google-maps/core';
             *
             * @Component({
             *  selector: 'my-map-cmp',
             *  directives: [SebmGoogleMap],
             *  styles: [`
             *    .sebm-google-map-container {
             *      height: 300px;
             *    }
             * `],
             *  template: `
             *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
             *    </sebm-google-map>
             *  `
             * })
             * ```
             */
            var SebmGoogleMap = (function() {
                function SebmGoogleMap(_elem, _mapsWrapper) {
                    this._elem = _elem;
                    this._mapsWrapper = _mapsWrapper;
                    /**
                     * The longitude that defines the center of the map.
                     */
                    this.longitude = 0;
                    /**
                     * The latitude that defines the center of the map.
                     */
                    this.latitude = 0;
                    /**
                     * The zoom level of the map. The default zoom level is 8.
                     */
                    this.zoom = 8;
                    /**
                     * Enables/disables if map is draggable.
                     */
                    this.draggable = true;
                    /**
                     * Enables/disables zoom and center on double click. Enabled by default.
                     */
                    this.disableDoubleClickZoom = false;
                    /**
                     * Enables/disables all default UI of the Google map. Please note: When the map is created, this
                     * value cannot get updated.
                     */
                    this.disableDefaultUI = false;
                    /**
                     * If false, disables scrollwheel zooming on the map. The scrollwheel is enabled by default.
                     */
                    this.scrollwheel = true;
                    /**
                     * If false, prevents the map from being controlled by the keyboard. Keyboard shortcuts are
                     * enabled by default.
                     */
                    this.keyboardShortcuts = true;
                    /**
                     * The enabled/disabled state of the Zoom control.
                     */
                    this.zoomControl = true;
                    /**
                     * Styles to apply to each of the default map types. Note that for Satellite/Hybrid and Terrain
                     * modes, these styles will only apply to labels and geometry.
                     */
                    this.styles = [];
                    /**
                     * When true and the latitude and/or longitude values changes, the Google Maps panTo method is
                     * used to
                     * center the map. See: https://developers.google.com/maps/documentation/javascript/reference#Map
                     */
                    this.usePanning = false;
                    /**
                     * The initial enabled/disabled state of the Street View Pegman control.
                     * This control is part of the default UI, and should be set to false when displaying a map type
                     * on which the Street View road overlay should not appear (e.g. a non-Earth map type).
                     */
                    this.streetViewControl = true;
                    /**
                     * Sets the viewport to contain the given bounds.
                     */
                    this.fitBounds = null;
                    /**
                     * The initial enabled/disabled state of the Scale control. This is disabled by default.
                     */
                    this.scaleControl = false;
                    /**
                     * The initial enabled/disabled state of the Map type control.
                     */
                    this.mapTypeControl = false;
                    this._observableSubscriptions = [];
                    /**
                     * This event emitter gets emitted when the user clicks on the map (but not when they click on a
                     * marker or infoWindow).
                     */
                    this.mapClick = new core_1.EventEmitter();
                    /**
                     * This event emitter gets emitted when the user right-clicks on the map (but not when they click
                     * on a marker or infoWindow).
                     */
                    this.mapRightClick = new core_1.EventEmitter();
                    /**
                     * This event emitter gets emitted when the user double-clicks on the map (but not when they click
                     * on a marker or infoWindow).
                     */
                    this.mapDblClick = new core_1.EventEmitter();
                    /**
                     * This event emitter is fired when the map center changes.
                     */
                    this.centerChange = new core_1.EventEmitter();
                    /**
                     * This event is fired when the viewport bounds have changed.
                     */
                    this.boundsChange = new core_1.EventEmitter();
                    /**
                     * This event is fired when the map becomes idle after panning or zooming.
                     */
                    this.idle = new core_1.EventEmitter();
                    /**
                     * This event is fired when the zoom level has changed.
                     */
                    this.zoomChange = new core_1.EventEmitter();
                }
                /** @internal */
                SebmGoogleMap.prototype.ngOnInit = function() {
                    // todo: this should be solved with a new component and a viewChild decorator
                    var container = this._elem.nativeElement.querySelector('.sebm-google-map-container-inner');
                    this._initMapInstance(container);
                };
                SebmGoogleMap.prototype._initMapInstance = function(el) {
                    this._mapsWrapper.createMap(el, {
                        center: { lat: this.latitude || 0, lng: this.longitude || 0 },
                        zoom: this.zoom,
                        minZoom: this.minZoom,
                        maxZoom: this.maxZoom,
                        disableDefaultUI: this.disableDefaultUI,
                        backgroundColor: this.backgroundColor,
                        draggable: this.draggable,
                        draggableCursor: this.draggableCursor,
                        draggingCursor: this.draggingCursor,
                        keyboardShortcuts: this.keyboardShortcuts,
                        zoomControl: this.zoomControl,
                        styles: this.styles,
                        streetViewControl: this.streetViewControl,
                        scaleControl: this.scaleControl,
                        mapTypeControl: this.mapTypeControl
                    });
                    // register event listeners
                    this._handleMapCenterChange();
                    this._handleMapZoomChange();
                    this._handleMapMouseEvents();
                    this._handleBoundsChange();
                    this._handleIdleEvent();
                };
                /** @internal */
                SebmGoogleMap.prototype.ngOnDestroy = function() {
                    // unsubscribe all registered observable subscriptions
                    this._observableSubscriptions.forEach(function(s) {
                        return s.unsubscribe();
                    });
                };
                /* @internal */
                SebmGoogleMap.prototype.ngOnChanges = function(changes) {
                    this._updateMapOptionsChanges(changes);
                    this._updatePosition(changes);
                };
                SebmGoogleMap.prototype._updateMapOptionsChanges = function(changes) {
                    var options = {};
                    var optionKeys = Object.keys(changes).filter(function(k) {
                        return SebmGoogleMap._mapOptionsAttributes.indexOf(k) !== -1;
                    });
                    optionKeys.forEach(function(k) {
                        options[k] = changes[k].currentValue;
                    });
                    this._mapsWrapper.setMapOptions(options);
                };
                /**
                 * Triggers a resize event on the google map instance.
                 * Returns a promise that gets resolved after the event was triggered.
                 */
                SebmGoogleMap.prototype.triggerResize = function() {
                    var _this = this;
                    // Note: When we would trigger the resize event and show the map in the same turn (which is a
                    // common case for triggering a resize event), then the resize event would not
                    // work (to show the map), so we trigger the event in a timeout.
                    return new Promise(function(resolve) {
                        setTimeout(function() {
                            return _this._mapsWrapper.triggerMapEvent('resize').then(function() {
                                return resolve();
                            });
                        });
                    });
                };
                SebmGoogleMap.prototype._updatePosition = function(changes) {
                    if (changes['latitude'] == null && changes['longitude'] == null && changes['fitBounds'] == null) {
                        // no position update needed
                        return;
                    }
                    // we prefer fitBounds in changes
                    if (changes['fitBounds'] && this.fitBounds != null) {
                        this._fitBounds();
                        return;
                    }
                    if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {
                        return;
                    }
                    var newCenter = {
                        lat: this.latitude,
                        lng: this.longitude
                    };
                    if (this.usePanning) {
                        this._mapsWrapper.panTo(newCenter);
                    } else {
                        this._mapsWrapper.setCenter(newCenter);
                    }
                };
                SebmGoogleMap.prototype._fitBounds = function() {
                    if (this.usePanning) {
                        this._mapsWrapper.panToBounds(this.fitBounds);
                        return;
                    }
                    this._mapsWrapper.fitBounds(this.fitBounds);
                };
                SebmGoogleMap.prototype._handleMapCenterChange = function() {
                    var _this = this;
                    var s = this._mapsWrapper.subscribeToMapEvent('center_changed').subscribe(function() {
                        _this._mapsWrapper.getCenter().then(function(center) {
                            _this.latitude = center.lat();
                            _this.longitude = center.lng();
                            _this.centerChange.emit({ lat: _this.latitude, lng: _this.longitude });
                        });
                    });
                    this._observableSubscriptions.push(s);
                };
                SebmGoogleMap.prototype._handleBoundsChange = function() {
                    var _this = this;
                    var s = this._mapsWrapper.subscribeToMapEvent('bounds_changed').subscribe(function() {
                        _this._mapsWrapper.getBounds().then(function(bounds) {
                            _this.boundsChange.emit(bounds);
                        });
                    });
                    this._observableSubscriptions.push(s);
                };
                SebmGoogleMap.prototype._handleMapZoomChange = function() {
                    var _this = this;
                    var s = this._mapsWrapper.subscribeToMapEvent('zoom_changed').subscribe(function() {
                        _this._mapsWrapper.getZoom().then(function(z) {
                            _this.zoom = z;
                            _this.zoomChange.emit(z);
                        });
                    });
                    this._observableSubscriptions.push(s);
                };
                SebmGoogleMap.prototype._handleIdleEvent = function() {
                    var _this = this;
                    var s = this._mapsWrapper.subscribeToMapEvent('idle').subscribe(function() {
                        _this.idle.emit(void 0);
                    });
                    this._observableSubscriptions.push(s);
                };
                SebmGoogleMap.prototype._handleMapMouseEvents = function() {
                    var _this = this;
                    var events = [{ name: 'click', emitter: this.mapClick }, { name: 'rightclick', emitter: this.mapRightClick }];
                    events.forEach(function(e) {
                        var s = _this._mapsWrapper.subscribeToMapEvent(e.name).subscribe(function(event) {
                            var value = { coords: { lat: event.latLng.lat(), lng: event.latLng.lng() } };
                            e.emitter.emit(value);
                        });
                        _this._observableSubscriptions.push(s);
                    });
                };
                /**
                 * Map option attributes that can change over time
                 */
                SebmGoogleMap._mapOptionsAttributes = [
                    'disableDoubleClickZoom',
                    'scrollwheel',
                    'draggable',
                    'draggableCursor',
                    'draggingCursor',
                    'keyboardShortcuts',
                    'zoomControl',
                    'styles',
                    'streetViewControl',
                    'zoom',
                    'mapTypeControl',
                    'minZoom',
                    'maxZoom'
                ];
                SebmGoogleMap.decorators = [
                    {
                        type: core_1.Component,
                        args: [
                            {
                                selector: 'sebm-google-map',
                                providers: [
                                    google_maps_api_wrapper_1.GoogleMapsAPIWrapper,
                                    marker_manager_1.MarkerManager,
                                    info_window_manager_1.InfoWindowManager,
                                    circle_manager_1.CircleManager,
                                    polyline_manager_1.PolylineManager,
                                    polygon_manager_1.PolygonManager,
                                    kml_layer_manager_1.KmlLayerManager
                                ],
                                inputs: [
                                    'longitude',
                                    'latitude',
                                    'zoom',
                                    'minZoom',
                                    'maxZoom',
                                    'draggable: mapDraggable',
                                    'disableDoubleClickZoom',
                                    'disableDefaultUI',
                                    'scrollwheel',
                                    'backgroundColor',
                                    'draggableCursor',
                                    'draggingCursor',
                                    'keyboardShortcuts',
                                    'zoomControl',
                                    'styles',
                                    'usePanning',
                                    'streetViewControl',
                                    'fitBounds',
                                    'scaleControl',
                                    'mapTypeControl'
                                ],
                                outputs: ['mapClick', 'mapRightClick', 'mapDblClick', 'centerChange', 'idle', 'boundsChange', 'zoomChange'],
                                host: { '[class.sebm-google-map-container]': 'true' },
                                styles: [
                                    '\n    .sebm-google-map-container-inner {\n      width: inherit;\n      height: inherit;\n    }\n    .sebm-google-map-content {\n      display:none;\n    }\n  '
                                ],
                                template:
                                    "\n    <div class='sebm-google-map-container-inner'></div>\n    <div class='sebm-google-map-content'>\n      <ng-content></ng-content>\n    </div>\n  "
                            }
                        ]
                    }
                ];
                /** @nocollapse */
                SebmGoogleMap.ctorParameters = function() {
                    return [{ type: core_1.ElementRef }, { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper }];
                };
                return SebmGoogleMap;
            })();
            exports.SebmGoogleMap = SebmGoogleMap;
            //# sourceMappingURL=google-map.js.map

            /***/
        },
        /* 66 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var Observable_1 = __webpack_require__(10);
            var maps_api_loader_1 = __webpack_require__(67);
            /**
             * Wrapper class that handles the communication with the Google Maps Javascript
             * API v3
             */
            var GoogleMapsAPIWrapper = (function() {
                function GoogleMapsAPIWrapper(_loader, _zone) {
                    var _this = this;
                    this._loader = _loader;
                    this._zone = _zone;
                    this._map = new Promise(function(resolve) {
                        _this._mapResolver = resolve;
                    });
                }
                GoogleMapsAPIWrapper.prototype.createMap = function(el, mapOptions) {
                    var _this = this;
                    return this._loader.load().then(function() {
                        var map = new google.maps.Map(el, mapOptions);
                        _this._mapResolver(map);
                        return;
                    });
                };
                GoogleMapsAPIWrapper.prototype.setMapOptions = function(options) {
                    this._map.then(function(m) {
                        m.setOptions(options);
                    });
                };
                /**
                 * Creates a google map marker with the map context
                 */
                GoogleMapsAPIWrapper.prototype.createMarker = function(options) {
                    if (options === void 0) {
                        options = {};
                    }
                    return this._map.then(function(map) {
                        options.map = map;
                        return new google.maps.Marker(options);
                    });
                };
                GoogleMapsAPIWrapper.prototype.createInfoWindow = function(options) {
                    return this._map.then(function() {
                        return new google.maps.InfoWindow(options);
                    });
                };
                /**
                 * Creates a google.map.Circle for the current map.
                 */
                GoogleMapsAPIWrapper.prototype.createCircle = function(options) {
                    return this._map.then(function(map) {
                        options.map = map;
                        return new google.maps.Circle(options);
                    });
                };
                GoogleMapsAPIWrapper.prototype.createPolyline = function(options) {
                    return this.getNativeMap().then(function(map) {
                        var line = new google.maps.Polyline(options);
                        line.setMap(map);
                        return line;
                    });
                };
                GoogleMapsAPIWrapper.prototype.createPolygon = function(options) {
                    return this.getNativeMap().then(function(map) {
                        var polygon = new google.maps.Polygon(options);
                        polygon.setMap(map);
                        return polygon;
                    });
                };
                /**
                 * Determines if given coordinates are insite a Polygon path.
                 */
                GoogleMapsAPIWrapper.prototype.containsLocation = function(latLng, polygon) {
                    return google.maps.geometry.poly.containsLocation(latLng, polygon);
                };
                GoogleMapsAPIWrapper.prototype.subscribeToMapEvent = function(eventName) {
                    var _this = this;
                    return Observable_1.Observable.create(function(observer) {
                        _this._map.then(function(m) {
                            m.addListener(eventName, function(arg) {
                                _this._zone.run(function() {
                                    return observer.next(arg);
                                });
                            });
                        });
                    });
                };
                GoogleMapsAPIWrapper.prototype.setCenter = function(latLng) {
                    return this._map.then(function(map) {
                        return map.setCenter(latLng);
                    });
                };
                GoogleMapsAPIWrapper.prototype.getZoom = function() {
                    return this._map.then(function(map) {
                        return map.getZoom();
                    });
                };
                GoogleMapsAPIWrapper.prototype.getBounds = function() {
                    return this._map.then(function(map) {
                        return map.getBounds();
                    });
                };
                GoogleMapsAPIWrapper.prototype.setZoom = function(zoom) {
                    return this._map.then(function(map) {
                        return map.setZoom(zoom);
                    });
                };
                GoogleMapsAPIWrapper.prototype.getCenter = function() {
                    return this._map.then(function(map) {
                        return map.getCenter();
                    });
                };
                GoogleMapsAPIWrapper.prototype.panTo = function(latLng) {
                    return this._map.then(function(map) {
                        return map.panTo(latLng);
                    });
                };
                GoogleMapsAPIWrapper.prototype.fitBounds = function(latLng) {
                    return this._map.then(function(map) {
                        return map.fitBounds(latLng);
                    });
                };
                GoogleMapsAPIWrapper.prototype.panToBounds = function(latLng) {
                    return this._map.then(function(map) {
                        return map.panToBounds(latLng);
                    });
                };
                /**
                 * Returns the native Google Maps Map instance. Be careful when using this instance directly.
                 */
                GoogleMapsAPIWrapper.prototype.getNativeMap = function() {
                    return this._map;
                };
                /**
                 * Triggers the given event name on the map instance.
                 */
                GoogleMapsAPIWrapper.prototype.triggerMapEvent = function(eventName) {
                    return this._map.then(function(m) {
                        return google.maps.event.trigger(m, eventName);
                    });
                };
                GoogleMapsAPIWrapper.decorators = [{ type: core_1.Injectable }];
                /** @nocollapse */
                GoogleMapsAPIWrapper.ctorParameters = function() {
                    return [{ type: maps_api_loader_1.MapsAPILoader }, { type: core_1.NgZone }];
                };
                return GoogleMapsAPIWrapper;
            })();
            exports.GoogleMapsAPIWrapper = GoogleMapsAPIWrapper;
            //# sourceMappingURL=google-maps-api-wrapper.js.map

            /***/
        },
        /* 67 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var MapsAPILoader = (function() {
                function MapsAPILoader() {}
                MapsAPILoader.decorators = [{ type: core_1.Injectable }];
                /** @nocollapse */
                MapsAPILoader.ctorParameters = function() {
                    return [];
                };
                return MapsAPILoader;
            })();
            exports.MapsAPILoader = MapsAPILoader;
            //# sourceMappingURL=maps-api-loader.js.map

            /***/
        },
        /* 68 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var Observable_1 = __webpack_require__(10);
            var google_maps_api_wrapper_1 = __webpack_require__(66);
            var CircleManager = (function() {
                function CircleManager(_apiWrapper, _zone) {
                    this._apiWrapper = _apiWrapper;
                    this._zone = _zone;
                    this._circles = new Map();
                }
                CircleManager.prototype.addCircle = function(circle) {
                    this._circles.set(
                        circle,
                        this._apiWrapper.createCircle({
                            center: { lat: circle.latitude, lng: circle.longitude },
                            clickable: circle.clickable,
                            draggable: circle.draggable,
                            editable: circle.editable,
                            fillColor: circle.fillColor,
                            fillOpacity: circle.fillOpacity,
                            radius: circle.radius,
                            strokeColor: circle.strokeColor,
                            strokeOpacity: circle.strokeOpacity,
                            strokePosition: circle.strokePosition,
                            strokeWeight: circle.strokeWeight,
                            visible: circle.visible,
                            zIndex: circle.zIndex
                        })
                    );
                };
                /**
                 * Removes the given circle from the map.
                 */
                CircleManager.prototype.removeCircle = function(circle) {
                    var _this = this;
                    return this._circles.get(circle).then(function(c) {
                        c.setMap(null);
                        _this._circles.delete(circle);
                    });
                };
                CircleManager.prototype.setOptions = function(circle, options) {
                    return this._circles.get(circle).then(function(c) {
                        return c.setOptions(options);
                    });
                };
                CircleManager.prototype.getBounds = function(circle) {
                    return this._circles.get(circle).then(function(c) {
                        return c.getBounds();
                    });
                };
                CircleManager.prototype.getCenter = function(circle) {
                    return this._circles.get(circle).then(function(c) {
                        return c.getCenter();
                    });
                };
                CircleManager.prototype.getRadius = function(circle) {
                    return this._circles.get(circle).then(function(c) {
                        return c.getRadius();
                    });
                };
                CircleManager.prototype.setCenter = function(circle) {
                    return this._circles.get(circle).then(function(c) {
                        return c.setCenter({ lat: circle.latitude, lng: circle.longitude });
                    });
                };
                CircleManager.prototype.setEditable = function(circle) {
                    return this._circles.get(circle).then(function(c) {
                        return c.setEditable(circle.editable);
                    });
                };
                CircleManager.prototype.setDraggable = function(circle) {
                    return this._circles.get(circle).then(function(c) {
                        return c.setDraggable(circle.draggable);
                    });
                };
                CircleManager.prototype.setVisible = function(circle) {
                    return this._circles.get(circle).then(function(c) {
                        return c.setVisible(circle.visible);
                    });
                };
                CircleManager.prototype.setRadius = function(circle) {
                    return this._circles.get(circle).then(function(c) {
                        return c.setRadius(circle.radius);
                    });
                };
                CircleManager.prototype.createEventObservable = function(eventName, circle) {
                    var _this = this;
                    return Observable_1.Observable.create(function(observer) {
                        var listener = null;
                        _this._circles.get(circle).then(function(c) {
                            listener = c.addListener(eventName, function(e) {
                                return _this._zone.run(function() {
                                    return observer.next(e);
                                });
                            });
                        });
                        return function() {
                            if (listener !== null) {
                                listener.remove();
                            }
                        };
                    });
                };
                CircleManager.decorators = [{ type: core_1.Injectable }];
                /** @nocollapse */
                CircleManager.ctorParameters = function() {
                    return [{ type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper }, { type: core_1.NgZone }];
                };
                return CircleManager;
            })();
            exports.CircleManager = CircleManager;
            //# sourceMappingURL=circle-manager.js.map

            /***/
        },
        /* 69 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var Observable_1 = __webpack_require__(10);
            var core_1 = __webpack_require__(8);
            var google_maps_api_wrapper_1 = __webpack_require__(66);
            var marker_manager_1 = __webpack_require__(70);
            var InfoWindowManager = (function() {
                function InfoWindowManager(_mapsWrapper, _zone, _markerManager) {
                    this._mapsWrapper = _mapsWrapper;
                    this._zone = _zone;
                    this._markerManager = _markerManager;
                    this._infoWindows = new Map();
                }
                InfoWindowManager.prototype.deleteInfoWindow = function(infoWindow) {
                    var _this = this;
                    var iWindow = this._infoWindows.get(infoWindow);
                    if (iWindow == null) {
                        // info window already deleted
                        return Promise.resolve();
                    }
                    return iWindow.then(function(i) {
                        return _this._zone.run(function() {
                            i.close();
                            _this._infoWindows.delete(infoWindow);
                        });
                    });
                };
                InfoWindowManager.prototype.setPosition = function(infoWindow) {
                    return this._infoWindows.get(infoWindow).then(function(i) {
                        return i.setPosition({
                            lat: infoWindow.latitude,
                            lng: infoWindow.longitude
                        });
                    });
                };
                InfoWindowManager.prototype.setZIndex = function(infoWindow) {
                    return this._infoWindows.get(infoWindow).then(function(i) {
                        return i.setZIndex(infoWindow.zIndex);
                    });
                };
                InfoWindowManager.prototype.open = function(infoWindow) {
                    var _this = this;
                    return this._infoWindows.get(infoWindow).then(function(w) {
                        if (infoWindow.hostMarker != null) {
                            return _this._markerManager.getNativeMarker(infoWindow.hostMarker).then(function(marker) {
                                return _this._mapsWrapper.getNativeMap().then(function(map) {
                                    return w.open(map, marker);
                                });
                            });
                        }
                        return _this._mapsWrapper.getNativeMap().then(function(map) {
                            return w.open(map);
                        });
                    });
                };
                InfoWindowManager.prototype.close = function(infoWindow) {
                    return this._infoWindows.get(infoWindow).then(function(w) {
                        return w.close();
                    });
                };
                InfoWindowManager.prototype.setOptions = function(infoWindow, options) {
                    return this._infoWindows.get(infoWindow).then(function(i) {
                        return i.setOptions(options);
                    });
                };
                InfoWindowManager.prototype.addInfoWindow = function(infoWindow) {
                    var options = {
                        content: infoWindow.content,
                        maxWidth: infoWindow.maxWidth,
                        zIndex: infoWindow.zIndex
                    };
                    if (typeof infoWindow.latitude === 'number' && typeof infoWindow.longitude === 'number') {
                        options.position = { lat: infoWindow.latitude, lng: infoWindow.longitude };
                    }
                    var infoWindowPromise = this._mapsWrapper.createInfoWindow(options);
                    this._infoWindows.set(infoWindow, infoWindowPromise);
                };
                /**
                 * Creates a Google Maps event listener for the given InfoWindow as an Observable
                 */
                InfoWindowManager.prototype.createEventObservable = function(eventName, infoWindow) {
                    var _this = this;
                    return Observable_1.Observable.create(function(observer) {
                        _this._infoWindows.get(infoWindow).then(function(i) {
                            i.addListener(eventName, function(e) {
                                return _this._zone.run(function() {
                                    return observer.next(e);
                                });
                            });
                        });
                    });
                };
                InfoWindowManager.decorators = [{ type: core_1.Injectable }];
                /** @nocollapse */
                InfoWindowManager.ctorParameters = function() {
                    return [
                        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper },
                        { type: core_1.NgZone },
                        { type: marker_manager_1.MarkerManager }
                    ];
                };
                return InfoWindowManager;
            })();
            exports.InfoWindowManager = InfoWindowManager;
            //# sourceMappingURL=info-window-manager.js.map

            /***/
        },
        /* 70 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var Observable_1 = __webpack_require__(10);
            var google_maps_api_wrapper_1 = __webpack_require__(66);
            var MarkerManager = (function() {
                function MarkerManager(_mapsWrapper, _zone) {
                    this._mapsWrapper = _mapsWrapper;
                    this._zone = _zone;
                    this._markers = new Map();
                }
                MarkerManager.prototype.deleteMarker = function(marker) {
                    var _this = this;
                    var m = this._markers.get(marker);
                    if (m == null) {
                        // marker already deleted
                        return Promise.resolve();
                    }
                    return m.then(function(m) {
                        return _this._zone.run(function() {
                            m.setMap(null);
                            _this._markers.delete(marker);
                        });
                    });
                };
                MarkerManager.prototype.updateMarkerPosition = function(marker) {
                    return this._markers.get(marker).then(function(m) {
                        return m.setPosition({ lat: marker.latitude, lng: marker.longitude });
                    });
                };
                MarkerManager.prototype.updateTitle = function(marker) {
                    return this._markers.get(marker).then(function(m) {
                        return m.setTitle(marker.title);
                    });
                };
                MarkerManager.prototype.updateLabel = function(marker) {
                    return this._markers.get(marker).then(function(m) {
                        m.setLabel(marker.label);
                    });
                };
                MarkerManager.prototype.updateDraggable = function(marker) {
                    return this._markers.get(marker).then(function(m) {
                        return m.setDraggable(marker.draggable);
                    });
                };
                MarkerManager.prototype.updateIcon = function(marker) {
                    return this._markers.get(marker).then(function(m) {
                        return m.setIcon(marker.iconUrl);
                    });
                };
                MarkerManager.prototype.updateOpacity = function(marker) {
                    return this._markers.get(marker).then(function(m) {
                        return m.setOpacity(marker.opacity);
                    });
                };
                MarkerManager.prototype.updateVisible = function(marker) {
                    return this._markers.get(marker).then(function(m) {
                        return m.setVisible(marker.visible);
                    });
                };
                MarkerManager.prototype.updateZIndex = function(marker) {
                    return this._markers.get(marker).then(function(m) {
                        return m.setZIndex(marker.zIndex);
                    });
                };
                MarkerManager.prototype.addMarker = function(marker) {
                    var markerPromise = this._mapsWrapper.createMarker({
                        position: { lat: marker.latitude, lng: marker.longitude },
                        label: marker.label,
                        draggable: marker.draggable,
                        icon: marker.iconUrl,
                        opacity: marker.opacity,
                        visible: marker.visible,
                        zIndex: marker.zIndex,
                        title: marker.title
                    });
                    this._markers.set(marker, markerPromise);
                };
                MarkerManager.prototype.getNativeMarker = function(marker) {
                    return this._markers.get(marker);
                };
                MarkerManager.prototype.createEventObservable = function(eventName, marker) {
                    var _this = this;
                    return Observable_1.Observable.create(function(observer) {
                        _this._markers.get(marker).then(function(m) {
                            m.addListener(eventName, function(e) {
                                return _this._zone.run(function() {
                                    return observer.next(e);
                                });
                            });
                        });
                    });
                };
                MarkerManager.decorators = [{ type: core_1.Injectable }];
                /** @nocollapse */
                MarkerManager.ctorParameters = function() {
                    return [{ type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper }, { type: core_1.NgZone }];
                };
                return MarkerManager;
            })();
            exports.MarkerManager = MarkerManager;
            //# sourceMappingURL=marker-manager.js.map

            /***/
        },
        /* 71 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var Observable_1 = __webpack_require__(10);
            var google_maps_api_wrapper_1 = __webpack_require__(66);
            var PolygonManager = (function() {
                function PolygonManager(_mapsWrapper, _zone) {
                    this._mapsWrapper = _mapsWrapper;
                    this._zone = _zone;
                    this._polygons = new Map();
                }
                PolygonManager.prototype.addPolygon = function(path) {
                    var polygonPromise = this._mapsWrapper.createPolygon({
                        clickable: path.clickable,
                        draggable: path.draggable,
                        editable: path.editable,
                        fillColor: path.fillColor,
                        fillOpacity: path.fillOpacity,
                        geodesic: path.geodesic,
                        paths: path.paths,
                        strokeColor: path.strokeColor,
                        strokeOpacity: path.strokeOpacity,
                        strokeWeight: path.strokeWeight,
                        visible: path.visible,
                        zIndex: path.zIndex
                    });
                    this._polygons.set(path, polygonPromise);
                };
                PolygonManager.prototype.updatePolygon = function(polygon) {
                    var _this = this;
                    var m = this._polygons.get(polygon);
                    if (m == null) {
                        return Promise.resolve();
                    }
                    return m.then(function(l) {
                        return _this._zone.run(function() {
                            l.setPaths(polygon.paths);
                        });
                    });
                };
                PolygonManager.prototype.setPolygonOptions = function(path, options) {
                    return this._polygons.get(path).then(function(l) {
                        l.setOptions(options);
                    });
                };
                PolygonManager.prototype.deletePolygon = function(paths) {
                    var _this = this;
                    var m = this._polygons.get(paths);
                    if (m == null) {
                        return Promise.resolve();
                    }
                    return m.then(function(l) {
                        return _this._zone.run(function() {
                            l.setMap(null);
                            _this._polygons.delete(paths);
                        });
                    });
                };
                PolygonManager.prototype.createEventObservable = function(eventName, path) {
                    var _this = this;
                    return Observable_1.Observable.create(function(observer) {
                        _this._polygons.get(path).then(function(l) {
                            l.addListener(eventName, function(e) {
                                return _this._zone.run(function() {
                                    return observer.next(e);
                                });
                            });
                        });
                    });
                };
                PolygonManager.decorators = [{ type: core_1.Injectable }];
                /** @nocollapse */
                PolygonManager.ctorParameters = function() {
                    return [{ type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper }, { type: core_1.NgZone }];
                };
                return PolygonManager;
            })();
            exports.PolygonManager = PolygonManager;
            //# sourceMappingURL=polygon-manager.js.map

            /***/
        },
        /* 72 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var Observable_1 = __webpack_require__(10);
            var google_maps_api_wrapper_1 = __webpack_require__(66);
            var PolylineManager = (function() {
                function PolylineManager(_mapsWrapper, _zone) {
                    this._mapsWrapper = _mapsWrapper;
                    this._zone = _zone;
                    this._polylines = new Map();
                }
                PolylineManager._convertPoints = function(line) {
                    var path = line._getPoints().map(function(point) {
                        return { lat: point.latitude, lng: point.longitude };
                    });
                    return path;
                };
                PolylineManager.prototype.addPolyline = function(line) {
                    var path = PolylineManager._convertPoints(line);
                    var polylinePromise = this._mapsWrapper.createPolyline({
                        clickable: line.clickable,
                        draggable: line.draggable,
                        editable: line.editable,
                        geodesic: line.geodesic,
                        strokeColor: line.strokeColor,
                        strokeOpacity: line.strokeOpacity,
                        strokeWeight: line.strokeWeight,
                        visible: line.visible,
                        zIndex: line.zIndex,
                        path: path
                    });
                    this._polylines.set(line, polylinePromise);
                };
                PolylineManager.prototype.updatePolylinePoints = function(line) {
                    var _this = this;
                    var path = PolylineManager._convertPoints(line);
                    var m = this._polylines.get(line);
                    if (m == null) {
                        return Promise.resolve();
                    }
                    return m.then(function(l) {
                        return _this._zone.run(function() {
                            l.setPath(path);
                        });
                    });
                };
                PolylineManager.prototype.setPolylineOptions = function(line, options) {
                    return this._polylines.get(line).then(function(l) {
                        l.setOptions(options);
                    });
                };
                PolylineManager.prototype.deletePolyline = function(line) {
                    var _this = this;
                    var m = this._polylines.get(line);
                    if (m == null) {
                        return Promise.resolve();
                    }
                    return m.then(function(l) {
                        return _this._zone.run(function() {
                            l.setMap(null);
                            _this._polylines.delete(line);
                        });
                    });
                };
                PolylineManager.prototype.createEventObservable = function(eventName, line) {
                    var _this = this;
                    return Observable_1.Observable.create(function(observer) {
                        _this._polylines.get(line).then(function(l) {
                            l.addListener(eventName, function(e) {
                                return _this._zone.run(function() {
                                    return observer.next(e);
                                });
                            });
                        });
                    });
                };
                PolylineManager.decorators = [{ type: core_1.Injectable }];
                /** @nocollapse */
                PolylineManager.ctorParameters = function() {
                    return [{ type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper }, { type: core_1.NgZone }];
                };
                return PolylineManager;
            })();
            exports.PolylineManager = PolylineManager;
            //# sourceMappingURL=polyline-manager.js.map

            /***/
        },
        /* 73 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var Observable_1 = __webpack_require__(10);
            var google_maps_api_wrapper_1 = __webpack_require__(66);
            /**
             * Manages all KML Layers for a Google Map instance.
             */
            var KmlLayerManager = (function() {
                function KmlLayerManager(_wrapper, _zone) {
                    this._wrapper = _wrapper;
                    this._zone = _zone;
                    this._layers = new Map();
                }
                /**
                 * Adds a new KML Layer to the map.
                 */
                KmlLayerManager.prototype.addKmlLayer = function(layer) {
                    var newLayer = this._wrapper.getNativeMap().then(function(m) {
                        return new google.maps.KmlLayer({
                            clickable: layer.clickable,
                            map: m,
                            preserveViewport: layer.preserveViewport,
                            screenOverlays: layer.screenOverlays,
                            suppressInfoWindows: layer.suppressInfoWindows,
                            url: layer.url,
                            zIndex: layer.zIndex
                        });
                    });
                    this._layers.set(layer, newLayer);
                };
                KmlLayerManager.prototype.setOptions = function(layer, options) {
                    this._layers.get(layer).then(function(l) {
                        return l.setOptions(options);
                    });
                };
                KmlLayerManager.prototype.deleteKmlLayer = function(layer) {
                    var _this = this;
                    this._layers.get(layer).then(function(l) {
                        l.setMap(null);
                        _this._layers.delete(layer);
                    });
                };
                /**
                 * Creates a Google Maps event listener for the given KmlLayer as an Observable
                 */
                KmlLayerManager.prototype.createEventObservable = function(eventName, layer) {
                    var _this = this;
                    return Observable_1.Observable.create(function(observer) {
                        _this._layers.get(layer).then(function(m) {
                            m.addListener(eventName, function(e) {
                                return _this._zone.run(function() {
                                    return observer.next(e);
                                });
                            });
                        });
                    });
                };
                KmlLayerManager.decorators = [{ type: core_1.Injectable }];
                /** @nocollapse */
                KmlLayerManager.ctorParameters = function() {
                    return [{ type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper }, { type: core_1.NgZone }];
                };
                return KmlLayerManager;
            })();
            exports.KmlLayerManager = KmlLayerManager;
            //# sourceMappingURL=kml-layer-manager.js.map

            /***/
        },
        /* 74 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var circle_manager_1 = __webpack_require__(68);
            var SebmGoogleMapCircle = (function() {
                function SebmGoogleMapCircle(_manager) {
                    this._manager = _manager;
                    /**
                     * Indicates whether this Circle handles mouse events. Defaults to true.
                     */
                    this.clickable = true;
                    /**
                     * If set to true, the user can drag this circle over the map. Defaults to false.
                     */
                    this.draggable = false;
                    /**
                     * If set to true, the user can edit this circle by dragging the control points shown at
                     * the center and around the circumference of the circle. Defaults to false.
                     */
                    this.editable = false;
                    /**
                     * The radius in meters on the Earth's surface.
                     */
                    this.radius = 0;
                    /**
                     * The stroke position. Defaults to CENTER.
                     * This property is not supported on Internet Explorer 8 and earlier.
                     */
                    this.strokePosition = 'CENTER';
                    /**
                     * The stroke width in pixels.
                     */
                    this.strokeWeight = 0;
                    /**
                     * Whether this circle is visible on the map. Defaults to true.
                     */
                    this.visible = true;
                    /**
                     * This event is fired when the circle's center is changed.
                     */
                    this.centerChange = new core_1.EventEmitter();
                    /**
                     * This event emitter gets emitted when the user clicks on the circle.
                     */
                    this.circleClick = new core_1.EventEmitter();
                    /**
                     * This event emitter gets emitted when the user clicks on the circle.
                     */
                    this.circleDblClick = new core_1.EventEmitter();
                    /**
                     * This event is repeatedly fired while the user drags the circle.
                     */
                    this.drag = new core_1.EventEmitter();
                    /**
                     * This event is fired when the user stops dragging the circle.
                     */
                    this.dragEnd = new core_1.EventEmitter();
                    /**
                     * This event is fired when the user starts dragging the circle.
                     */
                    this.dragStart = new core_1.EventEmitter();
                    /**
                     * This event is fired when the DOM mousedown event is fired on the circle.
                     */
                    this.mouseDown = new core_1.EventEmitter();
                    /**
                     * This event is fired when the DOM mousemove event is fired on the circle.
                     */
                    this.mouseMove = new core_1.EventEmitter();
                    /**
                     * This event is fired on circle mouseout.
                     */
                    this.mouseOut = new core_1.EventEmitter();
                    /**
                     * This event is fired on circle mouseover.
                     */
                    this.mouseOver = new core_1.EventEmitter();
                    /**
                     * This event is fired when the DOM mouseup event is fired on the circle.
                     */
                    this.mouseUp = new core_1.EventEmitter();
                    /**
                     * This event is fired when the circle's radius is changed.
                     */
                    this.radiusChange = new core_1.EventEmitter();
                    /**
                     * This event is fired when the circle is right-clicked on.
                     */
                    this.rightClick = new core_1.EventEmitter();
                    this._circleAddedToManager = false;
                    this._eventSubscriptions = [];
                }
                /** @internal */
                SebmGoogleMapCircle.prototype.ngOnInit = function() {
                    this._manager.addCircle(this);
                    this._circleAddedToManager = true;
                    this._registerEventListeners();
                };
                /** @internal */
                SebmGoogleMapCircle.prototype.ngOnChanges = function(changes) {
                    if (!this._circleAddedToManager) {
                        return;
                    }
                    if (changes['latitude'] || changes['longitude']) {
                        this._manager.setCenter(this);
                    }
                    if (changes['editable']) {
                        this._manager.setEditable(this);
                    }
                    if (changes['draggable']) {
                        this._manager.setDraggable(this);
                    }
                    if (changes['visible']) {
                        this._manager.setVisible(this);
                    }
                    if (changes['radius']) {
                        this._manager.setRadius(this);
                    }
                    this._updateCircleOptionsChanges(changes);
                };
                SebmGoogleMapCircle.prototype._updateCircleOptionsChanges = function(changes) {
                    var options = {};
                    var optionKeys = Object.keys(changes).filter(function(k) {
                        return SebmGoogleMapCircle._mapOptions.indexOf(k) !== -1;
                    });
                    optionKeys.forEach(function(k) {
                        options[k] = changes[k].currentValue;
                    });
                    if (optionKeys.length > 0) {
                        this._manager.setOptions(this, options);
                    }
                };
                SebmGoogleMapCircle.prototype._registerEventListeners = function() {
                    var _this = this;
                    var events = new Map();
                    events.set('center_changed', this.centerChange);
                    events.set('click', this.circleClick);
                    events.set('dblclick', this.circleDblClick);
                    events.set('drag', this.drag);
                    events.set('dragend', this.dragEnd);
                    events.set('dragStart', this.dragStart);
                    events.set('mousedown', this.mouseDown);
                    events.set('mousemove', this.mouseMove);
                    events.set('mouseout', this.mouseOut);
                    events.set('mouseover', this.mouseOver);
                    events.set('mouseup', this.mouseUp);
                    events.set('radius_changed', this.radiusChange);
                    events.set('rightclick', this.rightClick);
                    events.forEach(function(eventEmitter, eventName) {
                        _this._eventSubscriptions.push(
                            _this._manager.createEventObservable(eventName, _this).subscribe(function(value) {
                                switch (eventName) {
                                    case 'radius_changed':
                                        _this._manager.getRadius(_this).then(function(radius) {
                                            return eventEmitter.emit(radius);
                                        });
                                        break;
                                    case 'center_changed':
                                        _this._manager.getCenter(_this).then(function(center) {
                                            return eventEmitter.emit({ lat: center.lat(), lng: center.lng() });
                                        });
                                        break;
                                    default:
                                        eventEmitter.emit({ coords: { lat: value.latLng.lat(), lng: value.latLng.lng() } });
                                }
                            })
                        );
                    });
                };
                /** @internal */
                SebmGoogleMapCircle.prototype.ngOnDestroy = function() {
                    this._eventSubscriptions.forEach(function(s) {
                        s.unsubscribe();
                    });
                    this._eventSubscriptions = null;
                    this._manager.removeCircle(this);
                };
                /**
                 * Gets the LatLngBounds of this Circle.
                 */
                SebmGoogleMapCircle.prototype.getBounds = function() {
                    return this._manager.getBounds(this);
                };
                SebmGoogleMapCircle.prototype.getCenter = function() {
                    return this._manager.getCenter(this);
                };
                SebmGoogleMapCircle._mapOptions = [
                    'fillColor',
                    'fillOpacity',
                    'strokeColor',
                    'strokeOpacity',
                    'strokePosition',
                    'strokeWeight',
                    'visible',
                    'zIndex'
                ];
                SebmGoogleMapCircle.decorators = [
                    {
                        type: core_1.Directive,
                        args: [
                            {
                                selector: 'sebm-google-map-circle',
                                inputs: [
                                    'latitude',
                                    'longitude',
                                    'clickable',
                                    'draggable: circleDraggable',
                                    'editable',
                                    'fillColor',
                                    'fillOpacity',
                                    'radius',
                                    'strokeColor',
                                    'strokeOpacity',
                                    'strokePosition',
                                    'strokeWeight',
                                    'visible',
                                    'zIndex'
                                ],
                                outputs: [
                                    'centerChange',
                                    'circleClick',
                                    'circleDblClick',
                                    'drag',
                                    'dragEnd',
                                    'dragStart',
                                    'mouseDown',
                                    'mouseMove',
                                    'mouseOut',
                                    'mouseOver',
                                    'mouseUp',
                                    'radiusChange',
                                    'rightClick'
                                ]
                            }
                        ]
                    }
                ];
                /** @nocollapse */
                SebmGoogleMapCircle.ctorParameters = function() {
                    return [{ type: circle_manager_1.CircleManager }];
                };
                return SebmGoogleMapCircle;
            })();
            exports.SebmGoogleMapCircle = SebmGoogleMapCircle;
            //# sourceMappingURL=google-map-circle.js.map

            /***/
        },
        /* 75 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var info_window_manager_1 = __webpack_require__(69);
            var infoWindowId = 0;
            /**
             * SebmGoogleMapInfoWindow renders a info window inside a {@link SebmGoogleMapMarker} or standalone.
             *
             * ### Example
             * ```typescript
             * import { Component } from 'angular2/core';
             * import { SebmGoogleMap, SebmGoogleMapMarker, SebmGoogleMapInfoWindow } from
             * 'angular2-google-maps/core';
             *
             * @Component({
             *  selector: 'my-map-cmp',
             *  directives: [SebmGoogleMap, SebmGoogleMapMarker, SebmGoogleMapInfoWindow],
             *  styles: [`
             *    .sebm-google-map-container {
             *      height: 300px;
             *    }
             * `],
             *  template: `
             *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
             *      <sebm-google-map-marker [latitude]="lat" [longitude]="lng" [label]="'M'">
             *        <sebm-google-map-info-window [disableAutoPan]="true">
             *          Hi, this is the content of the <strong>info window</strong>
             *        </sebm-google-map-info-window>
             *      </sebm-google-map-marker>
             *    </sebm-google-map>
             *  `
             * })
             * ```
             */
            var SebmGoogleMapInfoWindow = (function() {
                function SebmGoogleMapInfoWindow(_infoWindowManager, _el) {
                    this._infoWindowManager = _infoWindowManager;
                    this._el = _el;
                    /**
                     * Sets the open state for the InfoWindow. You can also call the open() and close() methods.
                     */
                    this.isOpen = false;
                    /**
                     * Emits an event when the info window is closed.
                     */
                    this.infoWindowClose = new core_1.EventEmitter();
                    this._infoWindowAddedToManager = false;
                    this._id = (infoWindowId++).toString();
                }
                SebmGoogleMapInfoWindow.prototype.ngOnInit = function() {
                    this.content = this._el.nativeElement.querySelector('.sebm-google-map-info-window-content');
                    this._infoWindowManager.addInfoWindow(this);
                    this._infoWindowAddedToManager = true;
                    this._updateOpenState();
                    this._registerEventListeners();
                };
                /** @internal */
                SebmGoogleMapInfoWindow.prototype.ngOnChanges = function(changes) {
                    if (!this._infoWindowAddedToManager) {
                        return;
                    }
                    if ((changes['latitude'] || changes['longitude']) && typeof this.latitude === 'number' && typeof this.longitude === 'number') {
                        this._infoWindowManager.setPosition(this);
                    }
                    if (changes['zIndex']) {
                        this._infoWindowManager.setZIndex(this);
                    }
                    if (changes['isOpen']) {
                        this._updateOpenState();
                    }
                    this._setInfoWindowOptions(changes);
                };
                SebmGoogleMapInfoWindow.prototype._registerEventListeners = function() {
                    var _this = this;
                    this._infoWindowManager.createEventObservable('closeclick', this).subscribe(function() {
                        _this.isOpen = false;
                        _this.infoWindowClose.emit();
                    });
                };
                SebmGoogleMapInfoWindow.prototype._updateOpenState = function() {
                    this.isOpen ? this.open() : this.close();
                };
                SebmGoogleMapInfoWindow.prototype._setInfoWindowOptions = function(changes) {
                    var options = {};
                    var optionKeys = Object.keys(changes).filter(function(k) {
                        return SebmGoogleMapInfoWindow._infoWindowOptionsInputs.indexOf(k) !== -1;
                    });
                    optionKeys.forEach(function(k) {
                        options[k] = changes[k].currentValue;
                    });
                    this._infoWindowManager.setOptions(this, options);
                };
                /**
                 * Opens the info window.
                 */
                SebmGoogleMapInfoWindow.prototype.open = function() {
                    return this._infoWindowManager.open(this);
                };
                /**
                 * Closes the info window.
                 */
                SebmGoogleMapInfoWindow.prototype.close = function() {
                    var _this = this;
                    return this._infoWindowManager.close(this).then(function() {
                        _this.infoWindowClose.emit();
                    });
                };
                /** @internal */
                SebmGoogleMapInfoWindow.prototype.id = function() {
                    return this._id;
                };
                /** @internal */
                SebmGoogleMapInfoWindow.prototype.toString = function() {
                    return 'SebmGoogleMapInfoWindow-' + this._id.toString();
                };
                /** @internal */
                SebmGoogleMapInfoWindow.prototype.ngOnDestroy = function() {
                    this._infoWindowManager.deleteInfoWindow(this);
                };
                SebmGoogleMapInfoWindow._infoWindowOptionsInputs = ['disableAutoPan', 'maxWidth'];
                SebmGoogleMapInfoWindow.decorators = [
                    {
                        type: core_1.Component,
                        args: [
                            {
                                selector: 'sebm-google-map-info-window',
                                inputs: ['latitude', 'longitude', 'disableAutoPan', 'isOpen', 'zIndex', 'maxWidth'],
                                outputs: ['infoWindowClose'],
                                template: "<div class='sebm-google-map-info-window-content'>\n      <ng-content></ng-content>\n    </div>\n  "
                            }
                        ]
                    }
                ];
                /** @nocollapse */
                SebmGoogleMapInfoWindow.ctorParameters = function() {
                    return [{ type: info_window_manager_1.InfoWindowManager }, { type: core_1.ElementRef }];
                };
                return SebmGoogleMapInfoWindow;
            })();
            exports.SebmGoogleMapInfoWindow = SebmGoogleMapInfoWindow;
            //# sourceMappingURL=google-map-info-window.js.map

            /***/
        },
        /* 76 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var kml_layer_manager_1 = __webpack_require__(73);
            var layerId = 0;
            var SebmGoogleMapKmlLayer = (function() {
                function SebmGoogleMapKmlLayer(_manager) {
                    this._manager = _manager;
                    this._addedToManager = false;
                    this._id = (layerId++).toString();
                    this._subscriptions = [];
                    /**
                     * If true, the layer receives mouse events. Default value is true.
                     */
                    this.clickable = true;
                    /**
                     * By default, the input map is centered and zoomed to the bounding box of the contents of the
                     * layer.
                     * If this option is set to true, the viewport is left unchanged, unless the map's center and zoom
                     * were never set.
                     */
                    this.preserveViewport = false;
                    /**
                     * Whether to render the screen overlays. Default true.
                     */
                    this.screenOverlays = true;
                    /**
                     * Suppress the rendering of info windows when layer features are clicked.
                     */
                    this.suppressInfoWindows = false;
                    /**
                     * The URL of the KML document to display.
                     */
                    this.url = null;
                    /**
                     * The z-index of the layer.
                     */
                    this.zIndex = null;
                    /**
                     * This event is fired when a feature in the layer is clicked.
                     */
                    this.layerClick = new core_1.EventEmitter();
                    /**
                     * This event is fired when the KML layers default viewport has changed.
                     */
                    this.defaultViewportChange = new core_1.EventEmitter();
                    /**
                     * This event is fired when the KML layer has finished loading.
                     * At this point it is safe to read the status property to determine if the layer loaded
                     * successfully.
                     */
                    this.statusChange = new core_1.EventEmitter();
                }
                SebmGoogleMapKmlLayer.prototype.ngOnInit = function() {
                    if (this._addedToManager) {
                        return;
                    }
                    this._manager.addKmlLayer(this);
                    this._addedToManager = true;
                    this._addEventListeners();
                };
                SebmGoogleMapKmlLayer.prototype.ngOnChanges = function(changes) {
                    if (!this._addedToManager) {
                        return;
                    }
                    this._updatePolygonOptions(changes);
                };
                SebmGoogleMapKmlLayer.prototype._updatePolygonOptions = function(changes) {
                    var options = Object.keys(changes)
                        .filter(function(k) {
                            return SebmGoogleMapKmlLayer._kmlLayerOptions.indexOf(k) !== -1;
                        })
                        .reduce(function(obj, k) {
                            obj[k] = changes[k].currentValue;
                            return obj;
                        }, {});
                    if (Object.keys(options).length > 0) {
                        this._manager.setOptions(this, options);
                    }
                };
                SebmGoogleMapKmlLayer.prototype._addEventListeners = function() {
                    var _this = this;
                    var listeners = [
                        {
                            name: 'click',
                            handler: function(ev) {
                                return _this.layerClick.emit(ev);
                            }
                        },
                        {
                            name: 'defaultviewport_changed',
                            handler: function() {
                                return _this.defaultViewportChange.emit();
                            }
                        },
                        {
                            name: 'status_changed',
                            handler: function() {
                                return _this.statusChange.emit();
                            }
                        }
                    ];
                    listeners.forEach(function(obj) {
                        var os = _this._manager.createEventObservable(obj.name, _this).subscribe(obj.handler);
                        _this._subscriptions.push(os);
                    });
                };
                /** @internal */
                SebmGoogleMapKmlLayer.prototype.id = function() {
                    return this._id;
                };
                /** @internal */
                SebmGoogleMapKmlLayer.prototype.toString = function() {
                    return 'SebmGoogleMapKmlLayer-' + this._id.toString();
                };
                /** @internal */
                SebmGoogleMapKmlLayer.prototype.ngOnDestroy = function() {
                    this._manager.deleteKmlLayer(this);
                    // unsubscribe all registered observable subscriptions
                    this._subscriptions.forEach(function(s) {
                        return s.unsubscribe();
                    });
                };
                SebmGoogleMapKmlLayer._kmlLayerOptions = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'];
                SebmGoogleMapKmlLayer.decorators = [
                    {
                        type: core_1.Directive,
                        args: [
                            {
                                selector: 'sebm-google-map-kml-layer',
                                inputs: ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'],
                                outputs: ['layerClick', 'defaultViewportChange', 'statusChange']
                            }
                        ]
                    }
                ];
                /** @nocollapse */
                SebmGoogleMapKmlLayer.ctorParameters = function() {
                    return [{ type: kml_layer_manager_1.KmlLayerManager }];
                };
                return SebmGoogleMapKmlLayer;
            })();
            exports.SebmGoogleMapKmlLayer = SebmGoogleMapKmlLayer;
            //# sourceMappingURL=google-map-kml-layer.js.map

            /***/
        },
        /* 77 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var marker_manager_1 = __webpack_require__(70);
            var google_map_info_window_1 = __webpack_require__(75);
            var markerId = 0;
            /**
             * SebmGoogleMapMarker renders a map marker inside a {@link SebmGoogleMap}.
             *
             * ### Example
             * ```typescript
             * import { Component } from 'angular2/core';
             * import { SebmGoogleMap, SebmGoogleMapMarker } from 'angular2-google-maps/core';
             *
             * @Component({
             *  selector: 'my-map-cmp',
             *  directives: [SebmGoogleMap, SebmGoogleMapMarker],
             *  styles: [`
             *    .sebm-google-map-container {
             *      height: 300px;
             *    }
             * `],
             *  template: `
             *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
             *      <sebm-google-map-marker [latitude]="lat" [longitude]="lng" [label]="'M'">
             *      </sebm-google-map-marker>
             *    </sebm-google-map>
             *  `
             * })
             * ```
             */
            var SebmGoogleMapMarker = (function() {
                function SebmGoogleMapMarker(_markerManager) {
                    this._markerManager = _markerManager;
                    /**
                     * If true, the marker can be dragged. Default value is false.
                     */
                    this.draggable = false;
                    /**
                     * If true, the marker is visible
                     */
                    this.visible = true;
                    /**
                     * Whether to automatically open the child info window when the marker is clicked.
                     */
                    this.openInfoWindow = true;
                    /**
                     * The marker's opacity between 0.0 and 1.0.
                     */
                    this.opacity = 1;
                    /**
                     * All markers are displayed on the map in order of their zIndex, with higher values displaying in
                     * front of markers with lower values. By default, markers are displayed according to their
                     * vertical position on screen, with lower markers appearing in front of markers further up the
                     * screen.
                     */
                    this.zIndex = 1;
                    /**
                     * This event emitter gets emitted when the user clicks on the marker.
                     */
                    this.markerClick = new core_1.EventEmitter();
                    /**
                     * This event is fired when the user stops dragging the marker.
                     */
                    this.dragEnd = new core_1.EventEmitter();
                    /**
                     * This event is fired when the user mouses over the marker.
                     */
                    this.mouseOver = new core_1.EventEmitter();
                    /**
                     * This event is fired when the user mouses outside the marker.
                     */
                    this.mouseOut = new core_1.EventEmitter();
                    this._markerAddedToManger = false;
                    this._observableSubscriptions = [];
                    this._id = (markerId++).toString();
                }
                /* @internal */
                SebmGoogleMapMarker.prototype.ngAfterContentInit = function() {
                    if (this.infoWindow != null) {
                        this.infoWindow.hostMarker = this;
                    }
                };
                /** @internal */
                SebmGoogleMapMarker.prototype.ngOnChanges = function(changes) {
                    if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {
                        return;
                    }
                    if (!this._markerAddedToManger) {
                        this._markerManager.addMarker(this);
                        this._markerAddedToManger = true;
                        this._addEventListeners();
                        return;
                    }
                    if (changes['latitude'] || changes['longitude']) {
                        this._markerManager.updateMarkerPosition(this);
                    }
                    if (changes['title']) {
                        this._markerManager.updateTitle(this);
                    }
                    if (changes['label']) {
                        this._markerManager.updateLabel(this);
                    }
                    if (changes['draggable']) {
                        this._markerManager.updateDraggable(this);
                    }
                    if (changes['iconUrl']) {
                        this._markerManager.updateIcon(this);
                    }
                    if (changes['opacity']) {
                        this._markerManager.updateOpacity(this);
                    }
                    if (changes['visible']) {
                        this._markerManager.updateVisible(this);
                    }
                    if (changes['zIndex']) {
                        this._markerManager.updateZIndex(this);
                    }
                };
                SebmGoogleMapMarker.prototype._addEventListeners = function() {
                    var _this = this;
                    var cs = this._markerManager.createEventObservable('click', this).subscribe(function() {
                        if (_this.openInfoWindow && _this.infoWindow != null) {
                            _this.infoWindow.open();
                        }
                        _this.markerClick.emit(null);
                    });
                    this._observableSubscriptions.push(cs);
                    var ds = this._markerManager.createEventObservable('dragend', this).subscribe(function(e) {
                        _this.dragEnd.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
                    });
                    this._observableSubscriptions.push(ds);
                    var mover = this._markerManager.createEventObservable('mouseover', this).subscribe(function(e) {
                        _this.mouseOver.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
                    });
                    this._observableSubscriptions.push(mover);
                    var mout = this._markerManager.createEventObservable('mouseout', this).subscribe(function(e) {
                        _this.mouseOut.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
                    });
                    this._observableSubscriptions.push(mout);
                };
                /** @internal */
                SebmGoogleMapMarker.prototype.id = function() {
                    return this._id;
                };
                /** @internal */
                SebmGoogleMapMarker.prototype.toString = function() {
                    return 'SebmGoogleMapMarker-' + this._id.toString();
                };
                /** @internal */
                SebmGoogleMapMarker.prototype.ngOnDestroy = function() {
                    this._markerManager.deleteMarker(this);
                    // unsubscribe all registered observable subscriptions
                    this._observableSubscriptions.forEach(function(s) {
                        return s.unsubscribe();
                    });
                };
                SebmGoogleMapMarker.decorators = [
                    {
                        type: core_1.Directive,
                        args: [
                            {
                                selector: 'sebm-google-map-marker',
                                inputs: [
                                    'latitude',
                                    'longitude',
                                    'title',
                                    'label',
                                    'draggable: markerDraggable',
                                    'iconUrl',
                                    'openInfoWindow',
                                    'opacity',
                                    'visible',
                                    'zIndex'
                                ],
                                outputs: ['markerClick', 'dragEnd', 'mouseOver', 'mouseOut']
                            }
                        ]
                    }
                ];
                /** @nocollapse */
                SebmGoogleMapMarker.ctorParameters = function() {
                    return [{ type: marker_manager_1.MarkerManager }];
                };
                SebmGoogleMapMarker.propDecorators = {
                    infoWindow: [{ type: core_1.ContentChild, args: [google_map_info_window_1.SebmGoogleMapInfoWindow] }]
                };
                return SebmGoogleMapMarker;
            })();
            exports.SebmGoogleMapMarker = SebmGoogleMapMarker;
            //# sourceMappingURL=google-map-marker.js.map

            /***/
        },
        /* 78 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var polygon_manager_1 = __webpack_require__(71);
            /**
             * SebmGoogleMapPolygon renders a polygon on a {@link SebmGoogleMap}
             *
             * ### Example
             * ```typescript
             * import { Component } from '@angular/core';
             * import { SebmGoogleMap, SebmGooglePolygon, LatLngLiteral } from 'angular2-maps/core';
             *
             * @Component({
             *  selector: 'my-map-cmp',
             *  styles: [`
             *    .semb-map-container {
             *      height: 300px;
             *    }
             * `],
             *  template: `
             *    <semb-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
             *      <semb-map-polygon [paths]="paths">
             *      </semb-map-polygon>
             *    </semb-map>
             *  `
             * })
             * export class MyMapCmp {
             *   lat: number = 0;
             *   lng: number = 0;
             *   zoom: number = 10;
             *   paths: Array<LatLngLiteral> = [
             *     { lat: 0,  lng: 10 },
             *     { lat: 0,  lng: 20 },
             *     { lat: 10, lng: 20 },
             *     { lat: 10, lng: 10 },
             *     { lat: 0,  lng: 10 }
             *   ]
             *   // Nesting paths will create a hole where they overlap;
             *   nestedPaths: Array<Array<LatLngLiteral>> = [[
             *     { lat: 0,  lng: 10 },
             *     { lat: 0,  lng: 20 },
             *     { lat: 10, lng: 20 },
             *     { lat: 10, lng: 10 },
             *     { lat: 0,  lng: 10 }
             *   ], [
             *     { lat: 0, lng: 15 },
             *     { lat: 0, lng: 20 },
             *     { lat: 5, lng: 20 },
             *     { lat: 5, lng: 15 },
             *     { lat: 0, lng: 15 }
             *   ]]
             * }
             * ```
             */
            var SebmGoogleMapPolygon = (function() {
                function SebmGoogleMapPolygon(_polygonManager) {
                    this._polygonManager = _polygonManager;
                    /**
                     * Indicates whether this Polygon handles mouse events. Defaults to true.
                     */
                    this.clickable = true;
                    /**
                     * If set to true, the user can drag this shape over the map. The geodesic
                     * property defines the mode of dragging. Defaults to false.
                     */
                    this.draggable = false;
                    /**
                     * If set to true, the user can edit this shape by dragging the control
                     * points shown at the vertices and on each segment. Defaults to false.
                     */
                    this.editable = false;
                    /**
                     * When true, edges of the polygon are interpreted as geodesic and will
                     * follow the curvature of the Earth. When false, edges of the polygon are
                     * rendered as straight lines in screen space. Note that the shape of a
                     * geodesic polygon may appear to change when dragged, as the dimensions
                     * are maintained relative to the surface of the earth. Defaults to false.
                     */
                    this.geodesic = false;
                    /**
                     * The ordered sequence of coordinates that designates a closed loop.
                     * Unlike polylines, a polygon may consist of one or more paths.
                     *  As a result, the paths property may specify one or more arrays of
                     * LatLng coordinates. Paths are closed automatically; do not repeat the
                     * first vertex of the path as the last vertex. Simple polygons may be
                     * defined using a single array of LatLngs. More complex polygons may
                     * specify an array of arrays. Any simple arrays are converted into Arrays.
                     * Inserting or removing LatLngs from the Array will automatically update
                     * the polygon on the map.
                     */
                    this.paths = [];
                    /**
                     * This event is fired when the DOM click event is fired on the Polygon.
                     */
                    this.polyClick = new core_1.EventEmitter();
                    /**
                     * This event is fired when the DOM dblclick event is fired on the Polygon.
                     */
                    this.polyDblClick = new core_1.EventEmitter();
                    /**
                     * This event is repeatedly fired while the user drags the polygon.
                     */
                    this.polyDrag = new core_1.EventEmitter();
                    /**
                     * This event is fired when the user stops dragging the polygon.
                     */
                    this.polyDragEnd = new core_1.EventEmitter();
                    /**
                     * This event is fired when the user starts dragging the polygon.
                     */
                    this.polyDragStart = new core_1.EventEmitter();
                    /**
                     * This event is fired when the DOM mousedown event is fired on the Polygon.
                     */
                    this.polyMouseDown = new core_1.EventEmitter();
                    /**
                     * This event is fired when the DOM mousemove event is fired on the Polygon.
                     */
                    this.polyMouseMove = new core_1.EventEmitter();
                    /**
                     * This event is fired on Polygon mouseout.
                     */
                    this.polyMouseOut = new core_1.EventEmitter();
                    /**
                     * This event is fired on Polygon mouseover.
                     */
                    this.polyMouseOver = new core_1.EventEmitter();
                    /**
                     * This event is fired whe the DOM mouseup event is fired on the Polygon
                     */
                    this.polyMouseUp = new core_1.EventEmitter();
                    /**
                     * This even is fired when the Polygon is right-clicked on.
                     */
                    this.polyRightClick = new core_1.EventEmitter();
                    this._polygonAddedToManager = false;
                    this._subscriptions = [];
                }
                /** @internal */
                SebmGoogleMapPolygon.prototype.ngAfterContentInit = function() {
                    if (!this._polygonAddedToManager) {
                        this._init();
                    }
                };
                SebmGoogleMapPolygon.prototype.ngOnChanges = function(changes) {
                    if (!this._polygonAddedToManager) {
                        this._init();
                        return;
                    }
                    this._polygonManager.setPolygonOptions(this, this._updatePolygonOptions(changes));
                };
                SebmGoogleMapPolygon.prototype._init = function() {
                    this._polygonManager.addPolygon(this);
                    this._polygonAddedToManager = true;
                    this._addEventListeners();
                };
                SebmGoogleMapPolygon.prototype._addEventListeners = function() {
                    var _this = this;
                    var handlers = [
                        {
                            name: 'click',
                            handler: function(ev) {
                                return _this.polyClick.emit(ev);
                            }
                        },
                        {
                            name: 'dbclick',
                            handler: function(ev) {
                                return _this.polyDblClick.emit(ev);
                            }
                        },
                        {
                            name: 'drag',
                            handler: function(ev) {
                                return _this.polyDrag.emit(ev);
                            }
                        },
                        {
                            name: 'dragend',
                            handler: function(ev) {
                                return _this.polyDragEnd.emit(ev);
                            }
                        },
                        {
                            name: 'dragstart',
                            handler: function(ev) {
                                return _this.polyDragStart.emit(ev);
                            }
                        },
                        {
                            name: 'mousedown',
                            handler: function(ev) {
                                return _this.polyMouseDown.emit(ev);
                            }
                        },
                        {
                            name: 'mousemove',
                            handler: function(ev) {
                                return _this.polyMouseMove.emit(ev);
                            }
                        },
                        {
                            name: 'mouseout',
                            handler: function(ev) {
                                return _this.polyMouseOut.emit(ev);
                            }
                        },
                        {
                            name: 'mouseover',
                            handler: function(ev) {
                                return _this.polyMouseOver.emit(ev);
                            }
                        },
                        {
                            name: 'mouseup',
                            handler: function(ev) {
                                return _this.polyMouseUp.emit(ev);
                            }
                        },
                        {
                            name: 'rightclick',
                            handler: function(ev) {
                                return _this.polyRightClick.emit(ev);
                            }
                        }
                    ];
                    handlers.forEach(function(obj) {
                        var os = _this._polygonManager.createEventObservable(obj.name, _this).subscribe(obj.handler);
                        _this._subscriptions.push(os);
                    });
                };
                SebmGoogleMapPolygon.prototype._updatePolygonOptions = function(changes) {
                    return Object.keys(changes)
                        .filter(function(k) {
                            return SebmGoogleMapPolygon._polygonOptionsAttributes.indexOf(k) !== -1;
                        })
                        .reduce(function(obj, k) {
                            obj[k] = changes[k].currentValue;
                            return obj;
                        }, {});
                };
                /** @internal */
                SebmGoogleMapPolygon.prototype.id = function() {
                    return this._id;
                };
                /** @internal */
                SebmGoogleMapPolygon.prototype.ngOnDestroy = function() {
                    this._polygonManager.deletePolygon(this);
                    // unsubscribe all registered observable subscriptions
                    this._subscriptions.forEach(function(s) {
                        return s.unsubscribe();
                    });
                };
                SebmGoogleMapPolygon._polygonOptionsAttributes = [
                    'clickable',
                    'draggable',
                    'editable',
                    'fillColor',
                    'fillOpacity',
                    'geodesic',
                    'icon',
                    'map',
                    'paths',
                    'strokeColor',
                    'strokeOpacity',
                    'strokeWeight',
                    'visible',
                    'zIndex',
                    'draggable',
                    'editable',
                    'visible'
                ];
                SebmGoogleMapPolygon.decorators = [
                    {
                        type: core_1.Directive,
                        args: [
                            {
                                selector: 'sebm-map-polygon',
                                inputs: [
                                    'clickable',
                                    'draggable: polyDraggable',
                                    'editable',
                                    'fillColor',
                                    'fillOpacity',
                                    'geodesic',
                                    'paths',
                                    'strokeColor',
                                    'strokeOpacity',
                                    'strokeWeight',
                                    'visible',
                                    'zIndex'
                                ],
                                outputs: [
                                    'polyClick',
                                    'polyDblClick',
                                    'polyDrag',
                                    'polyDragEnd',
                                    'polyMouseDown',
                                    'polyMouseMove',
                                    'polyMouseOut',
                                    'polyMouseOver',
                                    'polyMouseUp',
                                    'polyRightClick'
                                ]
                            }
                        ]
                    }
                ];
                /** @nocollapse */
                SebmGoogleMapPolygon.ctorParameters = function() {
                    return [{ type: polygon_manager_1.PolygonManager }];
                };
                return SebmGoogleMapPolygon;
            })();
            exports.SebmGoogleMapPolygon = SebmGoogleMapPolygon;
            //# sourceMappingURL=google-map-polygon.js.map

            /***/
        },
        /* 79 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var polyline_manager_1 = __webpack_require__(72);
            var google_map_polyline_point_1 = __webpack_require__(80);
            var polylineId = 0;
            /**
             * SebmGoogleMapPolyline renders a polyline on a {@link SebmGoogleMap}
             *
             * ### Example
             * ```typescript
             * import { Component } from 'angular2/core';
             * import { SebmGoogleMap, SebmGooglePolyline, SebmGooglePolylinePoint } from
             * 'angular2-google-maps/core';
             *
             * @Component({
             *  selector: 'my-map-cmp',
             *  directives: [SebmGoogleMap, SebmGooglePolyline, SebmGooglePolylinePoint],
             *  styles: [`
             *    .sebm-google-map-container {
             *      height: 300px;
             *    }
             * `],
             *  template: `
             *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
             *      <sebm-google-map-polyline>
             *          <sebm-google-map-polyline-point [latitude]="latA" [longitude]="lngA">
             *          </sebm-google-map-polyline-point>
             *          <sebm-google-map-polyline-point [latitude]="latB" [longitude]="lngB">
             *          </sebm-google-map-polyline-point>
             *      </sebm-google-map-polyline>
             *    </sebm-google-map>
             *  `
             * })
             * ```
             */
            var SebmGoogleMapPolyline = (function() {
                function SebmGoogleMapPolyline(_polylineManager) {
                    this._polylineManager = _polylineManager;
                    /**
                     * Indicates whether this Polyline handles mouse events. Defaults to true.
                     */
                    this.clickable = true;
                    /**
                     * If set to true, the user can drag this shape over the map. The geodesic property defines the
                     * mode of dragging. Defaults to false.
                     */
                    this.draggable = false;
                    /**
                     * If set to true, the user can edit this shape by dragging the control points shown at the
                     * vertices and on each segment. Defaults to false.
                     */
                    this.editable = false;
                    /**
                     * When true, edges of the polygon are interpreted as geodesic and will follow the curvature of
                     * the Earth. When false, edges of the polygon are rendered as straight lines in screen space.
                     * Note that the shape of a geodesic polygon may appear to change when dragged, as the dimensions
                     * are maintained relative to the surface of the earth. Defaults to false.
                     */
                    this.geodesic = false;
                    /**
                     * Whether this polyline is visible on the map. Defaults to true.
                     */
                    this.visible = true;
                    /**
                     * This event is fired when the DOM click event is fired on the Polyline.
                     */
                    this.lineClick = new core_1.EventEmitter();
                    /**
                     * This event is fired when the DOM dblclick event is fired on the Polyline.
                     */
                    this.lineDblClick = new core_1.EventEmitter();
                    /**
                     * This event is repeatedly fired while the user drags the polyline.
                     */
                    this.lineDrag = new core_1.EventEmitter();
                    /**
                     * This event is fired when the user stops dragging the polyline.
                     */
                    this.lineDragEnd = new core_1.EventEmitter();
                    /**
                     * This event is fired when the user starts dragging the polyline.
                     */
                    this.lineDragStart = new core_1.EventEmitter();
                    /**
                     * This event is fired when the DOM mousedown event is fired on the Polyline.
                     */
                    this.lineMouseDown = new core_1.EventEmitter();
                    /**
                     * This event is fired when the DOM mousemove event is fired on the Polyline.
                     */
                    this.lineMouseMove = new core_1.EventEmitter();
                    /**
                     * This event is fired on Polyline mouseout.
                     */
                    this.lineMouseOut = new core_1.EventEmitter();
                    /**
                     * This event is fired on Polyline mouseover.
                     */
                    this.lineMouseOver = new core_1.EventEmitter();
                    /**
                     * This event is fired whe the DOM mouseup event is fired on the Polyline
                     */
                    this.lineMouseUp = new core_1.EventEmitter();
                    /**
                     * This even is fired when the Polyline is right-clicked on.
                     */
                    this.lineRightClick = new core_1.EventEmitter();
                    this._polylineAddedToManager = false;
                    this._subscriptions = [];
                    this._id = (polylineId++).toString();
                }
                /** @internal */
                SebmGoogleMapPolyline.prototype.ngAfterContentInit = function() {
                    var _this = this;
                    if (this.points.length) {
                        this.points.forEach(function(point) {
                            var s = point.positionChanged.subscribe(function() {
                                _this._polylineManager.updatePolylinePoints(_this);
                            });
                            _this._subscriptions.push(s);
                        });
                    }
                    if (!this._polylineAddedToManager) {
                        this._init();
                    }
                    var s = this.points.changes.subscribe(function() {
                        return _this._polylineManager.updatePolylinePoints(_this);
                    });
                    this._subscriptions.push(s);
                    this._polylineManager.updatePolylinePoints(this);
                };
                SebmGoogleMapPolyline.prototype.ngOnChanges = function(changes) {
                    if (!this._polylineAddedToManager) {
                        this._init();
                        return;
                    }
                    var options = {};
                    var optionKeys = Object.keys(changes).filter(function(k) {
                        return SebmGoogleMapPolyline._polylineOptionsAttributes.indexOf(k) !== -1;
                    });
                    optionKeys.forEach(function(k) {
                        return (options[k] = changes[k].currentValue);
                    });
                    this._polylineManager.setPolylineOptions(this, options);
                };
                SebmGoogleMapPolyline.prototype._init = function() {
                    this._polylineManager.addPolyline(this);
                    this._polylineAddedToManager = true;
                    this._addEventListeners();
                };
                SebmGoogleMapPolyline.prototype._addEventListeners = function() {
                    var _this = this;
                    var handlers = [
                        {
                            name: 'click',
                            handler: function(ev) {
                                return _this.lineClick.emit(ev);
                            }
                        },
                        {
                            name: 'dbclick',
                            handler: function(ev) {
                                return _this.lineDblClick.emit(ev);
                            }
                        },
                        {
                            name: 'drag',
                            handler: function(ev) {
                                return _this.lineDrag.emit(ev);
                            }
                        },
                        {
                            name: 'dragend',
                            handler: function(ev) {
                                return _this.lineDragEnd.emit(ev);
                            }
                        },
                        {
                            name: 'dragstart',
                            handler: function(ev) {
                                return _this.lineDragStart.emit(ev);
                            }
                        },
                        {
                            name: 'mousedown',
                            handler: function(ev) {
                                return _this.lineMouseDown.emit(ev);
                            }
                        },
                        {
                            name: 'mousemove',
                            handler: function(ev) {
                                return _this.lineMouseMove.emit(ev);
                            }
                        },
                        {
                            name: 'mouseout',
                            handler: function(ev) {
                                return _this.lineMouseOut.emit(ev);
                            }
                        },
                        {
                            name: 'mouseover',
                            handler: function(ev) {
                                return _this.lineMouseOver.emit(ev);
                            }
                        },
                        {
                            name: 'mouseup',
                            handler: function(ev) {
                                return _this.lineMouseUp.emit(ev);
                            }
                        },
                        {
                            name: 'rightclick',
                            handler: function(ev) {
                                return _this.lineRightClick.emit(ev);
                            }
                        }
                    ];
                    handlers.forEach(function(obj) {
                        var os = _this._polylineManager.createEventObservable(obj.name, _this).subscribe(obj.handler);
                        _this._subscriptions.push(os);
                    });
                };
                /** @internal */
                SebmGoogleMapPolyline.prototype._getPoints = function() {
                    if (this.points) {
                        return this.points.toArray();
                    }
                    return [];
                };
                /** @internal */
                SebmGoogleMapPolyline.prototype.id = function() {
                    return this._id;
                };
                /** @internal */
                SebmGoogleMapPolyline.prototype.ngOnDestroy = function() {
                    this._polylineManager.deletePolyline(this);
                    // unsubscribe all registered observable subscriptions
                    this._subscriptions.forEach(function(s) {
                        return s.unsubscribe();
                    });
                };
                SebmGoogleMapPolyline._polylineOptionsAttributes = [
                    'draggable',
                    'editable',
                    'visible',
                    'geodesic',
                    'strokeColor',
                    'strokeOpacity',
                    'strokeWeight',
                    'zIndex'
                ];
                SebmGoogleMapPolyline.decorators = [
                    {
                        type: core_1.Directive,
                        args: [
                            {
                                selector: 'sebm-google-map-polyline',
                                inputs: [
                                    'clickable',
                                    'draggable: polylineDraggable',
                                    'editable',
                                    'geodesic',
                                    'strokeColor',
                                    'strokeWeight',
                                    'strokeOpacity',
                                    'visible',
                                    'zIndex'
                                ],
                                outputs: [
                                    'lineClick',
                                    'lineDblClick',
                                    'lineDrag',
                                    'lineDragEnd',
                                    'lineMouseDown',
                                    'lineMouseMove',
                                    'lineMouseOut',
                                    'lineMouseOver',
                                    'lineMouseUp',
                                    'lineRightClick'
                                ]
                            }
                        ]
                    }
                ];
                /** @nocollapse */
                SebmGoogleMapPolyline.ctorParameters = function() {
                    return [{ type: polyline_manager_1.PolylineManager }];
                };
                SebmGoogleMapPolyline.propDecorators = {
                    points: [{ type: core_1.ContentChildren, args: [google_map_polyline_point_1.SebmGoogleMapPolylinePoint] }]
                };
                return SebmGoogleMapPolyline;
            })();
            exports.SebmGoogleMapPolyline = SebmGoogleMapPolyline;
            //# sourceMappingURL=google-map-polyline.js.map

            /***/
        },
        /* 80 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            /**
             * SebmGoogleMapPolylinePoint represents one element of a polyline within a  {@link
             * SembGoogleMapPolyline}
             */
            var SebmGoogleMapPolylinePoint = (function() {
                function SebmGoogleMapPolylinePoint() {
                    /**
                     * This event emitter gets emitted when the position of the point changed.
                     */
                    this.positionChanged = new core_1.EventEmitter();
                }
                SebmGoogleMapPolylinePoint.prototype.ngOnChanges = function(changes) {
                    if (changes['latitude'] || changes['longitude']) {
                        var position = {
                            lat: changes['latitude'].currentValue,
                            lng: changes['longitude'].currentValue
                        };
                        this.positionChanged.emit(position);
                    }
                };
                SebmGoogleMapPolylinePoint.decorators = [{ type: core_1.Directive, args: [{ selector: 'sebm-google-map-polyline-point' }] }];
                /** @nocollapse */
                SebmGoogleMapPolylinePoint.ctorParameters = function() {
                    return [];
                };
                SebmGoogleMapPolylinePoint.propDecorators = {
                    latitude: [{ type: core_1.Input }],
                    longitude: [{ type: core_1.Input }],
                    positionChanged: [{ type: core_1.Output }]
                };
                return SebmGoogleMapPolylinePoint;
            })();
            exports.SebmGoogleMapPolylinePoint = SebmGoogleMapPolylinePoint;
            //# sourceMappingURL=google-map-polyline-point.js.map

            /***/
        },
        /* 81 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var google_maps_api_wrapper_1 = __webpack_require__(66);
            exports.GoogleMapsAPIWrapper = google_maps_api_wrapper_1.GoogleMapsAPIWrapper;
            var circle_manager_1 = __webpack_require__(68);
            exports.CircleManager = circle_manager_1.CircleManager;
            var info_window_manager_1 = __webpack_require__(69);
            exports.InfoWindowManager = info_window_manager_1.InfoWindowManager;
            var marker_manager_1 = __webpack_require__(70);
            exports.MarkerManager = marker_manager_1.MarkerManager;
            var polygon_manager_1 = __webpack_require__(71);
            exports.PolygonManager = polygon_manager_1.PolygonManager;
            var polyline_manager_1 = __webpack_require__(72);
            exports.PolylineManager = polyline_manager_1.PolylineManager;
            var kml_layer_manager_1 = __webpack_require__(73);
            exports.KmlLayerManager = kml_layer_manager_1.KmlLayerManager;
            var lazy_maps_api_loader_1 = __webpack_require__(82);
            exports.GoogleMapsScriptProtocol = lazy_maps_api_loader_1.GoogleMapsScriptProtocol;
            exports.LAZY_MAPS_API_CONFIG = lazy_maps_api_loader_1.LAZY_MAPS_API_CONFIG;
            exports.LazyMapsAPILoader = lazy_maps_api_loader_1.LazyMapsAPILoader;
            var maps_api_loader_1 = __webpack_require__(67);
            exports.MapsAPILoader = maps_api_loader_1.MapsAPILoader;
            var noop_maps_api_loader_1 = __webpack_require__(84);
            exports.NoOpMapsAPILoader = noop_maps_api_loader_1.NoOpMapsAPILoader;
            //# sourceMappingURL=services.js.map

            /***/
        },
        /* 82 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __extends =
                (this && this.__extends) ||
                function(d, b) {
                    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                };
            var core_1 = __webpack_require__(8);
            var browser_globals_1 = __webpack_require__(83);
            var maps_api_loader_1 = __webpack_require__(67);
            (function(GoogleMapsScriptProtocol) {
                GoogleMapsScriptProtocol[(GoogleMapsScriptProtocol['HTTP'] = 1)] = 'HTTP';
                GoogleMapsScriptProtocol[(GoogleMapsScriptProtocol['HTTPS'] = 2)] = 'HTTPS';
                GoogleMapsScriptProtocol[(GoogleMapsScriptProtocol['AUTO'] = 3)] = 'AUTO';
            })(exports.GoogleMapsScriptProtocol || (exports.GoogleMapsScriptProtocol = {}));
            var GoogleMapsScriptProtocol = exports.GoogleMapsScriptProtocol;
            /**
             * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link
             * LazyMapsAPILoaderConfig}.
             */
            exports.LAZY_MAPS_API_CONFIG = new core_1.OpaqueToken('angular2-google-maps LAZY_MAPS_API_CONFIG');
            var LazyMapsAPILoader = (function(_super) {
                __extends(LazyMapsAPILoader, _super);
                function LazyMapsAPILoader(config, w, d) {
                    _super.call(this);
                    this._config = config || {};
                    this._windowRef = w;
                    this._documentRef = d;
                }
                LazyMapsAPILoader.prototype.load = function() {
                    var _this = this;
                    if (this._scriptLoadingPromise) {
                        return this._scriptLoadingPromise;
                    }
                    var script = this._documentRef.getNativeDocument().createElement('script');
                    script.type = 'text/javascript';
                    script.async = true;
                    script.defer = true;
                    var callbackName = 'angular2GoogleMapsLazyMapsAPILoader';
                    script.src = this._getScriptSrc(callbackName);
                    this._scriptLoadingPromise = new Promise(function(resolve, reject) {
                        _this._windowRef.getNativeWindow()[callbackName] = function() {
                            resolve();
                        };
                        script.onerror = function(error) {
                            reject(error);
                        };
                    });
                    this._documentRef.getNativeDocument().body.appendChild(script);
                    return this._scriptLoadingPromise;
                };
                LazyMapsAPILoader.prototype._getScriptSrc = function(callbackName) {
                    var protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;
                    var protocol;
                    switch (protocolType) {
                        case GoogleMapsScriptProtocol.AUTO:
                            protocol = '';
                            break;
                        case GoogleMapsScriptProtocol.HTTP:
                            protocol = 'http:';
                            break;
                        case GoogleMapsScriptProtocol.HTTPS:
                            protocol = 'https:';
                            break;
                    }
                    var hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
                    var queryParams = {
                        v: this._config.apiVersion || '3',
                        callback: callbackName,
                        key: this._config.apiKey,
                        client: this._config.clientId,
                        channel: this._config.channel,
                        libraries: this._config.libraries,
                        region: this._config.region,
                        language: this._config.language
                    };
                    var params = Object.keys(queryParams)
                        .filter(function(k) {
                            return queryParams[k] != null;
                        })
                        .filter(function(k) {
                            // remove empty arrays
                            return !Array.isArray(queryParams[k]) || (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
                        })
                        .map(function(k) {
                            // join arrays as comma seperated strings
                            var i = queryParams[k];
                            if (Array.isArray(i)) {
                                return { key: k, value: i.join(',') };
                            }
                            return { key: k, value: queryParams[k] };
                        })
                        .map(function(entry) {
                            return entry.key + '=' + entry.value;
                        })
                        .join('&');
                    return protocol + '//' + hostAndPath + '?' + params;
                };
                LazyMapsAPILoader.decorators = [{ type: core_1.Injectable }];
                /** @nocollapse */
                LazyMapsAPILoader.ctorParameters = function() {
                    return [
                        { type: undefined, decorators: [{ type: core_1.Inject, args: [exports.LAZY_MAPS_API_CONFIG] }] },
                        { type: browser_globals_1.WindowRef },
                        { type: browser_globals_1.DocumentRef }
                    ];
                };
                return LazyMapsAPILoader;
            })(maps_api_loader_1.MapsAPILoader);
            exports.LazyMapsAPILoader = LazyMapsAPILoader;
            //# sourceMappingURL=lazy-maps-api-loader.js.map

            /***/
        },
        /* 83 */
        /***/ function(module, exports) {
            'use strict';
            var WindowRef = (function() {
                function WindowRef() {}
                WindowRef.prototype.getNativeWindow = function() {
                    return window;
                };
                return WindowRef;
            })();
            exports.WindowRef = WindowRef;
            var DocumentRef = (function() {
                function DocumentRef() {}
                DocumentRef.prototype.getNativeDocument = function() {
                    return document;
                };
                return DocumentRef;
            })();
            exports.DocumentRef = DocumentRef;
            exports.BROWSER_GLOBALS_PROVIDERS = [WindowRef, DocumentRef];
            //# sourceMappingURL=browser-globals.js.map

            /***/
        },
        /* 84 */
        /***/ function(module, exports) {
            'use strict';
            /**
             * When using the NoOpMapsAPILoader, the Google Maps API must be added to the page via a `<script>`
             * Tag.
             * It's important that the Google Maps API script gets loaded first on the page.
             */
            var NoOpMapsAPILoader = (function() {
                function NoOpMapsAPILoader() {}
                NoOpMapsAPILoader.prototype.load = function() {
                    if (!window.google || !window.google.maps) {
                        throw new Error('Google Maps API not loaded on page. Make sure window.google.maps is available!');
                    }
                    return Promise.resolve();
                };
                return NoOpMapsAPILoader;
            })();
            exports.NoOpMapsAPILoader = NoOpMapsAPILoader;
            //# sourceMappingURL=noop-maps-api-loader.js.map

            /***/
        },
        /* 85 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var core_1 = __webpack_require__(8);
            var google_map_kml_layer_1 = __webpack_require__(76);
            var google_map_1 = __webpack_require__(65);
            var google_map_circle_1 = __webpack_require__(74);
            var google_map_info_window_1 = __webpack_require__(75);
            var google_map_marker_1 = __webpack_require__(77);
            var google_map_polygon_1 = __webpack_require__(78);
            var google_map_polyline_1 = __webpack_require__(79);
            var google_map_polyline_point_1 = __webpack_require__(80);
            var lazy_maps_api_loader_1 = __webpack_require__(82);
            var lazy_maps_api_loader_2 = __webpack_require__(82);
            var maps_api_loader_1 = __webpack_require__(67);
            var browser_globals_1 = __webpack_require__(83);
            /**
             * @internal
             */
            function coreDirectives() {
                return [
                    google_map_1.SebmGoogleMap,
                    google_map_marker_1.SebmGoogleMapMarker,
                    google_map_info_window_1.SebmGoogleMapInfoWindow,
                    google_map_circle_1.SebmGoogleMapCircle,
                    google_map_polygon_1.SebmGoogleMapPolygon,
                    google_map_polyline_1.SebmGoogleMapPolyline,
                    google_map_polyline_point_1.SebmGoogleMapPolylinePoint,
                    google_map_kml_layer_1.SebmGoogleMapKmlLayer
                ];
            }
            exports.coreDirectives = coreDirectives;
            /**
             * The angular2-google-maps core module. Contains all Directives/Services/Pipes
             * of the core module. Please use `AgmCoreModule.forRoot()` in your app module.
             */
            var AgmCoreModule = (function() {
                function AgmCoreModule() {}
                /**
                 * Please use this method when you register the module at the root level.
                 */
                AgmCoreModule.forRoot = function(lazyMapsAPILoaderConfig) {
                    return {
                        ngModule: AgmCoreModule,
                        providers: browser_globals_1.BROWSER_GLOBALS_PROVIDERS.concat([
                            { provide: maps_api_loader_1.MapsAPILoader, useClass: lazy_maps_api_loader_1.LazyMapsAPILoader },
                            { provide: lazy_maps_api_loader_2.LAZY_MAPS_API_CONFIG, useValue: lazyMapsAPILoaderConfig }
                        ])
                    };
                };
                AgmCoreModule.decorators = [{ type: core_1.NgModule, args: [{ declarations: coreDirectives(), exports: coreDirectives() }] }];
                /** @nocollapse */
                AgmCoreModule.ctorParameters = function() {
                    return [];
                };
                return AgmCoreModule;
            })();
            exports.AgmCoreModule = AgmCoreModule;
            //# sourceMappingURL=core-module.js.map

            /***/
        },
        /* 86 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var practice_data_1 = __webpack_require__(87);
            var PracticeComponent = (function() {
                function PracticeComponent() {
                    // Practice data to inject into our template
                    this.practiceData = practice_data_1.PRACTICE_DATA;
                }
                PracticeComponent.prototype.ngOnInit = function() {};
                return PracticeComponent;
            })();
            PracticeComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'practice',
                        template: __webpack_require__(88),
                        styles: [__webpack_require__(89)]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                PracticeComponent
            );
            exports.PracticeComponent = PracticeComponent;

            /***/
        },
        /* 87 */
        /***/ function(module, exports) {
            'use strict';
            exports.PRACTICE_DATA = [
                {
                    season: 'Fall',
                    what: 'Normal Practice',
                    time: '4:30PM-7PM',
                    when: 'Mondays & Wednesdays',
                    locationLabel: 'Complex Fields',
                    locationLink:
                        'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
                },
                //{
                //season: 'Fall',
                //what: 'Weekend Invite Practice',
                //time: 'TBD',
                //when: 'Weekends',
                //locationLabel: 'Complex Fields',
                //locationLink:
                //'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
                //},
                {
                    season: 'Winter',
                    what: 'Normal Practice',
                    time: '9:30PM-12AM',
                    when: 'Mondays & Wednesdays',
                    locationLabel: 'Armory',
                    locationLink:
                        'https://www.google.com/maps/place/Armory/@40.105402,-88.235534,17z/data=!3m1!5s0x880cd73b8c4fbb7d:0xa84890110afd0990!4m7!1m4!3m3!1s0x880cd73a16c1d78f:0xe1bb009225fc1225!2sE+Armory+Ave,+Champaign,+IL+61820!3b1!3m1!1s0x0000000000000000:0x0b21d56f2b951978'
                },
                {
                    season: 'Winter',
                    what: 'Indoor Field Practice',
                    time: '9PM-11PM',
                    when: 'Thursdays',
                    locationLabel: 'Irwin Facility',
                    locationLink:
                        'https://www.google.com/maps/place/Irwin+Indoor+Football+Facility,+University+of+Illinois+at+Urbana-Champaign,+Champaign,+IL+61820/@40.1006475,-88.2342204,17z/data=!3m1!4b1!4m6!1m3!3m2!1s0x880cd724a92655e9:0xa53c0525046826fa!2sUniversity+of+Illinois+at+Urbana-Champaign!3m1!1s0x880cd725292c02bd:0x18f5a03daad8677a'
                },
                {
                    season: 'Spring',
                    what: 'Normal Practice',
                    time: '4:30PM-7PM',
                    when: 'Mondays & Wednesdays',
                    locationLabel: 'Complex Fields',
                    locationLink:
                        'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
                },
                {
                    season: 'Spring',
                    what: 'Normal Practice',
                    time: '11AM-1PM',
                    when: 'Non-Tournament Weekends',
                    locationLabel: 'Complex Fields',
                    locationLink:
                        'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
                }
            ];

            /***/
        },
        /* 88 */
        /***/ function(module, exports) {
            module.exports =
                '<!--Header-->\n<h1 class="ui header">Practice</h1>\n<!--Table-->\n<table class="ui celled table">\n    <thead>\n        <tr>\n            <th>Season</th>\n            <th>What</th>\n            <th>Time</th>\n            <th>When</th>\n            <th>Location</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr *ngFor="let practiceRow of practiceData">\n            <td>{{practiceRow.season}}</td>\n            <td>{{practiceRow.what}}</td>\n            <td>{{practiceRow.time}}</td>\n            <td>{{practiceRow.when}}</td>\n            <td><a class="practice-location-link" href="{{practiceRow.locationLink}}" target="_blank">{{practiceRow.locationLabel}}</a></td>\n        </tr>\n    </tbody>\n</table>\n\n<iframe src="https://calendar.google.com/calendar/b/1/embed?height=600&amp;wkst=1&amp;bgcolor=%23ffffff&amp;ctz=America%2FChicago&amp;src=aWxsaW5vaXMuZWR1XzhxNHUwYzM2aTlhbzBnajIwOXNndDNzMGpzQGdyb3VwLmNhbGVuZGFyLmdvb2dsZS5jb20&amp;src=aWxsaW5vaXMuZWR1Xzg3dXFzZmJrbzBhZjU0ZmNuNDFudWFnbGVrQGdyb3VwLmNhbGVuZGFyLmdvb2dsZS5jb20&amp;color=%2333B679&amp;color=%23E4C441&amp;showTitle=0&amp;showNav=1&amp;showDate=1&amp;showPrint=0&amp;showTabs=1&amp;showCalendars=1&amp;showTz=1&amp;mode=WEEK" style="border-width:0" width="950" height="650" frameborder="0" scrolling="no"></iframe>\n';

            /***/
        },
        /* 89 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(90);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 90 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([module.id, 'tr{text-align:center}', '']);

            // exports

            /***/
        },
        /* 91 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var router_1 = __webpack_require__(92);
            var tournaments_data_1 = __webpack_require__(122);
            var TournamentsComponent = (function() {
                // Inject the ActivatedRoute into our component
                function TournamentsComponent(route) {
                    this.route = route;
                    // Tournament data to inject into our template
                    this.tournamentData = tournaments_data_1.TOURNAMENTS_DATA;
                }
                /**
                 * Subscribe to our route parameters (tournament year).
                 */
                TournamentsComponent.prototype.ngOnInit = function() {
                    var _this = this;
                    this.routeParamsSubscription = this.route.params.subscribe(function(params) {
                        // (+) converts string 'year' to a number
                        _this.year = +params['year'];
                    });
                };
                /**
                 * Unsubscribe to our route parameters (tournament year).
                 */
                TournamentsComponent.prototype.ngOnDestroy = function() {
                    this.routeParamsSubscription.unsubscribe();
                };
                return TournamentsComponent;
            })();
            TournamentsComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'tournaments',
                        template: __webpack_require__(123),
                        styles: [__webpack_require__(124)]
                    }),
                    __metadata('design:paramtypes', [
                        (typeof (_a = typeof router_1.ActivatedRoute !== 'undefined' && router_1.ActivatedRoute) === 'function' && _a) || Object
                    ])
                ],
                TournamentsComponent
            );
            exports.TournamentsComponent = TournamentsComponent;
            var _a;

            /***/
        },
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        /* 92 */ /* 93 */ /* 94 */ /* 95 */ /* 96 */ /* 97 */ /* 98 */ /* 99 */ /* 100 */ /* 101 */ /* 102 */ /* 103 */ /* 104 */ /* 105 */ /* 106 */ /* 107 */ /* 108 */ /* 109 */ /* 110 */ /* 111 */ /* 112 */ /* 113 */ /* 114 */ /* 115 */ /* 116 */ /* 117 */ /* 118 */ /* 119 */ /* 120 */ /* 121 */ /* 122 */
        /***/ function(module, exports) {
            'use strict';
            exports.TOURNAMENTS_DATA = [
                {
                    year: 2019,
                    tournaments: [
                        {
                            season: 'Fall',
                            nameLabel: 'Stanley Cup',
                            nameLink: '',
                            when: 'Sept. 15th-16th',
                            location: 'Normal, IL',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'No Wisconsequences',
                            nameLink: 'http://nowisconsequences.ultimatecentral.com/',
                            when: 'Oct. 6th-7th',
                            location: 'Hartland, WI',
                            result: 'Cancelled'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Missouri Loves Company',
                            nameLink:
                                'https://www.facebook.com/MissouriLovesCompany2018/?__tn__=kC-R&eid=ARD-KglibzvntFiwk2JIDOD7ylzeCvYMbvSB_99_VM1USVNvHhUI-xbx9_5daViGshubp48EAO_JeeQN&hc_ref=ARTJXZoaRgrfp1S7ZG7wFELrx16ZzqCQFcVGc0QTgJRTXYDiQzO5vvz7C7w98xlGwlQ&fref=nf&__xts__[0]=68.ARCyulKkGdiLaL5RY_ewBJJWmIkPdXmYjylVbU1evhOA8aoDo2_4d1-gUj0K4XicIY-HFgNGrqckgixrUWF8wLlYLEOEbjGJELrPVLQJWNQd-6jNksBooiRrMXDGPJluVge-2PBdUQilJrrLatP_ZcJhVYl551eFsop8NRJbIFTCqIPsdaKbj8Ggei4fvK4bZCKmz713zkUebAyg0wossHhbsRjhfQOvXK5Qw4K01SqL_OOKS6TWXAiCNgo5lPfjYvXyv8DOJZu1yfJxqBqXGltD5gJ01APAoEbn9MWANl4VPubpnCJTyYsDC04AC4sBWgpgtKsWCCkuNSVAVU0',
                            when: 'November 3rd-4th',
                            location: 'Columbia, MO',
                            result: '-'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'T-Town Throwdown',
                            nameLink: 'https://play.usaultimate.org/events/T-Town-Throwdown/',
                            when: 'Jan. 26th-27th',
                            location: 'Tuscaloosa, AL',
                            result: '3rd'
                        },
                        {
                            season: 'Spring',
                            nameLabel: "President's Day Invite",
                            nameLink: 'https://play.usaultimate.org/events/Presidents-Day-Invite-2019/',
                            when: 'Feb. 16th-18th',
                            location: 'San Diego, CA',
                            result: '10th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Centex',
                            nameLink: 'https://play.usaultimate.org/events/Centex-2019-Men-/',
                            when: 'March 16th-17th',
                            location: 'Austin, TX',
                            result: '9th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Huck Finn',
                            nameLink: 'https://play.usaultimate.org/events/Huck-Finn-XXIII/',
                            when: 'March 30th-31st',
                            location: 'St. Charles, MO',
                            result: '2nd'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Illinois Conferences',
                            nameLink: 'https://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2019/',
                            when: 'April 13th-14th',
                            location: 'Rantoul, IL',
                            result: 'T-2nd*'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Great Lakes Regionals',
                            nameLink: 'https://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2019/',
                            when: 'April 27th-28th',
                            location: 'Joliet, IL',
                            result: '3rd'
                        }
                    ]
                },
                {
                    year: 2018,
                    tournaments: [
                        {
                            season: 'Fall',
                            nameLabel: 'Boiler Breakaway',
                            nameLink: 'https://boilerlink.purdue.edu/event/972920',
                            when: 'Sept. 16th-17th',
                            location: 'West Lafayette, IN',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'No Wisconsequences',
                            nameLink: 'http://nowisconsequences.ultimatecentral.com',
                            when: 'Oct. 7th-8th',
                            location: 'Hartland, WI',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Missouri Loves Company',
                            nameLink: 'http://ultimate.missouri.edu/mlc/2017/',
                            when: 'Nov. 4th-5th',
                            location: 'Columbia, MO',
                            result: '-'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Mid-Atlantic Warmup',
                            nameLink: 'https://play.usaultimate.org/events/Mid-Atlantic-Warmup-2018/',
                            when: 'Feb. 3rd-4th',
                            location: 'Williamsburg, VA',
                            result: '1st'
                        },
                        {
                            season: 'Spring',
                            nameLabel: "President's Day Invite",
                            nameLink: 'https://play.usaultimate.org/events/Presidents-Day-Invitational-Tournament-2018/',
                            when: 'Feb. 17th-19th',
                            location: 'San Diego, CA',
                            result: '9th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Centex',
                            nameLink: 'https://play.usaultimate.org/events/Mens-Centex-2018/',
                            when: 'March 10th-11th',
                            location: 'Austin, TX',
                            result: '6th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Huck Finn',
                            nameLink: 'https://play.usaultimate.org/events/Huck-Finn-2018/',
                            when: 'March 31st-April 1st',
                            location: 'St. Louis, MO',
                            result: '13th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Illinois Conferences',
                            nameLink: 'https://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2018/',
                            when: 'April 14th-15th',
                            location: 'Rantoul, IL',
                            result: '2nd'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Great Lakes Regionals',
                            nameLink: 'https://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2018/',
                            when: 'April 28th-29th',
                            location: 'Brighton, MI',
                            result: 'T-3rd'
                        }
                    ]
                },
                {
                    year: 2017,
                    tournaments: [
                        {
                            season: 'Fall',
                            nameLabel: 'Boiler Breakaway',
                            nameLink: 'https://boilerlink.purdue.edu/organization/mensultimate/calendar/details/972920',
                            when: 'Sept. 17th-18th',
                            location: 'West Lafayette, IN',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'No Wisconsequences',
                            nameLink: 'http://nowisconsequences.ultimatecentral.com',
                            when: 'Oct. 8th-9th',
                            location: 'Hartland, WI',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Missouri Loves Company',
                            nameLink: 'http://ultimate.missouri.edu/mlc/2016',
                            when: 'Nov. 5th-6th',
                            location: 'Columbia, MO',
                            result: '-'
                        },
                        {
                            season: 'Spring',
                            nameLabel: "President's Day Invite",
                            nameLink: 'http://play.usaultimate.org/events/Presidents-Day-Tournament-2017',
                            when: 'Feb. 17th-20th',
                            location: 'San Diego, CA',
                            result: '5th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Centex',
                            nameLink: 'http://play.usaultimate.org/events/Centex-2017-Open',
                            when: 'March 10th-13th',
                            location: 'Austin, TX',
                            result: '7th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Huck Finn',
                            nameLink: 'http://play.usaultimate.org/events/Huck-Finn-2017',
                            when: 'April 1st-2nd',
                            location: 'St. Louis, MO',
                            result: '11th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Illinois Conferences',
                            nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2017',
                            when: 'April 22nd-23rd',
                            location: 'Rantoul, IL',
                            result: '2nd'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Great Lakes Regionals',
                            nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2017',
                            when: 'May 6th-7th',
                            location: 'Fair Oaks, IN',
                            result: '6th'
                        }
                    ]
                },
                {
                    year: 2016,
                    tournaments: [
                        {
                            season: 'Fall',
                            nameLabel: 'Boiler Breakaway',
                            nameLink: 'https://www.reddit.com/r/ultimate/comments/38gy72/new_fields_boiler_breakaway_2015_hosted_by_undue',
                            when: 'Sept. 19th-20th',
                            location: 'Westfield, IN',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Huck of the Irish',
                            nameLink: 'https://ndultimate.wordpress.com/hoti',
                            when: 'Oct. 3rd-4th',
                            location: 'South Bend, IN',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Chicago Invite',
                            nameLink: 'http://www.chicagoinvite.com',
                            when: 'Oct. 17th-18th',
                            location: 'Rockford, IL',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Missouri Loves Company',
                            nameLink: 'http://ultiworld.com/2015/11/12/missouri-loves-company-2015-tournament-recap-mens',
                            when: 'Nov. 7th-8th',
                            location: 'Columbia, MO',
                            result: '10th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Florida Warmup',
                            nameLink: 'http://play.usaultimate.org/events/Warm-up-A-Florida-Affair-2016',
                            when: 'Feb. 11th-14th',
                            location: 'Tampa, FL',
                            result: '15th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Easterns',
                            nameLink: 'http://play.usaultimate.org/events/College-Easterns-2016',
                            when: 'March 18th-20th',
                            location: 'North Myrtle Beach, SC',
                            result: '19th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Huck Finn',
                            nameLink: 'http://play.usaultimate.org/events/Huck-Finn-XX-2016',
                            when: 'Feb. 11th-14th',
                            location: 'St. Louis, MO',
                            result: '11th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Illinois Conferences',
                            nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2016',
                            when: 'April 16th-17th',
                            location: 'Rantoul, IL',
                            result: '3rd'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Great Lakes Regionals',
                            nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2016',
                            when: 'April 30th-May 1st',
                            location: 'Fair Oaks, IN',
                            result: '3rd'
                        }
                    ]
                },
                {
                    year: 2015,
                    tournaments: [
                        {
                            season: 'Fall',
                            nameLabel: 'Huck of the Irish',
                            nameLink: 'https://ndultimate.wordpress.com/whitesmoke',
                            when: 'Sept. 27th-28th',
                            location: 'South Bend, IN',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Glory Days',
                            nameLink: 'http://www.sun-ultimate.org/glory-days.html',
                            when: 'Oct. 4th-5th',
                            location: 'Rockford, IL',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Illinois Invite',
                            nameLink: 'https://illinois.collegiatelink.net/organization/illinoismensultimatefrisbeeteam/calendar/details/504204',
                            when: 'Oct. 18th-19th',
                            location: 'Rantoul, IL',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Missouri Loves Company',
                            nameLink: 'http://ultiworld.com/2014/11/06/missouri-loves-company-2014-tournament-preview-mens',
                            when: 'Nov. 8th-9th',
                            location: 'Columbia, MO',
                            result: '-'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Florida Warmup',
                            nameLink: 'http://play.usaultimate.org/events/Warm-Up-A-Florida-Affair-2015',
                            when: 'Feb. 13th-15th',
                            location: 'Tampa, FL',
                            result: '13th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Centex Invite',
                            nameLink: 'http://play.usaultimate.org/events/Centex-Invite-2015',
                            when: 'March 14th-15th',
                            location: 'Austin, TX',
                            result: '17th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Easterns',
                            nameLink: 'http://play.usaultimate.org/events/Easterns-2015',
                            when: 'March 27th-29th',
                            location: 'North Myrtle Beach, SC',
                            result: '17th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Illinois Conferences',
                            nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2015',
                            when: 'April 11th-12th',
                            location: 'Rantoul, IL',
                            result: '2nd'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Great Lakes Regionals',
                            nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2015',
                            when: 'April 25th-26th',
                            location: 'Rockford, IL',
                            result: '1st'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'D-I National Championships',
                            nameLink: 'http://play.usaultimate.org/events/USA-Ultimate-D-I-College-Championships-2015',
                            when: 'May 22nd-25th',
                            location: 'Milwaukee, WI',
                            result: '13th'
                        }
                    ]
                },
                {
                    year: 2014,
                    tournaments: [
                        {
                            season: 'Fall',
                            nameLabel: 'Boiler Breakaway',
                            nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/13422',
                            when: 'Oct. 5th-6th',
                            location: 'West Lafayette, IN',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Illinois Invite',
                            nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/13350',
                            when: 'Oct. 12th-13th',
                            location: 'Rantoul, IL',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Michigan Round Robin',
                            nameLink: '',
                            when: 'Oct. 20th',
                            location: 'Ann Arbor, MI',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Glory Days',
                            nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/13499',
                            when: 'Oct. 26th-27th',
                            location: 'Rockford, IL',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Missouri Loves Company',
                            nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/14017',
                            when: 'Nov. 9th-10th',
                            location: 'Columbia, MO',
                            result: '13th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Cat Fight',
                            nameLink: 'http://play.usaultimate.org/events/Cat-Fight',
                            when: 'Feb. 22nd-23rd',
                            location: 'Lexington, KY',
                            result: '1st'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Easterns',
                            nameLink: 'http://play.usaultimate.org/events/Easterns-and-DIII-Easterns',
                            when: 'March 22nd-23rd',
                            location: 'Little River, SC',
                            result: '13th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Illinois Conferences',
                            nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC',
                            when: 'April 12th-13th',
                            location: 'Rantoul, IL',
                            result: '1st'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Great Lakes Regionals',
                            nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals',
                            when: 'April 26th-27th',
                            location: 'Rockford, IL',
                            result: '5th'
                        }
                    ]
                },
                {
                    year: 2013,
                    tournaments: [
                        {
                            season: 'Fall',
                            nameLabel: 'Boiler Breakaway',
                            nameLink: 'http://scores.usaultimate.org/scores2012/#college-open/tournament/11432',
                            when: 'Sept. 22nd-23rd',
                            location: 'West Lafayette, IN',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Illinois Invite',
                            nameLink: 'http://scores.usaultimate.org/scores2012/#college-open/tournament/11476',
                            when: 'Oct. 13th-14th',
                            location: 'Rantoul, IL',
                            result: '-'
                        },
                        {
                            season: 'Fall',
                            nameLabel: 'Missouri Loves Company',
                            nameLink: 'http://scores.usaultimate.org/scores2012/#college-open/tournament/11657',
                            when: 'Nov. 10th-11th',
                            location: 'Columbia, MO',
                            result: '-'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Huck Finn',
                            nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12115',
                            when: 'March 9th-10th',
                            location: 'Chesterfield, MO',
                            result: '13th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Centex',
                            nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12707',
                            when: 'March 16th-17th',
                            location: 'Austin, TX',
                            result: '4th'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Illinois Conferences',
                            nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12604',
                            when: 'April 13th-14th',
                            location: 'Rantoul, IL',
                            result: '1st'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'Great Lakes Regionals',
                            nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12667',
                            when: 'April 27th-28th',
                            location: 'Rockford, IL',
                            result: '1st'
                        },
                        {
                            season: 'Spring',
                            nameLabel: 'D-I National Championships',
                            nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12686',
                            when: 'May 24th-27th',
                            location: 'Madison, WI',
                            result: '17th'
                        }
                    ]
                }
            ];

            /***/
        },
        /* 123 */
        /***/ function(module, exports) {
            module.exports =
                '<!--Header-->\n<h1 class="ui header">Tournaments</h1>\n<!--Menu-->\n<div class="ui secondary pointing menu">\n    <a class="item" routerLink="/tournaments/2013" [ngClass]="{\'active\': year === 2013}">2013</a>\n    <a class="item" routerLink="/tournaments/2014" [ngClass]="{\'active\': year === 2014}">2014</a>\n    <a class="item" routerLink="/tournaments/2015" [ngClass]="{\'active\': year === 2015}">2015</a>\n    <a class="item" routerLink="/tournaments/2016" [ngClass]="{\'active\': year === 2016}">2016</a>\n    <a class="item" routerLink="/tournaments/2017" [ngClass]="{\'active\': year === 2017}">2017</a>\n    <a class="item" routerLink="/tournaments/2018" [ngClass]="{\'active\': year === 2018}">2018</a>\n    <a class="item" routerLink="/tournaments/2019" [ngClass]="{\'active\': year === 2019}">2019</a>\n</div>\n<!--Table-->\n<ng-container *ngFor="let tournamentYear of tournamentData">\n    <ng-container *ngIf="tournamentYear.year === year">\n        <table class="ui celled table" *ngIf="tournamentData">\n            <thead>\n                <tr>\n                    <th>Season</th>\n                    <th>Name</th>\n                    <th>When</th>\n                    <th>Location</th>\n                    <th>Result</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr *ngFor="let tournament of tournamentYear.tournaments">\n                    <td>{{tournament.season}}</td>\n                    <td>\n                        <!--Only render a link if there is one provided in the data, otherwise just render the text-->\n                        <a class="tournament-info-link" *ngIf="tournament.nameLink" href="{{tournament.nameLink}}" target="_blank">{{tournament.nameLabel}}</a>\n                        <ng-container *ngIf="!tournament.nameLink">{{tournament.nameLabel}}</ng-container>\n                    </td>\n                    <td>{{tournament.when}}</td>\n                    <td>{{tournament.location}}</td>\n                    <td>{{tournament.result}}</td>\n                </tr>\n            </tbody>\n        </table>\n        * Bracket play not completed due to inclement weather\n    </ng-container>\n</ng-container>\n';

            /***/
        },
        /* 124 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(125);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 125 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([module.id, '', '']);

            // exports

            /***/
        },
        /* 126 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var router_1 = __webpack_require__(92);
            var rosters_data_1 = __webpack_require__(127);
            var RosterComponent = (function() {
                // Inject the ActivatedRoute into our component
                function RosterComponent(route) {
                    this.route = route;
                    // Roster data to inject into our template
                    this.rosterData = rosters_data_1.ROSTER_DATA;
                }
                /**
                 * Subscribe to our route parameters (roster year).
                 */
                RosterComponent.prototype.ngOnInit = function() {
                    var _this = this;
                    this.routeParamsSubscription = this.route.params.subscribe(function(params) {
                        // (+) converts string 'year' to a number
                        _this.year = +params['year'];
                    });
                };
                /**
                 * Unsubscribe to our route parameters (roster year).
                 */
                RosterComponent.prototype.ngOnDestroy = function() {
                    this.routeParamsSubscription.unsubscribe();
                };
                return RosterComponent;
            })();
            RosterComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'roster',
                        template: __webpack_require__(128),
                        styles: [__webpack_require__(129)]
                    }),
                    __metadata('design:paramtypes', [
                        (typeof (_a = typeof router_1.ActivatedRoute !== 'undefined' && router_1.ActivatedRoute) === 'function' && _a) || Object
                    ])
                ],
                RosterComponent
            );
            exports.RosterComponent = RosterComponent;
            var _a;

            /***/
        },
        /* 127 */
        /***/ function(module, exports) {
            'use strict';
            exports.ROSTER_DATA = [
                {
                    year: 2019,
                    imagePath: './assets/team-photo-2019.jpg',
                    players: [
                        {
                            number: 0,
                            name: 'Gregory Schwarz',
                            year: 'Grad'
                        },
                        {
                            number: 1,
                            name: 'Drake Hill',
                            year: 'Junior'
                        },
                        {
                            number: 2,
                            name: 'Ben Sabourin*',
                            year: 'Senior'
                        },
                        {
                            number: 4,
                            name: 'Asa Bowen',
                            year: 'Sophomore'
                        },
                        {
                            number: 6,
                            name: 'Jacob Cuthbert',
                            year: 'Senior'
                        },
                        {
                            number: 7,
                            name: 'Alex Liu',
                            year: 'Sophomore'
                        },
                        {
                            number: 8,
                            name: 'Devin Kelly',
                            year: 'Senior'
                        },
                        {
                            number: 13,
                            name: 'Reid Martin*',
                            year: 'Sophomore'
                        },
                        {
                            number: 14,
                            name: 'Aidan Levin',
                            year: 'Sophomore'
                        },
                        {
                            number: 19,
                            name: 'Joey Kennedy',
                            year: 'Freshman'
                        },
                        {
                            number: 20,
                            name: 'Ryan Kantor',
                            year: 'Senior'
                        },
                        {
                            number: 21,
                            name: 'Ben Lee',
                            year: 'Junior'
                        },
                        {
                            number: 22,
                            name: 'Lucas Gough',
                            year: 'Junior'
                        },
                        {
                            number: 24,
                            name: 'Josh Deeman*',
                            year: 'Senior'
                        },
                        {
                            number: 31,
                            name: 'Frank Dore',
                            year: 'Senior'
                        },
                        {
                            number: 32,
                            name: 'Daman Mulye',
                            year: 'Freshman'
                        },
                        {
                            number: 35,
                            name: 'Cameron Hartman',
                            year: 'Senior'
                        },
                        {
                            number: 38,
                            name: 'John Kulikowski',
                            year: 'Senior'
                        },
                        {
                            number: 40,
                            name: 'Rishav Rout',
                            year: 'Sophomore'
                        },
                        {
                            number: 46,
                            name: 'Nate Willis',
                            year: 'Grad'
                        },
                        {
                            number: 74,
                            name: 'Anthony Ruzzo',
                            year: 'Sophomore'
                        },
                        {
                            number: 82,
                            name: 'Brandon Carrel',
                            year: 'Junior'
                        },
                        {
                            number: undefined,
                            name: 'Daniel McDonald',
                            year: 'Coach'
                        }
                    ]
                },
                {
                    year: 2018,
                    imagePath: './assets/team-photo-2018.jpg',
                    players: [
                        {
                            number: 1,
                            name: 'Drake Hill',
                            year: 'Sophomore'
                        },
                        {
                            number: 2,
                            name: "Ben 'Beef' Sabourin",
                            year: 'Junior'
                        },
                        {
                            number: 4,
                            name: 'Asa Bowen',
                            year: 'Freshman'
                        },
                        {
                            number: 6,
                            name: 'Jacob Cuthbert',
                            year: 'Junior'
                        },
                        {
                            number: 7,
                            name: 'Kevin Lin',
                            year: 'Senior'
                        },
                        {
                            number: 8,
                            name: 'Devin Kelly',
                            year: 'Junior'
                        },
                        {
                            number: 13,
                            name: 'Walter Jaskowiak',
                            year: 'Junior'
                        },
                        {
                            number: 19,
                            name: 'Jacob Komenda*',
                            year: 'Senior'
                        },
                        {
                            number: 20,
                            name: 'Ryan Kantor',
                            year: 'Junior'
                        },
                        {
                            number: 23,
                            name: 'Hector Moreno',
                            year: 'Senior'
                        },
                        {
                            number: 24,
                            name: 'Josh Deeman*',
                            year: 'Junior'
                        },
                        {
                            number: 28,
                            name: 'Frank Dore',
                            year: 'Junior'
                        },
                        {
                            number: 35,
                            name: 'Cameron Hartman',
                            year: 'Junior'
                        },
                        {
                            number: 36,
                            name: 'Dalton Chaffee',
                            year: 'Grad'
                        },
                        {
                            number: 38,
                            name: 'John Kulikowski',
                            year: 'Junior'
                        },
                        {
                            number: 47,
                            name: 'Grant Whitman',
                            year: 'Senior'
                        },
                        {
                            number: 55,
                            name: 'Murray Chen',
                            year: 'Senior'
                        },
                        {
                            number: 74,
                            name: 'Anthony Ruzzo',
                            year: 'Freshman'
                        },
                        {
                            number: 89,
                            name: 'Reid Martin',
                            year: 'Freshman'
                        },
                        {
                            number: 96,
                            name: 'Dirk Husemann',
                            year: 'Senior'
                        },
                        {
                            number: undefined,
                            name: 'Daniel McDonald',
                            year: 'Coach'
                        }
                    ]
                },
                {
                    year: 2017,
                    imagePath: './assets/team-photo-2017.jpg',
                    players: [
                        {
                            number: 2,
                            name: "Ben 'Beef' Sabourin",
                            year: 'Sophomore'
                        },
                        {
                            number: 3,
                            name: 'Cody Gray',
                            year: 'Grad'
                        },
                        {
                            number: 6,
                            name: 'Jacob Cuthbert',
                            year: 'Sophomore'
                        },
                        {
                            number: 7,
                            name: 'Kevin Lin',
                            year: 'Junior'
                        },
                        {
                            number: 8,
                            name: 'Devin Kelly',
                            year: 'Sophomore'
                        },
                        {
                            number: 13,
                            name: 'Walter Jaskowiak',
                            year: 'Sophomore'
                        },
                        {
                            number: 18,
                            name: 'Hector Moreno',
                            year: 'Junior'
                        },
                        {
                            number: 19,
                            name: 'Jacob Komenda*',
                            year: 'Junior'
                        },
                        {
                            number: 23,
                            name: 'Jarred Elliott',
                            year: 'Senior'
                        },
                        {
                            number: 24,
                            name: 'Josh Deeman',
                            year: 'Sophomore'
                        },
                        {
                            number: 28,
                            name: 'Frank Dore',
                            year: 'Sophomore'
                        },
                        {
                            number: 29,
                            name: 'Ben Foster*',
                            year: 'Senior'
                        },
                        {
                            number: 33,
                            name: 'Jacob Trueb',
                            year: 'Junior'
                        },
                        {
                            number: 35,
                            name: 'Cameron Hartman',
                            year: 'Sophomore'
                        },
                        {
                            number: 38,
                            name: 'John Kulikowski',
                            year: 'Sophomore'
                        },
                        {
                            number: 47,
                            name: 'Grant Whitman',
                            year: 'Junior'
                        },
                        {
                            number: 81,
                            name: "Chris 'Books' Buchta*",
                            year: 'Senior'
                        },
                        {
                            number: 95,
                            name: 'Tat Shing',
                            year: 'Junior'
                        },
                        {
                            number: undefined,
                            name: 'Erik Huemiller',
                            year: 'Coach'
                        }
                    ]
                },
                {
                    year: 2016,
                    imagePath: './assets/team-photo-2016.jpg',
                    players: [
                        {
                            number: 1,
                            name: 'Nick Prozorovsky*',
                            year: 'Senior'
                        },
                        {
                            number: 2,
                            name: 'Ben Sabourin',
                            year: 'Freshman'
                        },
                        {
                            number: 3,
                            name: 'Cody Gray',
                            year: 'Grad'
                        },
                        {
                            number: 4,
                            name: 'Michael Cosmos',
                            year: 'Senior'
                        },
                        {
                            number: 7,
                            name: 'Kevin Lin',
                            year: 'Sophomore'
                        },
                        {
                            number: 8,
                            name: 'Johnny Saniat',
                            year: 'Senior'
                        },
                        {
                            number: 10,
                            name: 'Jacob Komenda',
                            year: 'Sophomore'
                        },
                        {
                            number: 12,
                            name: 'Kan Zi Yang',
                            year: 'Senior'
                        },
                        {
                            number: 13,
                            name: 'Mark Peterson',
                            year: 'Senior'
                        },
                        {
                            number: 17,
                            name: 'Prayag Patel*',
                            year: 'Senior'
                        },
                        {
                            number: 18,
                            name: 'Alex Guy',
                            year: 'Senior'
                        },
                        {
                            number: 23,
                            name: 'Jarred Elliott',
                            year: 'Junior'
                        },
                        {
                            number: 24,
                            name: 'Josh Deeman',
                            year: 'Freshman'
                        },
                        {
                            number: 27,
                            name: 'Wilson Wang',
                            year: 'Senior'
                        },
                        {
                            number: 29,
                            name: 'Ben Foster',
                            year: 'Junior'
                        },
                        {
                            number: 37,
                            name: 'Walter Jaskowiak',
                            year: 'Freshman'
                        },
                        {
                            number: 38,
                            name: 'Jacob Trueb',
                            year: 'Sophomore'
                        },
                        {
                            number: 41,
                            name: 'Devin Kelly',
                            year: 'Freshman'
                        },
                        {
                            number: 44,
                            name: 'Ryan Kantor',
                            year: 'Freshman'
                        },
                        {
                            number: 48,
                            name: 'Hector Moreno',
                            year: 'Sophomore'
                        },
                        {
                            number: 71,
                            name: 'Bobby Gazdziak',
                            year: 'Senior'
                        },
                        {
                            number: 81,
                            name: 'Chris Buchta*',
                            year: 'Junior'
                        },
                        {
                            number: 88,
                            name: 'Tim Chu',
                            year: 'Senior'
                        },
                        {
                            number: 95,
                            name: 'Tat Shing',
                            year: 'Sophomore'
                        },
                        {
                            number: 97,
                            name: 'Jacob Cuthbert',
                            year: 'Freshman'
                        },
                        {
                            number: undefined,
                            name: 'Matt West',
                            year: 'Assistant Coach'
                        },
                        {
                            number: undefined,
                            name: 'Erik Huemiller',
                            year: 'Coach'
                        }
                    ]
                },
                {
                    year: 2015,
                    imagePath: './assets/team-photo-2015.jpg',
                    players: [
                        {
                            number: 0,
                            name: 'Max Willis',
                            year: 'Senior'
                        },
                        {
                            number: 1,
                            name: 'Nick Prozorovsky*',
                            year: 'Junior'
                        },
                        {
                            number: 4,
                            name: 'Michael Pohling',
                            year: 'Senior'
                        },
                        {
                            number: 7,
                            name: 'Matt West',
                            year: 'Grad'
                        },
                        {
                            number: 8,
                            name: 'John Saniat*',
                            year: 'Junior'
                        },
                        {
                            number: 10,
                            name: 'Joe Moyles',
                            year: 'Senior'
                        },
                        {
                            number: 11,
                            name: 'Jon Mckoy',
                            year: 'Senior'
                        },
                        {
                            number: 12,
                            name: 'Kan Zi Yang',
                            year: 'Junior'
                        },
                        {
                            number: 13,
                            name: 'Mark Peterson',
                            year: 'Junior'
                        },
                        {
                            number: 17,
                            name: 'Prayag Patel',
                            year: 'Junior'
                        },
                        {
                            number: 18,
                            name: 'Eric Bultman',
                            year: 'Senior'
                        },
                        {
                            number: 21,
                            name: 'Jarred Elliott',
                            year: 'Sophomore'
                        },
                        {
                            number: 23,
                            name: 'Tyler DeNooyer',
                            year: 'Grad'
                        },
                        {
                            number: 27,
                            name: 'Wilson Wang',
                            year: 'Junior'
                        },
                        {
                            number: 29,
                            name: 'Ben Foster',
                            year: 'Sophomore'
                        },
                        {
                            number: 35,
                            name: 'Marty Markenson*',
                            year: 'Senior'
                        },
                        {
                            number: 38,
                            name: 'Grant Hallan',
                            year: 'Senior'
                        },
                        {
                            number: 46,
                            name: 'Kevin Birchok',
                            year: 'Senior'
                        },
                        {
                            number: 69,
                            name: 'Jacob Komenda',
                            year: 'Freshman'
                        },
                        {
                            number: 75,
                            name: 'Eric Badger',
                            year: 'Grad'
                        },
                        {
                            number: 81,
                            name: 'Chris Buchta',
                            year: 'Sophomore'
                        },
                        {
                            number: 97,
                            name: 'Kevin Lin',
                            year: 'Freshman'
                        },
                        {
                            number: undefined,
                            name: 'Matt Stupca',
                            year: 'Coach'
                        }
                    ]
                },
                {
                    year: 2014,
                    imagePath: './assets/team-photo-2014.jpg',
                    players: [
                        {
                            number: 0,
                            name: 'Max Willis',
                            year: 'Junior'
                        },
                        {
                            number: 1,
                            name: 'Nick Prozorovsky',
                            year: 'Sophomore'
                        },
                        {
                            number: 3,
                            name: 'Sean Hill',
                            year: 'Senior'
                        },
                        {
                            number: 4,
                            name: 'Michael Pohling',
                            year: 'Junior'
                        },
                        {
                            number: 6,
                            name: 'Nick Oo',
                            year: 'Junior'
                        },
                        {
                            number: 8,
                            name: 'Johnny Saniat',
                            year: 'Sophomore'
                        },
                        {
                            number: 10,
                            name: 'Joe Moyles',
                            year: 'Junior'
                        },
                        {
                            number: 11,
                            name: 'Jon Mckoy',
                            year: 'Junior'
                        },
                        {
                            number: 12,
                            name: 'Kan Zi Yang',
                            year: 'Sophomore'
                        },
                        {
                            number: 17,
                            name: 'Prayag Patel',
                            year: 'Sophomore'
                        },
                        {
                            number: 18,
                            name: 'Eric Bultman*',
                            year: 'Junior'
                        },
                        {
                            number: 21,
                            name: 'Chris Buchta',
                            year: 'Freshman'
                        },
                        {
                            number: 22,
                            name: 'Brian Rathunde',
                            year: 'Senior'
                        },
                        {
                            number: 23,
                            name: 'Greg Hill',
                            year: 'Senior'
                        },
                        {
                            number: 24,
                            name: 'Jim Riddle',
                            year: 'Senior'
                        },
                        {
                            number: 27,
                            name: 'Wilson Wang',
                            year: 'Sophomore'
                        },
                        {
                            number: 30,
                            name: 'Steve Brand',
                            year: 'Grad'
                        },
                        {
                            number: 35,
                            name: 'Marty Markenson*',
                            year: 'Junior'
                        },
                        {
                            number: 38,
                            name: 'Grant Hallan',
                            year: 'Junior'
                        },
                        {
                            number: 39,
                            name: 'Ross Tuttle',
                            year: 'Senior'
                        },
                        {
                            number: 44,
                            name: 'Michael Cosmos',
                            year: 'Sophomore'
                        },
                        {
                            number: 46,
                            name: 'Kevin Birchok',
                            year: 'Junior'
                        },
                        {
                            number: 64,
                            name: 'Neal Phelps*',
                            year: 'Grad'
                        },
                        {
                            number: 69,
                            name: 'Tyler DeNooyer',
                            year: 'Grad'
                        },
                        {
                            number: 81,
                            name: 'Arthur Ding',
                            year: 'Sophomore'
                        },
                        {
                            number: undefined,
                            name: 'Walden Nelson',
                            year: 'Coach'
                        }
                    ]
                },
                {
                    year: 2013,
                    imagePath: './assets/team-photo-2013.jpg',
                    players: [
                        {
                            number: 1,
                            name: 'Nick Prozorovsky',
                            year: 'Freshman'
                        },
                        {
                            number: 3,
                            name: 'Sean Hill',
                            year: 'Junior'
                        },
                        {
                            number: 4,
                            name: 'Rob Dreier',
                            year: 'Senior'
                        },
                        {
                            number: 6,
                            name: 'Brad Bolliger',
                            year: 'Senior'
                        },
                        {
                            number: 9,
                            name: 'Preston Goulson',
                            year: 'Senior'
                        },
                        {
                            number: 11,
                            name: 'Jon Mckoy',
                            year: 'Sophomore'
                        },
                        {
                            number: 12,
                            name: 'Derek Yan',
                            year: 'Freshman'
                        },
                        {
                            number: 18,
                            name: 'Eric Bultman',
                            year: 'Sophomore'
                        },
                        {
                            number: 20,
                            name: 'Tyler Anderson',
                            year: 'Senior'
                        },
                        {
                            number: 22,
                            name: 'Brian Rathunde',
                            year: 'Junior'
                        },
                        {
                            number: 23,
                            name: 'Ryan Smith*',
                            year: 'Grad'
                        },
                        {
                            number: 27,
                            name: 'Wilson Wang',
                            year: 'Freshman'
                        },
                        {
                            number: 30,
                            name: 'Colin Reid*',
                            year: 'Senior'
                        },
                        {
                            number: 34,
                            name: 'Michael Pohling',
                            year: 'Sophomore'
                        },
                        {
                            number: 35,
                            name: 'Marty Markenson',
                            year: 'Sophomore'
                        },
                        {
                            number: 39,
                            name: 'Ross Tuttle',
                            year: 'Junior'
                        },
                        {
                            number: 44,
                            name: 'Nate Gibbons*',
                            year: 'Senior'
                        },
                        {
                            number: 45,
                            name: 'Greg Hill',
                            year: 'Junior'
                        },
                        {
                            number: 64,
                            name: 'Neal Phelps*',
                            year: 'Grad'
                        },
                        {
                            number: 65,
                            name: 'Michael Cosmos',
                            year: 'Freshman'
                        },
                        {
                            number: 87,
                            name: 'Adam Wright',
                            year: 'Senior'
                        },
                        {
                            number: 99,
                            name: 'Johnny Saniat',
                            year: 'Junior'
                        },
                        {
                            number: undefined,
                            name: 'Walden Nelson',
                            year: 'Coach'
                        }
                    ]
                },
                {
                    year: 2011,
                    imagePath: './assets/team-photo-2011.jpg',
                    players: [
                        {
                            number: 2,
                            name: 'Joe Sidrys',
                            year: 'Senior'
                        },
                        {
                            number: 5,
                            name: 'Jack Krieger',
                            year: 'Junior'
                        },
                        {
                            number: 8,
                            name: 'Kyle McKinley',
                            year: 'Grad'
                        },
                        {
                            number: 13,
                            name: 'Tom Rudwick',
                            year: 'Senior'
                        },
                        {
                            number: 14,
                            name: 'Austin Lien',
                            year: 'Senior'
                        },
                        {
                            number: 15,
                            name: 'Alex Komisarz',
                            year: 'Senior'
                        },
                        {
                            number: 16,
                            name: 'Andy Kilinskis',
                            year: 'Junior'
                        },
                        {
                            number: 18,
                            name: 'Kurt Zoellick',
                            year: 'Grad'
                        },
                        {
                            number: 22,
                            name: 'Brian Chrysler',
                            year: 'Grad'
                        },
                        {
                            number: 23,
                            name: 'Ryan Smith',
                            year: 'Grad'
                        },
                        {
                            number: 25,
                            name: 'Mark Hirschman',
                            year: 'Senior'
                        },
                        {
                            number: 27,
                            name: 'Chris Hidaka',
                            year: 'Grad'
                        },
                        {
                            number: 29,
                            name: 'Matt Kurley',
                            year: 'Grad'
                        },
                        {
                            number: 32,
                            name: 'Chris Kvistad',
                            year: 'Junior'
                        },
                        {
                            number: 33,
                            name: 'Don McDonald',
                            year: 'Grad'
                        },
                        {
                            number: 36,
                            name: 'Brian Pierce',
                            year: 'Junior'
                        },
                        {
                            number: 47,
                            name: 'Jon Hatcher',
                            year: 'Senior'
                        },
                        {
                            number: 61,
                            name: 'Brian Phelan',
                            year: 'Grad'
                        },
                        {
                            number: 64,
                            name: 'Neal Phelps*',
                            year: 'Senior'
                        },
                        {
                            number: 80,
                            name: 'Jon Ogrodnik',
                            year: 'Grad'
                        },
                        {
                            number: 81,
                            name: 'Suleyman Ahmad',
                            year: 'Senior'
                        },
                        {
                            number: 84,
                            name: "Charlie O'Brien",
                            year: 'Grad'
                        },
                        {
                            number: 87,
                            name: 'Adam Wright',
                            year: 'Junior'
                        },
                        {
                            number: 88,
                            name: 'Kevin Bruns',
                            year: 'Junior'
                        },
                        {
                            number: 90,
                            name: 'Zachary Frantz',
                            year: 'Junior'
                        },
                        {
                            number: undefined,
                            name: 'Walden Nelson',
                            year: 'Coach'
                        }
                    ]
                }
            ];

            /***/
        },
        /* 128 */
        /***/ function(module, exports) {
            module.exports =
                '<!--Header-->\n<h1 class="ui header">Roster</h1>\n<!--Menu-->\n<div class="ui secondary pointing menu">\n    <a class="item" routerLink="/roster/2011" [ngClass]="{\'active\': year === 2011}">2011</a>\n    <a class="item" routerLink="/roster/2013" [ngClass]="{\'active\': year === 2013}">2013</a>\n    <a class="item" routerLink="/roster/2014" [ngClass]="{\'active\': year === 2014}">2014</a>\n    <a class="item" routerLink="/roster/2015" [ngClass]="{\'active\': year === 2015}">2015</a>\n    <a class="item" routerLink="/roster/2016" [ngClass]="{\'active\': year === 2016}">2016</a>\n    <a class="item" routerLink="/roster/2017" [ngClass]="{\'active\': year === 2017}">2017</a>\n    <a class="item" routerLink="/roster/2018" [ngClass]="{\'active\': year === 2018}">2018</a>\n    <a class="item" routerLink="/roster/2019" [ngClass]="{\'active\': year === 2019}">2019</a>\n</div>\n<!--Table-->\n<ng-container *ngFor="let rosterYear of rosterData">\n    <ng-container *ngIf="rosterYear.year === year">\n        <img src="{{rosterYear.imagePath}}"/>\n        <table class="ui celled table">\n            <thead>\n                <tr>\n                    <th>#</th>\n                    <th>Name</th>\n                    <th>Year</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr *ngFor="let player of rosterYear.players">\n                    <td>{{player.number}}</td>\n                    <td>{{player.name}}</td>\n                    <td>{{player.year}}</td>\n                </tr>\n            </tbody>\n        </table>\n        <p>(*) indicates captain for that year</p>\n    </ng-container>\n</ng-container>\n';

            /***/
        },
        /* 129 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(130);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 130 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([module.id, 'img{width:75%;border:1px solid #00004d;border-radius:.28571429em}p{text-align:left;text-indent:0}', '']);

            // exports

            /***/
        },
        /* 131 */
        /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ (function($) {
                'use strict';
                var __decorate =
                    (this && this.__decorate) ||
                    function(decorators, target, key, desc) {
                        var c = arguments.length,
                            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                            d;
                        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
                            r = Reflect.decorate(decorators, target, key, desc);
                        else
                            for (var i = decorators.length - 1; i >= 0; i--)
                                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                        return c > 3 && r && Object.defineProperty(target, key, r), r;
                    };
                var __metadata =
                    (this && this.__metadata) ||
                    function(k, v) {
                        if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                    };
                var core_1 = __webpack_require__(8);
                var google_spreadsheet_service_1 = __webpack_require__(45);
                var gtm_util_1 = __webpack_require__(46);
                var AbsentComponent = (function() {
                    // Constructor with our http service injected
                    function AbsentComponent(spreadsheetService) {
                        this.spreadsheetService = spreadsheetService;
                        // API url for our personal server
                        this.googleSheetsApiUrl =
                            'https://nick-proz-node-server.herokuapp.com/sheets/11ijrHoysiIwsFfEggbSNM9Y8VvzU65jeuhQ3vkV5FGw/sheetIndex/1/rows/';
                        // API url for our backup server (sheetsu API)
                        // private googleSheetsBackupApiUrl = 'https://sheetsu.com/apis/v1.0/7a030ae60b7d';
                        this.googleSheetsBackupApiUrl = '';
                        // Error messages
                        this.validationErrors = 'Please do not leave any required fields blank.';
                        this.submissionError = 'Could not submit the form  due to a server error. Please try again soon or contact the web admins.';
                        // Boolean indicating if our form is in the process of submitting (to show our loading icon)
                        this.formIsSubmitting = false;
                        // Boolean indicating if our form was successfully submitted (to show our success message)
                        this.submitSuccess = false;
                    }
                    AbsentComponent.prototype.ngAfterViewInit = function() {
                        $(this.monthDropdown.nativeElement).dropdown();
                    };
                    AbsentComponent.prototype.handleSubmit = function(event, monthInput) {
                        event.preventDefault();
                        this.month = monthInput;
                        this.submitSuccess = false;
                        if (!this.formIsValid()) {
                            this.formErrors = this.validationErrors;
                        } else {
                            this.formIsSubmitting = true;
                            this.formErrors = null;
                            var date = new Date();
                            var data = {
                                Timestamp: date.toLocaleString(),
                                'First Name': this.firstName,
                                'Last Name': this.lastName,
                                Time: this.time,
                                Date: this.month + '/' + this.day,
                                Reason: this.reason
                            };
                            this.submitAbsentForm(data);
                        }
                    };
                    /**
                     * Submits our form to the spreadsheet by calling our service method.
                     * On success, we show our confirmation modal and reset our rsvp modal.
                     * On failure, we hide our submitting dialog and show our submission error to the user.
                     *
                     * @param data - data to submit to our spreadsheet
                     */
                    AbsentComponent.prototype.submitAbsentForm = function(data) {
                        var _this = this;
                        // Push our form data to the data layer for Google Tag Manager to consume
                        gtm_util_1.GtmUtil.pushObjectToDataLayer(AbsentComponent.gtmEventName, AbsentComponent.gtmVariableName, data);
                        this.spreadsheetService
                            .postRowToSpreadsheet(this.googleSheetsApiUrl, this.googleSheetsBackupApiUrl, data)
                            .then(function() {
                                _this.resetForm();
                                _this.submitSuccess = true;
                            })
                            .catch(function() {
                                _this.formIsSubmitting = false;
                                _this.formErrors = _this.submissionError;
                            });
                    };
                    /**
                     * Clears our input fields, errors, and resets our form is submitting flag.
                     */
                    AbsentComponent.prototype.resetForm = function() {
                        this.firstName = null;
                        this.lastName = null;
                        this.reason = null;
                        this.time = null;
                        this.day = null;
                        this.month = null;
                        this.formErrors = null;
                        this.formIsSubmitting = false;
                    };
                    /**
                     * Front-end validation for our form.
                     * Our form is valid only if all fields are populated.
                     *
                     * @returns {boolean} - true if the form is valid, false otherwise
                     */
                    AbsentComponent.prototype.formIsValid = function() {
                        return (
                            this.firstName != null &&
                            this.firstName != '' &&
                            this.lastName != null &&
                            this.lastName != '' &&
                            this.reason != null &&
                            this.reason != '' &&
                            this.time != null &&
                            this.time != '' &&
                            this.month != null &&
                            this.month > 0 &&
                            this.day != null
                        );
                    };
                    return AbsentComponent;
                })();
                // GTM variables
                AbsentComponent.gtmEventName = 'Absent Form Submit';
                AbsentComponent.gtmVariableName = 'absent-form';
                __decorate(
                    [
                        core_1.ViewChild('monthDropdown'),
                        __metadata(
                            'design:type',
                            (typeof (_a = typeof core_1.ElementRef !== 'undefined' && core_1.ElementRef) === 'function' && _a) || Object
                        )
                    ],
                    AbsentComponent.prototype,
                    'monthDropdown',
                    void 0
                );
                AbsentComponent = __decorate(
                    [
                        core_1.Component({
                            selector: 'absent',
                            template: __webpack_require__(133),
                            styles: [__webpack_require__(134)]
                        }),
                        __metadata('design:paramtypes', [
                            (typeof (_b =
                                typeof google_spreadsheet_service_1.SpreadsheetService !== 'undefined' &&
                                google_spreadsheet_service_1.SpreadsheetService) === 'function' &&
                                _b) ||
                                Object
                        ])
                    ],
                    AbsentComponent
                );
                exports.AbsentComponent = AbsentComponent;
                var _a, _b;

                /* WEBPACK VAR INJECTION */
            }.call(exports, __webpack_require__(132)));

            /***/
        },
        ,
        /* 132 */ /* 133 */
        /***/ function(module, exports) {
            module.exports =
                '<!--Header-->\n<h1 class="ui header">Practice Absence Form</h1>\n<!--Submitting Loader-->\n<div *ngIf="formIsSubmitting" class="ui active inverted dimmer"><div class="ui text loader">Submitting</div></div>\n<!--Form-->\n<form class="ui form">\n    <div class="two fields">\n        <div class="field">\n            <label>First Name <span class="required">*</span></label>\n            <input [(ngModel)]="firstName" type="text" name="first-name" placeholder="First Name">\n        </div>\n        <div class="field">\n            <label>Last Name <span class="required">*</span></label>\n            <input [(ngModel)]="lastName" type="text" name="last-name" placeholder="Last Name">\n        </div>\n    </div>\n    <div class="field">\n        <label>Reason for missing or being late to practice <span class="required">*</span></label>\n        <input [(ngModel)]="reason" type="text" name="reason" placeholder="Better be good...">\n    </div>\n    <div class="field">\n        <label>From what time to what time is your conflict? <span class="required">*</span></label>\n        <input [(ngModel)]="time" type="text" name="time" placeholder="Time">\n    </div>\n    <div class="field">\n        <div class="two fields">\n            <div class="field">\n                <label>Practice date <span class="required">*</span></label>\n                <input [(ngModel)]="day" maxlength="2" type="text" name="day" placeholder="Day (0-31)">\n            </div>\n            <div class="field">\n                <label>&nbsp;</label>\n                <div #monthDropdown class="ui search selection dropdown">\n                    <input #monthInput type="hidden" name="month">\n                    <i class="dropdown icon"></i>\n                    <div class="default text">Month</div>\n                    <div class="menu">\n                        <div class="item" data-value="01">January</div>\n                        <div class="item" data-value="02">February</div>\n                        <div class="item" data-value="03">March</div>\n                        <div class="item" data-value="04">April</div>\n                        <div class="item" data-value="05">May</div>\n                        <div class="item" data-value="06">June</div>\n                        <div class="item" data-value="07">July</div>\n                        <div class="item" data-value="08">August</div>\n                        <div class="item" data-value="09">September</div>\n                        <div class="item" data-value="10">October</div>\n                        <div class="item" data-value="11">November</div>\n                        <div class="item" data-value="12">December</div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n    <button (click)="handleSubmit($event, monthInput.value)" class="ui button submit-button" type="submit">Submit</button>\n    <!--Error/Success Messages-->\n    <div class="ui error message" *ngIf="formErrors">\n        <p>{{formErrors}}</p>\n    </div>\n    <div class="ui success message" *ngIf="submitSuccess">\n        <div class="header">Form Submitted</div>\n        <p>The form was successfully submitted. Stop missing practice.</p>\n    </div>\n</form>\n';

            /***/
        },
        /* 134 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(135);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 135 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([
                module.id,
                '.submit-button{margin-bottom:45px}label{text-align:left}.ui.form{width:80%;margin:0 auto}.ui.form .ui.error.message,.ui.form .ui.success.message{display:block}.ui.form .ui.error.message p,.ui.form .ui.success.message p{text-align:center}.ui.search.selection.dropdown.active.visible,.ui.selection.active.dropdown .menu,.ui.selection.active.dropdown:hover{border-color:#ff6226}.ui.dropdown{min-width:inherit}',
                ''
            ]);

            // exports

            /***/
        },
        /* 136 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var home_component_1 = __webpack_require__(34);
            var about_component_1 = __webpack_require__(40);
            var prospective_players_component_1 = __webpack_require__(44);
            var contact_component_1 = __webpack_require__(50);
            var practice_component_1 = __webpack_require__(86);
            var tournaments_component_1 = __webpack_require__(91);
            var roster_component_1 = __webpack_require__(126);
            var absent_component_1 = __webpack_require__(131);
            var team_history_component_1 = __webpack_require__(137);
            var awards_component_1 = __webpack_require__(142);
            var results_component_1 = __webpack_require__(147);
            exports.ROUTES = [
                { path: '', redirectTo: 'home', pathMatch: 'full' },
                { path: 'home', component: home_component_1.HomeComponent },
                { path: 'practice', component: practice_component_1.PracticeComponent },
                { path: 'absent', component: absent_component_1.AbsentComponent },
                { path: 'contact', component: contact_component_1.ContactComponent },
                { path: 'home', component: home_component_1.HomeComponent },
                { path: 'about', component: about_component_1.AboutComponent },
                { path: 'prospects', component: prospective_players_component_1.ProspectivePlayersComponent },
                { path: 'tournaments/:year', component: tournaments_component_1.TournamentsComponent },
                { path: 'roster/:year', component: roster_component_1.RosterComponent },
                { path: 'history/:year', component: team_history_component_1.TeamHistoryComponent },
                { path: 'awards', component: awards_component_1.AwardsComponent },
                { path: 'results', component: results_component_1.ResultsComponent },
                { path: '**', component: home_component_1.HomeComponent }
            ];

            /***/
        },
        /* 137 */
        /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ (function($) {
                'use strict';
                var __decorate =
                    (this && this.__decorate) ||
                    function(decorators, target, key, desc) {
                        var c = arguments.length,
                            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                            d;
                        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
                            r = Reflect.decorate(decorators, target, key, desc);
                        else
                            for (var i = decorators.length - 1; i >= 0; i--)
                                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                        return c > 3 && r && Object.defineProperty(target, key, r), r;
                    };
                var __metadata =
                    (this && this.__metadata) ||
                    function(k, v) {
                        if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                    };
                var core_1 = __webpack_require__(8);
                var history_year_data_1 = __webpack_require__(138);
                var router_1 = __webpack_require__(92);
                var TeamHistoryComponent = (function() {
                    // Inject the ActivatedRoute into our component
                    function TeamHistoryComponent(route) {
                        this.route = route;
                        // Results data to inject into our template
                        this.historyData = history_year_data_1.HISTORY_DATA;
                    }
                    TeamHistoryComponent.prototype.ngAfterViewInit = function() {
                        $(this.firstDropdown.nativeElement).dropdown({});
                        $(this.secondDropdown.nativeElement).dropdown({});
                        $(this.thirdDropdown.nativeElement).dropdown({});
                    };
                    /**
                     * Subscribe to our route parameters (tournament year).
                     */
                    TeamHistoryComponent.prototype.ngOnInit = function() {
                        var _this = this;
                        this.routeParamsSubscription = this.route.params.subscribe(function(params) {
                            // (+) converts string 'year' to a number
                            _this.year = +params['year'];
                        });
                    };
                    /**
                     * Unsubscribe to our route parameters (tournament year).
                     */
                    TeamHistoryComponent.prototype.ngOnDestroy = function() {
                        this.routeParamsSubscription.unsubscribe();
                    };
                    return TeamHistoryComponent;
                })();
                __decorate(
                    [
                        core_1.ViewChild('1994dropdown'),
                        __metadata(
                            'design:type',
                            (typeof (_a = typeof core_1.ElementRef !== 'undefined' && core_1.ElementRef) === 'function' && _a) || Object
                        )
                    ],
                    TeamHistoryComponent.prototype,
                    'firstDropdown',
                    void 0
                );
                __decorate(
                    [
                        core_1.ViewChild('2000dropdown'),
                        __metadata(
                            'design:type',
                            (typeof (_b = typeof core_1.ElementRef !== 'undefined' && core_1.ElementRef) === 'function' && _b) || Object
                        )
                    ],
                    TeamHistoryComponent.prototype,
                    'secondDropdown',
                    void 0
                );
                __decorate(
                    [
                        core_1.ViewChild('2010dropdown'),
                        __metadata(
                            'design:type',
                            (typeof (_c = typeof core_1.ElementRef !== 'undefined' && core_1.ElementRef) === 'function' && _c) || Object
                        )
                    ],
                    TeamHistoryComponent.prototype,
                    'thirdDropdown',
                    void 0
                );
                TeamHistoryComponent = __decorate(
                    [
                        core_1.Component({
                            selector: 'team-history',
                            template: __webpack_require__(139),
                            styles: [__webpack_require__(140)]
                        }),
                        __metadata('design:paramtypes', [
                            (typeof (_d = typeof router_1.ActivatedRoute !== 'undefined' && router_1.ActivatedRoute) === 'function' && _d) || Object
                        ])
                    ],
                    TeamHistoryComponent
                );
                exports.TeamHistoryComponent = TeamHistoryComponent;
                var _a, _b, _c, _d;

                /* WEBPACK VAR INJECTION */
            }.call(exports, __webpack_require__(132)));

            /***/
        },
        /* 138 */
        /***/ function(module, exports) {
            'use strict';
            exports.HISTORY_DATA = [
                {
                    year: 2017,
                    imagePath: './assets/team-photo-2017.jpg',
                    summaryMarkup: '\n            <p></p>\n        '
                },
                {
                    year: 2016,
                    imagePath: './assets/team-photo-2016.jpg',
                    summaryMarkup:
                        '\n            <p>Illinois Ultimate came into the 2016 season with a taste of success and big shoes to fill. Returning captain Nick Prozorovsky and new captains Prayag Patel and Chris Buchta were tasked with the difficult prospect of replacing the 12 graduating players as well as coach Matt Stupca. Boomland coach Erik Huemiller and recent alum Matt West were able to fill the leadership void as the team looked to reload for another run at Nationals.</p>\n            <p>The tryouts for the team were very competitive, with the biggest incoming class in recent memory. The final roster included 7 rookies, 1 grad student, 5 former Boomland players, and 12 returners. The newest iteration of Illinois Ultimate tested themselves at Missouri Loves Company, but returned with shoulder injuries to seniors Nick Prozorovsky and Alex Guy that would hamper them for the rest of the season.</p>\n            <p>This spring season had the team heading to Florida, South Carolina, and Missouri in search of elite competition.</p>\n            <p>Mid February had the team flying south to compete at Warm Up. Unfortunately, the week prior had grad student Cody Gray breaking his hand in Irwin and senior Wilson Wang pulling his hamstring in the Armory, both big handler losses. On Saturday, the team started with 10-13 and 11-13 losses to Texas and Florida State. The third game of the day was against perennial powerhouse Pittsburgh. Illinois came out sloppy and was pressured into making many errors, resulting in a 1-7 score at half and an embarrassing 2-12 loss, finishing 0-4 on the day after another loss to BYU. Saturday started off better with a 13-5 win over host South Florida, but was followed by big losses to Virginia Tech and Auburn. Illinois finished the tournament 2-7, with a universe loss to in region rival Northwestern and only wins coming against South Florida.</p>\n            <p>With most of the team finally healthy, the team made the trip to Easterns for the second tournament of the season. The first game of the tournament was a rematch against Pittsburgh. This time, Illinois was prepared for the intensity and was able to make it a closer game, but still lost 12-15. Another rematch against Virginia Tech ended similarly, losing 11-14, and the team ended Saturday 0-4, with a 10-15 loss to UNC Darkside and an 11-13 loss to regional rival Michigan. On a wet, cold, and windy Sunday, Illinois was not able to come out with any fire and lost badly to James Madison and Connecticut, going 0-6 on the weekend.</p>\n            <p>The final regular season tournament of the year was Huck Finn and the boys from Illinois looked to bounce back from a so far unsuccessful regular season. With a mindset of improving for the series the Illini came out with a 7-0 lead at half on Indiana and closed it out with an 11-4 win. Dayton was the next game, which was a 13-4 win for the Illini which meant that they would play Maryland for the pool. Ankle injuries to Prayag Patel and Ben Foster meant that the O line was playing without two key contributors, but the team was able to tough out a 14-11 win, setting up a crossover game against Illinois State. In a very windy game, Illinois triumphed over their in state competitors in a 10-6 victory, securing a quarterfinals berth. The team closed out the tournament with losses to Arkansas and Purdue, and prepared themselves for Conferences.</p>\n            <p>Once again, Rantoul was host to Conferences, but this time there could be no complaints about the weather. Illinois started out strong with comfortable wins over the rest of the pool, including an 11-4 victory over UChicago. Winning the pool lined up a semifinal game against Illinois State, which was won handily 13-7 and set up a classic Illinois - Northwestern rematch. Unfortunately, the team struggled to find the endzone and for the second year in a row, lost to Northwestern at Conferences. In the 2nd place match against UChicago, Illinois was unable to find a groove and lost 9-11. With Regionals in two weeks and only one bid for the region, Illinois had a lot of work to do.</p>\n            <p>In a change of pace, Regionals was not hosted in Rockford, but in Fair Oaks, Indiana. The conditions were terrible, low temperatures coupled with heavy wind and rain meant that it would be difficult getting a good grip. In the first game against Kentucky, both O and D line were able to perform well, giving up no breaks and handing out a few of their own and finishing with a score of 12-6. The trend continued against Indiana, with Illinois winning 13-6. Next up was Notre Dame, a rematch of last year\u2019s finals, winner takes the pool and quarterfinals berth. A completely upwind/downwind game found the d line with opportunities to break, but never able to finish the job. With neither team being broken, Notre Dame won the flip and the game, 9-10. Illinois finished up the day with a 13-5 win over Michigan State to set up a quarterfinals matchup against Northwestern.</p>\n            <p>Conditions on Sunday were better and with a little support from Walden Nelson, the team was ready to avenge their recent losses. Illinois started on D and Northwestern came out with an break early in the game, but the team fought back and breaks were traded to have it be on serve at half. The second half commenced with more of a cleaner game, with both teams trading offensive holds. A chance at a break due to a Nick Pro sky was called back on a controversial observer ruling and the game reached softcap with the score 10-11. Chris Buchta tied up the score with a huck from Kevin Lin and the d line went out to try and break with the season on the line. After a turn from Northwestern, Illinois worked the disc down the field and rookie Jacob Cuthbert took a timeout outside of the endzone. One endzone set later, Prayag found Cuthbert for the win, sending Illinois to the semifinals.</p>\n            <p>Due to the loss in pool play, Illinois\u2019s matchup in the semifinals was Michigan. Despite the tough game before, Illinois had to come out hot if they wanted to win the game. Michigan came out of the gate fast, scoring on a huck. Illinois followed suit, and the two teams traded offensive holds until Michigan broke for 3-5. As the game went on, the defensive pressure from Michigan intensified and Illinois\u2019 o line was not able to match the goals that Michigan\u2019s o line was putting out. Coming out of half at 5-8, Illinois turned and was broken again. A late injury to Prayag pushed the hope of a comeback a little further out of reach and a senior d line was unable to keep Michigan from seizing the victory 10-15. Michigan went on to defeat Notre Dame 15-9 to take the bid to Nationals. Illinois finished the season with a 11-10 victory over Purdue for 3rd in the region.</p>\n            <p>Captain Nick Prozorovsky and John Saniat received 1st team All-Region honors and Captain Prayag Patel received 2nd team All-Region. Ben Sabourin and Jacob Cuthbert were voted All-Freshmen for the region, with Ben winning Freshman of the Year.</p>\n        '
                },
                {
                    year: 2015,
                    imagePath: './assets/team-photo-2015.jpg',
                    summaryMarkup:
                        "\n            <p>After the worst regionals performance since 2006, Illinois entered the 2015 season with a new looking team and a new mindset. Major losses included long time coach Walden Nelson, as well as O-line stars Neal Phelps, Brian Rathunde, and Sean Hill. Marty Markenson returned as captain and was joined by first-timers Johnny Saniat and Nick Prozorovsky.</p>\n            <p>The major change to the team came in the form of returning coach, Matt Stupca. Matt coached the team from 2006-2009 and brought them to Nationals twice, finishing in 5th place in 2008. The experienced coach gave the team the necessary leadership needed to rebuild the club for a possible Nationals run again.</p>\n            <p>As always, the fall tryouts were competitive and exciting, with another strong rookie class and many B-teamers and outsiders joining the scene. When it was all said and done, the final roster consisted of 23 people. The roster included 2 rookies, 5 B-teamers, 15 returners, and 1 transfer student. New additions included Valparaiso stud, Matt West, basketball crossover Jarred Elliot, lovable spirit leader Eric Badger, and rookies Kevin Lin and Jacob Komenda.</p>\n            <p>Come end of fall, Illinois was re-armed and ready for another run for Nationals in the spring season.</p>\n            <p>The spring season schedule was perhaps one of Illinois' most busy. The team was scheduled to attend 3 of the highest level tournaments around the country, including tournaments in Texas, Florida, and South Carolina.</p>\n            <p>When February came around, it was time to head south to Tampa for the first spring tournament, Florida Warm-Up. For the first time, the team traveled by air to a tournament. Warm-Up, a three day tournament, proved to be a useful lesson to the team. On day one, the Illini went 1-3 with only one win in a night game vs. Cornell. It was a disappointing performance, but day two spelt different stories for Illinois. Saturday morning, The Illini would play the revered Nationals team UCF in a game that was recorded by Ultiworld. The Illini were no doubt underdogs, but fought hard to take a lead on the Dogs of War. Major plays included a Callahan by handler Prayag Patel and a huck break-score by Max Willis to rookie Jacob Komenda. The Dogs of War fought, but the Illini pulled through, winning the game 13-9 and claiming one of the biggest upsets of the tournament. Illinois would cruise to two more wins that day, finishing 3-0 for Saturday. With emotions high but legs tired, the Illini finished off the long weekend with a tough loss against Georgetown and a win against Wisconsin-Milwaukee on Sunday to end Florida Warm up. They finished 5-4 on the weekend.</p>\n            <p>The next big tournament was the famous Centex invite in Austin, Texas. The team was seeded 9th overall out of 20 after their impressive win against Central Florida back at Warm-Up. With high expectations, the Illini would jump right into it, playing one of the best teams of 2015, North-Carolina Wilmington. The first point of the game would prove to be somewhat of a theme for the Illini that weekend, as top cutter Nick Prozorovsky would go down with a knee injury. The Illini could not upset the big dog this time though, as Wilmington won comfortably at 11-3.</p>\n            <p>As the day went on, the injuries continued. Nearly half of the Illini squad would go down that day. The pain also showed in the scores, as the Illini would lose to Texas 12-5 and fall to two lower-seeded teams Arkansas and Iowa. They finished 0-4 on Saturday. </p>\n            <p>In the loser's bracket on Sunday, Illinois would go 3-0 with wins over California, Iowa State, and Wisconsin-Milwaukee. </p>\n            <p>The finale of the spring tournaments was the very competitive Easterns in North Myrtle Beach, South Carolina, which a year earlier was won by Great Lakes region rival Michigan. The Illini went into the tournament with a bit of a different look, as Boomland coach Erik Huemiller would fill in for coach Matt Stupca as well as numerous injured and absent players returning to the squad. They were seeded as the 20 seed, with nowhere to go but up.</p>\n            <p>In a highly competitive pool, the Illini would start off against the 2012-2013 national champions, Pittsburgh. Pitt had won every tournament up to this point. The Illini took advantage of Pitts many sloppy mistakes, but could not come away with another upset, falling 15-10. The troubles continued, with losses to Carleton College, UMass, and Georgia. This put the Illini's first day record at a troubling 1-12 on the season.</p>\n            <p>Sunday would prove to be an important day for the Illini. Despite the troubles on Day 1s, the Illini had played well the second day of tournaments all season, with a 6-0 record. As the last ranked seed at the tournament, they would fight to break seed against NC State, Colorado State, and 10-seeded Auburn.</p>\n            <p>With many different position changes, the Illini came out with a new fire, going 3-0 again on Sunday and taking out the competition handily. With this, the Illini spring regular season would come to an end. They would finish with a 10-12 record, with only one of those wins coming on day one of a tournament. This issue would be in the back of everyone's head going into the postseason.</p>\n            <p>Sectionals, as always, was held in Rantoul, IL. The Illini came in as the favorite, with Northwestern and UChicago sitting close behind. The Illini would rough out wins against Eastern Illinois and Southern Illinois before taking on UChicago, who had ended their 2014 season dramatically last year at regionals.</p>\n            <p>The game was up and down but eventually ended in another crushing loss for the Illini on universe point. This sent the Illini into Sunday with a first round match against other rival Northwestern, who the team hadn't played since last year. The game was close early on, but the upstate rivals pulled ahead and eventually took the game 15-9. It was the second very alarming loss in a row for the Illini, and for the first time in years, would eliminate them from winning sectionals.</p>\n            <p>Despite this news, the Illini took down Illinois State in the next game to ensure another game against UChicago for second place in the section. In the game that had a game to go atmosphere, the Illini finally were able to hit on all cylinders, blowing out their recent rivals 15-6 and taking second place at sectionals. It would prove to be somewhat of a weight lifted off everyone's back going into regionals, but there was still much work to be done.</p>\n            <p>Regionals was back at Rockford, a place of many emotions for most Illinois players. Illinois came in as the 3 seed; in a pool with Purdue, Grand Valley, and again, UChicago. The recent ups and downs of the Illinois season, as well as inspiring messages by coach Stupca and some of the players, had the team focused as ever.</p>\n            <p>The first game against Purdue saw the O-Line in cruise control with a level of consistency not seen before in the season. With a few breaks mixed in, the Illini took the first game of the day 11-8. With an easier 13-6 win against Grand Valley State, Illinois would play their final game of the day against UChicago. The game was played just a few fields away from where Chicago ended Illinois season one year prior. Emotions ran high again, but the Illini finally put UChicago to rest in an 11-5 victory. It was a big statement for Illinois and sent them into Sunday's championship bracket riding high.</p>\n            <p>Illinois went into Sunday still not having been broken yet, a true testament to their O-line's improved focus. The first game of the day was against last year's second Nationals team from the region, Eastern Michigan. The game was tight throughout with both O-lines trading, but the Illini pulled through to win the game 15-12. The game saw the Illini let up one break, which was the first break allowed all weekend.</p>\n            <p>This sent the team into semis against their athletic, Big 10 counterparts, Indiana. Indiana, for the most part, was completely unfamiliar to the Illini's play style going into the matchup. With the 'game to go' in the back of everyone's heads, the Illini poured on the points and won 15-5, claiming their biggest victory of the tournament. The D-Line shined this game, giving the O-line a much needed rest heading into the biggest game of the season.</p>\n            <p>The 'game to go' saw the Illini face up against a team they never would have expected. In surprising fashion, the scrappy and energized Notre Dame would stand as their last test of the season. The other side of the bracket would prove to be one to remember, as Notre Dame had beaten rival Michigan after Michigan had beaten Northwestern on double game point the game before. It was win or go home for the Illini.</p>\n            <p>The game was a spectacle, with many of the program's alumni and half the region watching. And with expectations set on Nationals, the Illini delivered, winning the game 15-7 and punching their ticket to Milwaukee for Nationals.</p>\n            <p>The victory was a huge one for the program and it proved to be a huge swing in the eventual Coach of the Year award won by Illinois coach, Matt Stupca. Illinois ended the weekend 6-0, and unbelievably, only allowed 1 break all weekend.</p>\n            <p>The Illini were headed to Nationals!!!</p>\n            <p>After failing to reach Nationals the year earlier, Illinois returned and were seeded 19th among the competition. The Illini, having struggled against top competition earlier in the season, were highly focused going into Nationals.</p>\n            <p>Unusual circumstances at other regionals put the Illini in what was considered one of the best Nationals pools ever, Pool C. Their pool included Maryland, Oregon, Florida State, and UNC. Illinois had not played any of those teams during the regular season.</p>\n            <p>The first game was against Maryland, whose star player and Callahan nominee, was brothers with one of Illinois' rookies. The game was heated though, with highlights including a wild sky by Tyler 'Dutch' DeNooyer and a handblock of Maryland's star by Prayag Patel.</p>\n            <p>The game came down to the wire, but saw the Illini as the slim victors 15-13, with former Nationals scoring top-lister Nick Prozorovsky catching the final point to put the Illini 1-0 on the weekend. It was a win for the Illini that spoke volumes to the idea that they truly belonged there.</p>\n            <p>The next matchup was under the lights on the big field against UNC. Illinois faced another top level player, the eventual Callahan winner, Jon Nethercutt. Nethercutt and his UNC Darkside squad had been one of the highest ranked teams going into the tournament and looked even stronger with the return of the mighty cutter, Ben Snell. </p>\n            <p>Considered the underdogs by far, Illinois jumped out to a quick 2-0 lead, breaking the seemingly unstoppable UNC O-line. The early start proved to be important as Darkside fought back and took the half by only one point. The game was closer than anyone could have predicted.</p>\n            <p>But it was not enough to take down the Atlantic Coast champs, as Darkside took the game 15-12. Nethercutt proved to be hyped correctly, but the Illini still played strong regardless.</p>\n            <p>Day 2 saw the Illini in a huge spotlight, facing Oregon Ego to start the day. The road to Nationals had been shaky for Ego, as their struggles at regionals were the sole reason they had even been placed into Pool C as the shocking 15 seed. They sat 0-2 on the weekend, and were in a do-or-die situation for their season. Fittingly, the Illini matched up against them with a chance to end their season, and a chance to end the college career of one of the games' most well-known players, Dylan Freechild.</p>\n            <p>Freechild and the amped up Ego squad came out strong, taking an early and commanding lead. There were some glimmers of hope for Illinois, but none proved strong enough to get them close, as Ego won the game handily 15-7. This put the Illini at 1-2, and kept the season alive for Oregon.</p>\n            <p>The final game of pool play came against Chris Laroque and Florida State. A year earlier, Illinois had lost a tough game on double game point against FSU at Easterns. Illinois yet again was a heavy underdog. They managed to keep it close for most the game, but FSU's star-studded team proved too strong as FSU took the game 15-11. It was another game very close at half for Illinois, which was promising. The loss would put Illinois out of contention to move into the next round of play.</p>\n            <p>In the final game of the season, Illinois would play Cincinnati. With a win, they would claim a tie for 13th place. With a loss, they would finish 17th at Nationals for the 5th time in a row, perhaps proving the 'curse of Illinois-th place' to be true.</p>\n            <p>But the Illini had no plans to settle for that, as they took the game 15-12 with a bit of a late surge. The game proved to be an Illini classic, with a goal line D by Mark Peterson and a bookends point from Kanzy. The win was topped off with Nick Prozorovsky catching the game winning catch, sending the fans home happy and ending an excellent Illinois season.</p>\n            <p>Illinois broke the 'curse' and finished 13th, their best Nationals performance since 2008.</p>\n            <p>Not surprisingly, three of the final four teams were from Pool C, and the championship saw UNC match up against Oregon. UNC would win again, blowing out Oregon 15-6. In the end, it was actually Illinois who had put the most points up on the eventual champions, with 12 points. Nick Prozorovsky finished pool play tied for the lead in goals scored at 24. Most importantly, Illinois broke seed, gaining the respect deserved and achieving their goals. The 13 seniors leaving were sent home happy.</p>\n            <p>Matt West and Nick Prozorovsky won 1st team all region honors. Kevin Lin won Freshman of the Region. The Matt Stupca deservedly won Coach of the year.</p>\n        "
                },
                {
                    year: 2014,
                    imagePath: './assets/team-photo-2014.jpg',
                    summaryMarkup:
                        "\n            <p>Illinois entered the season hoping to return to Nationals. The team lost 3 time captain and Player of the Region, Ryan 'Kennedy' Smith. Returning captain and Machine star Neal Phelps was joined by first time junior captains Marty Markenson and Eric Bultman. The captaining team was young and inexperienced but Walden Nelson returned giving the team hope.</p>\n            <p>At MLC the team was able to exceed expectations by finishing in 2nd place, losing to the eventual National Champions Colorado Mamabird in the finals. This win in addition to the previous year's nationals birth gave the team a cockiness they were unable to shed.</p>\n            <p>The spring schedule was a weak one compared to years' past. The team only attended two tournaments, Huck Finn and Easterns. The team was able to easily win Kat Fight which further boosted the team's ego. At Easterns they fell short in Pool play losing to Pitt, Florida State, Luther, and Central Florida. But won 13th place with wins against Massachusetts and Luther.</p>\n            <p>Illinois was able to comfortable win the Illinois Conference Championships with a win in the finals over Northwestern. The Great Lakes earned two bids to nationals thanks to Northwestern and Michigan. Illinois won their pool and set themselves up for a shot at Nationals. Northwestern learned from their Conference loss and was able to adapt to slow down the Illinois offense forcing Illinois to fight through the backdoor. They next played Chicago in a windy game in which both teams attempted to score with 50/50 shots. These conditions stopped Illinois' high speed offense and gave Chicago a chance to have many opportunities on defense. Chicago finally finished the game with a stall 9 jump ball in the endzone finishing Illinois' season.</p>\n        "
                },
                {
                    year: 2013,
                    imagePath: './assets/team-photo-2013.jpg',
                    summaryMarkup:
                        "\n            <p>After the disappointing and heartbreaking finish in 2012, Illinois lost a huge chunk of veteran talent and had to reload for 2013. Ryan Smith was captain for the 3rd year in a row and was joined by three first year captains in Neal Phelps, Colin Reid and Nathan Gibbons. The captains and the seniors on the team used the previous year's finish as motivation and set the tone at practices throughout the whole year.</p>    \n            <p>Tryouts were completed shockingly early for the 2nd year in a row. With so many open spots, Illinois was fortunate to receive a very deep and talented freshman class. Five freshman made the A-team, with three of them all coming from the same high school. A large chunk of the team were stepping into new roles or were new to college ultimate altogether. They would be forced to acclimate and adjust quickly if Illinois were to meet it's goals for the year.</p>    \n            <p>At Huck Finn, Illinois came in very over confident and were punished by the frisbee gods for their hubris. They thought they could walk into the tournament and do well. They got a huge wake up call on Saturday with three losses including a potential candidate for worst loss of the program. Another blemish on Coach Walden Nelson's coaching record. Illinois used their performance on Saturday of Huck Finn as cause for penance and toughed out an undefeated Sunday through atrocious weather conditions.</p>    \n            <p>The next weekend at Centex, Illinois came out with a renewed focus and sense of urgency. They gritted out a semifinals finish including splitting two universe point games against Harvard. This tournament gave people on the team reason to believe and showed what the team was capable of.</p>    \n            <p>Sectionals was held in Chicago. There were some tough games, but Illinois won their third consecutive conference championship. After winning the tournament, Illinois did hill sprints to help get mentally prepared for the bloodbath of a 1 bid region.</p>    \n            <p>Illinois came into Regionals as the #2 seed and knew what they had to do. Just like 2011, the format was pool play on Saturday with bracket play on Sunday. The first two games were comfortable victories. The third pool play game against Indiana was a back and forth affair. Indiana led late in the game, but on long turn-filled universe point, Illinois ground out a tough win.</p>    \n            <p>Sunday morning, Illinois came out very hot and played extremely well in a good win over up and coming Northwestern. In the first half of the Regional semi-final against MSU, Illinois could not continue their good play. The Oline struggled mightily with execution errors from the younger players on the line. The first half score was 5-8 MSU. Early in the second half, this worrying trend continued and the score went to 6-10 MSU. When things were looking dire, the soon to be graduating players refused to go down without a fight. Big plays from Preston Goulson and Tyler Anderson fueled a furious Illinois comeback highlighted by a big sky from Brian Rathunde. Illinois pulled out a stunning 14-11 win over MSU. This set up the classic Great Lake Regionals matchup between Illinois and Michigan. For the first time since 2008, this matchup would be for the Regional title and the sole bid to Nationals. Illinois maintained a very slim lead throughout the game. The Oline played very calmly even with increased pressure from Michigan. Late in the game, Illinois pulled out a couple breaks and ended the game on a d and subsequent score by Jon McKoy. Illinois returned to Nationals as the sole representative of the Great Lakes. Ryan Smith won Player of the Region honors, Neal Phelps, Nathan Gibbons earned First Team All-Region awards, Brad Bolliger earned a Second Team and Nick Prozorovsky, Johnny Saniat and Derek Yan earned Freshman team awards.</p>    \n            <p>Unfortunately at Nationals, Illinois could not break the 17th place curse. Some key players were unable to play. Illinois gamely tried to fight on but just could not overcome their depleted personnel. In a unsurprising turn of events, Illinois finished 17th at Nationals.</p>    \n        "
                },
                {
                    year: 2012,
                    imagePath: './assets/team-photo-2012.jpg',
                    summaryMarkup:
                        "\n            <p>For the first time since 2008, Illinois returned a majority of the team and had high expectations going into the season. Major personnel losses included 2-time captain Austin Lien and 3-year O-line starter Chris Hidaka. Zach Frantz and Ryan Smith returned as captains and were joined by Kevin Bruns. With such a large number of returning A-teamers, tryouts were as competitive as ever and there were many people fighting for the few remaining spots. After following the Illinois tradition of making final cuts really late, 3 freshmen had made the A-team, which hadn't happened since 2009.</p>    \n            <p>For such a veteran team, focus and urgency was lacking during the season. There were many times where people would be going through the motions and not getting the most of the practice. Unlike past years, when the senior class would set the tone for all their younger teammates, this year saw a rift open up between the seniors and the younger members of the team. This rift manifested itself in many ways throughout the season, but it came to a head at Centex where a team meeting was held Saturday night after pool play and two juniors spoke to all the seniors and told them to get their act together.</p>    \n            <p>With high expectations going into the season, Illinois scheduled a more competitive tournament schedule than in 2011 and went to Easterns and Centex two tournaments with several Nationals contenders in addition to the early season tournament Free State Classic. With all the drama going on behind closed doors, Illinois had an up and down tournament performance with some uncharacteristic big losses. At Free State, Illinois struggled to play in the wind against Iowa and lost to them twice, once on Saturday and again in the Final. At Centex, Illinois played Iowa again and came out hot and took a 3-0 lead, but that quickly disappeared and Iowa won again in dominating fashion. This bled into the most dispiriting performance by Illinois in many years, as they proceeded to be blanked in the first half by Tufts. After play ended, the aforementioned team meeting was held. Sunday of Centex, Illinois came out reinvigorated and played a close game with Luther but eventually lost on universe. The following weekend at Easterns, Illinois played much more consistently and lost twice, once to eventual champions Pittsburgh and again on universe to Tufts. Buoyed by their Easterns results, Illinois looked ahead to the series and a return to Nationals.</p>    \n            <p>The third annual alumni game was held, and the alumni extended their winning streak to two games after a dismal performance by the college kids. After taking half 8-5, the college team seemed to think the game was over and did not try as hard as the older, more out of shape alumni. Unfortunately, the lessons from the alumni game would not be remembered later in the season.</p>    \n            <p>Sectionals once again were held in Rantoul and like every other tournament that has ever been held there, the weather was terrible. Saturday was cold, windy, and wet and Illinois took care of business winning every game handily. Sunday was sunny and very windy and after going up by a lot on Northwestern, Illinois lost their focus and let them back into the game. Illinois eventually closed it out and won by a few points.</p>    \n            <p>Like the past three years, Illinois was counting on being able to flip the switch and play their best ultimate of the season at Regionals. With two bids to Nationals, the best format and Regionals being held in Naperville, confidence was very high that Illinois would be able to get the job done and qualify for Nationals. It was a cold, windy, wet day on Saturday but Illinois won their first game comfortably. In a shocking turn of events, a lack of focus caused Illinois to come out flat against Eastern Illinois in the regional quarterfinals. Eastern Illinois came out and punched in four breaks in a row. Illinois fought back and tied the score at 5-5, but they could never get over the hump and take the lead. Eastern Illinois' Michael Schwenk carried the team to an upset with a 13-10 victory and gave Illinois their first loss at Regionals since 2008.</p>    \n            <p>With their backs against the wall, Illinois regrouped and took care of business on Saturday and stayed alive in the 2nd place bracket for Sunday. For the first time since 2007, Illinois was not in the Regional Final Sunday morning but instead in a fight for their season in the backdoor semi- finals. They dispatched Indiana 15-7 and had a rematch with Eastern Illinois in the backdoor final. Illinois did not take them lightly this time and came out with a rarely seen intensity and beat Eastern 15-2. However, the team's focus and execution was not there and multiple turnovers on every point culminated in the destruction of Coach Walden Nelson's clipboard. Illinois, after an arduous road, had finally made it to a game to go to Nationals against Michigan State. Illinois started the game out strong and fired up and came out with two quick breaks. MSU played a lot of zone in an effort to negate Ryan Smith's hucks. But Ryan did not take the bait and lead the offense to a clean no break first half and the defense got 3 breaks for an 8-5 halftime lead. Illinois smelled a Nationals berth and came out of half with 2 more points for a commanding 10-5 lead. This was when Michigan State held their ground and began a tenacious comeback. Staying with their zone, MSU began to force more and more turnovers from Illinois and began to convert them for breaks. A 10-5 lead quickly became 10-8 and MSU clawed slowly back from there to finally take the lead at 13-12. A lot of credit is to be given to MSU for never giving up and fighting their way back to the lead. But Illinois' lack of composure on offense coupled with a willingness to turn the disc over, as well as timeout mismanagement by Coach Walden Nelson did not help the cause. Even with all that being said, Illinois scored on offense to make it 13- 13 universe point with the winner going to Nationals. Illinois got the disc twice on universe and both times threw passes into the endzone that hit a receiver's hands, but alas both passes were dropped. After the second drop in the endzone MSU picked up the disc and immediately threw an 80 yard, more than full field huck for the game and the Nationals berth.</p>    \n            <p>This was not the ending to the 2012 season that Illinois imagined. For the first time since 2007, Illinois' graduating seniors did not get to end their careers at Nationals. With a huge graduating class, it will be up to the few returning A-teamers to pick up the pieces and return Illinois to Nationals.</p>    \n        "
                },
                {
                    year: 2011,
                    imagePath: './assets/team-photo-2011.jpg',
                    summaryMarkup:
                        "\n            <p>The program lost several program mainstays such as 5-year A-teamer and 2-time captain Brian Phelan, Top 10 Callahan finisher and captain Walden Nelson, and Team Spirit Leader Kurt Zoellick among others. This required the large junior class to step up and meet the challenge. Juniors Zachary Frantz and Ryan Smith stepped up to become captains alongside returning captain Austin Lien. The captains surveyed the tryout pool and saw that it was one of the most competitive in recent history. Wanting to give everyone a fair look, final cuts weren't made until the end of January. After the smoke cleared, the final roster stood at 27 and after a 1 year hiatus of no freshman making the cut, 2 freshman found themselves on the team.</p>\n            <p>Even with a full roster, Illinois battled the injury bug throughout the season. Dline handler Adam Wright tore his acl at Rivalry Reheat and only returned for a few points at Nationals. Captain Zachary Frantz battled Plantar Fasciitis the whole year, missing every tournament besides Regionals and Nationals. 5th year cutter Chris Hidaka badly sprained his ankle in the 2nd game of the first tournament and never quite regained his old form. Seniors Suleyman Ahmad and Jonathan Hatcher had leg problems of their own and were in and out of the line up. Junior Ryan Kurnik broke his hand and missed the last half of the season. In addition there were numerous other injuries that kept people away from the field.</p>\n            <p>However there were still tournaments to be played and games to be won. Compared to past years, Illinois traveled to less competitive tournaments. Unfortunately this did not lead to more victories as Illinois struggled to maintain focus for whole games, often playing one good and one bad half. There were some benefits as several players were able to gain much needed experience playing new and more challenging roles than they were accustomed to. Illinois made semifinals of both the Freestate Classic and Huck Finn before losing to Central Region teams Iowa and Minnesota. Going into the series, Illinois hoped to follow the trends of the past two Illinois teams and play their best ultimate during the series.</p>\n            <p>Sectionals was held close by in Rantoul, Illinois as people still didn't get the memo not to have tournaments there in the Spring. Saturday was a windy and rainy day, Illinois took care of business and won every game by a comfortable margin. On Sunday, buoyed by the rare beautiful Rantoul weather, Illinois beat Northwestern and Eastern Illinois to repeat as Sectional Champions.</p>\n            <p>Just like 2010, Illinois had the 3rd seed going into Regionals. Unlike past years only 1 team would make it to Nationals, meaning 1 bad half and the season would be over. Another change was the format, with the format being pool play instead of a straight bracket. In a very windy Saturday, Illinois gutted out a close game against Loyola, winning on double game point. After that scare woke them up, they beat Western Michigan and Notre Dame handily. Everyone on the team was looking forward to facing Michigan in semis but first they would have to get through Indiana in the first game of the day on Sunday. Led by their senior leaders Ed Wu and Taylor Kraemer, Indiana gave Illinois all they could handle in a close back and forth game before Illinois pulled it out winning 15-13. This led to the semifinal showdown with Michigan for the third year in a row. However, this year would be different from the past two years as Illinois came out firing with an intensity that Michigan either could not or was unwilling to match. It was a total team effort as everyone contributed to a resounding 15-9 win. It was a great win, but people were too satisfied with that victory considering that the bid to Nationals was still up for grabs. Illinois still had to face a determined opponent in Michigan State who undoubtedly had plans for revenge from 2010. Fortunately for Illinois, Michigan State had several unforced errors in the first half of the game and Illinois took advantage going up several breaks in the first half. Michigan State tried to mount a comeback in the second half but the score difference was too great. Illinois won the region for the 3rd year in a row and took the regions only bid to Nationals with a 15-11 victory. Illinois had several players who played well during Regionals including but not limited to Dane Jorgensen, Brian Pierce, Austin Lien, Zachary Frantz, Ryan Smith and Neal Phelps. In a surprising turn of events, only Ryan Smith was a member of the All-Region team.</p>\n            <p>Going into Nationals, Illinois planned on breaking the curse of two straight 17th places. Ironically enough and deservedly so, Illinois had the 17th seed going in. Illinois was in a pool with overall #1 seed Pittsburgh and #12 seed and fan favorite Colorado College. In the first game of Nationals against Colorado College, Illinois battled nerves and had several unforced errors in the first half. However, led by Neal Phelps' stellar defense on Callahan candidate Nicky Spiva and Dane Jorgensen's aerial ability, Illinois fought and clawed back for a gritty 13-11 victory. This was Illinois' first Nationals pool play victory in 2 years and had them primed to take a spot in prequarters. After losing 15-10 to Pittsburgh highlighted by a break with several Nationals first timers and both rookies, Illinois only needed to win 1 of their next 2 games to take a spot in prequarters. Unfortunately, the issues that beguiled Illinois throughout the season came up once again. To put it simply, Illinois did not show up on Saturday of Nationals. Illinois looked lifeless and lost to Iowa 15-10. Even with that being said, Illinois simply had to win against Tufts to advance to the bracket. With their season on the line, Illinois gave a sad, disappointing effort both on the field and on the sidelines. Their effort was no where close to good enough and they got punished deservedly, 15-7, knocking them into the placement bracket for the 3rd year in a row. Illinois lost to Whitman 16-14 after leading most of the game and then in the game they have never lost, beat Florida and took 17th place for the 3rd year in a row. However there is hope for the future with 20 returning players and a talented incoming class, Illinois will look to break the curse of 17th.</p>\n        "
                },
                {
                    year: 2010,
                    imagePath: './assets/team-photo-2010.jpg',
                    summaryMarkup:
                        '\n            <p>Illinois had to deal with several big losses from the year before but none bigger than the departure of longtime coach Matt Stupca who coached from 2004-2009. The captains Brian Phelan, Walden Nelson and Austin Lien, had to come to terms with the responsibilities and extra work that Matt Stupca provided, and carry a bigger load themselves. Dealing with the heavy losses from the year before, Illinois called up a number of players from the B-team and two from the C-team which was a program first. Illinois spent much of the season acclimating the new players so that they would be ready for Nationals level competition.</p>\n            <p>They had uneven results and growing pains throughout the year, with a highlight being making the finals of Mardis Gras before losing to Wisconsin by a substantial margin. It also included another shellacking by Michigan at Huck Finn as many players got their first taste of the regional rivalry. Illinois had several injuries throughout the year which made practice attendance an issue, however Illinois fought through them and went into the College Series mostly healthy.</p>\n            <p>At Sectionals Illinois held the 1 seed going in, but lost on Saturday of Sectionals for the first time since the Regions and Sections were redrawn. This gave them a 2 seed out of their pool and a first round match up with Notre Dame the 2 seed overall, with good seeding at Regionals on the line. Illinois went up big early but Notre Dame made a furious comeback to tie up late in the game, Illinois received going upwind and threw caution into the wind by throwing several close throws through and around the Notre Dame zone before punching it in and winning 14-13. Illinois then took care of business and made it to finals, exacting revenge on Purdue for the Saturday loss and beating them 15-5 and reclaiming the Sectional title.</p>\n            <p>Going into Regionals Illinois had the 3 seed going in behind Michigan State and Michigan. Illinois beat both Dayton and Purdue handily and advanced to semifinals before finding out that Regionals would be postponed for a week. Having a week to prepare and to heal, Illinois faced Michigan at Regionals as is the norm. In a heavy wind game, which saw several lead changes, but few breaks, and lots of great plays from both teams, Illinois was able to score on a gut-wrenching universe point and won the game 9-8.</p>\n            <p>This sent Illinois to its 3rd straight Regional final with a chance to repeat as Regional champions for the first time in the programs history. Illinois faced Michigan State with the Regional title on the line and prevailed in a close game with Illinois being able to pull away in the end, 15-10. Illinois repeated as Regional champions for the first time and had Brian Phelan and Walden Nelson win first team All-Region honors and had Ryan Smith win 2nd team All-Region, becoming the first sophomore in the programs history to win a regional award. Illinois was seeded 14th going into Nationals. They lost to Harvard handily but was still in contention for a prequarters berth if they were able to beat both UNCW and Iowa. However, in games possibly showing a lack of experience or the burden of captaining and coaching proving too great, Illinois lost late leads in both games and lost to UNCW 14-12 and to Iowa 16-14. Illinois then played Carleton in a much closer than expected 15-12 loss and lost to Wisconsin. Beating Kansas in the last game of the tournament gave Illinois its only win at Nationals and sent them home with another 17th place finish. Illinois did not graduate as many players as in years past, which makes Illinois in a prime position to continue its Nationals qualifying streak.</p>\n        '
                },
                {
                    year: 2009,
                    imagePath: './assets/team-photo-2009.jpg',
                    summaryMarkup:
                        "\n            <p>2009 saw the departures of many fixtures of the Illinois program such as Joel Koehneman, Pat Stephens, Jake Segil and David Abram. In their place it was up to the class of 2005 to step up and lead the program. It was the first time in several years that there were 3 captains vacancies. They were filled by Denis Agniel, Brian Phelan and Charlie O'Brien. Like in 2006 when the team lost several impact players, the team was able to recruit a very deep class that rivals and may surpass the freshman class of 2006. This influx of freshman led to the 2nd year of the C- teams existence in the programs history.</p>    \n            <p>The regular season for Illinois was very rough, with the team trying to find people who would be able to fill the big holes left by the departed players. This led to several big losses throughout the year and poor tournament finishes, culminating in a 13-2 beatdown by regional rival Michigan at Huck Finn. Going into the postseason/the college series, Illinois had a lot of uncertainty. At Sectionals, Illinois took care of business on Saturday and beat a tough North Park team in semifinals and made Finals against Notre Dame. In a rainy, cold final, Illinois looked like they did throughout the season and lost 15-10. This gave Illinois a 4 seed going into Regionals and a definite longshot for one of the two Nationals bids.</p>\n            <p>Illinois faced tougher than expected games against Kenyon and North Park before meeting Michigan in Regional semifinals. Illinois came together in a way that had not been seen all season, and put forth their best effort of the season and beat Michigan in a tense hard fought game 12-9. This put Illinois in its second straight Regional final against Ohio State. The previous day's momentum carried over as Illinois beat Ohio State handily 15-11, taking home its first Regional championship since 2002.</p>\n            <p>Illinois placed Denis Agniel, Brian Phelan, Pavan Sarguru, and Walden Nelson on the Great Lakes 2nd Team All-Region, Coach Matt Stupca won the inaugural Coach of the Region award, and Ryan Smith won Freshman of the year. Winning the Region gave Illinois an 8 seed going into Nationals, however whatever magic Illinois had at Regionals was lost at Nationals, as Illinois lost several games by big margins except for one close pool play game against Tufts and the only win against Cal. They did so in good spirit, winning the 2009 Nationals Spirit Award and dubbed Zubair: The most spirited man in ultimate. Although, this performance gave Illinois a disappointing 17th place finish at Nationals and with several players graduating including captain Denis Agniel, the prospect of another rebuilding year loomed large.</p>\n        "
                },
                {
                    year: 2008,
                    imagePath: './assets/team-photo-2008.jpg',
                    summaryMarkup:
                        "\n            <p>Using the loss at Regionals the previous year as motivation and determined to make Nationals in captains Joel Koehneman, Pat Stephans and David Abrams, final year. Many players on the team spent their summer and fall, going to tournaments together in an effort to get better. Illinois also got a key transfer student Denis Agniel, who created the team at Loyola University in Chicago. This was a very veteran team under coach Matt Stupca that was poised to make a run into Nationals.</p>    \n            <p>Throughout the season, Illinois had a chance to win every game that they played. The biggest margin of victory in Illinois' losses heading into Regionals was 3 points. Illinois suffered some key injuries before Sectionals but managed to persevere and hold of North Park in an exciting 17-16 Sectional Final. Like the previous year Illinois had a 2 seed going into Regionals. They took care of business on Saturday winning all 3 games and securing a spot in the Regional finals. In many people's first Regional final, Illinois played tentatively and lost 15-11 to Michigan putting them in the 2nd place game against Ohio State. In a reversal of the previous years game at Regionals, Illinois stormed out to a big lead and maintained it throughout and punched their first ticket to Nationals in 3 years.</p>    \n            <p>Pat Stephens and Joel Koehneman both won all-region honors. Nationals that year was in Boulder, Colorado and Illinois went into it holding an 8 seed and in a pool with Florida, North Texas and Delaware. Illinois beat Delaware to clinch a spot in prequarters, and lost to Florida and North Texas. In prequarters Illinois was matched up against Michigan, who they had lost to at Regionals and had not beaten since 2004. In a hard fought game led by the graduating players, Illinois prevailed 15-11 sending them into quarters against the hometown team Colorado. In an exciting game that saw several big plays, Illinois lost 15-12 to Colorado and ended their season having them tied for 5th which is the highest finish in the programs history. 2008 saw the departure of many mainstays for Illinois and the following years would show how well the recruiting efforts of 2005 paid off.</p>      \n        "
                },
                {
                    year: 2007,
                    imagePath: '',
                    summaryMarkup:
                        '\n            <p>Coming off of one the worst years in recent history, Illinois started to put the pieces in place to make a run at a Nationals berth. The leadership which added Jake Segil as a captain, joining Joel Koehneman and Brian Korbesmeyer and Matt Stupca as coach, continued to focus on recruiting, resulting in an another big influx of freshman. Resulting in the creation of the first C-team in the programs history. However, unlike the previous year, many of them stopped playing within a year.</p>    \n            <p>In order to gear up to make a run and to face stiffer competition, Illinois designed a much harder tournament schedule travelling to tournaments in Las Vegas and Austin, in addition to ones they had previously gone to in Baton Rouge and Atlanta. This benefited the team, as they were able to match up and see where they stood in relation to both Nationals finalists. As a result, the team was able to see that they were more than prepared to take a Nationals berth out of Regionals.</p>    \n            <p>Illinois steamrolled through Sectionals and reclaimed the Sectionals crown and had a 2-seed going into Regionals. Regionals was held in Rantoul, Illinois and was hosted by Illinois. Illinois took care of business early, beating Dayton and Notre Dame handily before squaring off against Indiana in Regional semifinals. In a very heavy upwind downwind game that saw very few breaks, Illinois received going downwind on universe point but was unable to punch it in and lost on a couple floaty upwind hucks. Out of the running for first, Illinois was now in the backdoor bracket having to win every game in order to advance to Nationals. They beat Northwestern and faced Ohio State, the #1 seed going into the tournament who had also lost in semis to Michigan. Perhaps showing a little bit of inexperience in a pressure filled game, Illinois went down big early, going down 5-0, however, they mounted a furious comeback and came close to negating the early deficit, but eventually succumbed 15-12 and ending their season without a Nationals berth for the 3rd year in a row. Illinois finished 4th at Regionals.</p>    \n            <p>Brian Korbesmeyer and Joel Koehneman both received all-region honors. However unlike the previous year, there were several graduating players most notably Brian Korbesmeyer, who had captained the team the previous 2 years and was a major player on offense. Finding players to step into the holes left by the graduating players was a major question going into the next year.</p>    \n        '
                },
                {
                    year: 2006,
                    imagePath: '',
                    summaryMarkup:
                        '\n            <p>After coming so close to a Nationals berth the year before, 2006 was a rebuilding year for Illinois. After losing several starting players, the captains, Brian Korbesmeyer and Joel Koehneman and coach Matt Stupca, decided to focus their energies on recruiting and replenishing the program. This led to one of the deepest freshman classes in the programs history largely due to the efforts of Brian Korbesmeyer. In order to facilitate the rebuilding process, the leadership decided to go with a very small A-team roster of less than 20 guys, so that everyone would be able to play both on the A-team and on the B-team. The B-team with the services of coach Nick McDuffee was able to nurture the players and have them ready to take the next step onto the A-team. It was a season with very few bright spots, as Illinois did not make the Sectional final for one of the few times in modern history, finishing 4th at Sectionals, and did not even make Sunday of Regionals, finishing tied for 7th after losing in quarterfinals and getting eliminated in the backdoor bracket. However, there were encouraging signs for future years to come, Brian Phelan won freshman of the year for the Great Lakes Region and there were several talented players waiting in the wings, ready to make their mark on the program and the same core of players returning.</p>    \n        '
                },
                {
                    year: 2005,
                    imagePath: '',
                    summaryMarkup:
                        '\n            <p>Illinois advanced to the finals at Regionals and lost to Michigan on double game point, and had to immediately play Michigan State for second place and the chance to return to nationals. Coming out flat after the loss to Michigan Illinois went down 3-0. Battled back to double game point but again lost and were eliminated.</p>\n        '
                },
                {
                    year: 2004,
                    imagePath: '',
                    summaryMarkup:
                        '\n            <p>Illinois finished second at Regionals and advanced to Nationals in Seattle, Washington. Illinois lost a close game to North Carolina State in Prequarters and finished 9th.</p>\n        '
                },
                {
                    year: 2003,
                    imagePath: '',
                    summaryMarkup:
                        '\n            <p>Illinois started being invited to the major tournaments, including its first invite to Easterns. This helped prepare the team for the season. Seeded first at Regionals, Illinois lost in the finals to Ohio State and advanced to Nationals in Austin, TX. After beating Michigan and Georgia fairly handily in the first two games, Illinois beat North Carolina State 17-15 to win the pool. In quarters Illinois matched up with Colorado.They were 3 feet away from being up 14-13, pulling downwind, but victory eluded them, and ended up finishing tied for 5th.</p>\n        '
                },
                {
                    year: 2002,
                    imagePath: '',
                    summaryMarkup:
                        "\n            <p>The program made a big jump forward under the coaching of Joe Ferrari. The team advanced to the Regional Final for the first time ever, the Final was against Michigan. There was a consistent wind of 25-35 mph with gusts of over 40. For a lot of the game it was upwind/downwind with the huck and zone strategy being employed. Then early in the second half we got a big break off and were able to work the disc up the backhand sideline all the way to the endzone for a score to take the lead. From there we maintained our lead up to 13-12. Michigan worked the disc upwind and called a timeout 5 yards out of the endzone on the forehand side. Out of the timeout they had a man break open on the force side. Alvin Wang was able to run past for the game saving d. We were able to score that point and the next downwinder in the back corner of the endzone to advance to our first Nationals. Illinois' first Nationals tournament was in Spokane, WA. We lost many close games early to Colorado and Carleton. We beat Colorado later in the tournament and finished 9th.</p>\n        "
                },
                {
                    year: 2001,
                    imagePath: '',
                    summaryMarkup:
                        "\n            <p>Bill Finn and Nick McDuffee joined the team this year, and the team was the strongest it had ever been with these two outstanding rookies. Many of the older returners now had 3-4 years of competitive ultimate under their belts, and the team was on the verge of breaking through. A Sectional final win over Indiana set up Illinois as the 3rd seed at Regionals behind Michigan and OSU (regional hosts). After beating a tough ND team in quarterfinals, Illinois faced Michigan in the semifinals. Despite being up by a few goals at half-time, Michigan's Nationals experience showed and they ended up winning a closely fought game. Sunday morning, Illinois lost to Oberlin, making it three straight years of semifinal losses at Regionals.</p>\n        "
                },
                {
                    year: 2000,
                    imagePath: '',
                    summaryMarkup:
                        '\n            <p>Illinois changed its name to FIST and had another good recruiting class with the likes of Greg Severin, Chris Hagen, Nels Overgaard-Cook, Kyle Eertmoed, Brian Fifarek, and Dave Draeger. Illinois went to the Stanford Invite for the first time. Regionals was at Purdue University that year, and Illinois lost to Dayton in semifinals, beat Oberlin Sunday morning, and then lost an elimination game to Notre Dame.</p>\n        '
                },
                {
                    year: 1999,
                    imagePath: '',
                    summaryMarkup:
                        "\n            <p>1999 saw another surge in the team's development. More recruits like Alvin Wang, John Koltse, and Kevin Patterson joined the team. The College Regions were redrawn which meant that Illinois had a real opportunity to qualify for nationals in the newly formed Great Lakes Region. It was a great year for the team, which racked up many wins, including wins at Frozen Over in Bloomington, IN and the first Sectional Championship for the team. Coming into Regionals, Illinois was seeded second and hosted the tournament. The team lost a heartbreaker in semifinals to Oberlin College, and then lost an elimination game on Sunday morning to Notre Dame.</p>\n        "
                },
                {
                    year: 1998,
                    imagePath: '',
                    summaryMarkup:
                        "\n            <p>Was a transformational year for the program, as a great class of rookies joined Illinois. Jarrett Bialek, Xia Xi, Andy Zill, Kyle Romberg, and Jacob Dee were among the new players who helped push the team to towards becoming a more legitimate program. The team changed their name to 'Men From Mars', got uniforms, designed new discs, and actually started practicing a real offensive scheme and spent more time working out off the field. Illinois set the goal of qualifying for Regionals, and at that time the Central Region included every state from Minnesota to Illinois to Colorado. A 4th place finish at sectionals propelled them to their first Regionals birth in many years. At Regionals in Michigan, Illinois played Grinnell and Colorado State pool play, but were eliminated from competition on Saturday.</p>\n        "
                },
                {
                    year: 1997,
                    imagePath: '',
                    summaryMarkup:
                        "\n            <p>Tom Coffin aka Iron Man, an older player deserves credit for organizing the program and recruiting efforts. He moved to Champaign in the fall of 1996 and really helped lead the program in the right direction along with players like Joe Ferrari and Ryan Fehrenbacher and others. In the fall of 1996, the team was mostly filled with graduate students and older players, and had a 'serious' pick-up vibe where practices were mostly scrimmages with some occasional drills. Under Captain Ted Winrow, 'Big Red Ultimate' struggled to win many games, but traveled to tournaments in Baton Rouge, LA, Carbondale, IL, Madison, WI, amongst a few others. Key players included John Conour, Leo Wang, Jon Rasmussen, and David Fiske. Joe Ferrari and Matt Taylor were the only freshmen, who showed up consistently, and the year ended with a low finish at Sectionals and Illinois did not qualify for Regionals that year. BRU - the origin of this name comes from the practice on the team where if you got handblocked you had to chug a bottle of Big Red Soda, which had some significance.</p>\n        "
                },
                {
                    year: 1996,
                    imagePath: '',
                    summaryMarkup:
                        '\n            <p>Illinois again hosted Sectionals and qualified for Regionals, finishing 3rd behind Notre Dame and Indiana. Our team by this point was more than half undergraduates; there were at most 14 at Regionals. The team was run at this time by Ted Winrow. Ted and Gary Ledonne were basically the entire team. Bill Branson was still playing, John Connour was in his first year, Leo Wang was in his first year alSophomore Gary Ledonne had to convince players to attend Regionals in West Lafayette. Illinois went 0-3 in pool play losing relatively close games to Colorado and Oberlin.</p>\n        '
                },
                {
                    year: 1995,
                    imagePath: '',
                    summaryMarkup:
                        '\n            <p>After losing 2 of our top grad students Illinois lost in the game to go to Regionals to Ball State.</p>\n        '
                },
                {
                    year: 1994,
                    imagePath: '',
                    summaryMarkup:
                        "\n            <p>In February of 1994, Illinois had winter practices in the Armory and the Bubble. The University would give us 1.5 hours a week Sunday night 10:30 to Midnight, we split use with the women's team. The makeup of the team was much different, there were had 17 players at Sectionals 4 were undergrads. Almost all grad students and most were in their late 20's. There was little to no recruiting effort. Practice generally consisted of some bad drills, but they were drills designed to learn how to throw in most cases, then we scrimmaged. Our level of athleticism was awful compared to today's game, but our older team was pretty strong throwing, at least for a college team at that time. Wind was our friend as it allowed us to run a zone. In any case the team was fairly solid. Tony Curtis, Mike Percy, and Bill Branson were some of the strong grad student throwers. Mike Fritz an old undergrad at 23, Ted Winrow and Gary Ledonne both sophomores were the contributing undergrads. The team hosted Sectionals and took 2nd to Purdue, our big win was beating Indiana who had been the strength of the Section. Regionals was in Grinnell, Iowa. It was the first year they had moved Colorado into our Region as they had lobbied for an easier Region. At Regionals Illinois went 3-1 in pool play, losing to Purdue, beating Colorado, Macalester, and Grinnell. In pre-quarters we beat Dayton making the top 8 double elimination for 3 spots. Lost to Carleton and Oberlin and that was it.</p>\n        "
                }
            ];

            /***/
        },
        /* 139 */
        /***/ function(module, exports) {
            module.exports =
                '<h1 class="ui header">Team History</h1>\n<div class="ui secondary pointing menu">\n    <div #1994dropdown class="ui dropdown item">\n        1994-1999<i class="dropdown icon"></i>\n        <div class="menu">\n            <div routerLink="/history/1994" [routerLinkActive]="[\'active\']" class="item">1994</div>\n            <div routerLink="/history/1995" [routerLinkActive]="[\'active\']" class="item">1995</div>\n            <div routerLink="/history/1996" [routerLinkActive]="[\'active\']" class="item">1996</div>\n            <div routerLink="/history/1997" [routerLinkActive]="[\'active\']" class="item">1997</div>\n            <div routerLink="/history/1998" [routerLinkActive]="[\'active\']" class="item">1998</div>\n            <div routerLink="/history/1999" [routerLinkActive]="[\'active\']" class="item">1999</div>\n        </div>\n    </div>\n    <div #2000dropdown class="ui dropdown item">\n        2000-2009<i class="dropdown icon"></i>\n        <div class="menu">\n            <div routerLink="/history/2001" [routerLinkActive]="[\'active\']" class="item">2001</div>\n            <div routerLink="/history/2002" [routerLinkActive]="[\'active\']" class="item">2002</div>\n            <div routerLink="/history/2003" [routerLinkActive]="[\'active\']" class="item">2003</div>\n            <div routerLink="/history/2004" [routerLinkActive]="[\'active\']" class="item">2004</div>\n            <div routerLink="/history/2005" [routerLinkActive]="[\'active\']" class="item">2005</div>\n            <div routerLink="/history/2006" [routerLinkActive]="[\'active\']" class="item">2006</div>\n            <div routerLink="/history/2007" [routerLinkActive]="[\'active\']" class="item">2007</div>\n            <div routerLink="/history/2008" [routerLinkActive]="[\'active\']" class="item">2008</div>\n            <div routerLink="/history/2009" [routerLinkActive]="[\'active\']" class="item">2009</div>\n        </div>\n    </div>\n    <div #2010dropdown class="ui dropdown item">\n        2010-2017<i class="dropdown icon"></i>\n        <div class="menu">\n            <div routerLink="/history/2010" [routerLinkActive]="[\'active\']" class="item">2010</div>\n            <div routerLink="/history/2011" [routerLinkActive]="[\'active\']" class="item">2011</div>\n            <div routerLink="/history/2012" [routerLinkActive]="[\'active\']" class="item">2012</div>\n            <div routerLink="/history/2013" [routerLinkActive]="[\'active\']" class="item">2013</div>\n            <div routerLink="/history/2014" [routerLinkActive]="[\'active\']" class="item">2014</div>\n            <div routerLink="/history/2015" [routerLinkActive]="[\'active\']" class="item">2015</div>\n            <div routerLink="/history/2016" [routerLinkActive]="[\'active\']" class="item">2016</div>\n            <div routerLink="/history/2017" [routerLinkActive]="[\'active\']" class="item">2017</div>\n\n        </div>\n    </div>\n</div>\n<h2 class="ui header">{{year}}</h2>\n<ng-container *ngFor="let historyYear of historyData">\n    <ng-container *ngIf="historyYear.year === year">\n        <img *ngIf="historyYear.imagePath" src="{{historyYear.imagePath}}"/>\n        <div class="summary" [innerHTML]="historyYear.summaryMarkup"></div>\n    </ng-container>\n</ng-container>\n<!--Only show the previous and next button if they are within the bounds of our history summaries-->\n<a *ngIf="year > 1994" routerLink="/history/{{year - 1}}"><i class="angle double left icon"></i></a>\n<a *ngIf="year < 2017" routerLink="/history/{{year + 1}}"><i class="angle double right icon"></i></a>';

            /***/
        },
        /* 140 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(141);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 141 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([
                module.id,
                'img{width:75%;border:1px solid #00004d;margin-bottom:15px;border-radius:.28571429em}i{font-size:2em}i.right{float:right}i.left{float:left}.summary{text-align:left;margin-bottom:20px}.ui.dropdown.item{width:121px;height:40px}.ui.dropdown.item .active,.ui.dropdown.item:focus{border:0}',
                ''
            ]);

            // exports

            /***/
        },
        /* 142 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var awards_data_1 = __webpack_require__(143);
            var AwardsComponent = (function() {
                function AwardsComponent() {
                    // Awards data to inject into our template
                    this.awardData = awards_data_1.AWARDS_DATA;
                }
                AwardsComponent.prototype.ngOnInit = function() {};
                return AwardsComponent;
            })();
            AwardsComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'awards',
                        template: __webpack_require__(144),
                        styles: [__webpack_require__(145)]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                AwardsComponent
            );
            exports.AwardsComponent = AwardsComponent;

            /***/
        },
        /* 143 */
        /***/ function(module, exports) {
            'use strict';
            exports.AWARDS_DATA = [
                {
                    year: 2019,
                    name: 'Joey Kennedy',
                    award: 'All-Freshman'
                },
                {
                    year: 2018,
                    name: 'Ben Sabourin',
                    award: '2nd Team'
                },
                {
                    year: 2018,
                    name: 'Reid Martin',
                    award: 'All-Freshman'
                },
                {
                    year: 2018,
                    name: 'Anthony Ruzzo',
                    award: 'All-Freshman'
                },
                {
                    year: 2017,
                    name: 'Drake Hill',
                    award: 'All-Freshman'
                },
                {
                    year: 2016,
                    name: 'Nick Prozorovsky',
                    award: '1st Team'
                },
                {
                    year: 2016,
                    name: 'Johnny Saniat',
                    award: '1st Team'
                },
                {
                    year: 2016,
                    name: 'Prayag Patel',
                    award: '2nd Team'
                },
                {
                    year: 2016,
                    name: 'Ben Sabourin',
                    award: 'All-Freshman/FOTY'
                },
                {
                    year: 2016,
                    name: 'Jacob Cuthbert',
                    award: 'All-Freshman'
                },
                {
                    year: 2015,
                    name: 'Matt Stupca',
                    award: 'COTY'
                },
                {
                    year: 2015,
                    name: 'Nick Prozorovsky',
                    award: '1st Team'
                },
                {
                    year: 2015,
                    name: 'Matt West',
                    award: '1st Team'
                },
                {
                    year: 2015,
                    name: 'Kevin Lin',
                    award: 'All-Freshman/FOTY'
                },
                {
                    year: 2014,
                    name: 'Neal Phelps',
                    award: '1st Team'
                },
                {
                    year: 2014,
                    name: 'Nick Prozorovsky',
                    award: '2nd Team'
                },
                {
                    year: 2013,
                    name: 'Nathan Gibbons',
                    award: '1st Team'
                },
                {
                    year: 2013,
                    name: 'Neal Phelps',
                    award: '1st Team'
                },
                {
                    year: 2013,
                    name: 'Ryan Smith',
                    award: '1st Team/POTY'
                },
                {
                    year: 2013,
                    name: 'Brad Bollinger',
                    award: '2nd Team'
                },
                {
                    year: 2013,
                    name: 'Nick Prozorovsky',
                    award: 'All Freshman'
                },
                {
                    year: 2013,
                    name: 'Johnny Saniat',
                    award: 'All Freshman'
                },
                {
                    year: 2013,
                    name: 'Derek Yan',
                    award: 'All Freshman'
                },
                {
                    year: 2012,
                    name: 'Ryan Smith',
                    award: '1st Team'
                },
                {
                    year: 2012,
                    name: 'Dane Jorgensen',
                    award: '2nd Team'
                },
                {
                    year: 2011,
                    name: 'Ryan Smith',
                    award: '1st Team'
                },
                {
                    year: 2010,
                    name: 'Walden Nelson',
                    award: '1st Team'
                },
                {
                    year: 2010,
                    name: 'Brian Phelan',
                    award: '1st Team'
                },
                {
                    year: 2010,
                    name: 'Ryan Smith',
                    award: '2nd Team'
                },
                {
                    year: 2009,
                    name: 'Matt Stupca',
                    award: 'COTY'
                },
                {
                    year: 2009,
                    name: 'Denis Agniel',
                    award: '2nd Team'
                },
                {
                    year: 2009,
                    name: 'Walden Nelson',
                    award: '2nd Team'
                },
                {
                    year: 2009,
                    name: 'Pavan Sarguru',
                    award: '2nd Team'
                },
                {
                    year: 2009,
                    name: 'Ryan Smith',
                    award: 'FOTY'
                },
                {
                    year: 2008,
                    name: 'Joel Koehneman',
                    award: '1st Team'
                },
                {
                    year: 2008,
                    name: 'Pat Stephens',
                    award: '1st Team'
                },
                {
                    year: 2007,
                    name: 'Joel Koehneman',
                    award: '1st Team'
                },
                {
                    year: 2007,
                    name: 'Brian Korbesmeyer',
                    award: '1st Team'
                },
                {
                    year: 2006,
                    name: 'Brian Phelan',
                    award: 'FOTY'
                },
                {
                    year: 2005,
                    name: 'Nick McDuffee',
                    award: '1st Team'
                },
                {
                    year: 2005,
                    name: 'Mike Clark',
                    award: '1st Team'
                },
                {
                    year: 2005,
                    name: 'David Abram',
                    award: 'FOTY'
                },
                {
                    year: 2004,
                    name: 'Matt Welsh',
                    award: '1st Team'
                },
                {
                    year: 2004,
                    name: 'Nick McDuffee',
                    award: '1st Team'
                },
                {
                    year: 2004,
                    name: 'Pat Stephens',
                    award: 'FOTY'
                },
                {
                    year: 2003,
                    name: 'Nate Bosscher',
                    award: '1st Team'
                },
                {
                    year: 2002,
                    name: 'Xi Xia',
                    award: '1st Team'
                },
                {
                    year: 2002,
                    name: 'Dane Olsen',
                    award: 'FOTY'
                }
            ];

            /***/
        },
        /* 144 */
        /***/ function(module, exports) {
            module.exports =
                '<h1 class="ui header">Awards</h1>\n<table class="ui celled table">\n    <thead>\n        <tr>\n            <th>Year</th>\n            <th>Name</th>\n            <th>Award</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr *ngFor="let award of awardData">\n            <td>{{award.year}}</td>\n            <td>{{award.name}}</td>\n            <td>{{award.award}}</td>\n        </tr>\n    </tbody>\n</table>\n<p>*All-Freshman team added in 2013, FOTY (Freshman of the Year) given to the All-Freshman member with the most 1st place votes</p>\n<p>*Player of the year award added in 2013, POTY (Player of the Year) given to the All-Region member with the most 1st place votes</p>\n<p>*COTY (Coach of the Year) added in 2009</p>\n<p>*2nd-Team All Region added in 2009</p>\n<p>*Awards first given out in 2002</p>';

            /***/
        },
        /* 145 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(146);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 146 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([module.id, 'p{text-align:left;text-indent:0}', '']);

            // exports

            /***/
        },
        /* 147 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var results_data_1 = __webpack_require__(148);
            var ResultsComponent = (function() {
                function ResultsComponent() {
                    // Results data to inject into our template
                    this.resultData = results_data_1.RESULTS_DATA;
                }
                ResultsComponent.prototype.ngOnInit = function() {};
                return ResultsComponent;
            })();
            ResultsComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'results',
                        template: __webpack_require__(149),
                        styles: [__webpack_require__(150)]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                ResultsComponent
            );
            exports.ResultsComponent = ResultsComponent;

            /***/
        },
        /* 148 */
        /***/ function(module, exports) {
            'use strict';
            exports.RESULTS_DATA = [
                {
                    year: 2019,
                    sectionals: 'T-2nd',
                    regionals: '3rd',
                    nationals: '-',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'https://play.usaultimate.org/teams/events/Eventteam/?TeamId=wZoyiwvCg1VhUIWNi1WDaBXsR6kdOBEmTJ6iynmvlbc%3d'
                },
                {
                    year: 2018,
                    sectionals: '2nd',
                    regionals: 'T-5th',
                    nationals: '-',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'https://play.usaultimate.org/teams/events/Eventteam/?TeamId=8KdMUyGieTTE%2f5I3oGTamGGWX6SQ2mVHHrWtpy%2fdJkk%3d'
                },
                {
                    year: 2017,
                    sectionals: '2nd',
                    regionals: '6th',
                    nationals: '-',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://play.usaultimate.org/events/teams/?EventTeamId=TIUxXrZ4pDNhNi4M3QA1J%2b9D8kAdNss8Ny4JyUUuZhg%3d'
                },
                {
                    year: 2016,
                    sectionals: '3rd',
                    regionals: '3rd',
                    nationals: '-',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://play.usaultimate.org/teams/events/Eventteam/?TeamId=nQzsCO0fKbUUEFZfKJ%2fOUotd%2f1PM6wo35HPaXJEMUC8%3d'
                },
                {
                    year: 2015,
                    sectionals: '2nd',
                    regionals: '1st',
                    nationals: '13th',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://play.usaultimate.org/teams/events/Eventteam/?TeamId=T%2bV6D2XyLTlkLA%2fX2WpaiPGnYy6S3Dn%2fmcblfo08DNo%3d'
                },
                {
                    year: 2014,
                    sectionals: '1st',
                    regionals: '5th',
                    nationals: '-',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://play.usaultimate.org/teams/events/Eventteam/?TeamId=1z8hrygGYaDwJqk8F%2fmP4lOk9BD3%2fI%2bKW33IHo8qF9E%3d'
                },
                {
                    year: 2013,
                    sectionals: '1st',
                    regionals: '1st',
                    nationals: '17th',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://scores.usaultimate.org/scores/#college-open/team/1794'
                },
                {
                    year: 2012,
                    sectionals: '1st',
                    regionals: '3rd',
                    nationals: '-',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://scores.usaultimate.org/scores2012/#college-open/team/1794'
                },
                {
                    year: 2011,
                    sectionals: '1st',
                    regionals: '1st',
                    nationals: '17th',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://scores.usaultimate.org/scores2011/#college-open/team/1794'
                },
                {
                    year: 2010,
                    sectionals: '1st',
                    regionals: '1st',
                    nationals: '17th',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://scores.usaultimate.org/scores2010/#college-open/team/1794'
                },
                {
                    year: 2009,
                    sectionals: '2nd',
                    regionals: '1st',
                    nationals: '13th',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://ultimate.scorereport.net/2009/scores.cgi?div=18&page=3&team=1794'
                },
                {
                    year: 2008,
                    sectionals: '1st',
                    regionals: '2nd',
                    nationals: '5th',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://ultimate.scorereport.net/2008/scores.cgi?div=18&page=3&team=1794'
                },
                {
                    year: 2007,
                    sectionals: '2st',
                    regionals: '4th',
                    nationals: '-',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://ultimate.scorereport.net/2007/scores.cgi?div=18&page=3&team=1794'
                },
                {
                    year: 2006,
                    sectionals: '3rd',
                    regionals: '7th',
                    nationals: '-',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://ultimate.scorereport.net/2006/scores.cgi?div=18&page=3&team=1794'
                },
                {
                    year: 2005,
                    sectionals: '2st',
                    regionals: '3rd',
                    nationals: '-',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://ultimate.scorereport.net/2005/scores.cgi?div=18&page=3&team=1794'
                },
                {
                    year: 2004,
                    sectionals: '1st',
                    regionals: '2nd',
                    nationals: '17th',
                    teamPageLabel: 'USAU',
                    teamPageLink: 'http://ultimate.scorereport.net/2004/scores.cgi?div=18&page=3&team=1794'
                }
            ];

            /***/
        },
        /* 149 */
        /***/ function(module, exports) {
            module.exports =
                '<h1 class="ui header">Results</h1>\n<table class="ui celled table">\n    <thead>\n    <tr>\n        <th>Year</th>\n        <th>Sectionals</th>\n        <th>Regionals</th>\n        <th>Nationals</th>\n        <th>Team Page</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr *ngFor="let result of resultData">\n        <td>{{result.year}}</td>\n        <td>{{result.sectionals}}</td>\n        <td>{{result.regionals}}</td>\n        <td>{{result.nationals}}</td>\n        <td><a class="usau-link" target="_blank" href="{{result.teamPageLink}}">{{result.teamPageLabel}}</a></td>\n    </tr>\n    </tbody>\n</table>';

            /***/
        },
        /* 150 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(151);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 151 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([module.id, '', '']);

            // exports

            /***/
        },
        /* 152 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var platform_browser_1 = __webpack_require__(26);
            var router_1 = __webpack_require__(92);
            var team_history_component_1 = __webpack_require__(137);
            var awards_component_1 = __webpack_require__(142);
            var results_component_1 = __webpack_require__(147);
            var app_routes_1 = __webpack_require__(136);
            var HistoryModule = (function() {
                function HistoryModule() {}
                return HistoryModule;
            })();
            HistoryModule = __decorate(
                [
                    core_1.NgModule({
                        imports: [platform_browser_1.BrowserModule, router_1.RouterModule.forRoot(app_routes_1.ROUTES)],
                        declarations: [
                            team_history_component_1.TeamHistoryComponent,
                            awards_component_1.AwardsComponent,
                            results_component_1.ResultsComponent
                        ]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                HistoryModule
            );
            exports.HistoryModule = HistoryModule;

            /***/
        },
        /* 153 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var router_1 = __webpack_require__(92);
            var menu_desktop_component_1 = __webpack_require__(154);
            var menu_mobile_component_1 = __webpack_require__(160);
            var left_sidebar_component_1 = __webpack_require__(164);
            var right_sidebar_component_1 = __webpack_require__(168);
            var page_frame_component_1 = __webpack_require__(175);
            var app_routes_1 = __webpack_require__(136);
            var footer_component_1 = __webpack_require__(179);
            var PageFrameModule = (function() {
                function PageFrameModule() {}
                return PageFrameModule;
            })();
            PageFrameModule = __decorate(
                [
                    core_1.NgModule({
                        imports: [router_1.RouterModule.forRoot(app_routes_1.ROUTES)],
                        declarations: [
                            page_frame_component_1.PageFrameComponent,
                            menu_desktop_component_1.MenuDesktopComponent,
                            menu_mobile_component_1.MenuMobileComponent,
                            left_sidebar_component_1.LeftSidebarComponent,
                            right_sidebar_component_1.RightSidebarComponent,
                            footer_component_1.FooterComponent
                        ],
                        exports: [page_frame_component_1.PageFrameComponent]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                PageFrameModule
            );
            exports.PageFrameModule = PageFrameModule;

            /***/
        },
        /* 154 */
        /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ (function($) {
                'use strict';
                var __decorate =
                    (this && this.__decorate) ||
                    function(decorators, target, key, desc) {
                        var c = arguments.length,
                            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                            d;
                        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
                            r = Reflect.decorate(decorators, target, key, desc);
                        else
                            for (var i = decorators.length - 1; i >= 0; i--)
                                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                        return c > 3 && r && Object.defineProperty(target, key, r), r;
                    };
                var __metadata =
                    (this && this.__metadata) ||
                    function(k, v) {
                        if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                    };
                var core_1 = __webpack_require__(8);
                var MenuDesktopComponent = (function() {
                    function MenuDesktopComponent() {}
                    /**
                     * Initialize our mobile menu dropdown.
                     */
                    MenuDesktopComponent.prototype.ngAfterViewInit = function() {
                        $(this.teamDropdown.nativeElement).dropdown({});
                        $(this.historyDropdown.nativeElement).dropdown({});
                    };
                    return MenuDesktopComponent;
                })();
                __decorate(
                    [
                        core_1.ViewChild('teamDropdown'),
                        __metadata(
                            'design:type',
                            (typeof (_a = typeof core_1.ElementRef !== 'undefined' && core_1.ElementRef) === 'function' && _a) || Object
                        )
                    ],
                    MenuDesktopComponent.prototype,
                    'teamDropdown',
                    void 0
                );
                __decorate(
                    [
                        core_1.ViewChild('historyDropdown'),
                        __metadata(
                            'design:type',
                            (typeof (_b = typeof core_1.ElementRef !== 'undefined' && core_1.ElementRef) === 'function' && _b) || Object
                        )
                    ],
                    MenuDesktopComponent.prototype,
                    'historyDropdown',
                    void 0
                );
                MenuDesktopComponent = __decorate(
                    [
                        core_1.Component({
                            selector: 'menu-desktop',
                            template: __webpack_require__(155),
                            styles: [__webpack_require__(157)]
                        }),
                        __metadata('design:paramtypes', [])
                    ],
                    MenuDesktopComponent
                );
                exports.MenuDesktopComponent = MenuDesktopComponent;
                var _a, _b;

                /* WEBPACK VAR INJECTION */
            }.call(exports, __webpack_require__(132)));

            /***/
        },
        /* 155 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports =
                '<!--Header-->\n<div class="header">\n    <a routerLink="/home"><img class="crest" src="' +
                __webpack_require__(156) +
                '"/></a>\n    <a routerLink="/home"><h1 class="header-text">Illinois Ultimate</h1></a>\n</div>\n<!--Menu-->\n<div class="ui pointing stackable menu">\n    <a routerLink="/home"       [routerLinkActive]="[\'active\']" class="item active"><i class="home icon"></i>Home</a>\n    <a routerLink="/about"      [routerLinkActive]="[\'active\']" class="item"><i class="info icon"></i>About Us</a>\n    <a routerLink="/prospects"  [routerLinkActive]="[\'active\']" class="item"><i class="child icon"></i>Prospective Players</a>\n    <div #teamDropdown class="ui dropdown item">\n        <i class="user icon"></i>Team<i class="dropdown icon"></i>\n        <div class="menu">\n            <div routerLink="/practice"          [routerLinkActive]="[\'active\']" class="item"><i class="soccer icon"></i>Practice</div>\n            <div routerLink="/tournaments/2019"  [routerLinkActive]="[\'active\']" class="item"><i class="calendar icon"></i>Tournaments</div>\n            <div routerLink="/roster/2019"       [routerLinkActive]="[\'active\']" class="item"><i class="ordered list icon"></i>Roster</div>\n            <div routerLink="/absent"            [routerLinkActive]="[\'active\']" class="item"><i class="remove icon"></i>Absent Form</div>\n        </div>\n    </div>\n    <div #historyDropdown class="ui dropdown item">\n        <i class="fast backward icon"></i>History<i class="dropdown icon"></i>\n        <div class="menu">\n            <div routerLink="/history/2017" [routerLinkActive]="[\'active\']" class="item"><i class="undo icon"></i>Team History</div>\n            <div routerLink="/awards"       [routerLinkActive]="[\'active\']" class="item"><i class="trophy icon"></i>Awards</div>\n            <div routerLink="/results"      [routerLinkActive]="[\'active\']" class="item"><i class="archive icon"></i>Past Results</div>\n        </div>\n    </div>\n    <a href="http://www.illiniulti.blogspot.com/" target="_blank" class="item"><i class="comment icon"></i>Blog</a>\n    <a routerLink="/contact" [routerLinkActive]="[\'active\']" class="item"><i class="mail icon"></i>Contact Us</a>\n</div>\n';

            /***/
        },
        /* 156 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__.p + 'assets/crest.png';

            /***/
        },
        /* 157 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(158);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 158 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([
                module.id,
                '.header{width:100%;background-image:url(' +
                    __webpack_require__(159) +
                    ');display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.header .header-text{font-size:72px;font-family:Oswald,sans-serif;color:#ff6226;text-transform:uppercase;padding:25px;margin:0;letter-spacing:2px;text-shadow:-1px -1px 0 #fff,1px -1px 0 #fff,-1px 1px 0 #fff,1px 1px 0 #fff}.header .crest{max-height:80px;max-width:50px}.ui.menu{margin-top:0;-ms-flex-pack:center;justify-content:center;margin-bottom:20px}',
                ''
            ]);

            // exports

            /***/
        },
        /* 159 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__.p + 'assets/header-background.jpg';

            /***/
        },
        /* 160 */
        /***/ function(module, exports, __webpack_require__) {
            /* WEBPACK VAR INJECTION */ (function($) {
                'use strict';
                var __decorate =
                    (this && this.__decorate) ||
                    function(decorators, target, key, desc) {
                        var c = arguments.length,
                            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                            d;
                        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
                            r = Reflect.decorate(decorators, target, key, desc);
                        else
                            for (var i = decorators.length - 1; i >= 0; i--)
                                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                        return c > 3 && r && Object.defineProperty(target, key, r), r;
                    };
                var __metadata =
                    (this && this.__metadata) ||
                    function(k, v) {
                        if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                    };
                var core_1 = __webpack_require__(8);
                var MenuMobileComponent = (function() {
                    function MenuMobileComponent() {}
                    /**
                     * Initialize our mobile menu dropdown.
                     */
                    MenuMobileComponent.prototype.ngAfterViewInit = function() {
                        // $(this.teamDropdown.nativeElement).dropdown({});
                        // $(this.historyDropdown.nativeElement).dropdown({});
                        $(this.mobileDropdown.nativeElement).dropdown({});
                    };
                    return MenuMobileComponent;
                })();
                __decorate(
                    [
                        core_1.ViewChild('teamDropdown'),
                        __metadata(
                            'design:type',
                            (typeof (_a = typeof core_1.ElementRef !== 'undefined' && core_1.ElementRef) === 'function' && _a) || Object
                        )
                    ],
                    MenuMobileComponent.prototype,
                    'teamDropdown',
                    void 0
                );
                __decorate(
                    [
                        core_1.ViewChild('historyDropdown'),
                        __metadata(
                            'design:type',
                            (typeof (_b = typeof core_1.ElementRef !== 'undefined' && core_1.ElementRef) === 'function' && _b) || Object
                        )
                    ],
                    MenuMobileComponent.prototype,
                    'historyDropdown',
                    void 0
                );
                __decorate(
                    [
                        core_1.ViewChild('mobileDropdown'),
                        __metadata(
                            'design:type',
                            (typeof (_c = typeof core_1.ElementRef !== 'undefined' && core_1.ElementRef) === 'function' && _c) || Object
                        )
                    ],
                    MenuMobileComponent.prototype,
                    'mobileDropdown',
                    void 0
                );
                MenuMobileComponent = __decorate(
                    [
                        core_1.Component({
                            selector: 'menu-mobile',
                            template: __webpack_require__(161),
                            styles: [__webpack_require__(162)]
                        }),
                        __metadata('design:paramtypes', [])
                    ],
                    MenuMobileComponent
                );
                exports.MenuMobileComponent = MenuMobileComponent;
                var _a, _b, _c;

                /* WEBPACK VAR INJECTION */
            }.call(exports, __webpack_require__(132)));

            /***/
        },
        /* 161 */
        /***/ function(module, exports) {
            module.exports =
                '<!--Header/Menu-->\n<div class="header">\n    <div #mobileDropdown class="ui inline dropdown">\n        <h1 class="header-text">Illinois Ultimate</h1>\n        <i class="dropdown icon"></i>\n        <div class="menu">\n            <a routerLink="/home"               [routerLinkActive]="[\'active\']" class="item"><i class="home icon"></i>Home</a>\n            <a routerLink="/about"              [routerLinkActive]="[\'active\']" class="item"><i class="info icon"></i>About Us</a>\n            <a routerLink="/prospects"          [routerLinkActive]="[\'active\']" class="item"><i class="child icon"></i>Prospective Players</a>\n            <a routerLink="/practice"           [routerLinkActive]="[\'active\']" class="item"><i class="soccer icon"></i>Practice</a>\n            <a routerLink="/tournaments/2019"   [routerLinkActive]="[\'active\']" class="item"><i class="calendar icon"></i>Tournaments</a>\n            <a routerLink="/roster/2019"        [routerLinkActive]="[\'active\']" class="item"><i class="ordered list icon"></i>Roster</a>\n            <a routerLink="/absent"             [routerLinkActive]="[\'active\']" class="item"><i class="remove icon"></i>Absent Form</a>\n            <a routerLink="/history/2017"       [routerLinkActive]="[\'active\']" class="item"><i class="undo icon"></i>Team History</a>\n            <a routerLink="/awards"             [routerLinkActive]="[\'active\']" class="item"><i class="trophy icon"></i>Awards</a>\n            <a routerLink="/results"            [routerLinkActive]="[\'active\']" class="item"><i class="archive icon"></i>Past Results</a>\n            <a routerLink="/blog"               [routerLinkActive]="[\'active\']" class="item"><i class="comment icon"></i>Blog</a>\n            <a routerLink="/contact"            [routerLinkActive]="[\'active\']" class="item"><i class="mail icon"></i>Contact Us</a>\n        </div>\n    </div>\n</div>\n';

            /***/
        },
        /* 162 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(163);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 163 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([
                module.id,
                '.header{width:100%;background-image:url(' +
                    __webpack_require__(159) +
                    ');display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;margin-bottom:20px}.header .ui.dropdown{text-align:center}.header .header-text{font-size:72px;font-family:Oswald,sans-serif;color:#ff6226;text-transform:uppercase;padding:10px;margin:0;letter-spacing:2px;text-shadow:-1px -1px 0 #fff,1px -1px 0 #fff,-1px 1px 0 #fff,1px 1px 0 #fff}.header .dropdown.icon{font-size:20px;color:#fff}.header .menu{width:100%}',
                ''
            ]);

            // exports

            /***/
        },
        /* 164 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var LeftSidebarComponent = (function() {
                function LeftSidebarComponent() {}
                LeftSidebarComponent.prototype.ngAfterViewInit = function() {
                    this.initializeTwitterWidget();
                };
                /**
                 * Twitter script for initializing our Twitter Timeline widget
                 */
                LeftSidebarComponent.prototype.initializeTwitterWidget = function() {
                    !(function(d, s, id) {
                        var js,
                            fjs = d.getElementsByTagName(s)[0],
                            p = 'https';
                        if (!d.getElementById(id)) {
                            js = d.createElement(s);
                            js.id = id;
                            js.src = p + '://platform.twitter.com/widgets.js';
                            fjs.parentNode.insertBefore(js, fjs);
                        }
                    })(document, 'script', 'twitter-wjs');
                };
                return LeftSidebarComponent;
            })();
            LeftSidebarComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'left-sidebar',
                        template: __webpack_require__(165),
                        styles: [__webpack_require__(166)]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                LeftSidebarComponent
            );
            exports.LeftSidebarComponent = LeftSidebarComponent;

            /***/
        },
        /* 165 */
        /***/ function(module, exports) {
            module.exports =
                '<div class="ui segment twitter-sidebar">\n    <a class="twitter-timeline" height="500px" href="https://twitter.com/illinimensulti" data-widget-id="605414836369883136">Tweets by @IlliniUlti</a>\n</div>\n';

            /***/
        },
        /* 166 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(167);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 167 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([module.id, '.twitter-sidebar{padding:0;max-width:200px;margin-left:auto;margin-right:auto}', '']);

            // exports

            /***/
        },
        /* 168 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var RightSidebarComponent = (function() {
                function RightSidebarComponent() {}
                RightSidebarComponent.prototype.ngOnInit = function() {};
                return RightSidebarComponent;
            })();
            RightSidebarComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'right-sidebar',
                        template: __webpack_require__(169),
                        styles: [__webpack_require__(173)]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                RightSidebarComponent
            );
            exports.RightSidebarComponent = RightSidebarComponent;

            /***/
        },
        /* 169 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports =
                '<!--Paypal Sidebar-->\n<div class="ui segment paypal-sidebar">\n    <h2 class="ui header">Help Out Illinois Ultimate!</h2>\n\n    <p>Illinois Ultimate is mostly student-funded, help us out by donating!</p>\n    <a href="https://www.paypal.me/illinoisUltimate" target="_blank">\n        <img class="paypal-donate hvr-grow" src="' +
                __webpack_require__(170) +
                '"/>\n    </a>\n</div>\n<!--Social Media Icons-->\n<a href="https://www.facebook.com/IllinoisUltimate" target="_blank">\n    <img class="social-media-button hvr-sink" src="' +
                __webpack_require__(171) +
                '"/>\n</a>\n<a href="https://twitter.com/illiniulti" target="_blank">\n    <img class="social-media-button hvr-sink" src="' +
                __webpack_require__(172) +
                '"/>\n</a>';

            /***/
        },
        /* 170 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__.p + 'assets/paypal-donate.png';

            /***/
        },
        /* 171 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__.p + 'assets/facebook-button.png';

            /***/
        },
        /* 172 */
        /***/ function(module, exports, __webpack_require__) {
            module.exports = __webpack_require__.p + 'assets/twitter-button.png';

            /***/
        },
        /* 173 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(174);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 174 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([
                module.id,
                '.paypal-sidebar{max-width:200px;margin-left:auto;margin-right:auto}.paypal-sidebar p{text-indent:0;margin-bottom:0;padding-top:15px;padding-bottom:15px}.paypal-donate{width:100px}.ui.header{margin-bottom:0}.social-media-button{width:40%;max-width:70px;display:inline-block;margin:3px;box-shadow:0 1px 2px 0 rgba(34,36,38,.15);border-radius:.28571429em}',
                ''
            ]);

            // exports

            /***/
        },
        /* 175 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var PageFrameComponent = (function() {
                function PageFrameComponent() {}
                PageFrameComponent.prototype.ngOnInit = function() {};
                return PageFrameComponent;
            })();
            PageFrameComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'page-frame',
                        template: __webpack_require__(176),
                        styles: [__webpack_require__(177)]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                PageFrameComponent
            );
            exports.PageFrameComponent = PageFrameComponent;

            /***/
        },
        /* 176 */
        /***/ function(module, exports) {
            module.exports =
                '<!--Header-->\n<menu-desktop class="menu-desktop"></menu-desktop>\n<menu-mobile class="menu-mobile"></menu-mobile>\n\n<!--Content-->\n<div class="main-container">\n    <div class="left-sidebar">\n        <left-sidebar></left-sidebar>\n    </div>\n    <div class="main-content">\n        <router-outlet></router-outlet>\n    </div>\n    <div class="right-sidebar">\n        <right-sidebar></right-sidebar>\n    </div>\n    <footer></footer>\n</div>';

            /***/
        },
        /* 177 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(178);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 178 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([
                module.id,
                '.left-sidebar,.menu-desktop,.right-sidebar{display:none}.main-container{margin-bottom:50px}@media screen and (min-width:768px){.main-container{display:-ms-flexbox;display:flex}.menu-mobile{display:none}.left-sidebar,.menu-desktop,.right-sidebar{display:block}.main-content{padding:0 10px;width:100%}.left-sidebar{margin-left:10px;-ms-flex:0 0 200px;flex:0 0 200px}.right-sidebar{margin-right:10px;margin-left:auto;-ms-flex:0 0 150px;flex:0 0 150px}}@media screen and (min-width:1024px){.main-content{padding:0 30px}.left-sidebar{margin-left:50px}.right-sidebar{margin-right:50px;-ms-flex:0 0 200px;flex:0 0 200px}}@media screen and (min-width:1280px){.main-content{padding:0 50px}.left-sidebar{margin-left:80px}.right-sidebar{margin-right:80px}}',
                ''
            ]);

            // exports

            /***/
        },
        /* 179 */
        /***/ function(module, exports, __webpack_require__) {
            'use strict';
            var __decorate =
                (this && this.__decorate) ||
                function(decorators, target, key, desc) {
                    var c = arguments.length,
                        r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
                        d;
                    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
                    else
                        for (var i = decorators.length - 1; i >= 0; i--)
                            if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                    return c > 3 && r && Object.defineProperty(target, key, r), r;
                };
            var __metadata =
                (this && this.__metadata) ||
                function(k, v) {
                    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
                };
            var core_1 = __webpack_require__(8);
            var FooterComponent = (function() {
                function FooterComponent() {}
                FooterComponent.prototype.ngAfterViewInit = function() {};
                return FooterComponent;
            })();
            FooterComponent = __decorate(
                [
                    core_1.Component({
                        selector: 'footer',
                        template: __webpack_require__(180),
                        styles: [__webpack_require__(181)]
                    }),
                    __metadata('design:paramtypes', [])
                ],
                FooterComponent
            );
            exports.FooterComponent = FooterComponent;

            /***/
        },
        /* 180 */
        /***/ function(module, exports) {
            module.exports =
                '<div class="ui menu">\n    <p>For support or to report website issues, email the admin at wcjphoenix@gmail.com or the creator at nick.prozorovsky@gmail.com</p>\n</div>';

            /***/
        },
        /* 181 */
        /***/ function(module, exports, __webpack_require__) {
            // css-to-string-loader: transforms styles from css-loader to a string output

            // Get the styles
            var styles = __webpack_require__(182);

            if (typeof styles === 'string') {
                // Return an existing string
                module.exports = styles;
            } else {
                // Call the custom toString method from css-loader module
                module.exports = styles.toString();
            }

            /***/
        },
        /* 182 */
        /***/ function(module, exports, __webpack_require__) {
            exports = module.exports = __webpack_require__(39)();
            // imports

            // module
            exports.push([
                module.id,
                '.ui.menu{position:fixed;right:0;bottom:0;left:0;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}p{margin:0 auto;font-size:10px}@media screen and (min-width:768px){p{font-size:12px}}',
                ''
            ]);

            // exports

            /***/
        }
    ]
);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2hvbWUvaG9tZS5qcGciLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmxlc3M/ODc5ZCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvYWJvdXQvYWJvdXQuY29tcG9uZW50Lmxlc3M/MWRjZCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcHJvc3BlY3RpdmUtcGxheWVycy9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2dsb2JhbC9zZXJ2aWNlL2dvb2dsZS1zcHJlYWRzaGVldC5zZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvZ2xvYmFsL3V0aWwvZ3RtLnV0aWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50Lmxlc3M/NzkyZSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3Byb3NwZWN0aXZlLXBsYXllcnMvcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50Lmxlc3M/NzI2ZSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9zaGFyZWQtc3R5bGUvc3R5bGVzLmNzcz9lZTQ5Iiwid2VicGFjazovLy8uL3NyYy9hcHAvc2hhcmVkLXN0eWxlL3N0eWxlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2dsb2JhbC9iYWNrZ3JvdW5kLmpwZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5jb21wb25lbnQubGVzcz8wOWY0Iiwid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90ZWFtLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9tYXBzLWFwaS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL2NpcmNsZS1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9tYXJrZXItbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFuYWdlcnMvcG9seWdvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9rbWwtbGF5ZXItbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWNpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWluZm8td2luZG93LmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAta21sLWxheWVyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtbWFya2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbGF6eS1tYXBzLWFwaS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3V0aWxzL2Jyb3dzZXItZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL25vb3AtbWFwcy1hcGktbG9hZGVyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9jb3JlLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcHJhY3RpY2UvcHJhY3RpY2UuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9kYXRhL3ByYWN0aWNlLmRhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC90ZWFtL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9wcmFjdGljZS5jb21wb25lbnQubGVzcz9lOWY3Iiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9wcmFjdGljZS5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vdG91cm5hbWVudHMvdG91cm5hbWVudHMuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy9kYXRhL3RvdXJuYW1lbnRzLmRhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC90ZWFtL3RvdXJuYW1lbnRzL3RvdXJuYW1lbnRzLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzcz81NmYyIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9kYXRhL3Jvc3RlcnMuZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQubGVzcz85MDNiIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9yb3N0ZXIvcm9zdGVyLmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQubGVzcz9mYTc1Iiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLnJvdXRlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hpc3RvcnkvdGVhbS1oaXN0b3J5L3RlYW0taGlzdG9yeS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L3RlYW0taGlzdG9yeS9kYXRhL2hpc3RvcnkteWVhci5kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5sZXNzPzBjNmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L3RlYW0taGlzdG9yeS90ZWFtLWhpc3RvcnkuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L2F3YXJkcy9hd2FyZHMuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvZGF0YS9hd2FyZHMuZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQubGVzcz9iODY2Iiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvYXdhcmRzLmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL2RhdGEvcmVzdWx0cy5kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L3Jlc3VsdHMvcmVzdWx0cy5jb21wb25lbnQubGVzcz9hMTcyIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L2hpc3RvcnkubW9kdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9wYWdlLWZyYW1lLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1kZXNrdG9wL21lbnUtZGVza3RvcC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbWVudS9jcmVzdC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50Lmxlc3M/MDMxOCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1kZXNrdG9wL21lbnUtZGVza3RvcC5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9tZW51L2hlYWRlci1iYWNrZ3JvdW5kLmpwZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9tZW51LW1vYmlsZS9tZW51LW1vYmlsZS5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3M/MWU3YiIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzPzhiY2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvcGF5cGFsLWRvbmF0ZS5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL2ZhY2Vib29rLWJ1dHRvbi5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL3R3aXR0ZXItYnV0dG9uLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcmlnaHQtc2lkZWJhci9yaWdodC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzPzA5NTMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmxlc3M/ZGM4MiIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvZm9vdGVyL2Zvb3Rlci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50Lmxlc3M/MDM1NSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvZm9vdGVyL2Zvb3Rlci5jb21wb25lbnQubGVzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLHlEQUEyRTtBQUMzRSxxQ0FBK0M7QUFFL0MsNENBQTZDO0FBQzdDOztHQUVFO0FBRUYsc0ZBQXFGO0FBQ3JGLEdBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDN0IscUJBQWMsRUFBRSxDQUFDO0FBQ3JCLEVBQUM7QUFDRCxhQUFZO0FBQ1osa0RBQXNCLEVBQUUsQ0FBQyxlQUFlLENBQUMsc0JBQVMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNicEQscUNBQXlDO0FBQ3pDLHdDQUF5RTtBQUN6RSxrREFBMEQ7QUFDMUQsc0NBQTJDO0FBQzNDLHVDQUE2QztBQUc3Qyxn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QWMsZUFBZSxjQUFjLGlCQUFpQixlQUFlLG1CQUFtQjs7QUFFbndCOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1BBLHFDQUF5RDtBQU96RDtLQUFBO0tBRUEsQ0FBQztLQURHLHlDQUFlLEdBQWYsY0FBeUIsQ0FBQztLQUM5QixzQkFBQztBQUFELEVBQUM7QUFGRDtLQUxDLGdCQUFTLENBQUM7U0FDUCxRQUFRLEVBQUUsUUFBUTtTQUNsQixRQUFRLEVBQUUsbUJBQU8sQ0FBQyxHQUF5QixDQUFDO1NBQzVDLE1BQU0sRUFBRSxDQUFDLG1CQUFPLENBQUMsR0FBeUIsQ0FBQyxDQUFDO01BQy9DLENBQUM7O29CQUdEO0FBRlksMENBQWU7Ozs7Ozs7QUNQNUIsOEw7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQSxFOzs7Ozs7QUNYQTtBQUNBOzs7QUFHQTtBQUNBLG9DQUFtQyxlQUFlLFFBQVEsU0FBUyxPQUFPLG9CQUFvQixhQUFhLHNCQUFzQixtQkFBbUIsRUFBRSxjQUFjLGVBQWUsb0NBQW9DLEVBQUUsZ0JBQWdCOztBQUV6TyIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbmltcG9ydCB7IGVuYWJsZVByb2RNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFwcE1vZHVsZSB9IGZyb20gJy4vYXBwL2FwcC5tb2R1bGUnO1xuLypcbiBPdXIgYXBwbGljYXRpb24gY29kZVxuKi9cblxuLy8gVHVybnMgb2ZmIGFzc2VydGlvbnMgYW5kIG90aGVyIGNoZWNrcyB3aXRoaW4gdGhlIGZyYW1ld29yayBpZiB3ZSBhcmUgaW4gcHJvZHVjdGlvblxuaWYgKHByb2Nlc3MuZW52LkVOViA9PT0gJ3Byb2QnKSB7XG4gICAgZW5hYmxlUHJvZE1vZGUoKTtcbn1cbi8vIEJvb3RzdHJhcFxucGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvbWFpbi50cyIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIYXNoTG9jYXRpb25TdHJhdGVneSwgTG9jYXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBIdHRwTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvaHR0cCc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEFnbUNvcmVNb2R1bGUgfSBmcm9tICdhbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlJztcblxuaW1wb3J0IHsgSG9tZUNvbXBvbmVudCB9IGZyb20gJy4vaG9tZS9ob21lLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBBYm91dENvbXBvbmVudCB9IGZyb20gJy4vYWJvdXQvYWJvdXQuY29tcG9uZW50JztcbmltcG9ydCB7IFByb3NwZWN0aXZlUGxheWVyc0NvbXBvbmVudCB9IGZyb20gJy4vcHJvc3BlY3RpdmUtcGxheWVycy9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb250YWN0Q29tcG9uZW50IH0gZnJvbSAnLi9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50JztcbmltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IFRlYW1Nb2R1bGUgfSBmcm9tICcuL3RlYW0vdGVhbS5tb2R1bGUnO1xuaW1wb3J0IHsgSGlzdG9yeU1vZHVsZSB9IGZyb20gJy4vaGlzdG9yeS9oaXN0b3J5Lm1vZHVsZSc7XG5pbXBvcnQgeyBQYWdlRnJhbWVNb2R1bGUgfSBmcm9tICcuL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQnJvd3Nlck1vZHVsZSxcbiAgICAgICAgSHR0cE1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIC8vIEFnbUNvcmVNb2R1bGUuZm9yUm9vdCh7XG4gICAgICAgIC8vICAgICBhcGlLZXk6ICdBSXphU3lCUklYQWs1eGR2bjNlenlwc1NlNTVmOGRaaGNIaGVBWjgnXG4gICAgICAgIC8vIH0pLFxuICAgICAgICBQYWdlRnJhbWVNb2R1bGUsXG4gICAgICAgIFRlYW1Nb2R1bGUsXG4gICAgICAgIEhpc3RvcnlNb2R1bGVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudCwgSG9tZUNvbXBvbmVudCwgQWJvdXRDb21wb25lbnQsIFByb3NwZWN0aXZlUGxheWVyc0NvbXBvbmVudCwgQ29udGFjdENvbXBvbmVudF0sXG4gICAgLy8gVXNlIGhhc2ggc3RyYXRlZ3kgc28gcGFnZSByZWZyZXNoZXMgb24gR2l0aHViIHBhZ2VzIHJvdXRlIGNvcnJlY3RseVxuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTG9jYXRpb25TdHJhdGVneSwgdXNlQ2xhc3M6IEhhc2hMb2NhdGlvblN0cmF0ZWd5IH1dLFxuICAgIGJvb3RzdHJhcDogW0FwcENvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvYXBwLm1vZHVsZS50cyIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Mi4yLjRcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9yL3RvUHJvbWlzZScpLCByZXF1aXJlKCdyeGpzL1N1YmplY3QnKSwgcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyksIHJlcXVpcmUoJ3J4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJywgJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJywgJ3J4anMvU3ViamVjdCcsICdyeGpzL09ic2VydmFibGUnLCAncnhqcy9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuZm9ybXMgPSBnbG9iYWwubmcuZm9ybXMgfHwge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUngsZ2xvYmFsLlJ4LGdsb2JhbC5SeC5PYnNlcnZhYmxlKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUscnhqc19vcGVyYXRvcl90b1Byb21pc2Uscnhqc19TdWJqZWN0LHJ4anNfT2JzZXJ2YWJsZSxyeGpzX29ic2VydmFibGVfZnJvbVByb21pc2UpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGNvbnRyb2wgZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIE9ubHkgdXNlZCBpbnRlcm5hbGx5IGluIHRoZSBmb3JtcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbHVlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbGlkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbGlkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImludmFsaWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuaW52YWxpZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwZW5kaW5nXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnBlbmRpbmcgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXJyb3JzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmVycm9ycyA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwcmlzdGluZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5wcmlzdGluZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXJ0eVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5kaXJ0eSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b3VjaGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnRvdWNoZWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidW50b3VjaGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnVudG91Y2hlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5kaXNhYmxlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmVuYWJsZWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3RhdHVzQ2hhbmdlc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5zdGF0dXNDaGFuZ2VzIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC52YWx1ZUNoYW5nZXMgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2wucmVzZXQodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLmhhc0Vycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5oYXNFcnJvcihlcnJvckNvZGUsIHBhdGgpIDogZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmdldEVycm9yKGVycm9yQ29kZSwgcGF0aCkgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBkaXJlY3RpdmUgdGhhdCBjb250YWlucyBtdWx0aXBsZSB7QGxpbmsgTmdDb250cm9sfXMuXG4gICAgICpcbiAgICAgKiBPbmx5IHVzZWQgYnkgdGhlIGZvcm1zIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29udHJvbENvbnRhaW5lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKENvbnRyb2xDb250YWluZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENvbnRyb2xDb250YWluZXIoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udHJvbENvbnRhaW5lci5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgZm9ybSB0byB3aGljaCB0aGlzIGNvbnRhaW5lciBiZWxvbmdzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udHJvbENvbnRhaW5lci5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgcGF0aCB0byB0aGlzIGNvbnRhaW5lci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIENvbnRyb2xDb250YWluZXI7XG4gICAgfShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUpKTtcblxuICAgIGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqID09IG51bGw7XG4gICAgfVxuICAgIC8vIEpTIGhhcyBOYU4gIT09IE5hTlxuICAgIGZ1bmN0aW9uIGxvb3NlSWRlbnRpY2FsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgfHwgdHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiBpc05hTihhKSAmJiBpc05hTihiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgICAgIHJldHVybiBvICE9PSBudWxsICYmICh0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbyA9PT0gJ29iamVjdCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgICAgICAgcmV0dXJuICFpc0pzT2JqZWN0KG9iaik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgSmF2YXNjcmlwdCBPYmplY3RzXG4gICAgICovXG4gICAgdmFyIFN0cmluZ01hcFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTdHJpbmdNYXBXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIubWVyZ2UgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKG0xKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBtW2tdID0gbTFba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gT2JqZWN0LmtleXMobTIpOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIG1ba10gPSBtMltrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICAgIHZhciBrMSA9IE9iamVjdC5rZXlzKG0xKTtcbiAgICAgICAgICAgIHZhciBrMiA9IE9iamVjdC5rZXlzKG0yKTtcbiAgICAgICAgICAgIGlmIChrMS5sZW5ndGggIT0gazIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrMVtpXTtcbiAgICAgICAgICAgICAgICBpZiAobTFba2V5XSAhPT0gbTJba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTdHJpbmdNYXBXcmFwcGVyO1xuICAgIH0oKSk7XG4gICAgdmFyIExpc3RXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTGlzdFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQWxsID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmZsYXR0ZW4gPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uIChmbGF0LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZsYXRJdGVtID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IExpc3RXcmFwcGVyLmZsYXR0ZW4oaXRlbSkgOiBpdGVtO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0LmNvbmNhdChmbGF0SXRlbSk7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaXN0V3JhcHBlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIGlzUHJvbWlzZSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5pc1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBpc0VtcHR5SW5wdXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXJzIGZvciB2YWxpZGF0b3JzIHRvIGJlIHVzZWQgZm9yIHtAbGluayBGb3JtQ29udHJvbH1zIGluIGEgZm9ybS5cbiAgICAgKlxuICAgICAqIFByb3ZpZGUgdGhpcyB1c2luZyBgbXVsdGk6IHRydWVgIHRvIGFkZCB2YWxpZGF0b3JzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2Zvcm1zL3RzL25nX3ZhbGlkYXRvcnMvbmdfdmFsaWRhdG9ycy50cyByZWdpb249J25nX3ZhbGlkYXRvcnMnfVxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTkdfVkFMSURBVE9SUyA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdOZ1ZhbGlkYXRvcnMnKTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcnMgZm9yIGFzeW5jaHJvbm91cyB2YWxpZGF0b3JzIHRvIGJlIHVzZWQgZm9yIHtAbGluayBGb3JtQ29udHJvbH1zXG4gICAgICogaW4gYSBmb3JtLlxuICAgICAqXG4gICAgICogUHJvdmlkZSB0aGlzIHVzaW5nIGBtdWx0aTogdHJ1ZWAgdG8gYWRkIHZhbGlkYXRvcnMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIE5HX1ZBTElEQVRPUlN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5HX0FTWU5DX1ZBTElEQVRPUlMgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignTmdBc3luY1ZhbGlkYXRvcnMnKTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHNldCBvZiB2YWxpZGF0b3JzIHVzZWQgYnkgZm9ybSBjb250cm9scy5cbiAgICAgKlxuICAgICAqIEEgdmFsaWRhdG9yIGlzIGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgYSB7QGxpbmsgRm9ybUNvbnRyb2x9IG9yIGNvbGxlY3Rpb24gb2ZcbiAgICAgKiBjb250cm9scyBhbmQgcmV0dXJucyBhIG1hcCBvZiBlcnJvcnMuIEEgbnVsbCBtYXAgbWVhbnMgdGhhdCB2YWxpZGF0aW9uIGhhcyBwYXNzZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHZhciBsb2dpbkNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woXCJcIiwgVmFsaWRhdG9ycy5yZXF1aXJlZClcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVmFsaWRhdG9ycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZhbGlkYXRvcnMoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIGNvbnRyb2xzIHRvIGhhdmUgYSBub24tZW1wdHkgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLnJlcXVpcmVkID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSA/IHsgJ3JlcXVpcmVkJzogdHJ1ZSB9IDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIGNvbnRyb2xzIHRvIGhhdmUgYSB2YWx1ZSBvZiBhIG1pbmltdW0gbGVuZ3RoLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5taW5MZW5ndGggPSBmdW5jdGlvbiAobWluTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUoY29udHJvbC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHZhbGlkYXRlIGVtcHR5IHZhbHVlcyB0byBhbGxvdyBvcHRpb25hbCBjb250cm9sc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdHlwZW9mIGNvbnRyb2wudmFsdWUgPT09ICdzdHJpbmcnID8gY29udHJvbC52YWx1ZS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggPCBtaW5MZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICB7ICdtaW5sZW5ndGgnOiB7ICdyZXF1aXJlZExlbmd0aCc6IG1pbkxlbmd0aCwgJ2FjdHVhbExlbmd0aCc6IGxlbmd0aCB9IH0gOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIGNvbnRyb2xzIHRvIGhhdmUgYSB2YWx1ZSBvZiBhIG1heGltdW0gbGVuZ3RoLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5tYXhMZW5ndGggPSBmdW5jdGlvbiAobWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdHlwZW9mIGNvbnRyb2wudmFsdWUgPT09ICdzdHJpbmcnID8gY29udHJvbC52YWx1ZS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggPiBtYXhMZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICB7ICdtYXhsZW5ndGgnOiB7ICdyZXF1aXJlZExlbmd0aCc6IG1heExlbmd0aCwgJ2FjdHVhbExlbmd0aCc6IGxlbmd0aCB9IH0gOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIGEgY29udHJvbCB0byBtYXRjaCBhIHJlZ2V4IHRvIGl0cyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMucGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnMubnVsbFZhbGlkYXRvcjtcbiAgICAgICAgICAgIHZhciByZWdleDtcbiAgICAgICAgICAgIHZhciByZWdleFN0cjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWdleFN0ciA9IFwiXlwiICsgcGF0dGVybiArIFwiJFwiO1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWdleFN0ciA9IHBhdHRlcm4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICByZWdleCA9IHBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUoY29udHJvbC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHZhbGlkYXRlIGVtcHR5IHZhbHVlcyB0byBhbGxvdyBvcHRpb25hbCBjb250cm9sc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250cm9sLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKSA/IG51bGwgOlxuICAgICAgICAgICAgICAgICAgICB7ICdwYXR0ZXJuJzogeyAncmVxdWlyZWRQYXR0ZXJuJzogcmVnZXhTdHIsICdhY3R1YWxWYWx1ZSc6IHZhbHVlIH0gfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOby1vcCB2YWxpZGF0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLm51bGxWYWxpZGF0b3IgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBvc2UgbXVsdGlwbGUgdmFsaWRhdG9ycyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdW5pb25cbiAgICAgICAgICogb2YgdGhlIGluZGl2aWR1YWwgZXJyb3IgbWFwcy5cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMuY29tcG9zZSA9IGZ1bmN0aW9uICh2YWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRvcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgcHJlc2VudFZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzLmZpbHRlcihpc1ByZXNlbnQpO1xuICAgICAgICAgICAgaWYgKHByZXNlbnRWYWxpZGF0b3JzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9tZXJnZUVycm9ycyhfZXhlY3V0ZVZhbGlkYXRvcnMoY29udHJvbCwgcHJlc2VudFZhbGlkYXRvcnMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jID0gZnVuY3Rpb24gKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdG9ycylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciBwcmVzZW50VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMuZmlsdGVyKGlzUHJlc2VudCk7XG4gICAgICAgICAgICBpZiAocHJlc2VudFZhbGlkYXRvcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBfZXhlY3V0ZUFzeW5jVmFsaWRhdG9ycyhjb250cm9sLCBwcmVzZW50VmFsaWRhdG9ycykubWFwKF9jb252ZXJ0VG9Qcm9taXNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oX21lcmdlRXJyb3JzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWYWxpZGF0b3JzO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gX2NvbnZlcnRUb1Byb21pc2Uob2JqKSB7XG4gICAgICAgIHJldHVybiBpc1Byb21pc2Uob2JqKSA/IG9iaiA6IHJ4anNfb3BlcmF0b3JfdG9Qcm9taXNlLnRvUHJvbWlzZS5jYWxsKG9iaik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9leGVjdXRlVmFsaWRhdG9ycyhjb250cm9sLCB2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdihjb250cm9sKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9leGVjdXRlQXN5bmNWYWxpZGF0b3JzKGNvbnRyb2wsIHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcnMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2KGNvbnRyb2wpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX21lcmdlRXJyb3JzKGFycmF5T2ZFcnJvcnMpIHtcbiAgICAgICAgdmFyIHJlcyA9IGFycmF5T2ZFcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChlcnJvcnMpID8gU3RyaW5nTWFwV3JhcHBlci5tZXJnZShyZXMsIGVycm9ycykgOiByZXM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlcykubGVuZ3RoID09PSAwID8gbnVsbCA6IHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHByb3ZpZGUgYSB7QGxpbmsgQ29udHJvbFZhbHVlQWNjZXNzb3J9IGZvciBmb3JtIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBEZWZhdWx0VmFsdWVBY2Nlc3Nvcn0gZm9yIGhvdyB0byBpbXBsZW1lbnQgb25lLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTkdfVkFMVUVfQUNDRVNTT1IgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignTmdWYWx1ZUFjY2Vzc29yJyk7XG5cbiAgICB2YXIgQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyBvbiBhIGNoZWNrYm94IGlucHV0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgKiAgYGBgXG4gICAgICogIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuYW1lPVwicmVtZW1iZXJMb2dpblwiIG5nTW9kZWw+XG4gICAgICogIGBgYFxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdjaGVja2VkJywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1jaGVja2JveF1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPWNoZWNrYm94XVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1jaGVja2JveF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC5jaGVja2VkKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgREVGQVVMVF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVmYXVsdFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgdGhhdCBpcyB1c2VkIGJ5IHRoZVxuICAgICAqIHtAbGluayBOZ01vZGVsfSwge0BsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfSwgYW5kIHtAbGluayBGb3JtQ29udHJvbE5hbWV9IGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgKiAgYGBgXG4gICAgICogIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJzZWFyY2hRdWVyeVwiIG5nTW9kZWw+XG4gICAgICogIGBgYFxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRGVmYXVsdFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWZhdWx0VmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbZm9ybUNvbnRyb2xOYW1lXSx0ZXh0YXJlYVtmb3JtQ29udHJvbE5hbWVdLGlucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW2Zvcm1Db250cm9sXSx0ZXh0YXJlYVtmb3JtQ29udHJvbF0saW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbbmdNb2RlbF0sdGV4dGFyZWFbbmdNb2RlbF0sW25nRGVmYXVsdENvbnRyb2xdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHZzYXZraW4gcmVwbGFjZSB0aGUgYWJvdmUgc2VsZWN0b3Igd2l0aCB0aGUgb25lIGJlbG93IGl0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzMwMTEgaXMgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yOiAnW25nQ29udHJvbF0sW25nTW9kZWxdLFtuZ0Zvcm1Db250cm9sXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoaW5wdXQpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0RFRkFVTFRfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgICAgICBpZiAodmFsaWRhdG9yLnZhbGlkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHZhbGlkYXRvci52YWxpZGF0ZShjKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQXN5bmNWYWxpZGF0b3IodmFsaWRhdG9yKSB7XG4gICAgICAgIGlmICh2YWxpZGF0b3IudmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gdmFsaWRhdG9yLnZhbGlkYXRlKGMpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBOVU1CRVJfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE51bWJlclZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgbnVtYmVyIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyB0aGF0IGlzIHVzZWQgYnkgdGhlXG4gICAgICoge0BsaW5rIE5nTW9kZWx9LCB7QGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge0BsaW5rIEZvcm1Db250cm9sTmFtZX0gZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAqICBgYGBcbiAgICAgKiAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBbKG5nTW9kZWwpXT1cImFnZVwiPlxuICAgICAqICBgYGBcbiAgICAgKi9cbiAgICB2YXIgTnVtYmVyVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE51bWJlclZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBuZWVkcyB0byBiZSBub3JtYWxpemVkIGZvciBJRTksIG90aGVyd2lzZSBpdCBpcyBzZXQgdG8gJ251bGwnIHdoZW4gbnVsbFxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbm9ybWFsaXplZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBmbih2YWx1ZSA9PSAnJyA/IG51bGwgOiBwYXJzZUZsb2F0KHZhbHVlKSk7IH07XG4gICAgICAgIH07XG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9bnVtYmVyXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9bnVtYmVyXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1udW1iZXJdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW05VTUJFUl9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBOdW1iZXJWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdW5pbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgYmFzZSBjbGFzcyB0aGF0IGFsbCBjb250cm9sIGRpcmVjdGl2ZSBleHRlbmQuXG4gICAgICogSXQgYmluZHMgYSB7QGxpbmsgRm9ybUNvbnRyb2x9IG9iamVjdCB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogVXNlZCBpbnRlcm5hbGx5IGJ5IEFuZ3VsYXIgZm9ybXMuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nQ29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQyKE5nQ29udHJvbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdDb250cm9sKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9yYXdWYWxpZGF0b3JzID0gW107XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDb250cm9sLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBOZ0NvbnRyb2w7XG4gICAgfShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUpKTtcblxuICAgIHZhciBSQURJT19WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjbGFzcyB1c2VkIGJ5IEFuZ3VsYXIgdG8gdW5jaGVjayByYWRpbyBidXR0b25zIHdpdGggdGhlIG1hdGNoaW5nIG5hbWUuXG4gICAgICovXG4gICAgdmFyIFJhZGlvQ29udHJvbFJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmFkaW9Db250cm9sUmVnaXN0cnkoKSB7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNvbnRyb2wsIGFjY2Vzc29yKSB7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvcnMucHVzaChbY29udHJvbCwgYWNjZXNzb3JdKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChhY2Nlc3Nvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX2FjY2Vzc29ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY2Nlc3NvcnNbaV1bMV0gPT09IGFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjY2Vzc29ycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvcnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNTYW1lR3JvdXAoYywgYWNjZXNzb3IpICYmIGNbMV0gIT09IGFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNbMV0uZmlyZVVuY2hlY2soYWNjZXNzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUuX2lzU2FtZUdyb3VwID0gZnVuY3Rpb24gKGNvbnRyb2xQYWlyLCBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgaWYgKCFjb250cm9sUGFpclswXS5jb250cm9sKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sUGFpclswXS5fcGFyZW50ID09PSBhY2Nlc3Nvci5fY29udHJvbC5fcGFyZW50ICYmXG4gICAgICAgICAgICAgICAgY29udHJvbFBhaXJbMV0ubmFtZSA9PT0gYWNjZXNzb3IubmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gUmFkaW9Db250cm9sUmVnaXN0cnk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyAgV3JpdGVzIHJhZGlvIGNvbnRyb2wgdmFsdWVzIGFuZCBsaXN0ZW5zIHRvIHJhZGlvIGNvbnRyb2wgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIFVzZWQgYnkge0BsaW5rIE5nTW9kZWx9LCB7QGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge0BsaW5rIEZvcm1Db250cm9sTmFtZX1cbiAgICAgKiB0byBrZWVwIHRoZSB2aWV3IHN5bmNlZCB3aXRoIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9IG1vZGVsLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBJZiB5b3UgaGF2ZSBpbXBvcnRlZCB0aGUge0BsaW5rIEZvcm1zTW9kdWxlfSBvciB0aGUge0BsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9LCB0aGlzXG4gICAgICogdmFsdWUgYWNjZXNzb3Igd2lsbCBiZSBhY3RpdmUgb24gYW55IHJhZGlvIGNvbnRyb2wgdGhhdCBoYXMgYSBmb3JtIGRpcmVjdGl2ZS4gWW91IGRvXG4gICAgICogKipub3QqKiBuZWVkIHRvIGFkZCBhIHNwZWNpYWwgc2VsZWN0b3IgdG8gYWN0aXZhdGUgaXQuXG4gICAgICpcbiAgICAgKiAjIyMgSG93IHRvIHVzZSByYWRpbyBidXR0b25zIHdpdGggZm9ybSBkaXJlY3RpdmVzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgcmFkaW8gYnV0dG9ucyBpbiBhIHRlbXBsYXRlLWRyaXZlbiBmb3JtLCB5b3UnbGwgd2FudCB0byBlbnN1cmUgdGhhdCByYWRpbyBidXR0b25zXG4gICAgICogaW4gdGhlIHNhbWUgZ3JvdXAgaGF2ZSB0aGUgc2FtZSBgbmFtZWAgYXR0cmlidXRlLiAgUmFkaW8gYnV0dG9ucyB3aXRoIGRpZmZlcmVudCBgbmFtZWBcbiAgICAgKiBhdHRyaWJ1dGVzIGRvIG5vdCBhZmZlY3QgZWFjaCBvdGhlci5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9yYWRpb0J1dHRvbnMvcmFkaW9fYnV0dG9uX2V4YW1wbGUudHMgcmVnaW9uPSdUZW1wbGF0ZURyaXZlbid9XG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIHJhZGlvIGJ1dHRvbnMgaW4gYSByZWFjdGl2ZSBmb3JtLCByYWRpbyBidXR0b25zIGluIHRoZSBzYW1lIGdyb3VwIHNob3VsZCBoYXZlIHRoZVxuICAgICAqIHNhbWUgYGZvcm1Db250cm9sTmFtZWAuIFlvdSBjYW4gYWxzbyBhZGQgYSBgbmFtZWAgYXR0cmlidXRlLCBidXQgaXQncyBvcHRpb25hbC5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9yZWFjdGl2ZVJhZGlvQnV0dG9ucy9yZWFjdGl2ZV9yYWRpb19idXR0b25fZXhhbXBsZS50cyByZWdpb249J1JlYWN0aXZlJ31cbiAgICAgKlxuICAgICAqICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZiwgX3JlZ2lzdHJ5LCBfaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0cnkgPSBfcmVnaXN0cnk7XG4gICAgICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wgPSB0aGlzLl9pbmplY3Rvci5nZXQoTmdDb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0cnkuYWRkKHRoaXMuX2NvbnRyb2wsIHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcmVnaXN0cnkucmVtb3ZlKHRoaXMpOyB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlID09PSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2NoZWNrZWQnLCB0aGlzLl9zdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmbihfdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlZ2lzdHJ5LnNlbGVjdChfdGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5maXJlVW5jaGVjayA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLndyaXRlVmFsdWUodmFsdWUpOyB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fY2hlY2tOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSAmJiB0aGlzLmZvcm1Db250cm9sTmFtZSAmJiB0aGlzLm5hbWUgIT09IHRoaXMuZm9ybUNvbnRyb2xOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dOYW1lRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5uYW1lICYmIHRoaXMuZm9ybUNvbnRyb2xOYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuZm9ybUNvbnRyb2xOYW1lO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fdGhyb3dOYW1lRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBJZiB5b3UgZGVmaW5lIGJvdGggYSBuYW1lIGFuZCBhIGZvcm1Db250cm9sTmFtZSBhdHRyaWJ1dGUgb24geW91ciByYWRpbyBidXR0b24sIHRoZWlyIHZhbHVlc1xcbiAgICAgIG11c3QgbWF0Y2guIEV4OiA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIGZvcm1Db250cm9sTmFtZT1cXFwiZm9vZFxcXCIgbmFtZT1cXFwiZm9vZFxcXCI+XFxuICAgIFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1yYWRpb11bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPXJhZGlvXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1yYWRpb11bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSQURJT19WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFJhZGlvQ29udHJvbFJlZ2lzdHJ5LCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdG9yLCB9LFxuICAgICAgICBdO1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICdmb3JtQ29udHJvbE5hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFJBTkdFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBSYW5nZVZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgcmFuZ2UgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIHRoYXQgaXMgdXNlZCBieSB0aGVcbiAgICAgKiB7QGxpbmsgTmdNb2RlbH0sIHtAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7QGxpbmsgRm9ybUNvbnRyb2xOYW1lfSBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogICMjIyBFeGFtcGxlXG4gICAgICogIGBgYFxuICAgICAqICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgWyhuZ01vZGVsKV09XCJhZ2VcIiA+XG4gICAgICogIGBgYFxuICAgICAqL1xuICAgIHZhciBSYW5nZVZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSYW5nZVZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHsgZm4odmFsdWUgPT0gJycgPyBudWxsIDogcGFyc2VGbG9hdCh2YWx1ZSkpOyB9O1xuICAgICAgICB9O1xuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPXJhbmdlXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9cmFuZ2VdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXJhbmdlXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGlucHV0KSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdvblRvdWNoZWQoKSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSQU5HRV9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFJhbmdlVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFNFTEVDVF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgZnVuY3Rpb24gX2J1aWxkVmFsdWVTdHJpbmcoaWQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpZCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZSh2YWx1ZSkpXG4gICAgICAgICAgICB2YWx1ZSA9ICdPYmplY3QnO1xuICAgICAgICByZXR1cm4gKGlkICsgXCI6IFwiICsgdmFsdWUpLnNsaWNlKDAsIDUwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2V4dHJhY3RJZCh2YWx1ZVN0cmluZykge1xuICAgICAgICByZXR1cm4gdmFsdWVTdHJpbmcuc3BsaXQoJzonKVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgV3JpdGVzIHZhbHVlcyBhbmQgbGlzdGVucyB0byBjaGFuZ2VzIG9uIGEgc2VsZWN0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IHtAbGluayBOZ01vZGVsfSwge0BsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfSwgYW5kIHtAbGluayBGb3JtQ29udHJvbE5hbWV9XG4gICAgICogdG8ga2VlcCB0aGUgdmlldyBzeW5jZWQgd2l0aCB0aGUge0BsaW5rIEZvcm1Db250cm9sfSBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogSWYgeW91IGhhdmUgaW1wb3J0ZWQgdGhlIHtAbGluayBGb3Jtc01vZHVsZX0gb3IgdGhlIHtAbGluayBSZWFjdGl2ZUZvcm1zTW9kdWxlfSwgdGhpc1xuICAgICAqIHZhbHVlIGFjY2Vzc29yIHdpbGwgYmUgYWN0aXZlIG9uIGFueSBzZWxlY3QgY29udHJvbCB0aGF0IGhhcyBhIGZvcm0gZGlyZWN0aXZlLiBZb3UgZG9cbiAgICAgKiAqKm5vdCoqIG5lZWQgdG8gYWRkIGEgc3BlY2lhbCBzZWxlY3RvciB0byBhY3RpdmF0ZSBpdC5cbiAgICAgKlxuICAgICAqICMjIyBIb3cgdG8gdXNlIHNlbGVjdCBjb250cm9scyB3aXRoIGZvcm0gZGlyZWN0aXZlc1xuICAgICAqXG4gICAgICogVG8gdXNlIGEgc2VsZWN0IGluIGEgdGVtcGxhdGUtZHJpdmVuIGZvcm0sIHNpbXBseSBhZGQgYW4gYG5nTW9kZWxgIGFuZCBhIGBuYW1lYFxuICAgICAqIGF0dHJpYnV0ZSB0byB0aGUgbWFpbiBgPHNlbGVjdD5gIHRhZy5cbiAgICAgKlxuICAgICAqIElmIHlvdXIgb3B0aW9uIHZhbHVlcyBhcmUgc2ltcGxlIHN0cmluZ3MsIHlvdSBjYW4gYmluZCB0byB0aGUgbm9ybWFsIGB2YWx1ZWAgcHJvcGVydHlcbiAgICAgKiBvbiB0aGUgb3B0aW9uLiAgSWYgeW91ciBvcHRpb24gdmFsdWVzIGhhcHBlbiB0byBiZSBvYmplY3RzIChhbmQgeW91J2QgbGlrZSB0byBzYXZlIHRoZVxuICAgICAqIHNlbGVjdGlvbiBpbiB5b3VyIGZvcm0gYXMgYW4gb2JqZWN0KSwgdXNlIGBuZ1ZhbHVlYCBpbnN0ZWFkOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NlbGVjdENvbnRyb2wvc2VsZWN0X2NvbnRyb2xfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBJbiByZWFjdGl2ZSBmb3JtcywgeW91J2xsIGFsc28gd2FudCB0byBhZGQgeW91ciBmb3JtIGRpcmVjdGl2ZSAoYGZvcm1Db250cm9sTmFtZWAgb3JcbiAgICAgKiBgZm9ybUNvbnRyb2xgKSBvbiB0aGUgbWFpbiBgPHNlbGVjdD5gIHRhZy4gTGlrZSBpbiB0aGUgZm9ybWVyIGV4YW1wbGUsIHlvdSBoYXZlIHRoZVxuICAgICAqIGNob2ljZSBvZiBiaW5kaW5nIHRvIHRoZSAgYHZhbHVlYCBvciBgbmdWYWx1ZWAgcHJvcGVydHkgb24gdGhlIHNlbGVjdCdzIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvcmVhY3RpdmVTZWxlY3RDb250cm9sL3JlYWN0aXZlX3NlbGVjdF9jb250cm9sX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogTm90ZTogV2UgbGlzdGVuIHRvIHRoZSAnY2hhbmdlJyBldmVudCBiZWNhdXNlICdpbnB1dCcgZXZlbnRzIGFyZW4ndCBmaXJlZFxuICAgICAqIGZvciBzZWxlY3RzIGluIEZpcmVmb3ggYW5kIElFOlxuICAgICAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwMjQzNTBcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy80NjYwMDQ1L1xuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2lkQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB2YXIgdmFsdWVTdHJpbmcgPSBfYnVpbGRWYWx1ZVN0cmluZyh0aGlzLl9nZXRPcHRpb25JZCh2YWx1ZSksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlU3RyaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZVN0cmluZztcbiAgICAgICAgICAgICAgICBmbihfdGhpcy5fZ2V0T3B0aW9uVmFsdWUodmFsdWVTdHJpbmcpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX3JlZ2lzdGVyT3B0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuX2lkQ291bnRlcisrKS50b1N0cmluZygpOyB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fZ2V0T3B0aW9uSWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBBcnJheS5mcm9tKHRoaXMuX29wdGlvbk1hcC5rZXlzKCkpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAobG9vc2VJZGVudGljYWwodGhpcy5fb3B0aW9uTWFwLmdldChpZCksIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZVN0cmluZykge1xuICAgICAgICAgICAgdmFyIGlkID0gX2V4dHJhY3RJZCh2YWx1ZVN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9uTWFwLmhhcyhpZCkgPyB0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKSA6IHZhbHVlU3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtmb3JtQ29udHJvbE5hbWVdLHNlbGVjdDpub3QoW211bHRpcGxlXSlbZm9ybUNvbnRyb2xdLHNlbGVjdDpub3QoW211bHRpcGxlXSlbbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbU0VMRUNUX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIE1hcmtzIGA8b3B0aW9uPmAgYXMgZHluYW1pYywgc28gQW5ndWxhciBjYW4gYmUgbm90aWZpZWQgd2hlbiBvcHRpb25zIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogU2VlIGRvY3MgZm9yIHtAbGluayBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvcn0gZm9yIHVzYWdlIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ1NlbGVjdE9wdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nU2VsZWN0T3B0aW9uKF9lbGVtZW50LCBfcmVuZGVyZXIsIF9zZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ID0gX3NlbGVjdDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QpXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLCBcIm5nVmFsdWVcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5zZXQodGhpcy5pZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyh0aGlzLmlkLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0T3B0aW9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLnByb3RvdHlwZS5fc2V0RWxlbWVudFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdTZWxlY3RPcHRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnb3B0aW9uJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ1ZhbHVlJyxdIH0sXSxcbiAgICAgICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsndmFsdWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdTZWxlY3RPcHRpb247XG4gICAgfSgpKTtcblxuICAgIHZhciBTRUxFQ1RfTVVMVElQTEVfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgZnVuY3Rpb24gX2J1aWxkVmFsdWVTdHJpbmckMShpZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlkID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHZhbHVlID0gXCInXCIgKyB2YWx1ZSArIFwiJ1wiO1xuICAgICAgICBpZiAoIWlzUHJpbWl0aXZlKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gJ09iamVjdCc7XG4gICAgICAgIHJldHVybiAoaWQgKyBcIjogXCIgKyB2YWx1ZSkuc2xpY2UoMCwgNTApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZXh0cmFjdElkJDEodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyaW5nLnNwbGl0KCc6JylbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyBvbiBhIHNlbGVjdCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2lkQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gdmFsdWU7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHZhbHVlcyB0byBpZHNcbiAgICAgICAgICAgIHZhciBpZHMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdGhpcy5fZ2V0T3B0aW9uSWQodik7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFwLmZvckVhY2goZnVuY3Rpb24gKG9wdCwgbykgeyBvcHQuX3NldFNlbGVjdGVkKGlkcy5pbmRleE9mKG8udG9TdHJpbmcoKSkgPiAtMSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgaWYgKF8uaGFzT3duUHJvcGVydHkoJ3NlbGVjdGVkT3B0aW9ucycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gXy5zZWxlY3RlZE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnMuaXRlbShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfdGhpcy5fZ2V0T3B0aW9uVmFsdWUob3B0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnMuaXRlbShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHQuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX3RoaXMuX2dldE9wdGlvblZhbHVlKG9wdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZuKHNlbGVjdGVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX3JlZ2lzdGVyT3B0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSAodGhpcy5faWRDb3VudGVyKyspLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYXAuc2V0KGlkLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2dldE9wdGlvbklkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gQXJyYXkuZnJvbSh0aGlzLl9vcHRpb25NYXAua2V5cygpKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGxvb3NlSWRlbnRpY2FsKHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpLl92YWx1ZSwgdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fZ2V0T3B0aW9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9leHRyYWN0SWQkMSh2YWx1ZVN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9uTWFwLmhhcyhpZCkgPyB0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKS5fdmFsdWUgOiB2YWx1ZVN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VsZWN0W211bHRpcGxlXVtmb3JtQ29udHJvbE5hbWVdLHNlbGVjdFttdWx0aXBsZV1bZm9ybUNvbnRyb2xdLHNlbGVjdFttdWx0aXBsZV1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldCknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbU0VMRUNUX01VTFRJUExFX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBNYXJrcyBgPG9wdGlvbj5gIGFzIGR5bmFtaWMsIHNvIEFuZ3VsYXIgY2FuIGJlIG5vdGlmaWVkIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPHNlbGVjdCBtdWx0aXBsZSBuYW1lPVwiY2l0eVwiIG5nTW9kZWw+XG4gICAgICogICA8b3B0aW9uICpuZ0Zvcj1cImxldCBjIG9mIGNpdGllc1wiIFt2YWx1ZV09XCJjXCI+PC9vcHRpb24+XG4gICAgICogPC9zZWxlY3Q+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdmFyIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uKF9lbGVtZW50LCBfcmVuZGVyZXIsIF9zZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ID0gX3NlbGVjdDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5fc2VsZWN0Ll9yZWdpc3Rlck9wdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUsIFwibmdWYWx1ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nJDEodGhpcy5pZCwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nJDEodGhpcy5pZCwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUuX3NldEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLl9zZXRTZWxlY3RlZCA9IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdvcHRpb24nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25nVmFsdWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nVmFsdWUnLF0gfSxdLFxuICAgICAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyd2YWx1ZScsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uO1xuICAgIH0oKSk7XG5cbiAgICBmdW5jdGlvbiBjb250cm9sUGF0aChuYW1lLCBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5wYXRoLmNvbmNhdChbbmFtZV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRVcENvbnRyb2woY29udHJvbCwgZGlyKSB7XG4gICAgICAgIGlmICghY29udHJvbClcbiAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ0Nhbm5vdCBmaW5kIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICBpZiAoIWRpci52YWx1ZUFjY2Vzc29yKVxuICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnTm8gdmFsdWUgYWNjZXNzb3IgZm9yIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgIGNvbnRyb2wudmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFtjb250cm9sLnZhbGlkYXRvciwgZGlyLnZhbGlkYXRvcl0pO1xuICAgICAgICBjb250cm9sLmFzeW5jVmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMoW2NvbnRyb2wuYXN5bmNWYWxpZGF0b3IsIGRpci5hc3luY1ZhbGlkYXRvcl0pO1xuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci53cml0ZVZhbHVlKGNvbnRyb2wudmFsdWUpO1xuICAgICAgICAvLyB2aWV3IC0+IG1vZGVsXG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UoZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBkaXIudmlld1RvTW9kZWxVcGRhdGUobmV3VmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbC5tYXJrQXNEaXJ0eSgpO1xuICAgICAgICAgICAgY29udHJvbC5zZXRWYWx1ZShuZXdWYWx1ZSwgeyBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2U6IGZhbHNlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdG91Y2hlZFxuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uVG91Y2hlZChmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sLm1hcmtBc1RvdWNoZWQoKTsgfSk7XG4gICAgICAgIGNvbnRyb2wucmVnaXN0ZXJPbkNoYW5nZShmdW5jdGlvbiAobmV3VmFsdWUsIGVtaXRNb2RlbEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBjb250cm9sIC0+IHZpZXdcbiAgICAgICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLndyaXRlVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICAgICAgLy8gY29udHJvbCAtPiBuZ01vZGVsXG4gICAgICAgICAgICBpZiAoZW1pdE1vZGVsRXZlbnQpXG4gICAgICAgICAgICAgICAgZGlyLnZpZXdUb01vZGVsVXBkYXRlKG5ld1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkaXIudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICBjb250cm9sLnJlZ2lzdGVyT25EaXNhYmxlZENoYW5nZShmdW5jdGlvbiAoaXNEaXNhYmxlZCkgeyBkaXIudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZS1ydW4gdmFsaWRhdGlvbiB3aGVuIHZhbGlkYXRvciBiaW5kaW5nIGNoYW5nZXMsIGUuZy4gbWlubGVuZ3RoPTMgLT4gbWlubGVuZ3RoPTRcbiAgICAgICAgZGlyLl9yYXdWYWxpZGF0b3JzLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRpci5fcmF3QXN5bmNWYWxpZGF0b3JzLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFuVXBDb250cm9sKGNvbnRyb2wsIGRpcikge1xuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9ub0NvbnRyb2xFcnJvcihkaXIpOyB9KTtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPblRvdWNoZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX25vQ29udHJvbEVycm9yKGRpcik7IH0pO1xuICAgICAgICBkaXIuX3Jhd1ZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRpci5fcmF3QXN5bmNWYWxpZGF0b3JzLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29udHJvbClcbiAgICAgICAgICAgIGNvbnRyb2wuX2NsZWFyQ2hhbmdlRm5zKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFVwRm9ybUNvbnRhaW5lcihjb250cm9sLCBkaXIpIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoY29udHJvbCkpXG4gICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdDYW5ub3QgZmluZCBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgY29udHJvbC52YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW2NvbnRyb2wudmFsaWRhdG9yLCBkaXIudmFsaWRhdG9yXSk7XG4gICAgICAgIGNvbnRyb2wuYXN5bmNWYWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyhbY29udHJvbC5hc3luY1ZhbGlkYXRvciwgZGlyLmFzeW5jVmFsaWRhdG9yXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9ub0NvbnRyb2xFcnJvcihkaXIpIHtcbiAgICAgICAgcmV0dXJuIF90aHJvd0Vycm9yKGRpciwgJ1RoZXJlIGlzIG5vIEZvcm1Db250cm9sIGluc3RhbmNlIGF0dGFjaGVkIHRvIGZvcm0gY29udHJvbCBlbGVtZW50IHdpdGgnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3Rocm93RXJyb3IoZGlyLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBtZXNzYWdlRW5kO1xuICAgICAgICBpZiAoZGlyLnBhdGgubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbWVzc2FnZUVuZCA9IFwicGF0aDogJ1wiICsgZGlyLnBhdGguam9pbignIC0+ICcpICsgXCInXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyLnBhdGhbMF0pIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFbmQgPSBcIm5hbWU6ICdcIiArIGRpci5wYXRoICsgXCInXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlRW5kID0gJ3Vuc3BlY2lmaWVkIG5hbWUgYXR0cmlidXRlJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSArIFwiIFwiICsgbWVzc2FnZUVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh2YWxpZGF0b3JzKSA/IFZhbGlkYXRvcnMuY29tcG9zZSh2YWxpZGF0b3JzLm1hcChub3JtYWxpemVWYWxpZGF0b3IpKSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHZhbGlkYXRvcnMpID8gVmFsaWRhdG9ycy5jb21wb3NlQXN5bmModmFsaWRhdG9ycy5tYXAobm9ybWFsaXplQXN5bmNWYWxpZGF0b3IpKSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB2aWV3TW9kZWwpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmhhc093blByb3BlcnR5KCdtb2RlbCcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1snbW9kZWwnXTtcbiAgICAgICAgaWYgKGNoYW5nZS5pc0ZpcnN0Q2hhbmdlKCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICFsb29zZUlkZW50aWNhbCh2aWV3TW9kZWwsIGNoYW5nZS5jdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgICB2YXIgQlVJTFRJTl9BQ0NFU1NPUlMgPSBbXG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgXTtcbiAgICBmdW5jdGlvbiBpc0J1aWx0SW5BY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIHJldHVybiBCVUlMVElOX0FDQ0VTU09SUy5zb21lKGZ1bmN0aW9uIChhKSB7IHJldHVybiB2YWx1ZUFjY2Vzc29yLmNvbnN0cnVjdG9yID09PSBhOyB9KTtcbiAgICB9XG4gICAgLy8gVE9ETzogdnNhdmtpbiByZW1vdmUgaXQgb25jZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMDExIGlzIGltcGxlbWVudGVkXG4gICAgZnVuY3Rpb24gc2VsZWN0VmFsdWVBY2Nlc3NvcihkaXIsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgIGlmICghdmFsdWVBY2Nlc3NvcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGRlZmF1bHRBY2Nlc3NvcjtcbiAgICAgICAgdmFyIGJ1aWx0aW5BY2Nlc3NvcjtcbiAgICAgICAgdmFyIGN1c3RvbUFjY2Vzc29yO1xuICAgICAgICB2YWx1ZUFjY2Vzc29ycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodi5jb25zdHJ1Y3RvciA9PT0gRGVmYXVsdFZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWNjZXNzb3IgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCdWlsdEluQWNjZXNzb3IodikpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVpbHRpbkFjY2Vzc29yKVxuICAgICAgICAgICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdNb3JlIHRoYW4gb25lIGJ1aWx0LWluIHZhbHVlIGFjY2Vzc29yIG1hdGNoZXMgZm9ybSBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgICAgICAgICBidWlsdGluQWNjZXNzb3IgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUFjY2Vzc29yKVxuICAgICAgICAgICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdNb3JlIHRoYW4gb25lIGN1c3RvbSB2YWx1ZSBhY2Nlc3NvciBtYXRjaGVzIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgICAgICAgICAgY3VzdG9tQWNjZXNzb3IgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN1c3RvbUFjY2Vzc29yKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUFjY2Vzc29yO1xuICAgICAgICBpZiAoYnVpbHRpbkFjY2Vzc29yKVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWx0aW5BY2Nlc3NvcjtcbiAgICAgICAgaWYgKGRlZmF1bHRBY2Nlc3NvcilcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QWNjZXNzb3I7XG4gICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ05vIHZhbGlkIHZhbHVlIGFjY2Vzc29yIGZvciBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBiYXNlIGNsYXNzIGZvciBjb2RlIHNoYXJlZCBiZXR3ZWVuIHtAbGluayBOZ01vZGVsR3JvdXB9IGFuZCB7QGxpbmsgRm9ybUdyb3VwTmFtZX0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZEZvcm1Hcm91cCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVGb3JtR3JvdXAodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUge0BsaW5rIEZvcm1Hcm91cH0gYmFja2luZyB0aGlzIGJpbmRpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtRGlyZWN0aXZlLmdldEZvcm1Hcm91cCh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgcGF0aCB0byB0aGlzIGNvbnRyb2wgZ3JvdXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSB7QGxpbmsgRm9ybX0gdG8gd2hpY2ggdGhpcyBncm91cCBiZWxvbmdzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIH0oQ29udHJvbENvbnRhaW5lcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBBYnN0cmFjdENvbnRyb2xTdGF0dXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2xTdGF0dXMoY2QpIHtcbiAgICAgICAgICAgIHRoaXMuX2NkID0gY2Q7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1VudG91Y2hlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NkLmNvbnRyb2wgPyB0aGlzLl9jZC5jb250cm9sLnVudG91Y2hlZCA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1RvdWNoZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC50b3VjaGVkIDogZmFsc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzUHJpc3RpbmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC5wcmlzdGluZSA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc0RpcnR5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wuZGlydHkgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NWYWxpZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NkLmNvbnRyb2wgPyB0aGlzLl9jZC5jb250cm9sLnZhbGlkIDogZmFsc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzSW52YWxpZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NkLmNvbnRyb2wgPyB0aGlzLl9jZC5jb250cm9sLmludmFsaWQgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NQZW5kaW5nXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wucGVuZGluZyA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Q29udHJvbFN0YXR1cztcbiAgICB9KCkpO1xuICAgIHZhciBuZ0NvbnRyb2xTdGF0dXNIb3N0ID0ge1xuICAgICAgICAnW2NsYXNzLm5nLXVudG91Y2hlZF0nOiAnbmdDbGFzc1VudG91Y2hlZCcsXG4gICAgICAgICdbY2xhc3MubmctdG91Y2hlZF0nOiAnbmdDbGFzc1RvdWNoZWQnLFxuICAgICAgICAnW2NsYXNzLm5nLXByaXN0aW5lXSc6ICduZ0NsYXNzUHJpc3RpbmUnLFxuICAgICAgICAnW2NsYXNzLm5nLWRpcnR5XSc6ICduZ0NsYXNzRGlydHknLFxuICAgICAgICAnW2NsYXNzLm5nLXZhbGlkXSc6ICduZ0NsYXNzVmFsaWQnLFxuICAgICAgICAnW2NsYXNzLm5nLWludmFsaWRdJzogJ25nQ2xhc3NJbnZhbGlkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1wZW5kaW5nXSc6ICduZ0NsYXNzUGVuZGluZycsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXJlY3RpdmUgYXV0b21hdGljYWxseSBhcHBsaWVkIHRvIEFuZ3VsYXIgZm9ybSBjb250cm9scyB0aGF0IHNldHMgQ1NTIGNsYXNzZXNcbiAgICAgKiBiYXNlZCBvbiBjb250cm9sIHN0YXR1cyAodmFsaWQvaW52YWxpZC9kaXJ0eS9ldGMpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0NvbnRyb2xTdGF0dXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhOZ0NvbnRyb2xTdGF0dXMsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nQ29udHJvbFN0YXR1cyhjZCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgY2QpO1xuICAgICAgICB9XG4gICAgICAgIE5nQ29udHJvbFN0YXR1cy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUNvbnRyb2xOYW1lXSxbbmdNb2RlbF0sW2Zvcm1Db250cm9sXScsIGhvc3Q6IG5nQ29udHJvbFN0YXR1c0hvc3QgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ0NvbnRyb2xTdGF0dXMuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTmdDb250cm9sU3RhdHVzO1xuICAgIH0oQWJzdHJhY3RDb250cm9sU3RhdHVzKSk7XG4gICAgLyoqXG4gICAgICogRGlyZWN0aXZlIGF1dG9tYXRpY2FsbHkgYXBwbGllZCB0byBBbmd1bGFyIGZvcm0gZ3JvdXBzIHRoYXQgc2V0cyBDU1MgY2xhc3Nlc1xuICAgICAqIGJhc2VkIG9uIGNvbnRyb2wgc3RhdHVzICh2YWxpZC9pbnZhbGlkL2RpcnR5L2V0YykuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nQ29udHJvbFN0YXR1c0dyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoTmdDb250cm9sU3RhdHVzR3JvdXAsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nQ29udHJvbFN0YXR1c0dyb3VwKGNkKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjZCk7XG4gICAgICAgIH1cbiAgICAgICAgTmdDb250cm9sU3RhdHVzR3JvdXAuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tmb3JtR3JvdXBOYW1lXSxbZm9ybUFycmF5TmFtZV0sW25nTW9kZWxHcm91cF0sW2Zvcm1Hcm91cF0sZm9ybTpub3QoW25nTm9Gb3JtXSksW25nRm9ybV0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogbmdDb250cm9sU3RhdHVzSG9zdFxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nQ29udHJvbFN0YXR1c0dyb3VwLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBOZ0NvbnRyb2xTdGF0dXNHcm91cDtcbiAgICB9KEFic3RyYWN0Q29udHJvbFN0YXR1cykpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZSBieSBkaXJlY3RpdmVzIGFuZCBjb21wb25lbnRzIHRvIGVtaXQgY3VzdG9tIEV2ZW50cy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlc1xuICAgICAqXG4gICAgICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCBgWmlwcHlgIGFsdGVybmF0aXZlbHkgZW1pdHMgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyB3aGVuIGl0c1xuICAgICAqIHRpdGxlIGdldHMgY2xpY2tlZDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICd6aXBweScsXG4gICAgICogICB0ZW1wbGF0ZTogYFxuICAgICAqICAgPGRpdiBjbGFzcz1cInppcHB5XCI+XG4gICAgICogICAgIDxkaXYgKGNsaWNrKT1cInRvZ2dsZSgpXCI+VG9nZ2xlPC9kaXY+XG4gICAgICogICAgIDxkaXYgW2hpZGRlbl09XCIhdmlzaWJsZVwiPlxuICAgICAqICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgKiAgICAgPC9kaXY+XG4gICAgICogIDwvZGl2PmB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBaaXBweSB7XG4gICAgICogICB2aXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICAgKiAgIEBPdXRwdXQoKSBvcGVuOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgKiAgIEBPdXRwdXQoKSBjbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICpcbiAgICAgKiAgIHRvZ2dsZSgpIHtcbiAgICAgKiAgICAgdGhpcy52aXNpYmxlID0gIXRoaXMudmlzaWJsZTtcbiAgICAgKiAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAqICAgICAgIHRoaXMub3Blbi5lbWl0KG51bGwpO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgIHRoaXMuY2xvc2UuZW1pdChudWxsKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSBldmVudHMgcGF5bG9hZCBjYW4gYmUgYWNjZXNzZWQgYnkgdGhlIHBhcmFtZXRlciBgJGV2ZW50YCBvbiB0aGUgY29tcG9uZW50cyBvdXRwdXQgZXZlbnRcbiAgICAgKiBoYW5kbGVyOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPHppcHB5IChvcGVuKT1cIm9uT3BlbigkZXZlbnQpXCIgKGNsb3NlKT1cIm9uQ2xvc2UoJGV2ZW50KVwiPjwvemlwcHk+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBVc2VzIFJ4Lk9ic2VydmFibGUgYnV0IHByb3ZpZGVzIGFuIGFkYXB0ZXIgdG8gbWFrZSBpdCB3b3JrIGFzIHNwZWNpZmllZCBoZXJlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qaHVzYWluL29ic2VydmFibGUtc3BlY1xuICAgICAqXG4gICAgICogT25jZSBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3BlYyBpcyBhdmFpbGFibGUsIHN3aXRjaCB0byBpdC5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEV2ZW50RW1pdHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ1KEV2ZW50RW1pdHRlciwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgW0V2ZW50RW1pdHRlcl0sIHdoaWNoIGRlcGVuZGluZyBvbiBbaXNBc3luY10sXG4gICAgICAgICAqIGRlbGl2ZXJzIGV2ZW50cyBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm91c2x5LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKGlzQXN5bmMpIHtcbiAgICAgICAgICAgIGlmIChpc0FzeW5jID09PSB2b2lkIDApIHsgaXNBc3luYyA9IGZhbHNlOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID0gaXNBc3luYztcbiAgICAgICAgfVxuICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodmFsdWUpIHsgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdmFsdWUpOyB9O1xuICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChnZW5lcmF0b3JPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICAgICAgdmFyIHNjaGVkdWxlckZuO1xuICAgICAgICAgICAgdmFyIGVycm9yRm4gPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlRm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dCAmJiB0eXBlb2YgZ2VuZXJhdG9yT3JOZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQubmV4dCh2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAodmFsdWUpIHsgZ2VuZXJhdG9yT3JOZXh0Lm5leHQodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKGVycikgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5lcnJvcihlcnIpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7IGdlbmVyYXRvck9yTmV4dC5lcnJvcihlcnIpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICgpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQuY29tcGxldGUoKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBnZW5lcmF0b3JPck5leHQuY29tcGxldGUoKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKHZhbHVlKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0KHZhbHVlKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHsgZ2VuZXJhdG9yT3JOZXh0KHZhbHVlKTsgfTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JGbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uIChlcnIpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcihlcnIpOyB9KTsgfSA6IGZ1bmN0aW9uIChlcnIpIHsgZXJyb3IoZXJyKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcGxldGUoKTsgfSk7IH0gOiBmdW5jdGlvbiAoKSB7IGNvbXBsZXRlKCk7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc3Vic2NyaWJlLmNhbGwodGhpcywgc2NoZWR1bGVyRm4sIGVycm9yRm4sIGNvbXBsZXRlRm4pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgIH0ocnhqc19TdWJqZWN0LlN1YmplY3QpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIEZvcm1Db250cm9sIGlzIHZhbGlkLCBpLmUuIHRoYXQgbm8gZXJyb3JzIGV4aXN0IGluIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgVkFMSUQgPSAnVkFMSUQnO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgRm9ybUNvbnRyb2wgaXMgaW52YWxpZCwgaS5lLiB0aGF0IGFuIGVycm9yIGV4aXN0cyBpbiB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIElOVkFMSUQgPSAnSU5WQUxJRCc7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBGb3JtQ29udHJvbCBpcyBwZW5kaW5nLCBpLmUuIHRoYXQgYXN5bmMgdmFsaWRhdGlvbiBpcyBvY2N1cnJpbmcgYW5kXG4gICAgICogZXJyb3JzIGFyZSBub3QgeWV0IGF2YWlsYWJsZSBmb3IgdGhlIGlucHV0IHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBQRU5ESU5HID0gJ1BFTkRJTkcnO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgRm9ybUNvbnRyb2wgaXMgZGlzYWJsZWQsIGkuZS4gdGhhdCB0aGUgY29udHJvbCBpcyBleGVtcHQgZnJvbSBhbmNlc3RvclxuICAgICAqIGNhbGN1bGF0aW9ucyBvZiB2YWxpZGl0eSBvciB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgRElTQUJMRUQgPSAnRElTQUJMRUQnO1xuICAgIGZ1bmN0aW9uIF9maW5kKGNvbnRyb2wsIHBhdGgsIGRlbGltaXRlcikge1xuICAgICAgICBpZiAocGF0aCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KGRlbGltaXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggaW5zdGFuY2VvZiBBcnJheSAmJiAocGF0aC5sZW5ndGggPT09IDApKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAodiwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBGb3JtR3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5jb250cm9sc1tuYW1lXSB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBGb3JtQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5hdChuYW1lKSB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIGNvbnRyb2wpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b09ic2VydmFibGUocikge1xuICAgICAgICByZXR1cm4gaXNQcm9taXNlKHIpID8gcnhqc19vYnNlcnZhYmxlX2Zyb21Qcm9taXNlLmZyb21Qcm9taXNlKHIpIDogcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29lcmNlVG9WYWxpZGF0b3IodmFsaWRhdG9yKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbGlkYXRvcikgPyBjb21wb3NlVmFsaWRhdG9ycyh2YWxpZGF0b3IpIDogdmFsaWRhdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2VyY2VUb0FzeW5jVmFsaWRhdG9yKGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFzeW5jVmFsaWRhdG9yKSA/IGNvbXBvc2VBc3luY1ZhbGlkYXRvcnMoYXN5bmNWYWxpZGF0b3IpIDogYXN5bmNWYWxpZGF0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIHtAbGluayBGb3JtQ29udHJvbH0sIHtAbGluayBGb3JtR3JvdXB9LCBhbmRcbiAgICAgKiB7QGxpbmsgRm9ybUFycmF5fS5cbiAgICAgKlxuICAgICAqIEl0IHByb3ZpZGVzIHNvbWUgb2YgdGhlIHNoYXJlZCBiZWhhdmlvciB0aGF0IGFsbCBjb250cm9scyBhbmQgZ3JvdXBzIG9mIGNvbnRyb2xzIGhhdmUsIGxpa2VcbiAgICAgKiBydW5uaW5nIHZhbGlkYXRvcnMsIGNhbGN1bGF0aW5nIHN0YXR1cywgYW5kIHJlc2V0dGluZyBzdGF0ZS4gSXQgYWxzbyBkZWZpbmVzIHRoZSBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCBhcmUgc2hhcmVkIGJldHdlZW4gYWxsIHN1Yi1jbGFzc2VzLCBsaWtlIGB2YWx1ZWAsIGB2YWxpZGAsIGFuZCBgZGlydHlgLiBJdCBzaG91bGRuJ3QgYmVcbiAgICAgKiBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0Q29udHJvbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0Q29udHJvbCh2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBhc3luY1ZhbGlkYXRvcjtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXN0aW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBwYXJlbnQgY29udHJvbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJzdGF0dXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIGNvbnRyb2wuIFRoZXJlIGFyZSBmb3VyIHBvc3NpYmxlXG4gICAgICAgICAgICAgKiB2YWxpZGF0aW9uIHN0YXR1c2VzOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICogKipWQUxJRCoqOiAgY29udHJvbCBoYXMgcGFzc2VkIGFsbCB2YWxpZGF0aW9uIGNoZWNrc1xuICAgICAgICAgICAgICogKiAqKklOVkFMSUQqKjogY29udHJvbCBoYXMgZmFpbGVkIGF0IGxlYXN0IG9uZSB2YWxpZGF0aW9uIGNoZWNrXG4gICAgICAgICAgICAgKiAqICoqUEVORElORyoqOiBjb250cm9sIGlzIGluIHRoZSBtaWRzdCBvZiBjb25kdWN0aW5nIGEgdmFsaWRhdGlvbiBjaGVja1xuICAgICAgICAgICAgICogKiAqKkRJU0FCTEVEKio6IGNvbnRyb2wgaXMgZXhlbXB0IGZyb20gdmFsaWRhdGlvbiBjaGVja3NcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGVzZSBzdGF0dXNlcyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLCBzbyBhIGNvbnRyb2wgY2Fubm90IGJlXG4gICAgICAgICAgICAgKiBib3RoIHZhbGlkIEFORCBpbnZhbGlkIG9yIGludmFsaWQgQU5EIGRpc2FibGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1czsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbGlkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGB2YWxpZGAgd2hlbiBpdHMgYHN0YXR1cyA9PT0gVkFMSURgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG9yZGVyIHRvIGhhdmUgdGhpcyBzdGF0dXMsIHRoZSBjb250cm9sIG11c3QgaGF2ZSBwYXNzZWQgYWxsIGl0c1xuICAgICAgICAgICAgICogdmFsaWRhdGlvbiBjaGVja3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzID09PSBWQUxJRDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcImludmFsaWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYGludmFsaWRgIHdoZW4gaXRzIGBzdGF0dXMgPT09IElOVkFMSURgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG9yZGVyIHRvIGhhdmUgdGhpcyBzdGF0dXMsIHRoZSBjb250cm9sIG11c3QgaGF2ZSBmYWlsZWRcbiAgICAgICAgICAgICAqIGF0IGxlYXN0IG9uZSBvZiBpdHMgdmFsaWRhdGlvbiBjaGVja3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzID09PSBJTlZBTElEOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicGVuZGluZ1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgcGVuZGluZ2Agd2hlbiBpdHMgYHN0YXR1cyA9PT0gUEVORElOR2AuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3JkZXIgdG8gaGF2ZSB0aGlzIHN0YXR1cywgdGhlIGNvbnRyb2wgbXVzdCBiZSBpbiB0aGVcbiAgICAgICAgICAgICAqIG1pZGRsZSBvZiBjb25kdWN0aW5nIGEgdmFsaWRhdGlvbiBjaGVjay5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT0gUEVORElORzsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBkaXNhYmxlZGAgd2hlbiBpdHMgYHN0YXR1cyA9PT0gRElTQUJMRURgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIERpc2FibGVkIGNvbnRyb2xzIGFyZSBleGVtcHQgZnJvbSB2YWxpZGF0aW9uIGNoZWNrcyBhbmRcbiAgICAgICAgICAgICAqIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGVpciBhbmNlc3RvclxuICAgICAgICAgICAgICogY29udHJvbHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzID09PSBESVNBQkxFRDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcImVuYWJsZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYGVuYWJsZWRgIGFzIGxvbmcgYXMgaXRzIGBzdGF0dXMgIT09IERJU0FCTEVEYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvdGhlciB3b3JkcywgaXQgaGFzIGEgc3RhdHVzIG9mIGBWQUxJRGAsIGBJTlZBTElEYCwgb3JcbiAgICAgICAgICAgICAqIGBQRU5ESU5HYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgIT09IERJU0FCTEVEOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZXJyb3JzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhbnkgZXJyb3JzIGdlbmVyYXRlZCBieSBmYWlsaW5nIHZhbGlkYXRpb24uIElmIHRoZXJlXG4gICAgICAgICAgICAgKiBhcmUgbm8gZXJyb3JzLCBpdCB3aWxsIHJldHVybiBudWxsLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Vycm9yczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInByaXN0aW5lXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBwcmlzdGluZWAgaWYgdGhlIHVzZXIgaGFzIG5vdCB5ZXQgY2hhbmdlZFxuICAgICAgICAgICAgICogdGhlIHZhbHVlIGluIHRoZSBVSS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgcHJvZ3JhbW1hdGljIGNoYW5nZXMgdG8gYSBjb250cm9sJ3MgdmFsdWUgd2lsbFxuICAgICAgICAgICAgICogKm5vdCogbWFyayBpdCBkaXJ0eS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcmlzdGluZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcImRpcnR5XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBkaXJ0eWAgaWYgdGhlIHVzZXIgaGFzIGNoYW5nZWQgdGhlIHZhbHVlXG4gICAgICAgICAgICAgKiBpbiB0aGUgVUkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHByb2dyYW1tYXRpYyBjaGFuZ2VzIHRvIGEgY29udHJvbCdzIHZhbHVlIHdpbGxcbiAgICAgICAgICAgICAqICpub3QqIG1hcmsgaXQgZGlydHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMucHJpc3RpbmU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ0b3VjaGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgbWFya2VkIGB0b3VjaGVkYCBvbmNlIHRoZSB1c2VyIGhhcyB0cmlnZ2VyZWRcbiAgICAgICAgICAgICogYSBgYmx1cmAgZXZlbnQgb24gaXQuXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90b3VjaGVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidW50b3VjaGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGB1bnRvdWNoZWRgIGlmIHRoZSB1c2VyIGhhcyBub3QgeWV0IHRyaWdnZXJlZFxuICAgICAgICAgICAgICogYSBgYmx1cmAgZXZlbnQgb24gaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuX3RvdWNoZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbWl0cyBhbiBldmVudCBldmVyeSB0aW1lIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCBjaGFuZ2VzLCBpblxuICAgICAgICAgICAgICogdGhlIFVJIG9yIHByb2dyYW1tYXRpY2FsbHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWVDaGFuZ2VzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwic3RhdHVzQ2hhbmdlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVtaXRzIGFuIGV2ZW50IGV2ZXJ5IHRpbWUgdGhlIHZhbGlkYXRpb24gc3RhdHVzIG9mIHRoZSBjb250cm9sXG4gICAgICAgICAgICAgKiBpcyByZS1jYWxjdWxhdGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1c0NoYW5nZXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0aGF0IGFyZSBhY3RpdmUgb24gdGhpcyBjb250cm9sLiAgQ2FsbGluZ1xuICAgICAgICAgKiB0aGlzIHdpbGwgb3ZlcndyaXRlIGFueSBleGlzdGluZyBzeW5jIHZhbGlkYXRvcnMuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldFZhbGlkYXRvcnMgPSBmdW5jdGlvbiAobmV3VmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9IGNvZXJjZVRvVmFsaWRhdG9yKG5ld1ZhbGlkYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBhc3luYyB2YWxpZGF0b3JzIHRoYXQgYXJlIGFjdGl2ZSBvbiB0aGlzIGNvbnRyb2wuIENhbGxpbmcgdGhpc1xuICAgICAgICAgKiB3aWxsIG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgYXN5bmMgdmFsaWRhdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0QXN5bmNWYWxpZGF0b3JzID0gZnVuY3Rpb24gKG5ld1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy5hc3luY1ZhbGlkYXRvciA9IGNvZXJjZVRvQXN5bmNWYWxpZGF0b3IobmV3VmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtcHRpZXMgb3V0IHRoZSBzeW5jIHZhbGlkYXRvciBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5jbGVhclZhbGlkYXRvcnMgPSBmdW5jdGlvbiAoKSB7IHRoaXMudmFsaWRhdG9yID0gbnVsbDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtcHRpZXMgb3V0IHRoZSBhc3luYyB2YWxpZGF0b3IgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuY2xlYXJBc3luY1ZhbGlkYXRvcnMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYHRvdWNoZWRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYWxzbyBtYXJrIGFsbCBkaXJlY3QgYW5jZXN0b3JzIGFzIGB0b3VjaGVkYCB0byBtYWludGFpblxuICAgICAgICAgKiB0aGUgbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc1RvdWNoZWQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl90b3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm1hcmtBc1RvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgdW50b3VjaGVkYC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGNvbnRyb2wgaGFzIGFueSBjaGlsZHJlbiwgaXQgd2lsbCBhbHNvIG1hcmsgYWxsIGNoaWxkcmVuIGFzIGB1bnRvdWNoZWRgXG4gICAgICAgICAqIHRvIG1haW50YWluIHRoZSBtb2RlbCwgYW5kIHJlLWNhbGN1bGF0ZSB0aGUgYHRvdWNoZWRgIHN0YXR1cyBvZiBhbGwgcGFyZW50XG4gICAgICAgICAqIGNvbnRyb2xzLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNVbnRvdWNoZWQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl90b3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5tYXJrQXNVbnRvdWNoZWQoeyBvbmx5U2VsZjogdHJ1ZSB9KTsgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlVG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBkaXJ0eWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCBhbHNvIG1hcmsgYWxsIGRpcmVjdCBhbmNlc3RvcnMgYXMgYGRpcnR5YCB0byBtYWludGFpblxuICAgICAgICAgKiB0aGUgbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc0RpcnR5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm1hcmtBc0RpcnR5KHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYHByaXN0aW5lYC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGNvbnRyb2wgaGFzIGFueSBjaGlsZHJlbiwgaXQgd2lsbCBhbHNvIG1hcmsgYWxsIGNoaWxkcmVuIGFzIGBwcmlzdGluZWBcbiAgICAgICAgICogdG8gbWFpbnRhaW4gdGhlIG1vZGVsLCBhbmQgcmUtY2FsY3VsYXRlIHRoZSBgcHJpc3RpbmVgIHN0YXR1cyBvZiBhbGwgcGFyZW50XG4gICAgICAgICAqIGNvbnRyb2xzLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNQcmlzdGluZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3ByaXN0aW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLm1hcmtBc1ByaXN0aW5lKHsgb25seVNlbGY6IHRydWUgfSk7IH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVByaXN0aW5lKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYHBlbmRpbmdgLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNQZW5kaW5nID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gUEVORElORztcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm1hcmtBc1BlbmRpbmcoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgY29udHJvbC4gVGhpcyBtZWFucyB0aGUgY29udHJvbCB3aWxsIGJlIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAgICAgKiBleGNsdWRlZCBmcm9tIHRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgYW55IHBhcmVudC4gSXRzIHN0YXR1cyBpcyBgRElTQUJMRURgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgY2hpbGRyZW4sIGFsbCBjaGlsZHJlbiB3aWxsIGJlIGRpc2FibGVkIHRvIG1haW50YWluIHRoZSBtb2RlbC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IERJU0FCTEVEO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLmRpc2FibGUoeyBvbmx5U2VsZjogdHJ1ZSB9KTsgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGVtaXRFdmVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZXMuZW1pdCh0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcy5lbWl0KHRoaXMuX3N0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBbmNlc3RvcnMob25seVNlbGYpO1xuICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2VGbikgeyByZXR1cm4gY2hhbmdlRm4odHJ1ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcyB0aGUgY29udHJvbC4gVGhpcyBtZWFucyB0aGUgY29udHJvbCB3aWxsIGJlIGluY2x1ZGVkIGluIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAgICAgKiB0aGUgYWdncmVnYXRlIHZhbHVlIG9mIGl0cyBwYXJlbnQuIEl0cyBzdGF0dXMgaXMgcmUtY2FsY3VsYXRlZCBiYXNlZCBvbiBpdHMgdmFsdWUgYW5kXG4gICAgICAgICAqIGl0cyB2YWxpZGF0b3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgY2hpbGRyZW4sIGFsbCBjaGlsZHJlbiB3aWxsIGJlIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IFZBTElEO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7IGNvbnRyb2wuZW5hYmxlKHsgb25seVNlbGY6IHRydWUgfSk7IH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5jZXN0b3JzKG9ubHlTZWxmKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlRm4pIHsgcmV0dXJuIGNoYW5nZUZuKGZhbHNlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZUFuY2VzdG9ycyA9IGZ1bmN0aW9uIChvbmx5U2VsZikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlUHJpc3RpbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7IHRoaXMuX3BhcmVudCA9IHBhcmVudDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlLWNhbGN1bGF0ZXMgdGhlIHZhbHVlIGFuZCB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgaXQgd2lsbCBhbHNvIHVwZGF0ZSB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IG9mIGl0cyBhbmNlc3RvcnMuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zZXRJbml0aWFsU3RhdHVzKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IHRoaXMuX3J1blZhbGlkYXRvcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IHRoaXMuX2NhbGN1bGF0ZVN0YXR1cygpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IFZBTElEIHx8IHRoaXMuX3N0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydW5Bc3luY1ZhbGlkYXRvcihlbWl0RXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbWl0RXZlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2VzLmVtaXQodGhpcy5fdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fdXBkYXRlVHJlZVZhbGlkaXR5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgZW1pdEV2ZW50ID0gKF9hID09PSB2b2lkIDAgPyB7IGVtaXRFdmVudDogdHJ1ZSB9IDogX2EpLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY3RybCkgeyByZXR1cm4gY3RybC5fdXBkYXRlVHJlZVZhbGlkaXR5KHsgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7IH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9zZXRJbml0aWFsU3RhdHVzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9zdGF0dXMgPSB0aGlzLl9hbGxDb250cm9sc0Rpc2FibGVkKCkgPyBESVNBQkxFRCA6IFZBTElEOyB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9ydW5WYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IgPyB0aGlzLnZhbGlkYXRvcih0aGlzKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3J1bkFzeW5jVmFsaWRhdG9yID0gZnVuY3Rpb24gKGVtaXRFdmVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gUEVORElORztcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxFeGlzdGluZ1N1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciBvYnMgPSB0b09ic2VydmFibGUodGhpcy5hc3luY1ZhbGlkYXRvcih0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0aW9uU3Vic2NyaXB0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgb2JzLnN1YnNjcmliZSh7IG5leHQ6IGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF90aGlzLnNldEVycm9ycyhyZXMsIHsgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2NhbmNlbEV4aXN0aW5nU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FzeW5jVmFsaWRhdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBlcnJvcnMgb24gYSBmb3JtIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZCB3aGVuIHZhbGlkYXRpb25zIGFyZSBydW4gbWFudWFsbHkgYnkgdGhlIHVzZXIsIHJhdGhlciB0aGFuIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIENhbGxpbmcgYHNldEVycm9yc2Agd2lsbCBhbHNvIHVwZGF0ZSB0aGUgdmFsaWRpdHkgb2YgdGhlIHBhcmVudCBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogY29uc3QgbG9naW4gPSBuZXcgRm9ybUNvbnRyb2woXCJzb21lTG9naW5cIik7XG4gICAgICAgICAqIGxvZ2luLnNldEVycm9ycyh7XG4gICAgICAgICAqICAgXCJub3RVbmlxdWVcIjogdHJ1ZVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KGxvZ2luLnZhbGlkKS50b0VxdWFsKGZhbHNlKTtcbiAgICAgICAgICogZXhwZWN0KGxvZ2luLmVycm9ycykudG9FcXVhbCh7XCJub3RVbmlxdWVcIjogdHJ1ZX0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBsb2dpbi5zZXRWYWx1ZShcInNvbWVPdGhlckxvZ2luXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QobG9naW4udmFsaWQpLnRvRXF1YWwodHJ1ZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5zZXRFcnJvcnMgPSBmdW5jdGlvbiAoZXJyb3JzLCBfYSkge1xuICAgICAgICAgICAgdmFyIGVtaXRFdmVudCA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29udHJvbHNFcnJvcnMoZW1pdEV2ZW50ICE9PSBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYSBjaGlsZCBjb250cm9sIGdpdmVuIHRoZSBjb250cm9sJ3MgbmFtZSBvciBwYXRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXRocyBjYW4gYmUgcGFzc2VkIGluIGFzIGFuIGFycmF5IG9yIGEgc3RyaW5nIGRlbGltaXRlZCBieSBhIGRvdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gZ2V0IGEgY29udHJvbCBuZXN0ZWQgd2l0aGluIGEgYHBlcnNvbmAgc3ViLWdyb3VwOlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGB0aGlzLmZvcm0uZ2V0KCdwZXJzb24ubmFtZScpO2BcbiAgICAgICAgICpcbiAgICAgICAgICogLU9SLVxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGB0aGlzLmZvcm0uZ2V0KFsncGVyc29uJywgJ25hbWUnXSk7YFxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gX2ZpbmQodGhpcywgcGF0aCwgJy4nKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBwYXRoIGhhcyB0aGUgZXJyb3Igc3BlY2lmaWVkLiBPdGhlcndpc2VcbiAgICAgICAgICogcmV0dXJucyBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbm8gcGF0aCBpcyBnaXZlbiwgaXQgY2hlY2tzIGZvciB0aGUgZXJyb3Igb24gdGhlIHByZXNlbnQgY29udHJvbC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgY29udHJvbCA9IHBhdGggPyB0aGlzLmdldChwYXRoKSA6IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbCAmJiBjb250cm9sLl9lcnJvcnMgPyBjb250cm9sLl9lcnJvcnNbZXJyb3JDb2RlXSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gcGF0aCBoYXMgdGhlIGVycm9yIHNwZWNpZmllZC4gT3RoZXJ3aXNlXG4gICAgICAgICAqIHJldHVybnMgZmFsc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIG5vIHBhdGggaXMgZ2l2ZW4sIGl0IGNoZWNrcyBmb3IgdGhlIGVycm9yIG9uIHRoZSBwcmVzZW50IGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmhhc0Vycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRFcnJvcihlcnJvckNvZGUsIHBhdGgpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0cmlldmVzIHRoZSB0b3AtbGV2ZWwgYW5jZXN0b3Igb2YgdGhpcyBjb250cm9sLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHguX3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB4ID0geC5fcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZUNvbnRyb2xzRXJyb3JzID0gZnVuY3Rpb24gKGVtaXRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gdGhpcy5fY2FsY3VsYXRlU3RhdHVzKCk7XG4gICAgICAgICAgICBpZiAoZW1pdEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcy5lbWl0KHRoaXMuX3N0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVDb250cm9sc0Vycm9ycyhlbWl0RXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2luaXRPYnNlcnZhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2NhbGN1bGF0ZVN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbGxDb250cm9sc0Rpc2FibGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERJU0FCTEVEO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9ycylcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbnlDb250cm9sc0hhdmVTdGF0dXMoUEVORElORykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBFTkRJTkc7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW55Q29udHJvbHNIYXZlU3RhdHVzKElOVkFMSUQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgcmV0dXJuIFZBTElEO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250cm9scyhmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC5zdGF0dXMgPT09IHN0YXR1czsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fYW55Q29udHJvbHNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250cm9scyhmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC5kaXJ0eTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fYW55Q29udHJvbHNUb3VjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FueUNvbnRyb2xzKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLnRvdWNoZWQ7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVByaXN0aW5lID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSAhdGhpcy5fYW55Q29udHJvbHNEaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVByaXN0aW5lKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVRvdWNoZWQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl90b3VjaGVkID0gdGhpcy5fYW55Q29udHJvbHNUb3VjaGVkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlVG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9pc0JveGVkVmFsdWUgPSBmdW5jdGlvbiAoZm9ybVN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1TdGF0ZSA9PT0gJ29iamVjdCcgJiYgZm9ybVN0YXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5sZW5ndGggPT09IDIgJiYgJ3ZhbHVlJyBpbiBmb3JtU3RhdGUgJiYgJ2Rpc2FibGVkJyBpbiBmb3JtU3RhdGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIHJldHVybiBBYnN0cmFjdENvbnRyb2w7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBUcmFja3MgdGhlIHZhbHVlIGFuZCB2YWxpZGF0aW9uIHN0YXR1cyBvZiBhbiBpbmRpdmlkdWFsIGZvcm0gY29udHJvbC5cbiAgICAgKlxuICAgICAqIEl0IGlzIG9uZSBvZiB0aGUgdGhyZWUgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2tzIG9mIEFuZ3VsYXIgZm9ybXMsIGFsb25nIHdpdGhcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSBhbmQge0BsaW5rIEZvcm1BcnJheX0uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFdoZW4gaW5zdGFudGlhdGluZyBhIHtAbGluayBGb3JtQ29udHJvbH0sIHlvdSBjYW4gcGFzcyBpbiBhbiBpbml0aWFsIHZhbHVlIGFzIHRoZVxuICAgICAqIGZpcnN0IGFyZ3VtZW50LiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjdHJsID0gbmV3IEZvcm1Db250cm9sKCdzb21lIHZhbHVlJyk7XG4gICAgICogY29uc29sZS5sb2coY3RybC52YWx1ZSk7ICAgICAvLyAnc29tZSB2YWx1ZSdcbiAgICAgKmBgYFxuICAgICAqXG4gICAgICogWW91IGNhbiBhbHNvIGluaXRpYWxpemUgdGhlIGNvbnRyb2wgd2l0aCBhIGZvcm0gc3RhdGUgb2JqZWN0IG9uIGluc3RhbnRpYXRpb24sXG4gICAgICogd2hpY2ggaW5jbHVkZXMgYm90aCB0aGUgdmFsdWUgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9sIGlzIGRpc2FibGVkLlxuICAgICAqIFlvdSBjYW4ndCB1c2UgdGhlIHZhbHVlIGtleSB3aXRob3V0IHRoZSBkaXNhYmxlZCBrZXk7IGJvdGggYXJlIHJlcXVpcmVkXG4gICAgICogdG8gdXNlIHRoaXMgd2F5IG9mIGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjdHJsID0gbmV3IEZvcm1Db250cm9sKHt2YWx1ZTogJ24vYScsIGRpc2FibGVkOiB0cnVlfSk7XG4gICAgICogY29uc29sZS5sb2coY3RybC52YWx1ZSk7ICAgICAvLyAnbi9hJ1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwuc3RhdHVzKTsgICAvLyAnRElTQUJMRUQnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUbyBpbmNsdWRlIGEgc3luYyB2YWxpZGF0b3IgKG9yIGFuIGFycmF5IG9mIHN5bmMgdmFsaWRhdG9ycykgd2l0aCB0aGUgY29udHJvbCxcbiAgICAgKiBwYXNzIGl0IGluIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuIEFzeW5jIHZhbGlkYXRvcnMgYXJlIGFsc28gc3VwcG9ydGVkLCBidXRcbiAgICAgKiBoYXZlIHRvIGJlIHBhc3NlZCBpbiBzZXBhcmF0ZWx5IGFzIHRoZSB0aGlyZCBhcmcuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGN0cmwgPSBuZXcgRm9ybUNvbnRyb2woJycsIFZhbGlkYXRvcnMucmVxdWlyZWQpO1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwudmFsdWUpOyAgICAgLy8gJydcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnN0YXR1cyk7ICAgLy8gJ0lOVkFMSUQnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBTZWUgaXRzIHN1cGVyY2xhc3MsIHtAbGluayBBYnN0cmFjdENvbnRyb2x9LCBmb3IgbW9yZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUNvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNihGb3JtQ29udHJvbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUNvbnRyb2woZm9ybVN0YXRlLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAoZm9ybVN0YXRlID09PSB2b2lkIDApIHsgZm9ybVN0YXRlID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgY29lcmNlVG9WYWxpZGF0b3IodmFsaWRhdG9yKSwgY29lcmNlVG9Bc3luY1ZhbGlkYXRvcihhc3luY1ZhbGlkYXRvcikpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Rm9ybVN0YXRlKGZvcm1TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRPYnNlcnZhYmxlcygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBmb3JtIGNvbnRyb2wgdG8gYHZhbHVlYC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYG9ubHlTZWxmYCBpcyBgdHJ1ZWAsIHRoaXMgY2hhbmdlIHdpbGwgb25seSBhZmZlY3QgdGhlIHZhbGlkYXRpb24gb2YgdGhpcyBgRm9ybUNvbnRyb2xgXG4gICAgICAgICAqIGFuZCBub3QgaXRzIHBhcmVudCBjb21wb25lbnQuIFRoaXMgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBlbWl0RXZlbnRgIGlzIGB0cnVlYCwgdGhpc1xuICAgICAgICAgKiBjaGFuZ2Ugd2lsbCBjYXVzZSBhIGB2YWx1ZUNoYW5nZXNgIGV2ZW50IG9uIHRoZSBgRm9ybUNvbnRyb2xgIHRvIGJlIGVtaXR0ZWQuIFRoaXMgZGVmYXVsdHNcbiAgICAgICAgICogdG8gdHJ1ZSAoYXMgaXQgZmFsbHMgdGhyb3VnaCB0byBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eWApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlYCBpcyBgdHJ1ZWAsIHRoZSB2aWV3IHdpbGwgYmUgbm90aWZpZWQgYWJvdXQgdGhlIG5ldyB2YWx1ZVxuICAgICAgICAgKiB2aWEgYW4gYG9uQ2hhbmdlYCBldmVudC4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBpZiBgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlYCBpcyBub3RcbiAgICAgICAgICogc3BlY2lmaWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZW1pdFZpZXdUb01vZGVsQ2hhbmdlYCBpcyBgdHJ1ZWAsIGFuIG5nTW9kZWxDaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCB0byB1cGRhdGUgdGhlXG4gICAgICAgICAqIG1vZGVsLiAgVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBpZiBgZW1pdFZpZXdUb01vZGVsQ2hhbmdlYCBpcyBub3Qgc3BlY2lmaWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQsIGVtaXRNb2RlbFRvVmlld0NoYW5nZSA9IF9iLmVtaXRNb2RlbFRvVmlld0NoYW5nZSwgZW1pdFZpZXdUb01vZGVsQ2hhbmdlID0gX2IuZW1pdFZpZXdUb01vZGVsQ2hhbmdlO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZS5sZW5ndGggJiYgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZUZuKSB7IHJldHVybiBjaGFuZ2VGbihfdGhpcy5fdmFsdWUsIGVtaXRWaWV3VG9Nb2RlbENoYW5nZSAhPT0gZmFsc2UpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXRjaGVzIHRoZSB2YWx1ZSBvZiBhIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZnVuY3Rpb25hbGx5IHRoZSBzYW1lIGFzIHtAbGluayBGb3JtQ29udHJvbC5zZXRWYWx1ZX0gYXQgdGhpcyBsZXZlbC5cbiAgICAgICAgICogSXQgZXhpc3RzIGZvciBzeW1tZXRyeSB3aXRoIHtAbGluayBGb3JtR3JvdXAucGF0Y2hWYWx1ZX0gb24gYEZvcm1Hcm91cHNgIGFuZCBgRm9ybUFycmF5c2AsXG4gICAgICAgICAqIHdoZXJlIGl0IGRvZXMgYmVoYXZlIGRpZmZlcmVudGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnBhdGNoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgZm9ybSBjb250cm9sLiBUaGlzIG1lYW5zIGJ5IGRlZmF1bHQ6XG4gICAgICAgICAqXG4gICAgICAgICAqICogaXQgaXMgbWFya2VkIGFzIGBwcmlzdGluZWBcbiAgICAgICAgICogKiBpdCBpcyBtYXJrZWQgYXMgYHVudG91Y2hlZGBcbiAgICAgICAgICogKiB2YWx1ZSBpcyBzZXQgdG8gbnVsbFxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgY2FuIGFsc28gcmVzZXQgdG8gYSBzcGVjaWZpYyBmb3JtIHN0YXRlIGJ5IHBhc3NpbmcgdGhyb3VnaCBhIHN0YW5kYWxvbmVcbiAgICAgICAgICogdmFsdWUgb3IgYSBmb3JtIHN0YXRlIG9iamVjdCB0aGF0IGNvbnRhaW5zIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZCBzdGF0ZVxuICAgICAgICAgKiAodGhlc2UgYXJlIHRoZSBvbmx5IHR3byBwcm9wZXJ0aWVzIHRoYXQgY2Fubm90IGJlIGNhbGN1bGF0ZWQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFeDpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogdGhpcy5jb250cm9sLnJlc2V0KCdOYW5jeScpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmNvbnRyb2wudmFsdWUpOyAgLy8gJ05hbmN5J1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogT1JcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHRoaXMuY29udHJvbC5yZXNldCh7dmFsdWU6ICdOYW5jeScsIGRpc2FibGVkOiB0cnVlfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuY29udHJvbC52YWx1ZSk7ICAvLyAnTmFuY3knXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuY29udHJvbC5zdGF0dXMpOyAgLy8gJ0RJU0FCTEVEJ1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChmb3JtU3RhdGUsIF9hKSB7XG4gICAgICAgICAgICBpZiAoZm9ybVN0YXRlID09PSB2b2lkIDApIHsgZm9ybVN0YXRlID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Rm9ybVN0YXRlKGZvcm1TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLm1hcmtBc1ByaXN0aW5lKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5tYXJrQXNVbnRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlLCB7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fYW55Q29udHJvbHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9hbGxDb250cm9sc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kaXNhYmxlZDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIGNoYW5nZSBldmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZS5wdXNoKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9jbGVhckNoYW5nZUZucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlID0gW107XG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlID0gW107XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIGxpc3RlbmVyIGZvciBkaXNhYmxlZCBldmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVnaXN0ZXJPbkRpc2FibGVkQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlLnB1c2goZm4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2ZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChjYikgeyB9O1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2FwcGx5Rm9ybVN0YXRlID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQm94ZWRWYWx1ZShmb3JtU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBmb3JtU3RhdGUudmFsdWU7XG4gICAgICAgICAgICAgICAgZm9ybVN0YXRlLmRpc2FibGVkID8gdGhpcy5kaXNhYmxlKHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSkgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBmb3JtU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQ29udHJvbDtcbiAgICB9KEFic3RyYWN0Q29udHJvbCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGEgZ3JvdXAgb2Yge0BsaW5rIEZvcm1Db250cm9sfVxuICAgICAqIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIEEgYEZvcm1Hcm91cGAgYWdncmVnYXRlcyB0aGUgdmFsdWVzIG9mIGVhY2ggY2hpbGQge0BsaW5rIEZvcm1Db250cm9sfSBpbnRvIG9uZSBvYmplY3QsXG4gICAgICogd2l0aCBlYWNoIGNvbnRyb2wgbmFtZSBhcyB0aGUga2V5LiAgSXQgY2FsY3VsYXRlcyBpdHMgc3RhdHVzIGJ5IHJlZHVjaW5nIHRoZSBzdGF0dXNlc1xuICAgICAqIG9mIGl0cyBjaGlsZHJlbi4gRm9yIGV4YW1wbGUsIGlmIG9uZSBvZiB0aGUgY29udHJvbHMgaW4gYSBncm91cCBpcyBpbnZhbGlkLCB0aGUgZW50aXJlXG4gICAgICogZ3JvdXAgYmVjb21lcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogYEZvcm1Hcm91cGAgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3MgdXNlZCB0byBkZWZpbmUgZm9ybXMgaW4gQW5ndWxhcixcbiAgICAgKiBhbG9uZyB3aXRoIHtAbGluayBGb3JtQ29udHJvbH0gYW5kIHtAbGluayBGb3JtQXJyYXl9LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBXaGVuIGluc3RhbnRpYXRpbmcgYSB7QGxpbmsgRm9ybUdyb3VwfSwgcGFzcyBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGQgY29udHJvbHMgYXMgdGhlIGZpcnN0XG4gICAgICogYXJndW1lbnQuIFRoZSBrZXkgZm9yIGVhY2ggY2hpbGQgd2lsbCBiZSB0aGUgbmFtZSB1bmRlciB3aGljaCBpdCBpcyByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woJ05hbmN5JywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqICAgbGFzdDogbmV3IEZvcm1Db250cm9sKCdEcmV3JyksXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6ICdOYW5jeScsIGxhc3Q7ICdEcmV3J31cbiAgICAgKiBjb25zb2xlLmxvZyhmb3JtLnN0YXR1cyk7ICAvLyAnVkFMSUQnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gaW5jbHVkZSBncm91cC1sZXZlbCB2YWxpZGF0b3JzIGFzIHRoZSBzZWNvbmQgYXJnLCBvciBncm91cC1sZXZlbCBhc3luY1xuICAgICAqIHZhbGlkYXRvcnMgYXMgdGhlIHRoaXJkIGFyZy4gVGhlc2UgY29tZSBpbiBoYW5keSB3aGVuIHlvdSB3YW50IHRvIHBlcmZvcm0gdmFsaWRhdGlvblxuICAgICAqIHRoYXQgY29uc2lkZXJzIHRoZSB2YWx1ZSBvZiBtb3JlIHRoYW4gb25lIGNoaWxkIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgcGFzc3dvcmQ6IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqICAgcGFzc3dvcmRDb25maXJtOiBuZXcgRm9ybUNvbnRyb2woJycsIFZhbGlkYXRvcnMubWluTGVuZ3RoKDIpKSxcbiAgICAgKiB9LCBwYXNzd29yZE1hdGNoVmFsaWRhdG9yKTtcbiAgICAgKlxuICAgICAqXG4gICAgICogZnVuY3Rpb24gcGFzc3dvcmRNYXRjaFZhbGlkYXRvcihnOiBGb3JtR3JvdXApIHtcbiAgICAgKiAgICByZXR1cm4gZy5nZXQoJ3Bhc3N3b3JkJykudmFsdWUgPT09IGcuZ2V0KCdwYXNzd29yZENvbmZpcm0nKS52YWx1ZVxuICAgICAqICAgICAgID8gbnVsbCA6IHsnbWlzbWF0Y2gnOiB0cnVlfTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNihGb3JtR3JvdXAsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Hcm91cChjb250cm9scywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlcnMgYSBjb250cm9sIHdpdGggdGhlIGdyb3VwJ3MgbGlzdCBvZiBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgZG9lcyBub3QgdXBkYXRlIHZhbHVlIG9yIHZhbGlkaXR5IG9mIHRoZSBjb250cm9sLCBzbyBmb3JcbiAgICAgICAgICogbW9zdCBjYXNlcyB5b3UnbGwgd2FudCB0byB1c2Uge0BsaW5rIEZvcm1Hcm91cC5hZGRDb250cm9sfSBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5yZWdpc3RlckNvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSwgY29udHJvbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHNbbmFtZV07XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdID0gY29udHJvbDtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UodGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgY29udHJvbCB0byB0aGlzIGdyb3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJDb250cm9sKG5hbWUsIGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIGNvbnRyb2wgZnJvbSB0aGlzIGdyb3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW25hbWVdKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbbmFtZV0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICBkZWxldGUgKHRoaXMuY29udHJvbHNbbmFtZV0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2UgYW4gZXhpc3RpbmcgY29udHJvbC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuc2V0Q29udHJvbCA9IGZ1bmN0aW9uIChuYW1lLCBjb250cm9sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tuYW1lXSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgZGVsZXRlICh0aGlzLmNvbnRyb2xzW25hbWVdKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sKVxuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJDb250cm9sKG5hbWUsIGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHdoZXRoZXIgdGhlcmUgaXMgYW4gZW5hYmxlZCBjb250cm9sIHdpdGggdGhlIGdpdmVuIG5hbWUgaW4gdGhlIGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3IgZGlzYWJsZWQgY29udHJvbHMuIElmIHlvdSdkIGxpa2UgdG8gY2hlY2sgZm9yXG4gICAgICAgICAqIGV4aXN0ZW5jZSBpbiB0aGUgZ3JvdXAgb25seSwgdXNlIHtAbGluayBBYnN0cmFjdENvbnRyb2wuZ2V0fSBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChjb250cm9sTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMuaGFzT3duUHJvcGVydHkoY29udHJvbE5hbWUpICYmIHRoaXMuY29udHJvbHNbY29udHJvbE5hbWVdLmVuYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHtAbGluayBGb3JtR3JvdXB9LiBJdCBhY2NlcHRzIGFuIG9iamVjdCB0aGF0IG1hdGNoZXNcbiAgICAgICAgICogIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdyb3VwLCB3aXRoIGNvbnRyb2wgbmFtZXMgYXMga2V5cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgc3RyaWN0IGNoZWNrcywgc28gaXQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5XG4gICAgICAgICAqIHRvIHNldCB0aGUgdmFsdWUgb2YgYSBjb250cm9sIHRoYXQgZG9lc24ndCBleGlzdCBvciBpZiB5b3UgZXhjbHVkZSB0aGVcbiAgICAgICAgICogdmFsdWUgb2YgYSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgICAgKiAgICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbGFzdDogbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIH0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiBudWxsLCBsYXN0OiBudWxsfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgZm9ybS5zZXRWYWx1ZSh7Zmlyc3Q6ICdOYW5jeScsIGxhc3Q6ICdEcmV3J30pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OiAnRHJldyd9XG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrQWxsVmFsdWVzUHJlc2VudCh2YWx1ZSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl90aHJvd0lmQ29udHJvbE1pc3NpbmcobmFtZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbHNbbmFtZV0uc2V0VmFsdWUodmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogIFBhdGNoZXMgdGhlIHZhbHVlIG9mIHRoZSB7QGxpbmsgRm9ybUdyb3VwfS4gSXQgYWNjZXB0cyBhbiBvYmplY3Qgd2l0aCBjb250cm9sXG4gICAgICAgICAqICBuYW1lcyBhcyBrZXlzLCBhbmQgd2lsbCBkbyBpdHMgYmVzdCB0byBtYXRjaCB0aGUgdmFsdWVzIHRvIHRoZSBjb3JyZWN0IGNvbnRyb2xzXG4gICAgICAgICAqICBpbiB0aGUgZ3JvdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqICBJdCBhY2NlcHRzIGJvdGggc3VwZXItc2V0cyBhbmQgc3ViLXNldHMgb2YgdGhlIGdyb3VwIHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqICBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICAgICAqICAgICBmaXJzdDogbmV3IEZvcm1Db250cm9sKCksXG4gICAgICAgICAqICAgICBsYXN0OiBuZXcgRm9ybUNvbnRyb2woKVxuICAgICAgICAgKiAgfSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6IG51bGwsIGxhc3Q6IG51bGx9XG4gICAgICAgICAqXG4gICAgICAgICAqICBmb3JtLnBhdGNoVmFsdWUoe2ZpcnN0OiAnTmFuY3knfSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6ICdOYW5jeScsIGxhc3Q6IG51bGx9XG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUucGF0Y2hWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29udHJvbHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbHNbbmFtZV0ucGF0Y2hWYWx1ZSh2YWx1ZVtuYW1lXSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSB7QGxpbmsgRm9ybUdyb3VwfS4gVGhpcyBtZWFucyBieSBkZWZhdWx0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIFRoZSBncm91cCBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHByaXN0aW5lYFxuICAgICAgICAgKiAqIFRoZSBncm91cCBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHVudG91Y2hlZGBcbiAgICAgICAgICogKiBUaGUgdmFsdWUgb2YgYWxsIGRlc2NlbmRhbnRzIHdpbGwgYmUgbnVsbCBvciBudWxsIG1hcHNcbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhbHNvIHJlc2V0IHRvIGEgc3BlY2lmaWMgZm9ybSBzdGF0ZSBieSBwYXNzaW5nIGluIGEgbWFwIG9mIHN0YXRlc1xuICAgICAgICAgKiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiB5b3VyIGZvcm0sIHdpdGggY29udHJvbCBuYW1lcyBhcyBrZXlzLiBUaGUgc3RhdGVcbiAgICAgICAgICogY2FuIGJlIGEgc3RhbmRhbG9uZSB2YWx1ZSBvciBhIGZvcm0gc3RhdGUgb2JqZWN0IHdpdGggYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkXG4gICAgICAgICAqIHN0YXR1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogdGhpcy5mb3JtLnJlc2V0KHtmaXJzdDogJ25hbWUnLCBsYXN0OiAnbGFzdCBuYW1lJ30pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmZvcm0udmFsdWUpOyAgLy8ge2ZpcnN0OiAnbmFtZScsIGxhc3Q6ICdsYXN0IG5hbWUnfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogLSBPUiAtXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiB0aGlzLmZvcm0ucmVzZXQoe1xuICAgICAgICAgKiAgIGZpcnN0OiB7dmFsdWU6ICduYW1lJywgZGlzYWJsZWQ6IHRydWV9LFxuICAgICAgICAgKiAgIGxhc3Q6ICdsYXN0J1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5mb3JtLnZhbHVlKTsgIC8vIHtmaXJzdDogJ25hbWUnLCBsYXN0OiAnbGFzdCBuYW1lJ31cbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5mb3JtLmdldCgnZmlyc3QnKS5zdGF0dXMpOyAgLy8gJ0RJU0FCTEVEJ1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5yZXNldCh2YWx1ZVtuYW1lXSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWdncmVnYXRlIHZhbHVlIG9mIHRoZSB7QGxpbmsgRm9ybUdyb3VwfSwgaW5jbHVkaW5nIGFueSBkaXNhYmxlZCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgeW91J2QgbGlrZSB0byBpbmNsdWRlIGFsbCB2YWx1ZXMgcmVnYXJkbGVzcyBvZiBkaXNhYmxlZCBzdGF0dXMsIHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyB0aGUgYmVzdCB3YXkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ3JvdXAuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLmdldFJhd1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZUNoaWxkcmVuKHt9LCBmdW5jdGlvbiAoYWNjLCBjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fdGhyb3dJZkNvbnRyb2xNaXNzaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5jb250cm9scykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgICBUaGVyZSBhcmUgbm8gZm9ybSBjb250cm9scyByZWdpc3RlcmVkIHdpdGggdGhpcyBncm91cCB5ZXQuICBJZiB5b3UncmUgdXNpbmcgbmdNb2RlbCxcXG4gICAgICAgIHlvdSBtYXkgd2FudCB0byBjaGVjayBuZXh0IHRpY2sgKGUuZy4gdXNlIHNldFRpbWVvdXQpLlxcbiAgICAgIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jb250cm9sc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZvcm0gY29udHJvbCB3aXRoIG5hbWU6IFwiICsgbmFtZSArIFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2xzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IHJldHVybiBjYihfdGhpcy5jb250cm9sc1trXSwgayk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX3NldFVwQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5zZXRQYXJlbnQoX3RoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKF90aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZhbHVlID0gdGhpcy5fcmVkdWNlVmFsdWUoKTsgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9hbnlDb250cm9scyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcmVzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMgfHwgKF90aGlzLmNvbnRhaW5zKG5hbWUpICYmIGNvbmRpdGlvbihjb250cm9sKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fcmVkdWNlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZUNoaWxkcmVuKHt9LCBmdW5jdGlvbiAoYWNjLCBjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuZW5hYmxlZCB8fCBfdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbbmFtZV0gPSBjb250cm9sLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fcmVkdWNlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoaW5pdFZhbHVlLCBmbikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGluaXRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgbmFtZSkgeyByZXMgPSBmbihyZXMsIGNvbnRyb2wsIG5hbWUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fYWxsQ29udHJvbHNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2xzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbE5hbWUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbY29udHJvbE5hbWVdLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2xzKS5sZW5ndGggPiAwIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fY2hlY2tBbGxWYWx1ZXNQcmVzZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBhIHZhbHVlIGZvciBmb3JtIGNvbnRyb2wgd2l0aCBuYW1lOiAnXCIgKyBuYW1lICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Hcm91cDtcbiAgICB9KEFic3RyYWN0Q29udHJvbCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGFuIGFycmF5IG9mIHtAbGluayBGb3JtQ29udHJvbH1cbiAgICAgKiBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBBIGBGb3JtQXJyYXlgIGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlcyBvZiBlYWNoIGNoaWxkIHtAbGluayBGb3JtQ29udHJvbH0gaW50byBhbiBhcnJheS5cbiAgICAgKiBJdCBjYWxjdWxhdGVzIGl0cyBzdGF0dXMgYnkgcmVkdWNpbmcgdGhlIHN0YXR1c2VzIG9mIGl0cyBjaGlsZHJlbi4gRm9yIGV4YW1wbGUsIGlmIG9uZSBvZlxuICAgICAqIHRoZSBjb250cm9scyBpbiBhIGBGb3JtQXJyYXlgIGlzIGludmFsaWQsIHRoZSBlbnRpcmUgYXJyYXkgYmVjb21lcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogYEZvcm1BcnJheWAgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3MgdXNlZCB0byBkZWZpbmUgZm9ybXMgaW4gQW5ndWxhcixcbiAgICAgKiBhbG9uZyB3aXRoIHtAbGluayBGb3JtQ29udHJvbH0gYW5kIHtAbGluayBGb3JtR3JvdXB9LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBXaGVuIGluc3RhbnRpYXRpbmcgYSB7QGxpbmsgRm9ybUFycmF5fSwgcGFzcyBpbiBhbiBhcnJheSBvZiBjaGlsZCBjb250cm9scyBhcyB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBhcnIgPSBuZXcgRm9ybUFycmF5KFtcbiAgICAgKiAgIG5ldyBGb3JtQ29udHJvbCgnTmFuY3knLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gICAgICogICBuZXcgRm9ybUNvbnRyb2woJ0RyZXcnKSxcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gWydOYW5jeScsICdEcmV3J11cbiAgICAgKiBjb25zb2xlLmxvZyhhcnIuc3RhdHVzKTsgIC8vICdWQUxJRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBpbmNsdWRlIGFycmF5LWxldmVsIHZhbGlkYXRvcnMgYXMgdGhlIHNlY29uZCBhcmcsIG9yIGFycmF5LWxldmVsIGFzeW5jXG4gICAgICogdmFsaWRhdG9ycyBhcyB0aGUgdGhpcmQgYXJnLiBUaGVzZSBjb21lIGluIGhhbmR5IHdoZW4geW91IHdhbnQgdG8gcGVyZm9ybSB2YWxpZGF0aW9uXG4gICAgICogdGhhdCBjb25zaWRlcnMgdGhlIHZhbHVlIG9mIG1vcmUgdGhhbiBvbmUgY2hpbGQgY29udHJvbC5cbiAgICAgKlxuICAgICAqICMjIyBBZGRpbmcgb3IgcmVtb3ZpbmcgY29udHJvbHNcbiAgICAgKlxuICAgICAqIFRvIGNoYW5nZSB0aGUgY29udHJvbHMgaW4gdGhlIGFycmF5LCB1c2UgdGhlIGBwdXNoYCwgYGluc2VydGAsIG9yIGByZW1vdmVBdGAgbWV0aG9kc1xuICAgICAqIGluIGBGb3JtQXJyYXlgIGl0c2VsZi4gVGhlc2UgbWV0aG9kcyBlbnN1cmUgdGhlIGNvbnRyb2xzIGFyZSBwcm9wZXJseSB0cmFja2VkIGluIHRoZVxuICAgICAqIGZvcm0ncyBoaWVyYXJjaHkuIERvIG5vdCBtb2RpZnkgdGhlIGFycmF5IG9mIGBBYnN0cmFjdENvbnRyb2xgcyB1c2VkIHRvIGluc3RhbnRpYXRlXG4gICAgICogdGhlIGBGb3JtQXJyYXlgIGRpcmVjdGx5LCBhcyB0aGF0IHdpbGwgcmVzdWx0IGluIHN0cmFuZ2UgYW5kIHVuZXhwZWN0ZWQgYmVoYXZpb3Igc3VjaFxuICAgICAqIGFzIGJyb2tlbiBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUFycmF5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRm9ybUFycmF5LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtQXJyYXkoY29udHJvbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3IgPT09IHZvaWQgMCkgeyBhc3luY1ZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgICAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRVcENvbnRyb2xzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRyb2xzW2luZGV4XTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCBhIG5ldyB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnB1c2goY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlckNvbnRyb2woY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IGEgbmV3IHtAbGluayBBYnN0cmFjdENvbnRyb2x9IGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCBjb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShpbmRleCwgMCwgY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlckNvbnRyb2woY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBjb250cm9sIGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucmVtb3ZlQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW2luZGV4XSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW2luZGV4XS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBsYWNlIGFuIGV4aXN0aW5nIGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnNldENvbnRyb2wgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW2luZGV4XSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW2luZGV4XS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9scy5zcGxpY2UoaW5kZXgsIDAsIGNvbnRyb2wpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXkucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlbmd0aCBvZiB0aGUgY29udHJvbCBhcnJheS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2xzLmxlbmd0aDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHtAbGluayBGb3JtQXJyYXl9LiBJdCBhY2NlcHRzIGFuIGFycmF5IHRoYXQgbWF0Y2hlc1xuICAgICAgICAgKiAgdGhlIHN0cnVjdHVyZSBvZiB0aGUgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgc3RyaWN0IGNoZWNrcywgc28gaXQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5XG4gICAgICAgICAqIHRvIHNldCB0aGUgdmFsdWUgb2YgYSBjb250cm9sIHRoYXQgZG9lc24ndCBleGlzdCBvciBpZiB5b3UgZXhjbHVkZSB0aGVcbiAgICAgICAgICogdmFsdWUgb2YgYSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICAgICAqICAgICBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgICAgICogICAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICAgICAqICBdKTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gW251bGwsIG51bGxdXG4gICAgICAgICAqXG4gICAgICAgICAqICBhcnIuc2V0VmFsdWUoWydOYW5jeScsICdEcmV3J10pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgJ0RyZXcnXVxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0FsbFZhbHVlc1ByZXNlbnQodmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAobmV3VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rocm93SWZDb250cm9sTWlzc2luZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLnNldFZhbHVlKG5ld1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBQYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGUge0BsaW5rIEZvcm1BcnJheX0uIEl0IGFjY2VwdHMgYW4gYXJyYXkgdGhhdCBtYXRjaGVzIHRoZVxuICAgICAgICAgKiAgc3RydWN0dXJlIG9mIHRoZSBjb250cm9sLCBhbmQgd2lsbCBkbyBpdHMgYmVzdCB0byBtYXRjaCB0aGUgdmFsdWVzIHRvIHRoZSBjb3JyZWN0XG4gICAgICAgICAqICBjb250cm9scyBpbiB0aGUgZ3JvdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqICBJdCBhY2NlcHRzIGJvdGggc3VwZXItc2V0cyBhbmQgc3ViLXNldHMgb2YgdGhlIGFycmF5IHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqICBjb25zdCBhcnIgPSBuZXcgRm9ybUFycmF5KFtcbiAgICAgICAgICogICAgIG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIF0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbbnVsbCwgbnVsbF1cbiAgICAgICAgICpcbiAgICAgICAgICogIGFyci5wYXRjaFZhbHVlKFsnTmFuY3knXSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFsnTmFuY3knLCBudWxsXVxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnBhdGNoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKG5ld1ZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLnBhdGNoVmFsdWUobmV3VmFsdWUsIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUge0BsaW5rIEZvcm1BcnJheX0uIFRoaXMgbWVhbnMgYnkgZGVmYXVsdDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBUaGUgYXJyYXkgYW5kIGFsbCBkZXNjZW5kYW50cyBhcmUgbWFya2VkIGBwcmlzdGluZWBcbiAgICAgICAgICogKiBUaGUgYXJyYXkgYW5kIGFsbCBkZXNjZW5kYW50cyBhcmUgbWFya2VkIGB1bnRvdWNoZWRgXG4gICAgICAgICAqICogVGhlIHZhbHVlIG9mIGFsbCBkZXNjZW5kYW50cyB3aWxsIGJlIG51bGwgb3IgbnVsbCBtYXBzXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWxzbyByZXNldCB0byBhIHNwZWNpZmljIGZvcm0gc3RhdGUgYnkgcGFzc2luZyBpbiBhbiBhcnJheSBvZiBzdGF0ZXNcbiAgICAgICAgICogdGhhdCBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGNvbnRyb2wuIFRoZSBzdGF0ZSBjYW4gYmUgYSBzdGFuZGFsb25lIHZhbHVlXG4gICAgICAgICAqIG9yIGEgZm9ybSBzdGF0ZSBvYmplY3Qgd2l0aCBib3RoIGEgdmFsdWUgYW5kIGEgZGlzYWJsZWQgc3RhdHVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiB0aGlzLmFyci5yZXNldChbJ25hbWUnLCAnbGFzdCBuYW1lJ10pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmFyci52YWx1ZSk7ICAvLyBbJ25hbWUnLCAnbGFzdCBuYW1lJ11cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIC0gT1IgLVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogdGhpcy5hcnIucmVzZXQoW1xuICAgICAgICAgKiAgIHt2YWx1ZTogJ25hbWUnLCBkaXNhYmxlZDogdHJ1ZX0sXG4gICAgICAgICAqICAgJ2xhc3QnXG4gICAgICAgICAqIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmFyci52YWx1ZSk7ICAvLyBbJ25hbWUnLCAnbGFzdCBuYW1lJ11cbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5hcnIuZ2V0KDApLnN0YXR1cyk7ICAvLyAnRElTQUJMRUQnXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gW107IH1cbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5yZXNldCh2YWx1ZVtpbmRleF0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGUgYXJyYXksIGluY2x1ZGluZyBhbnkgZGlzYWJsZWQgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSdkIGxpa2UgdG8gaW5jbHVkZSBhbGwgdmFsdWVzIHJlZ2FyZGxlc3Mgb2YgZGlzYWJsZWQgc3RhdHVzLCB1c2UgdGhpcyBtZXRob2QuXG4gICAgICAgICAqIE90aGVyd2lzZSwgdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgdGhlIGJlc3Qgd2F5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5nZXRSYXdWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbHMubWFwKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLnZhbHVlOyB9KTsgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl90aHJvd0lmQ29udHJvbE1pc3NpbmcgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250cm9scy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICAgIFRoZXJlIGFyZSBubyBmb3JtIGNvbnRyb2xzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGFycmF5IHlldC4gIElmIHlvdSdyZSB1c2luZyBuZ01vZGVsLFxcbiAgICAgICAgeW91IG1heSB3YW50IHRvIGNoZWNrIG5leHQgdGljayAoZS5nLiB1c2Ugc2V0VGltZW91dCkuXFxuICAgICAgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmF0KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZvcm0gY29udHJvbCBhdCBpbmRleCBcIiArIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbCwgaW5kZXgpIHsgY2IoY29udHJvbCwgaW5kZXgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY29udHJvbHMuZmlsdGVyKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLmVuYWJsZWQgfHwgX3RoaXMuZGlzYWJsZWQ7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC52YWx1ZTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fYW55Q29udHJvbHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9scy5zb21lKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLmVuYWJsZWQgJiYgY29uZGl0aW9uKGNvbnRyb2wpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9zZXRVcENvbnRyb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gX3RoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fY2hlY2tBbGxWYWx1ZXNQcmVzZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBhIHZhbHVlIGZvciBmb3JtIGNvbnRyb2wgYXQgaW5kZXg6IFwiICsgaSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9hbGxDb250cm9sc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY29udHJvbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMubGVuZ3RoID4gMCB8fCB0aGlzLmRpc2FibGVkO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9yZWdpc3RlckNvbnRyb2wgPSBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgICAgICBjb250cm9sLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSh0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUFycmF5O1xuICAgIH0oQWJzdHJhY3RDb250cm9sKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGZvcm1EaXJlY3RpdmVQcm92aWRlciA9IHtcbiAgICAgICAgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ0Zvcm07IH0pXG4gICAgfTtcbiAgICB2YXIgcmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIENyZWF0ZXMgYSB0b3AtbGV2ZWwge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgYW5kIGJpbmRzIGl0IHRvIGEgZm9ybVxuICAgICAqIHRvIHRyYWNrIGFnZ3JlZ2F0ZSBmb3JtIHZhbHVlIGFuZCB2YWxpZGF0aW9uIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogQXMgc29vbiBhcyB5b3UgaW1wb3J0IHRoZSBgRm9ybXNNb2R1bGVgLCB0aGlzIGRpcmVjdGl2ZSBiZWNvbWVzIGFjdGl2ZSBieSBkZWZhdWx0IG9uXG4gICAgICogYWxsIGA8Zm9ybT5gIHRhZ3MuICBZb3UgZG9uJ3QgbmVlZCB0byBhZGQgYSBzcGVjaWFsIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogWW91IGNhbiBleHBvcnQgdGhlIGRpcmVjdGl2ZSBpbnRvIGEgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGUgdXNpbmcgYG5nRm9ybWAgYXMgdGhlIGtleVxuICAgICAqIChleDogYCNteUZvcm09XCJuZ0Zvcm1cImApLiBUaGlzIGlzIG9wdGlvbmFsLCBidXQgdXNlZnVsLiAgTWFueSBwcm9wZXJ0aWVzIGZyb20gdGhlIHVuZGVybHlpbmdcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSBhcmUgZHVwbGljYXRlZCBvbiB0aGUgZGlyZWN0aXZlIGl0c2VsZiwgc28gYSByZWZlcmVuY2UgdG8gaXRcbiAgICAgKiB3aWxsIGdpdmUgeW91IGFjY2VzcyB0byB0aGUgYWdncmVnYXRlIHZhbHVlIGFuZCB2YWxpZGl0eSBzdGF0dXMgb2YgdGhlIGZvcm0sIGFzIHdlbGwgYXNcbiAgICAgKiB1c2VyIGludGVyYWN0aW9uIHByb3BlcnRpZXMgbGlrZSBgZGlydHlgIGFuZCBgdG91Y2hlZGAuXG4gICAgICpcbiAgICAgKiBUbyByZWdpc3RlciBjaGlsZCBjb250cm9scyB3aXRoIHRoZSBmb3JtLCB5b3UnbGwgd2FudCB0byB1c2Uge0BsaW5rIE5nTW9kZWx9IHdpdGggYVxuICAgICAqIGBuYW1lYCBhdHRyaWJ1dGUuICBZb3UgY2FuIGFsc28gdXNlIHtAbGluayBOZ01vZGVsR3JvdXB9IGlmIHlvdSdkIGxpa2UgdG8gY3JlYXRlXG4gICAgICogc3ViLWdyb3VwcyB3aXRoaW4gdGhlIGZvcm0uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGxpc3RlbiB0byB0aGUgZGlyZWN0aXZlJ3MgYG5nU3VibWl0YCBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB1c2VyIGhhc1xuICAgICAqIHRyaWdnZXJlZCBhIGZvcm0gc3VibWlzc2lvbi4gVGhlIGBuZ1N1Ym1pdGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIG9yaWdpbmFsIGZvcm1cbiAgICAgKiBzdWJtaXNzaW9uIGV2ZW50LlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm0vc2ltcGxlX2Zvcm1fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nRm9ybSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ0KE5nRm9ybSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdGb3JtKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmdTdWJtaXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm0gPVxuICAgICAgICAgICAgICAgIG5ldyBGb3JtR3JvdXAoe30sIGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpLCBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcInN1Ym1pdHRlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N1Ym1pdHRlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImNvbnRyb2xzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtLmNvbnRyb2xzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGRpci5fY29udHJvbCA9IGNvbnRhaW5lci5yZWdpc3RlckNvbnRyb2woZGlyLm5hbWUsIGRpci5jb250cm9sKTtcbiAgICAgICAgICAgICAgICBzZXRVcENvbnRyb2woZGlyLmNvbnRyb2wsIGRpcik7XG4gICAgICAgICAgICAgICAgZGlyLmNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5nZXRDb250cm9sID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDb250cm9sKGRpci5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5hZGRGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gICAgICAgICAgICAgICAgc2V0VXBGb3JtQ29udGFpbmVyKGdyb3VwLCBkaXIpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZWdpc3RlckNvbnRyb2woZGlyLm5hbWUsIGdyb3VwKTtcbiAgICAgICAgICAgICAgICBncm91cC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLnJlbW92ZUZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDb250cm9sKGRpci5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5nZXRGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTsgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uIChkaXIsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjdHJsID0gX3RoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGN0cmwuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5jb250cm9sLnNldFZhbHVlKHZhbHVlKTsgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5vblN1Ym1pdCA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5nU3VibWl0LmVtaXQoJGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5vblJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnJlc2V0Rm9ybSgpOyB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLnJlc2V0Rm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgIHRoaXMuZm9ybS5yZXNldCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLl9maW5kQ29udGFpbmVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPyB0aGlzLmZvcm0uZ2V0KHBhdGgpIDogdGhpcy5mb3JtO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2Zvcm06bm90KFtuZ05vRm9ybV0pOm5vdChbZm9ybUdyb3VwXSksbmdGb3JtLFtuZ0Zvcm1dJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2Zvcm1EaXJlY3RpdmVQcm92aWRlcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoc3VibWl0KSc6ICdvblN1Ym1pdCgkZXZlbnQpJywgJyhyZXNldCknOiAnb25SZXNldCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWyduZ1N1Ym1pdCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ0Zvcm0nXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdGb3JtLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTmdGb3JtO1xuICAgIH0oQ29udHJvbENvbnRhaW5lcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBFeGFtcGxlcyA9IHtcbiAgICAgICAgZm9ybUNvbnRyb2xOYW1lOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICA8aW5wdXQgZm9ybUNvbnRyb2xOYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgSW4geW91ciBjbGFzczpcXG5cXG4gICAgdGhpcy5teUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7XFxuICAgICAgIGZpcnN0TmFtZTogbmV3IEZvcm1Db250cm9sKClcXG4gICAgfSk7XCIsXG4gICAgICAgIGZvcm1Hcm91cE5hbWU6IFwiXFxuICAgIDxkaXYgW2Zvcm1Hcm91cF09XFxcIm15R3JvdXBcXFwiPlxcbiAgICAgICA8ZGl2IGZvcm1Hcm91cE5hbWU9XFxcInBlcnNvblxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XFxcImZpcnN0TmFtZVxcXCI+XFxuICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgSW4geW91ciBjbGFzczpcXG5cXG4gICAgdGhpcy5teUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7XFxuICAgICAgIHBlcnNvbjogbmV3IEZvcm1Hcm91cCh7IGZpcnN0TmFtZTogbmV3IEZvcm1Db250cm9sKCkgfSlcXG4gICAgfSk7XCIsXG4gICAgICAgIGZvcm1BcnJheU5hbWU6IFwiXFxuICAgIDxkaXYgW2Zvcm1Hcm91cF09XFxcIm15R3JvdXBcXFwiPlxcbiAgICAgIDxkaXYgZm9ybUFycmF5TmFtZT1cXFwiY2l0aWVzXFxcIj5cXG4gICAgICAgIDxkaXYgKm5nRm9yPVxcXCJsZXQgY2l0eSBvZiBjaXR5QXJyYXkuY29udHJvbHM7IGxldCBpPWluZGV4XFxcIj5cXG4gICAgICAgICAgPGlucHV0IFtmb3JtQ29udHJvbE5hbWVdPVxcXCJpXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgSW4geW91ciBjbGFzczpcXG5cXG4gICAgdGhpcy5jaXR5QXJyYXkgPSBuZXcgRm9ybUFycmF5KFtuZXcgRm9ybUNvbnRyb2woJ1NGJyldKTtcXG4gICAgdGhpcy5teUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7XFxuICAgICAgY2l0aWVzOiB0aGlzLmNpdHlBcnJheVxcbiAgICB9KTtcIixcbiAgICAgICAgbmdNb2RlbEdyb3VwOiBcIlxcbiAgICA8Zm9ybT5cXG4gICAgICAgPGRpdiBuZ01vZGVsR3JvdXA9XFxcInBlcnNvblxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwicGVyc29uLm5hbWVcXFwiIG5hbWU9XFxcImZpcnN0TmFtZVxcXCI+XFxuICAgICAgIDwvZGl2PlxcbiAgICA8L2Zvcm0+XCIsXG4gICAgICAgIG5nTW9kZWxXaXRoRm9ybUdyb3VwOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICAgPGlucHV0IGZvcm1Db250cm9sTmFtZT1cXFwiZmlyc3ROYW1lXFxcIj5cXG4gICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJzaG93TW9yZUNvbnRyb2xzXFxcIiBbbmdNb2RlbE9wdGlvbnNdPVxcXCJ7c3RhbmRhbG9uZTogdHJ1ZX1cXFwiPlxcbiAgICA8L2Rpdj5cXG4gIFwiXG4gICAgfTtcblxuICAgIHZhciBUZW1wbGF0ZURyaXZlbkVycm9ycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlRHJpdmVuRXJyb3JzKCkge1xuICAgICAgICB9XG4gICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1vZGVsUGFyZW50RXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgbmdNb2RlbCBjYW5ub3QgYmUgdXNlZCB0byByZWdpc3RlciBmb3JtIGNvbnRyb2xzIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwIGRpcmVjdGl2ZS4gIFRyeSB1c2luZ1xcbiAgICAgIGZvcm1Hcm91cCdzIHBhcnRuZXIgZGlyZWN0aXZlIFxcXCJmb3JtQ29udHJvbE5hbWVcXFwiIGluc3RlYWQuICBFeGFtcGxlOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUNvbnRyb2xOYW1lICsgXCJcXG5cXG4gICAgICBPciwgaWYgeW91J2QgbGlrZSB0byBhdm9pZCByZWdpc3RlcmluZyB0aGlzIGZvcm0gY29udHJvbCwgaW5kaWNhdGUgdGhhdCBpdCdzIHN0YW5kYWxvbmUgaW4gbmdNb2RlbE9wdGlvbnM6XFxuXFxuICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLm5nTW9kZWxXaXRoRm9ybUdyb3VwKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMuZm9ybUdyb3VwTmFtZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgIG5nTW9kZWwgY2Fubm90IGJlIHVzZWQgdG8gcmVnaXN0ZXIgZm9ybSBjb250cm9scyB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cE5hbWUgb3IgZm9ybUFycmF5TmFtZSBkaXJlY3RpdmUuXFxuXFxuICAgICAgT3B0aW9uIDE6IFVzZSBmb3JtQ29udHJvbE5hbWUgaW5zdGVhZCBvZiBuZ01vZGVsIChyZWFjdGl2ZSBzdHJhdGVneSk6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtR3JvdXBOYW1lICsgXCJcXG5cXG4gICAgICBPcHRpb24gMjogIFVwZGF0ZSBuZ01vZGVsJ3MgcGFyZW50IGJlIG5nTW9kZWxHcm91cCAodGVtcGxhdGUtZHJpdmVuIHN0cmF0ZWd5KTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLm5nTW9kZWxHcm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1pc3NpbmdOYW1lRXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWYgbmdNb2RlbCBpcyB1c2VkIHdpdGhpbiBhIGZvcm0gdGFnLCBlaXRoZXIgdGhlIG5hbWUgYXR0cmlidXRlIG11c3QgYmUgc2V0IG9yIHRoZSBmb3JtXFxuICAgICAgY29udHJvbCBtdXN0IGJlIGRlZmluZWQgYXMgJ3N0YW5kYWxvbmUnIGluIG5nTW9kZWxPcHRpb25zLlxcblxcbiAgICAgIEV4YW1wbGUgMTogPGlucHV0IFsobmdNb2RlbCldPVxcXCJwZXJzb24uZmlyc3ROYW1lXFxcIiBuYW1lPVxcXCJmaXJzdFxcXCI+XFxuICAgICAgRXhhbXBsZSAyOiA8aW5wdXQgWyhuZ01vZGVsKV09XFxcInBlcnNvbi5maXJzdE5hbWVcXFwiIFtuZ01vZGVsT3B0aW9uc109XFxcIntzdGFuZGFsb25lOiB0cnVlfVxcXCI+XCIpO1xuICAgICAgICB9O1xuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5tb2RlbEdyb3VwUGFyZW50RXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgbmdNb2RlbEdyb3VwIGNhbm5vdCBiZSB1c2VkIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwIGRpcmVjdGl2ZS5cXG5cXG4gICAgICBPcHRpb24gMTogVXNlIGZvcm1Hcm91cE5hbWUgaW5zdGVhZCBvZiBuZ01vZGVsR3JvdXAgKHJlYWN0aXZlIHN0cmF0ZWd5KTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Hcm91cE5hbWUgKyBcIlxcblxcbiAgICAgIE9wdGlvbiAyOiAgVXNlIGEgcmVndWxhciBmb3JtIHRhZyBpbnN0ZWFkIG9mIHRoZSBmb3JtR3JvdXAgZGlyZWN0aXZlICh0ZW1wbGF0ZS1kcml2ZW4gc3RyYXRlZ3kpOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMubmdNb2RlbEdyb3VwKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRlbXBsYXRlRHJpdmVuRXJyb3JzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ4ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIG1vZGVsR3JvdXBQcm92aWRlciA9IHtcbiAgICAgICAgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ01vZGVsR3JvdXA7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBDcmVhdGVzIGFuZCBiaW5kcyBhIHtAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgYXMgYSBjaGlsZCBvZiB7QGxpbmsgTmdGb3JtfSAob3IgaW4gb3RoZXIgd29yZHMsXG4gICAgICogd2l0aGluIGA8Zm9ybT5gIHRhZ3MpLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZGlyZWN0aXZlIGlmIHlvdSdkIGxpa2UgdG8gY3JlYXRlIGEgc3ViLWdyb3VwIHdpdGhpbiBhIGZvcm0uIFRoaXMgY2FuXG4gICAgICogY29tZSBpbiBoYW5keSBpZiB5b3Ugd2FudCB0byB2YWxpZGF0ZSBhIHN1Yi1ncm91cCBvZiB5b3VyIGZvcm0gc2VwYXJhdGVseSBmcm9tXG4gICAgICogdGhlIHJlc3Qgb2YgeW91ciBmb3JtLCBvciBpZiBzb21lIHZhbHVlcyBpbiB5b3VyIGRvbWFpbiBtb2RlbCBtYWtlIG1vcmUgc2Vuc2UgdG9cbiAgICAgKiBjb25zdW1lIHRvZ2V0aGVyIGluIGEgbmVzdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFBhc3MgaW4gdGhlIG5hbWUgeW91J2QgbGlrZSB0aGlzIHN1Yi1ncm91cCB0byBoYXZlIGFuZCBpdCB3aWxsIGJlY29tZSB0aGUga2V5XG4gICAgICogZm9yIHRoZSBzdWItZ3JvdXAgaW4gdGhlIGZvcm0ncyBmdWxsIHZhbHVlLiBZb3UgY2FuIGFsc28gZXhwb3J0IHRoZSBkaXJlY3RpdmUgaW50b1xuICAgICAqIGEgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGUgdXNpbmcgYG5nTW9kZWxHcm91cGAgKGV4OiBgI215R3JvdXA9XCJuZ01vZGVsR3JvdXBcImApLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL25nTW9kZWxHcm91cC9uZ19tb2RlbF9ncm91cF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqICoqTmdNb2R1bGUqKjogYEZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ01vZGVsR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOChOZ01vZGVsR3JvdXAsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nTW9kZWxHcm91cChwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE5nTW9kZWxHcm91cC5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nTW9kZWxHcm91cCkgJiYgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ0Zvcm0pKSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubW9kZWxHcm91cFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsR3JvdXAuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nTW9kZWxHcm91cF0nLCBwcm92aWRlcnM6IFttb2RlbEdyb3VwUHJvdmlkZXJdLCBleHBvcnRBczogJ25nTW9kZWxHcm91cCcgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ01vZGVsR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nTW9kZWxHcm91cC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ01vZGVsR3JvdXAnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdNb2RlbEdyb3VwO1xuICAgIH0oQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDcgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgZm9ybUNvbnRyb2xCaW5kaW5nID0ge1xuICAgICAgICBwcm92aWRlOiBOZ0NvbnRyb2wsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdNb2RlbDsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGBuZ01vZGVsYCBmb3JjZXMgYW4gYWRkaXRpb25hbCBjaGFuZ2UgZGV0ZWN0aW9uIHJ1biB3aGVuIGl0cyBpbnB1dHMgY2hhbmdlOlxuICAgICAqIEUuZy46XG4gICAgICogYGBgXG4gICAgICogPGRpdj57e215TW9kZWwudmFsaWR9fTwvZGl2PlxuICAgICAqIDxpbnB1dCBbKG5nTW9kZWwpXT1cIm15VmFsdWVcIiAjbXlNb2RlbD1cIm5nTW9kZWxcIj5cbiAgICAgKiBgYGBcbiAgICAgKiBJLmUuIGBuZ01vZGVsYCBjYW4gZXhwb3J0IGl0c2VsZiBvbiB0aGUgZWxlbWVudCBhbmQgdGhlbiBiZSB1c2VkIGluIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiBOb3JtYWxseSwgdGhpcyB3b3VsZCByZXN1bHQgaW4gZXhwcmVzc2lvbnMgYmVmb3JlIHRoZSBgaW5wdXRgIHRoYXQgdXNlIHRoZSBleHBvcnRlZCBkaXJlY3RpdmVcbiAgICAgKiB0byBoYXZlIGFuZCBvbGQgdmFsdWUgYXMgdGhleSBoYXZlIGJlZW5cbiAgICAgKiBkaXJ0eSBjaGVja2VkIGJlZm9yZS4gQXMgdGhpcyBpcyBhIHZlcnkgY29tbW9uIGNhc2UgZm9yIGBuZ01vZGVsYCwgd2UgYWRkZWQgdGhpcyBzZWNvbmQgY2hhbmdlXG4gICAgICogZGV0ZWN0aW9uIHJ1bi5cbiAgICAgKlxuICAgICAqIE5vdGVzOlxuICAgICAqIC0gdGhpcyBpcyBqdXN0IG9uZSBleHRyYSBydW4gbm8gbWF0dGVyIGhvdyBtYW55IGBuZ01vZGVsYCBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgKiAtIHRoaXMgaXMgYSBnZW5lcmFsIHByb2JsZW0gd2hlbiB1c2luZyBgZXhwb3J0QXNgIGZvciBkaXJlY3RpdmVzIVxuICAgICAqL1xuICAgIHZhciByZXNvbHZlZFByb21pc2UkMSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBDcmVhdGVzIGEge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSBmcm9tIGEgZG9tYWluIG1vZGVsIGFuZCBiaW5kcyBpdFxuICAgICAqIHRvIGEgZm9ybSBjb250cm9sIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBUaGUge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSB3aWxsIHRyYWNrIHRoZSB2YWx1ZSwgdXNlciBpbnRlcmFjdGlvbiwgYW5kXG4gICAgICogdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIGNvbnRyb2wgYW5kIGtlZXAgdGhlIHZpZXcgc3luY2VkIHdpdGggdGhlIG1vZGVsLiBJZiB1c2VkXG4gICAgICogd2l0aGluIGEgcGFyZW50IGZvcm0sIHRoZSBkaXJlY3RpdmUgd2lsbCBhbHNvIHJlZ2lzdGVyIGl0c2VsZiB3aXRoIHRoZSBmb3JtIGFzIGEgY2hpbGRcbiAgICAgKiBjb250cm9sLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBjYW4gYmUgdXNlZCBieSBpdHNlbGYgb3IgYXMgcGFydCBvZiBhIGxhcmdlciBmb3JtLiBBbGwgeW91IG5lZWQgaXMgdGhlXG4gICAgICogYG5nTW9kZWxgIHNlbGVjdG9yIHRvIGFjdGl2YXRlIGl0LlxuICAgICAqXG4gICAgICogSXQgYWNjZXB0cyBhIGRvbWFpbiBtb2RlbCBhcyBhbiBvcHRpb25hbCB7QGxpbmsgQElucHV0fS4gSWYgeW91IGhhdmUgYSBvbmUtd2F5IGJpbmRpbmdcbiAgICAgKiB0byBgbmdNb2RlbGAgd2l0aCBgW11gIHN5bnRheCwgY2hhbmdpbmcgdGhlIHZhbHVlIG9mIHRoZSBkb21haW4gbW9kZWwgaW4gdGhlIGNvbXBvbmVudFxuICAgICAqIGNsYXNzIHdpbGwgc2V0IHRoZSB2YWx1ZSBpbiB0aGUgdmlldy4gSWYgeW91IGhhdmUgYSB0d28td2F5IGJpbmRpbmcgd2l0aCBgWygpXWAgc3ludGF4XG4gICAgICogKGFsc28ga25vd24gYXMgJ2JhbmFuYS1ib3ggc3ludGF4JyksIHRoZSB2YWx1ZSBpbiB0aGUgVUkgd2lsbCBhbHdheXMgYmUgc3luY2VkIGJhY2sgdG9cbiAgICAgKiB0aGUgZG9tYWluIG1vZGVsIGluIHlvdXIgY2xhc3MgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIElmIHlvdSB3aXNoIHRvIGluc3BlY3QgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGFzc29jaWF0ZWQge0BsaW5rIEZvcm1Db250cm9sfSAobGlrZVxuICAgICAqIHZhbGlkaXR5IHN0YXRlKSwgeW91IGNhbiBhbHNvIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZ1xuICAgICAqIGBuZ01vZGVsYCBhcyB0aGUga2V5IChleDogYCNteVZhcj1cIm5nTW9kZWxcImApLiBZb3UgY2FuIHRoZW4gYWNjZXNzIHRoZSBjb250cm9sIHVzaW5nIHRoZVxuICAgICAqIGRpcmVjdGl2ZSdzIGBjb250cm9sYCBwcm9wZXJ0eSwgYnV0IG1vc3QgcHJvcGVydGllcyB5b3UnbGwgbmVlZCAobGlrZSBgdmFsaWRgIGFuZCBgZGlydHlgKVxuICAgICAqIHdpbGwgZmFsbCB0aHJvdWdoIHRvIHRoZSBjb250cm9sIGFueXdheSwgc28geW91IGNhbiBhY2Nlc3MgdGhlbSBkaXJlY3RseS4gWW91IGNhbiBzZWUgYVxuICAgICAqIGZ1bGwgbGlzdCBvZiBwcm9wZXJ0aWVzIGRpcmVjdGx5IGF2YWlsYWJsZSBpbiB7QGxpbmsgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlfS5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaXMgYW4gZXhhbXBsZSBvZiBhIHNpbXBsZSBzdGFuZGFsb25lIGNvbnRyb2wgdXNpbmcgYG5nTW9kZWxgOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZU5nTW9kZWwvc2ltcGxlX25nX21vZGVsX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogV2hlbiB1c2luZyB0aGUgYG5nTW9kZWxgIHdpdGhpbiBgPGZvcm0+YCB0YWdzLCB5b3UnbGwgYWxzbyBuZWVkIHRvIHN1cHBseSBhIGBuYW1lYCBhdHRyaWJ1dGVcbiAgICAgKiBzbyB0aGF0IHRoZSBjb250cm9sIGNhbiBiZSByZWdpc3RlcmVkIHdpdGggdGhlIHBhcmVudCBmb3JtIHVuZGVyIHRoYXQgbmFtZS5cbiAgICAgKlxuICAgICAqIEl0J3Mgd29ydGggbm90aW5nIHRoYXQgaW4gdGhlIGNvbnRleHQgb2YgYSBwYXJlbnQgZm9ybSwgeW91IG9mdGVuIGNhbiBza2lwIG9uZS13YXkgb3JcbiAgICAgKiB0d28td2F5IGJpbmRpbmcgYmVjYXVzZSB0aGUgcGFyZW50IGZvcm0gd2lsbCBzeW5jIHRoZSB2YWx1ZSBmb3IgeW91LiBZb3UgY2FuIGFjY2Vzc1xuICAgICAqIGl0cyBwcm9wZXJ0aWVzIGJ5IGV4cG9ydGluZyBpdCBpbnRvIGEgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGUgdXNpbmcgYG5nRm9ybWAgKGV4OlxuICAgICAqIGAjZj1cIm5nRm9ybVwiYCkuIFRoZW4geW91IGNhbiBwYXNzIGl0IHdoZXJlIGl0IG5lZWRzIHRvIGdvIG9uIHN1Ym1pdC5cbiAgICAgKlxuICAgICAqIElmIHlvdSBkbyBuZWVkIHRvIHBvcHVsYXRlIGluaXRpYWwgdmFsdWVzIGludG8geW91ciBmb3JtLCB1c2luZyBhIG9uZS13YXkgYmluZGluZyBmb3JcbiAgICAgKiBgbmdNb2RlbGAgdGVuZHMgdG8gYmUgc3VmZmljaWVudCBhcyBsb25nIGFzIHlvdSB1c2UgdGhlIGV4cG9ydGVkIGZvcm0ncyB2YWx1ZSByYXRoZXJcbiAgICAgKiB0aGFuIHRoZSBkb21haW4gbW9kZWwncyB2YWx1ZSBvbiBzdWJtaXQuXG4gICAgICpcbiAgICAgKiBUYWtlIGEgbG9vayBhdCBhbiBleGFtcGxlIG9mIHVzaW5nIGBuZ01vZGVsYCB3aXRoaW4gYSBmb3JtOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm0vc2ltcGxlX2Zvcm1fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBUbyBzZWUgYG5nTW9kZWxgIGV4YW1wbGVzIHdpdGggZGlmZmVyZW50IGZvcm0gY29udHJvbCB0eXBlcywgc2VlOlxuICAgICAqXG4gICAgICogKiBSYWRpbyBidXR0b25zOiB7QGxpbmsgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvcn1cbiAgICAgKiAqIFNlbGVjdHM6IHtAbGluayBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvcn1cbiAgICAgKlxuICAgICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKipOZ01vZHVsZSoqOiBgRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ01vZGVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDcoTmdNb2RlbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdNb2RlbChwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9yYXdWYWxpZGF0b3JzID0gdmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgICAgICB9XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrRm9yRXJyb3JzKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlZ2lzdGVyZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VXBDb250cm9sKCk7XG4gICAgICAgICAgICBpZiAoJ2lzRGlzYWJsZWQnIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEaXNhYmxlZChjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmZvcm1EaXJlY3RpdmUgJiYgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUNvbnRyb2wodGhpcyk7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udHJvbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBjb250cm9sUGF0aCh0aGlzLm5hbWUsIHRoaXMuX3BhcmVudCkgOiBbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl9yYXdWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLnZpZXdUb01vZGVsVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUuZW1pdChuZXdWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9zZXRVcENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1N0YW5kYWxvbmUoKSA/IHRoaXMuX3NldFVwU3RhbmRhbG9uZSgpIDpcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkQ29udHJvbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5faXNTdGFuZGFsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9wYXJlbnQgfHwgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuc3RhbmRhbG9uZSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9zZXRVcFN0YW5kYWxvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRVcENvbnRyb2wodGhpcy5fY29udHJvbCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fY2hlY2tGb3JFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzU3RhbmRhbG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGVja05hbWUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nTW9kZWxHcm91cCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLmZvcm1Hcm91cE5hbWVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdNb2RlbEdyb3VwKSAmJiAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nRm9ybSkpIHtcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5tb2RlbFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fY2hlY2tOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubmFtZSlcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNTdGFuZGFsb25lKCkgJiYgIXRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1pc3NpbmdOYW1lRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSQxLnRoZW4oZnVuY3Rpb24gKCkgeyBfdGhpcy5jb250cm9sLnNldFZhbHVlKHZhbHVlLCB7IGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2UgfSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fdXBkYXRlRGlzYWJsZWQgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZFZhbHVlID0gY2hhbmdlc1snaXNEaXNhYmxlZCddLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHZhciBpc0Rpc2FibGVkID0gZGlzYWJsZWRWYWx1ZSA9PT0gJycgfHwgKGRpc2FibGVkVmFsdWUgJiYgZGlzYWJsZWRWYWx1ZSAhPT0gJ2ZhbHNlJyk7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UkMS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCAmJiAhX3RoaXMuY29udHJvbC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250cm9sLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzRGlzYWJsZWQgJiYgX3RoaXMuY29udHJvbC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250cm9sLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmdNb2RlbF06bm90KFtmb3JtQ29udHJvbE5hbWVdKTpub3QoW2Zvcm1Db250cm9sXSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbZm9ybUNvbnRyb2xCaW5kaW5nXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdNb2RlbCdcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ01vZGVsLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1IsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdNb2RlbC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICAgICAnaXNEaXNhYmxlZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZGlzYWJsZWQnLF0gfSxdLFxuICAgICAgICAgICAgJ21vZGVsJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ01vZGVsJyxdIH0sXSxcbiAgICAgICAgICAgICdvcHRpb25zJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ01vZGVsT3B0aW9ucycsXSB9LF0sXG4gICAgICAgICAgICAndXBkYXRlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PdXRwdXQsIGFyZ3M6IFsnbmdNb2RlbENoYW5nZScsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ01vZGVsO1xuICAgIH0oTmdDb250cm9sKSk7XG5cbiAgICB2YXIgUmVhY3RpdmVFcnJvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWFjdGl2ZUVycm9ycygpIHtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdGl2ZUVycm9ycy5jb250cm9sUGFyZW50RXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybUNvbnRyb2xOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcXG4gICAgICAgZGlyZWN0aXZlIGFuZCBwYXNzIGl0IGFuIGV4aXN0aW5nIEZvcm1Hcm91cCBpbnN0YW5jZSAoeW91IGNhbiBjcmVhdGUgb25lIGluIHlvdXIgY2xhc3MpLlxcblxcbiAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtQ29udHJvbE5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5uZ01vZGVsR3JvdXBFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtQ29udHJvbE5hbWUgY2Fubm90IGJlIHVzZWQgd2l0aCBhbiBuZ01vZGVsR3JvdXAgcGFyZW50LiBJdCBpcyBvbmx5IGNvbXBhdGlibGUgd2l0aCBwYXJlbnRzXFxuICAgICAgIHRoYXQgYWxzbyBoYXZlIGEgXFxcImZvcm1cXFwiIHByZWZpeDogZm9ybUdyb3VwTmFtZSwgZm9ybUFycmF5TmFtZSwgb3IgZm9ybUdyb3VwLlxcblxcbiAgICAgICBPcHRpb24gMTogIFVwZGF0ZSB0aGUgcGFyZW50IHRvIGJlIGZvcm1Hcm91cE5hbWUgKHJlYWN0aXZlIGZvcm0gc3RyYXRlZ3kpXFxuXFxuICAgICAgICBcIiArIEV4YW1wbGVzLmZvcm1Hcm91cE5hbWUgKyBcIlxcblxcbiAgICAgICAgT3B0aW9uIDI6IFVzZSBuZ01vZGVsIGluc3RlYWQgb2YgZm9ybUNvbnRyb2xOYW1lICh0ZW1wbGF0ZS1kcml2ZW4gc3RyYXRlZ3kpXFxuXFxuICAgICAgICBcIiArIEV4YW1wbGVzLm5nTW9kZWxHcm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLm1pc3NpbmdGb3JtRXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybUdyb3VwIGV4cGVjdHMgYSBGb3JtR3JvdXAgaW5zdGFuY2UuIFBsZWFzZSBwYXNzIG9uZSBpbi5cXG5cXG4gICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtQ29udHJvbE5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5ncm91cFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Hcm91cE5hbWUgbXVzdCBiZSB1c2VkIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwIGRpcmVjdGl2ZS4gIFlvdSdsbCB3YW50IHRvIGFkZCBhIGZvcm1Hcm91cFxcbiAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cXG5cXG4gICAgICBFeGFtcGxlOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLmFycmF5UGFyZW50RXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybUFycmF5TmFtZSBtdXN0IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgWW91J2xsIHdhbnQgdG8gYWRkIGEgZm9ybUdyb3VwXFxuICAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cXG5cXG4gICAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgICBcIiArIEV4YW1wbGVzLmZvcm1BcnJheU5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5kaXNhYmxlZEF0dHJXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXFxuICAgICAgSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSB3aXRoIGEgcmVhY3RpdmUgZm9ybSBkaXJlY3RpdmUuIElmIHlvdSBzZXQgZGlzYWJsZWQgdG8gdHJ1ZVxcbiAgICAgIHdoZW4geW91IHNldCB1cCB0aGlzIGNvbnRyb2wgaW4geW91ciBjb21wb25lbnQgY2xhc3MsIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgd2lsbCBhY3R1YWxseSBiZSBzZXQgaW4gdGhlIERPTSBmb3JcXG4gICAgICB5b3UuIFdlIHJlY29tbWVuZCB1c2luZyB0aGlzIGFwcHJvYWNoIHRvIGF2b2lkICdjaGFuZ2VkIGFmdGVyIGNoZWNrZWQnIGVycm9ycy5cXG4gICAgICAgXFxuICAgICAgRXhhbXBsZTogXFxuICAgICAgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCh7dmFsdWU6ICdOYW5jeScsIGRpc2FibGVkOiB0cnVlfSwgVmFsaWRhdG9ycy5yZXF1aXJlZCksXFxuICAgICAgICBsYXN0OiBuZXcgRm9ybUNvbnRyb2woJ0RyZXcnLCBWYWxpZGF0b3JzLnJlcXVpcmVkKVxcbiAgICAgIH0pO1xcbiAgICBcIik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWFjdGl2ZUVycm9ycztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkOSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBmb3JtQ29udHJvbEJpbmRpbmckMSA9IHtcbiAgICAgICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1Db250cm9sRGlyZWN0aXZlOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgU3luY3MgYSBzdGFuZGFsb25lIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgdG8gYSBmb3JtIGNvbnRyb2wgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEluIG90aGVyIHdvcmRzLCB0aGlzIGRpcmVjdGl2ZSBlbnN1cmVzIHRoYXQgYW55IHZhbHVlcyB3cml0dGVuIHRvIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9XG4gICAgICogaW5zdGFuY2UgcHJvZ3JhbW1hdGljYWxseSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIERPTSBlbGVtZW50IChtb2RlbCAtPiB2aWV3KS4gQ29udmVyc2VseSxcbiAgICAgKiBhbnkgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIERPTSBlbGVtZW50IHRocm91Z2ggdXNlciBpbnB1dCB3aWxsIGJlIHJlZmxlY3RlZCBpbiB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlICh2aWV3IC0+IG1vZGVsKS5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgZGlyZWN0aXZlIGlmIHlvdSdkIGxpa2UgdG8gY3JlYXRlIGFuZCBtYW5hZ2UgYSB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIGRpcmVjdGx5LlxuICAgICAqIFNpbXBseSBjcmVhdGUgYSB7QGxpbmsgRm9ybUNvbnRyb2x9LCBzYXZlIGl0IHRvIHlvdXIgY29tcG9uZW50IGNsYXNzLCBhbmQgcGFzcyBpdCBpbnRvIHRoZVxuICAgICAqIHtAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0uXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGFzIGEgc3RhbmRhbG9uZSBjb250cm9sLiAgVW5saWtlIHtAbGluayBGb3JtQ29udHJvbE5hbWV9LFxuICAgICAqIGl0IGRvZXMgbm90IHJlcXVpcmUgdGhhdCB5b3VyIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgYmUgcGFydCBvZiBhbnkgcGFyZW50XG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0sIGFuZCBpdCB3b24ndCBiZSByZWdpc3RlcmVkIHRvIGFueSB7QGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfSB0aGF0XG4gICAgICogZXhpc3RzIGFib3ZlIGl0LlxuICAgICAqXG4gICAgICogKipHZXQgdGhlIHZhbHVlKio6IHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIGFsd2F5cyBzeW5jZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlLiBTZWUgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHByb3BlcnRpZXMgaW5cbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sfS5cbiAgICAgKlxuICAgICAqICoqU2V0IHRoZSB2YWx1ZSoqOiBZb3UgY2FuIHBhc3MgaW4gYW4gaW5pdGlhbCB2YWx1ZSB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIHtAbGluayBGb3JtQ29udHJvbH0sXG4gICAgICogb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZyB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnNldFZhbHVlfSBvclxuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wucGF0Y2hWYWx1ZX0uXG4gICAgICpcbiAgICAgKiAqKkxpc3RlbiB0byB2YWx1ZSoqOiBJZiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wsIHlvdSBjYW5cbiAgICAgKiBzdWJzY3JpYmUgdG8gdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2wudmFsdWVDaGFuZ2VzfSBldmVudC4gIFlvdSBjYW4gYWxzbyBsaXN0ZW4gdG9cbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c0NoYW5nZXN9IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHZhbGlkYXRpb24gc3RhdHVzIGlzXG4gICAgICogcmUtY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybUNvbnRyb2wvc2ltcGxlX2Zvcm1fY29udHJvbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqICoqTmdNb2R1bGUqKjogYFJlYWN0aXZlRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQ29udHJvbERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KEZvcm1Db250cm9sRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtQ29udHJvbERpcmVjdGl2ZSh2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImlzRGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoaXNEaXNhYmxlZCkgeyBSZWFjdGl2ZUVycm9ycy5kaXNhYmxlZEF0dHJXYXJuaW5nKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ29udHJvbENoYW5nZWQoY2hhbmdlcykpIHtcbiAgICAgICAgICAgICAgICBzZXRVcENvbnRyb2wodGhpcy5mb3JtLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250cm9sLmRpc2FibGVkICYmIHRoaXMudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZvcm0udXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtLnNldFZhbHVlKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3Jhd1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQobmV3VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUuX2lzQ29udHJvbENoYW5nZWQgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2Zvcm0nKTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Db250cm9sXScsIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZyQxXSwgZXhwb3J0QXM6ICduZ0Zvcm0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxVRV9BQ0NFU1NPUixdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdmb3JtJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydmb3JtQ29udHJvbCcsXSB9LF0sXG4gICAgICAgICAgICAnbW9kZWwnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWwnLF0gfSxdLFxuICAgICAgICAgICAgJ3VwZGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3V0cHV0LCBhcmdzOiBbJ25nTW9kZWxDaGFuZ2UnLF0gfSxdLFxuICAgICAgICAgICAgJ2lzRGlzYWJsZWQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Rpc2FibGVkJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Db250cm9sRGlyZWN0aXZlO1xuICAgIH0oTmdDb250cm9sKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBmb3JtRGlyZWN0aXZlUHJvdmlkZXIkMSA9IHtcbiAgICAgICAgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBGb3JtR3JvdXBEaXJlY3RpdmU7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBCaW5kcyBhbiBleGlzdGluZyB7QGxpbmsgRm9ybUdyb3VwfSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBhY2NlcHRzIGFuIGV4aXN0aW5nIHtAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlLiBJdCB3aWxsIHRoZW4gdXNlIHRoaXNcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSB0byBtYXRjaCBhbnkgY2hpbGQge0BsaW5rIEZvcm1Db250cm9sfSwge0BsaW5rIEZvcm1Hcm91cH0sXG4gICAgICogYW5kIHtAbGluayBGb3JtQXJyYXl9IGluc3RhbmNlcyB0byBjaGlsZCB7QGxpbmsgRm9ybUNvbnRyb2xOYW1lfSwge0BsaW5rIEZvcm1Hcm91cE5hbWV9LFxuICAgICAqIGFuZCB7QGxpbmsgRm9ybUFycmF5TmFtZX0gZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqICoqU2V0IHZhbHVlKio6IFlvdSBjYW4gc2V0IHRoZSBmb3JtJ3MgaW5pdGlhbCB2YWx1ZSB3aGVuIGluc3RhbnRpYXRpbmcgdGhlXG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0sIG9yIHlvdSBjYW4gc2V0IGl0IHByb2dyYW1tYXRpY2FsbHkgbGF0ZXIgdXNpbmcgdGhlIHtAbGluayBGb3JtR3JvdXB9J3NcbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnNldFZhbHVlfSBvciB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnBhdGNoVmFsdWV9IG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiAqKkxpc3RlbiB0byB2YWx1ZSoqOiBJZiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIGZvcm0sIHlvdSBjYW4gc3Vic2NyaWJlXG4gICAgICogdG8gdGhlIHtAbGluayBGb3JtR3JvdXB9J3Mge0BsaW5rIEFic3RyYWN0Q29udHJvbC52YWx1ZUNoYW5nZXN9IGV2ZW50LiAgWW91IGNhbiBhbHNvIGxpc3RlbiB0b1xuICAgICAqIGl0cyB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c0NoYW5nZXN9IGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHZhbGlkYXRpb24gc3RhdHVzIGlzXG4gICAgICogcmUtY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqIEZ1cnRoZXJtb3JlLCB5b3UgY2FuIGxpc3RlbiB0byB0aGUgZGlyZWN0aXZlJ3MgYG5nU3VibWl0YCBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB1c2VyIGhhc1xuICAgICAqIHRyaWdnZXJlZCBhIGZvcm0gc3VibWlzc2lvbi4gVGhlIGBuZ1N1Ym1pdGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIG9yaWdpbmFsIGZvcm1cbiAgICAgKiBzdWJtaXNzaW9uIGV2ZW50LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIEluIHRoaXMgZXhhbXBsZSwgd2UgY3JlYXRlIGZvcm0gY29udHJvbHMgZm9yIGZpcnN0IG5hbWUgYW5kIGxhc3QgbmFtZS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtR3JvdXAvc2ltcGxlX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICoqTmdNb2R1bGUqKjoge0BsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9XG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtR3JvdXBEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTEoRm9ybUdyb3VwRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtR3JvdXBEaXJlY3RpdmUoX3ZhbGlkYXRvcnMsIF9hc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IF92YWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0b3JzID0gX2FzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrRm9ybVByZXNlbnQoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KCdmb3JtJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVWYWxpZGF0b3JzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVSZWdpc3RyYXRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInN1Ym1pdHRlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N1Ym1pdHRlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBzZXRVcENvbnRyb2woY3RybCwgZGlyKTtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0cmw7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuZ2V0Q29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IExpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLmRpcmVjdGl2ZXMsIGRpcik7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuYWRkRm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgIHNldFVwRm9ybUNvbnRhaW5lcihjdHJsLCBkaXIpO1xuICAgICAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5yZW1vdmVGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuZ2V0Rm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuYWRkRm9ybUFycmF5ID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgIHNldFVwRm9ybUNvbnRhaW5lcihjdHJsLCBkaXIpO1xuICAgICAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5yZW1vdmVGb3JtQXJyYXkgPSBmdW5jdGlvbiAoZGlyKSB7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuZ2V0Rm9ybUFycmF5ID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoZGlyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgIGN0cmwuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm9uU3VibWl0ID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmdTdWJtaXQuZW1pdCgkZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm9uUmVzZXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMucmVzZXRGb3JtKCk7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUucmVzZXRGb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgdGhpcy5mb3JtLnJlc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZURvbVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q3RybCA9IF90aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyLl9jb250cm9sICE9PSBuZXdDdHJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVXBDb250cm9sKGRpci5fY29udHJvbCwgZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0N0cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRVcENvbnRyb2wobmV3Q3RybCwgZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgZGlyLl9jb250cm9sID0gbmV3Q3RybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5fdXBkYXRlVHJlZVZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5fdXBkYXRlUmVnaXN0cmF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmZvcm0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl91cGRhdGVEb21WYWx1ZSgpOyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbGRGb3JtKVxuICAgICAgICAgICAgICAgIHRoaXMuX29sZEZvcm0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbGRGb3JtID0gdGhpcy5mb3JtO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVWYWxpZGF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN5bmMgPSBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl92YWxpZGF0b3JzKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybS52YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW3RoaXMuZm9ybS52YWxpZGF0b3IsIHN5bmNdKTtcbiAgICAgICAgICAgIHZhciBhc3luYyA9IGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fYXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5hc3luY1ZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKFt0aGlzLmZvcm0uYXN5bmNWYWxpZGF0b3IsIGFzeW5jXSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrRm9ybVByZXNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9ybSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLm1pc3NpbmdGb3JtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbZm9ybURpcmVjdGl2ZVByb3ZpZGVyJDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKHN1Ym1pdCknOiAnb25TdWJtaXQoJGV2ZW50KScsICcocmVzZXQpJzogJ29uUmVzZXQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ2Zvcm0nOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Hcm91cCcsXSB9LF0sXG4gICAgICAgICAgICAnbmdTdWJtaXQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk91dHB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgfShDb250cm9sQ29udGFpbmVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBmb3JtR3JvdXBOYW1lUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUdyb3VwTmFtZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFN5bmNzIGEgbmVzdGVkIHtAbGluayBGb3JtR3JvdXB9IHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhIHBhcmVudCB7QGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfSAoc2VsZWN0b3I6XG4gICAgICogYFtmb3JtR3JvdXBdYCkuXG4gICAgICpcbiAgICAgKiBJdCBhY2NlcHRzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgbmVzdGVkIHtAbGluayBGb3JtR3JvdXB9IHlvdSB3YW50IHRvIGxpbmssIGFuZFxuICAgICAqIHdpbGwgbG9vayBmb3IgYSB7QGxpbmsgRm9ybUdyb3VwfSByZWdpc3RlcmVkIHdpdGggdGhhdCBuYW1lIGluIHRoZSBwYXJlbnRcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSB5b3UgcGFzc2VkIGludG8ge0BsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0uXG4gICAgICpcbiAgICAgKiBOZXN0ZWQgZm9ybSBncm91cHMgY2FuIGNvbWUgaW4gaGFuZHkgd2hlbiB5b3Ugd2FudCB0byB2YWxpZGF0ZSBhIHN1Yi1ncm91cCBvZiBhXG4gICAgICogZm9ybSBzZXBhcmF0ZWx5IGZyb20gdGhlIHJlc3Qgb3Igd2hlbiB5b3UnZCBsaWtlIHRvIGdyb3VwIHRoZSB2YWx1ZXMgb2YgY2VydGFpblxuICAgICAqIGNvbnRyb2xzIGludG8gdGhlaXIgb3duIG5lc3RlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKkFjY2VzcyB0aGUgZ3JvdXAqKjogWW91IGNhbiBhY2Nlc3MgdGhlIGFzc29jaWF0ZWQge0BsaW5rIEZvcm1Hcm91cH0gdXNpbmcgdGhlXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5nZXR9IG1ldGhvZC4gRXg6IGB0aGlzLmZvcm0uZ2V0KCduYW1lJylgLlxuICAgICAqXG4gICAgICogWW91IGNhbiBhbHNvIGFjY2VzcyBpbmRpdmlkdWFsIGNvbnRyb2xzIHdpdGhpbiB0aGUgZ3JvdXAgdXNpbmcgZG90IHN5bnRheC5cbiAgICAgKiBFeDogYHRoaXMuZm9ybS5nZXQoJ25hbWUuZmlyc3QnKWBcbiAgICAgKlxuICAgICAqICoqR2V0IHRoZSB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlXG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0uIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpbiB7QGxpbmsgQWJzdHJhY3RDb250cm9sfS5cbiAgICAgKlxuICAgICAqICoqU2V0IHRoZSB2YWx1ZSoqOiBZb3UgY2FuIHNldCBhbiBpbml0aWFsIHZhbHVlIGZvciBlYWNoIGNoaWxkIGNvbnRyb2wgd2hlbiBpbnN0YW50aWF0aW5nXG4gICAgICogdGhlIHtAbGluayBGb3JtR3JvdXB9LCBvciB5b3UgY2FuIHNldCBpdCBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3Ige0BsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfS5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgZ3JvdXAsIHlvdSBjYW5cbiAgICAgKiBzdWJzY3JpYmUgdG8gdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2wudmFsdWVDaGFuZ2VzfSBldmVudC4gIFlvdSBjYW4gYWxzbyBsaXN0ZW4gdG9cbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c0NoYW5nZXN9IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHZhbGlkYXRpb24gc3RhdHVzIGlzXG4gICAgICogcmUtY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvbmVzdGVkRm9ybUdyb3VwL25lc3RlZF9mb3JtX2dyb3VwX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgUmVhY3RpdmVGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUdyb3VwTmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMihGb3JtR3JvdXBOYW1lLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtR3JvdXBOYW1lKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwTmFtZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfaGFzSW52YWxpZFBhcmVudCh0aGlzLl9wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgUmVhY3RpdmVFcnJvcnMuZ3JvdXBQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwTmFtZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUdyb3VwTmFtZV0nLCBwcm92aWRlcnM6IFtmb3JtR3JvdXBOYW1lUHJvdmlkZXJdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUdyb3VwTmFtZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIEZvcm1Hcm91cE5hbWUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUdyb3VwTmFtZScsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtR3JvdXBOYW1lO1xuICAgIH0oQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpKTtcbiAgICB2YXIgZm9ybUFycmF5TmFtZVByb3ZpZGVyID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1BcnJheU5hbWU7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBTeW5jcyBhIG5lc3RlZCB7QGxpbmsgRm9ybUFycmF5fSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggYSBwYXJlbnQge0BsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0gKHNlbGVjdG9yOlxuICAgICAqIGBbZm9ybUdyb3VwXWApLlxuICAgICAqXG4gICAgICogSXQgYWNjZXB0cyB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIG5lc3RlZCB7QGxpbmsgRm9ybUFycmF5fSB5b3Ugd2FudCB0byBsaW5rLCBhbmRcbiAgICAgKiB3aWxsIGxvb2sgZm9yIGEge0BsaW5rIEZvcm1BcnJheX0gcmVnaXN0ZXJlZCB3aXRoIHRoYXQgbmFtZSBpbiB0aGUgcGFyZW50XG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgeW91IHBhc3NlZCBpbnRvIHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogTmVzdGVkIGZvcm0gYXJyYXlzIGNhbiBjb21lIGluIGhhbmR5IHdoZW4geW91IGhhdmUgYSBncm91cCBvZiBmb3JtIGNvbnRyb2xzIGJ1dFxuICAgICAqIHlvdSdyZSBub3Qgc3VyZSBob3cgbWFueSB0aGVyZSB3aWxsIGJlLiBGb3JtIGFycmF5cyBhbGxvdyB5b3UgdG8gY3JlYXRlIG5ld1xuICAgICAqIGZvcm0gY29udHJvbHMgZHluYW1pY2FsbHkuXG4gICAgICpcbiAgICAgKiAqKkFjY2VzcyB0aGUgYXJyYXkqKjogWW91IGNhbiBhY2Nlc3MgdGhlIGFzc29jaWF0ZWQge0BsaW5rIEZvcm1BcnJheX0gdXNpbmcgdGhlXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5nZXR9IG1ldGhvZCBvbiB0aGUgcGFyZW50IHtAbGluayBGb3JtR3JvdXB9LlxuICAgICAqIEV4OiBgdGhpcy5mb3JtLmdldCgnY2l0aWVzJylgLlxuICAgICAqXG4gICAgICogKipHZXQgdGhlIHZhbHVlKio6IHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIGFsd2F5cyBzeW5jZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUFycmF5fS4gU2VlIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIGluIHtAbGluayBBYnN0cmFjdENvbnRyb2x9LlxuICAgICAqXG4gICAgICogKipTZXQgdGhlIHZhbHVlKio6IFlvdSBjYW4gc2V0IGFuIGluaXRpYWwgdmFsdWUgZm9yIGVhY2ggY2hpbGQgY29udHJvbCB3aGVuIGluc3RhbnRpYXRpbmdcbiAgICAgKiB0aGUge0BsaW5rIEZvcm1BcnJheX0sIG9yIHlvdSBjYW4gc2V0IHRoZSB2YWx1ZSBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nIHRoZVxuICAgICAqIHtAbGluayBGb3JtQXJyYXl9J3Mge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3Ige0BsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfVxuICAgICAqIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiAqKkxpc3RlbiB0byB2YWx1ZSoqOiBJZiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIGFycmF5LCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgRm9ybUFycmF5fSdzIHtAbGluayBBYnN0cmFjdENvbnRyb2wudmFsdWVDaGFuZ2VzfSBldmVudC4gIFlvdSBjYW4gYWxzb1xuICAgICAqIGxpc3RlbiB0byBpdHMge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uXG4gICAgICogc3RhdHVzIGlzIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiAqKkFkZCBuZXcgY29udHJvbHMqKjogWW91IGNhbiBhZGQgbmV3IGNvbnRyb2xzIHRvIHRoZSB7QGxpbmsgRm9ybUFycmF5fSBkeW5hbWljYWxseSBieVxuICAgICAqIGNhbGxpbmcgaXRzIHtAbGluayBGb3JtQXJyYXkucHVzaH0gbWV0aG9kLlxuICAgICAqICBFeDogYHRoaXMuZm9ybS5nZXQoJ2NpdGllcycpLnB1c2gobmV3IEZvcm1Db250cm9sKCkpO2BcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvbmVzdGVkRm9ybUFycmF5L25lc3RlZF9mb3JtX2FycmF5X2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgUmVhY3RpdmVGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUFycmF5TmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMihGb3JtQXJyYXlOYW1lLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtQXJyYXlOYW1lKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICB9XG4gICAgICAgIEZvcm1BcnJheU5hbWUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkRm9ybUFycmF5KHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlRm9ybUFycmF5KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5TmFtZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybURpcmVjdGl2ZS5nZXRGb3JtQXJyYXkodGhpcyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5TmFtZS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRm9ybUFycmF5TmFtZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfaGFzSW52YWxpZFBhcmVudCh0aGlzLl9wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgUmVhY3RpdmVFcnJvcnMuYXJyYXlQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUFycmF5TmFtZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUFycmF5TmFtZV0nLCBwcm92aWRlcnM6IFtmb3JtQXJyYXlOYW1lUHJvdmlkZXJdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUFycmF5TmFtZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIEZvcm1BcnJheU5hbWUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUFycmF5TmFtZScsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQXJyYXlOYW1lO1xuICAgIH0oQ29udHJvbENvbnRhaW5lcikpO1xuICAgIGZ1bmN0aW9uIF9oYXNJbnZhbGlkUGFyZW50KHBhcmVudCkge1xuICAgICAgICByZXR1cm4gIShwYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBOYW1lKSAmJiAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cERpcmVjdGl2ZSkgJiZcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgRm9ybUFycmF5TmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTAgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgY29udHJvbE5hbWVCaW5kaW5nID0ge1xuICAgICAgICBwcm92aWRlOiBOZ0NvbnRyb2wsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUNvbnRyb2xOYW1lOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgIFN5bmNzIGEge0BsaW5rIEZvcm1Db250cm9sfSBpbiBhbiBleGlzdGluZyB7QGxpbmsgRm9ybUdyb3VwfSB0byBhIGZvcm0gY29udHJvbFxuICAgICAqIGVsZW1lbnQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEluIG90aGVyIHdvcmRzLCB0aGlzIGRpcmVjdGl2ZSBlbnN1cmVzIHRoYXQgYW55IHZhbHVlcyB3cml0dGVuIHRvIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9XG4gICAgICogaW5zdGFuY2UgcHJvZ3JhbW1hdGljYWxseSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIERPTSBlbGVtZW50IChtb2RlbCAtPiB2aWV3KS4gQ29udmVyc2VseSxcbiAgICAgKiBhbnkgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIERPTSBlbGVtZW50IHRocm91Z2ggdXNlciBpbnB1dCB3aWxsIGJlIHJlZmxlY3RlZCBpbiB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlICh2aWV3IC0+IG1vZGVsKS5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIGEgcGFyZW50IHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9IChzZWxlY3RvcjpcbiAgICAgKiBgW2Zvcm1Hcm91cF1gKS5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgdGhlIHN0cmluZyBuYW1lIG9mIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIHlvdSB3YW50IHRvXG4gICAgICogbGluaywgYW5kIHdpbGwgbG9vayBmb3IgYSB7QGxpbmsgRm9ybUNvbnRyb2x9IHJlZ2lzdGVyZWQgd2l0aCB0aGF0IG5hbWUgaW4gdGhlXG4gICAgICogY2xvc2VzdCB7QGxpbmsgRm9ybUdyb3VwfSBvciB7QGxpbmsgRm9ybUFycmF5fSBhYm92ZSBpdC5cbiAgICAgKlxuICAgICAqICoqQWNjZXNzIHRoZSBjb250cm9sKio6IFlvdSBjYW4gYWNjZXNzIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9IGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIHRoaXMgZGlyZWN0aXZlIGJ5IHVzaW5nIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLmdldH0gbWV0aG9kLlxuICAgICAqIEV4OiBgdGhpcy5mb3JtLmdldCgnZmlyc3QnKTtgXG4gICAgICpcbiAgICAgKiAqKkdldCB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlIHtAbGluayBGb3JtQ29udHJvbH0uXG4gICAgICogU2VlIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIGluIHtAbGluayBBYnN0cmFjdENvbnRyb2x9LlxuICAgICAqXG4gICAgICogICoqU2V0IHZhbHVlKio6IFlvdSBjYW4gc2V0IGFuIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBjb250cm9sIHdoZW4gaW5zdGFudGlhdGluZyB0aGVcbiAgICAgKiAge0BsaW5rIEZvcm1Db250cm9sfSwgb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZ1xuICAgICAqICB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnNldFZhbHVlfSBvciB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnBhdGNoVmFsdWV9LlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBpc1xuICAgICAqIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogSW4gdGhpcyBleGFtcGxlLCB3ZSBjcmVhdGUgZm9ybSBjb250cm9scyBmb3IgZmlyc3QgbmFtZSBhbmQgbGFzdCBuYW1lLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm1Hcm91cC9zaW1wbGVfZm9ybV9ncm91cF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIFRvIHNlZSBgZm9ybUNvbnRyb2xOYW1lYCBleGFtcGxlcyB3aXRoIGRpZmZlcmVudCBmb3JtIGNvbnRyb2wgdHlwZXMsIHNlZTpcbiAgICAgKlxuICAgICAqICogUmFkaW8gYnV0dG9uczoge0BsaW5rIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3J9XG4gICAgICogKiBTZWxlY3RzOiB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9XG4gICAgICpcbiAgICAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICoqTmdNb2R1bGUqKjoge0BsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9XG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQ29udHJvbE5hbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTAoRm9ybUNvbnRyb2xOYW1lLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtQ29udHJvbE5hbWUocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3Nvcih0aGlzLCB2YWx1ZUFjY2Vzc29ycyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwiaXNEaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7IFJlYWN0aXZlRXJyb3JzLmRpc2FibGVkQXR0cldhcm5pbmcoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hZGRlZClcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRVcENvbnRyb2woKTtcbiAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnVwZGF0ZU1vZGVsKHRoaXMsIHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLnZpZXdUb01vZGVsVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUuZW1pdChuZXdWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sUGF0aCh0aGlzLm5hbWUsIHRoaXMuX3BhcmVudCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fcmF3VmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250cm9sOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS5fY2hlY2tQYXJlbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwTmFtZSkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLm5nTW9kZWxHcm91cEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBOYW1lKSAmJiAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cERpcmVjdGl2ZSkgJiZcbiAgICAgICAgICAgICAgICAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1BcnJheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgUmVhY3RpdmVFcnJvcnMuY29udHJvbFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLl9zZXRVcENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1BhcmVudFR5cGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wgPSB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkQ29udHJvbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wuZGlzYWJsZWQgJiYgdGhpcy52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkZGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQ29udHJvbE5hbWVdJywgcHJvdmlkZXJzOiBbY29udHJvbE5hbWVCaW5kaW5nXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxVRV9BQ0NFU1NPUixdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUNvbnRyb2xOYW1lJyxdIH0sXSxcbiAgICAgICAgICAgICdtb2RlbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbCcsXSB9LF0sXG4gICAgICAgICAgICAndXBkYXRlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PdXRwdXQsIGFyZ3M6IFsnbmdNb2RlbENoYW5nZScsXSB9LF0sXG4gICAgICAgICAgICAnaXNEaXNhYmxlZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZGlzYWJsZWQnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUNvbnRyb2xOYW1lO1xuICAgIH0oTmdDb250cm9sKSk7XG5cbiAgICB2YXIgUkVRVUlSRURfVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlcXVpcmVkVmFsaWRhdG9yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IgdG8gYW55IGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxuICAgICAqIGByZXF1aXJlZGAgYXR0cmlidXRlLCB2aWEgdGhlIHtAbGluayBOR19WQUxJREFUT1JTfSBiaW5kaW5nLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxpbnB1dCBuYW1lPVwiZnVsbE5hbWVcIiBuZ01vZGVsIHJlcXVpcmVkPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBSZXF1aXJlZFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlcXVpcmVkVmFsaWRhdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXF1aXJlZFZhbGlkYXRvci5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXF1aXJlZDsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZWQgPSB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiBcIlwiICsgdmFsdWUgIT09ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlZCA/IFZhbGlkYXRvcnMucmVxdWlyZWQoYykgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW3JlcXVpcmVkXVtmb3JtQ29udHJvbE5hbWVdLFtyZXF1aXJlZF1bZm9ybUNvbnRyb2xdLFtyZXF1aXJlZF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUkVRVUlSRURfVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLnJlcXVpcmVkXSc6ICdyZXF1aXJlZCA/IFwiXCIgOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAncmVxdWlyZWQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlcXVpcmVkVmFsaWRhdG9yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXIgd2hpY2ggYWRkcyB7QGxpbmsgTWluTGVuZ3RoVmFsaWRhdG9yfSB0byB7QGxpbmsgTkdfVkFMSURBVE9SU30uXG4gICAgICpcbiAgICAgKiAjIyBFeGFtcGxlOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9mb3Jtcy90cy92YWxpZGF0b3JzL3ZhbGlkYXRvcnMudHMgcmVnaW9uPSdtaW4nfVxuICAgICAqL1xuICAgIHZhciBNSU5fTEVOR1RIX1ZBTElEQVRPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNaW5MZW5ndGhWYWxpZGF0b3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBkaXJlY3RpdmUgd2hpY2ggaW5zdGFsbHMgdGhlIHtAbGluayBNaW5MZW5ndGhWYWxpZGF0b3J9IGZvciBhbnkgYGZvcm1Db250cm9sTmFtZWAsXG4gICAgICogYGZvcm1Db250cm9sYCwgb3IgY29udHJvbCB3aXRoIGBuZ01vZGVsYCB0aGF0IGFsc28gaGFzIGEgYG1pbmxlbmd0aGAgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBNaW5MZW5ndGhWYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNaW5MZW5ndGhWYWxpZGF0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoJ21pbmxlbmd0aCcgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5sZW5ndGggPT0gbnVsbCA/IG51bGwgOiB0aGlzLl92YWxpZGF0b3IoYyk7XG4gICAgICAgIH07XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLl9jcmVhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLm1pbkxlbmd0aChwYXJzZUludCh0aGlzLm1pbmxlbmd0aCwgMTApKTtcbiAgICAgICAgfTtcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWlubGVuZ3RoXVtmb3JtQ29udHJvbE5hbWVdLFttaW5sZW5ndGhdW2Zvcm1Db250cm9sXSxbbWlubGVuZ3RoXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNSU5fTEVOR1RIX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5taW5sZW5ndGhdJzogJ21pbmxlbmd0aCA/IG1pbmxlbmd0aCA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ21pbmxlbmd0aCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWluTGVuZ3RoVmFsaWRhdG9yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXIgd2hpY2ggYWRkcyB7QGxpbmsgTWF4TGVuZ3RoVmFsaWRhdG9yfSB0byB7QGxpbmsgTkdfVkFMSURBVE9SU30uXG4gICAgICpcbiAgICAgKiAjIyBFeGFtcGxlOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9mb3Jtcy90cy92YWxpZGF0b3JzL3ZhbGlkYXRvcnMudHMgcmVnaW9uPSdtYXgnfVxuICAgICAqL1xuICAgIHZhciBNQVhfTEVOR1RIX1ZBTElEQVRPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNYXhMZW5ndGhWYWxpZGF0b3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBkaXJlY3RpdmUgd2hpY2ggaW5zdGFsbHMgdGhlIHtAbGluayBNYXhMZW5ndGhWYWxpZGF0b3J9IGZvciBhbnkgYGZvcm1Db250cm9sTmFtZSxcbiAgICAgKiBgZm9ybUNvbnRyb2xgLFxuICAgICAqIG9yIGNvbnRyb2wgd2l0aCBgbmdNb2RlbGAgdGhhdCBhbHNvIGhhcyBhIGBtYXhsZW5ndGhgIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTWF4TGVuZ3RoVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTWF4TGVuZ3RoVmFsaWRhdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKCdtYXhsZW5ndGgnIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4bGVuZ3RoICE9IG51bGwgPyB0aGlzLl92YWxpZGF0b3IoYykgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5tYXhMZW5ndGgocGFyc2VJbnQodGhpcy5tYXhsZW5ndGgsIDEwKSk7XG4gICAgICAgIH07XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21heGxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbbWF4bGVuZ3RoXVtmb3JtQ29udHJvbF0sW21heGxlbmd0aF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTUFYX0xFTkdUSF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIubWF4bGVuZ3RoXSc6ICdtYXhsZW5ndGggPyBtYXhsZW5ndGggOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdtYXhsZW5ndGgnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1heExlbmd0aFZhbGlkYXRvcjtcbiAgICB9KCkpO1xuICAgIHZhciBQQVRURVJOX1ZBTElEQVRPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBQYXR0ZXJuVmFsaWRhdG9yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHBhdHRlcm5gIHZhbGlkYXRvciB0byBhbnkgY29udHJvbHMgbWFya2VkIHdpdGggdGhlXG4gICAgICogYHBhdHRlcm5gIGF0dHJpYnV0ZSwgdmlhIHRoZSB7QGxpbmsgTkdfVkFMSURBVE9SU30gYmluZGluZy4gVXNlcyBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBhcyB0aGUgcmVnZXggdG8gdmFsaWRhdGUgQ29udHJvbCB2YWx1ZSBhZ2FpbnN0LiAgRm9sbG93cyBwYXR0ZXJuIGF0dHJpYnV0ZVxuICAgICAqIHNlbWFudGljczsgaS5lLiByZWdleCBtdXN0IG1hdGNoIGVudGlyZSBDb250cm9sIHZhbHVlLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxpbnB1dCBbbmFtZV09XCJmdWxsTmFtZVwiIHBhdHRlcm49XCJbYS16QS1aIF0qXCIgbmdNb2RlbD5cbiAgICAgKiBgYGBcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFBhdHRlcm5WYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQYXR0ZXJuVmFsaWRhdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICgncGF0dGVybicgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gdGhpcy5fdmFsaWRhdG9yKGMpOyB9O1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLnByb3RvdHlwZS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLl9jcmVhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZhbGlkYXRvciA9IFZhbGlkYXRvcnMucGF0dGVybih0aGlzLnBhdHRlcm4pOyB9O1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbcGF0dGVybl1bZm9ybUNvbnRyb2xOYW1lXSxbcGF0dGVybl1bZm9ybUNvbnRyb2xdLFtwYXR0ZXJuXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtQQVRURVJOX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5wYXR0ZXJuXSc6ICdwYXR0ZXJuID8gcGF0dGVybiA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAncGF0dGVybic6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUGF0dGVyblZhbGlkYXRvcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhbiB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBmcm9tIGEgdXNlci1zcGVjaWZpZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEl0IGlzIGVzc2VudGlhbGx5IHN5bnRhY3RpYyBzdWdhciB0aGF0IHNob3J0ZW5zIHRoZSBgbmV3IEZvcm1Hcm91cCgpYCxcbiAgICAgKiBgbmV3IEZvcm1Db250cm9sKClgLCBhbmQgYG5ldyBGb3JtQXJyYXkoKWAgYm9pbGVycGxhdGUgdGhhdCBjYW4gYnVpbGQgdXAgaW4gbGFyZ2VyXG4gICAgICogZm9ybXMuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRvIHVzZSwgaW5qZWN0IGBGb3JtQnVpbGRlcmAgaW50byB5b3VyIGNvbXBvbmVudCBjbGFzcy4gWW91IGNhbiB0aGVuIGNhbGwgaXRzIG1ldGhvZHNcbiAgICAgKiBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9mb3JtQnVpbGRlci9mb3JtX2J1aWxkZXJfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICAqICoqTmdNb2R1bGUqKjoge0BsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1CdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUJ1aWxkZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyB7QGxpbmsgRm9ybUdyb3VwfSB3aXRoIHRoZSBnaXZlbiBtYXAgb2YgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogVmFsaWQga2V5cyBmb3IgdGhlIGBleHRyYWAgcGFyYW1ldGVyIG1hcCBhcmUgYHZhbGlkYXRvcmAgYW5kIGBhc3luY1ZhbGlkYXRvcmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSB0aGUge0BsaW5rIEZvcm1Hcm91cH0gY29uc3RydWN0b3IgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uIChjb250cm9sc0NvbmZpZywgZXh0cmEpIHtcbiAgICAgICAgICAgIGlmIChleHRyYSA9PT0gdm9pZCAwKSB7IGV4dHJhID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gdGhpcy5fcmVkdWNlQ29udHJvbHMoY29udHJvbHNDb25maWcpO1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRvciA9IGlzUHJlc2VudChleHRyYSkgPyBleHRyYVsndmFsaWRhdG9yJ10gOiBudWxsO1xuICAgICAgICAgICAgdmFyIGFzeW5jVmFsaWRhdG9yID0gaXNQcmVzZW50KGV4dHJhKSA/IGV4dHJhWydhc3luY1ZhbGlkYXRvciddIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybUdyb3VwKGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyB7QGxpbmsgRm9ybUNvbnRyb2x9IHdpdGggdGhlIGdpdmVuIGBmb3JtU3RhdGVgLGB2YWxpZGF0b3JgLCBhbmRcbiAgICAgICAgICogYGFzeW5jVmFsaWRhdG9yYC5cbiAgICAgICAgICpcbiAgICAgICAgICogYGZvcm1TdGF0ZWAgY2FuIGVpdGhlciBiZSBhIHN0YW5kYWxvbmUgdmFsdWUgZm9yIHRoZSBmb3JtIGNvbnRyb2wgb3IgYW4gb2JqZWN0XG4gICAgICAgICAqIHRoYXQgY29udGFpbnMgYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkIHN0YXR1cy5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5jb250cm9sID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtQ29udHJvbChmb3JtU3RhdGUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEge0BsaW5rIEZvcm1BcnJheX0gZnJvbSB0aGUgZ2l2ZW4gYGNvbnRyb2xzQ29uZmlnYCBhcnJheSBvZlxuICAgICAgICAgKiBjb25maWd1cmF0aW9uLCB3aXRoIHRoZSBnaXZlbiBvcHRpb25hbCBgdmFsaWRhdG9yYCBhbmQgYGFzeW5jVmFsaWRhdG9yYC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uIChjb250cm9sc0NvbmZpZywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3IgPT09IHZvaWQgMCkgeyBhc3luY1ZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBjb250cm9scyA9IGNvbnRyb2xzQ29uZmlnLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gX3RoaXMuX2NyZWF0ZUNvbnRyb2woYyk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtQXJyYXkoY29udHJvbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5fcmVkdWNlQ29udHJvbHMgPSBmdW5jdGlvbiAoY29udHJvbHNDb25maWcpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29udHJvbHMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRyb2xzQ29uZmlnKS5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2xOYW1lXSA9IF90aGlzLl9jcmVhdGVDb250cm9sKGNvbnRyb2xzQ29uZmlnW2NvbnRyb2xOYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9scztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZUNvbnRyb2wgPSBmdW5jdGlvbiAoY29udHJvbENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBGb3JtQ29udHJvbCB8fCBjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgRm9ybUdyb3VwIHx8XG4gICAgICAgICAgICAgICAgY29udHJvbENvbmZpZyBpbnN0YW5jZW9mIEZvcm1BcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250cm9sQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbnRyb2xDb25maWdbMF07XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRvciA9IGNvbnRyb2xDb25maWcubGVuZ3RoID4gMSA/IGNvbnRyb2xDb25maWdbMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBhc3luY1ZhbGlkYXRvciA9IGNvbnRyb2xDb25maWcubGVuZ3RoID4gMiA/IGNvbnRyb2xDb25maWdbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wodmFsdWUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbChjb250cm9sQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUJ1aWxkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQnVpbGRlci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gRm9ybUJ1aWxkZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBTSEFSRURfRk9STV9ESVJFQ1RJVkVTID0gW1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbiwgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbiwgRGVmYXVsdFZhbHVlQWNjZXNzb3IsIE51bWJlclZhbHVlQWNjZXNzb3IsXG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3NvciwgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciwgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5nQ29udHJvbFN0YXR1cyxcbiAgICAgICAgTmdDb250cm9sU3RhdHVzR3JvdXAsIFJlcXVpcmVkVmFsaWRhdG9yLCBNaW5MZW5ndGhWYWxpZGF0b3IsIE1heExlbmd0aFZhbGlkYXRvciwgUGF0dGVyblZhbGlkYXRvclxuICAgIF07XG4gICAgdmFyIFRFTVBMQVRFX0RSSVZFTl9ESVJFQ1RJVkVTID0gW05nTW9kZWwsIE5nTW9kZWxHcm91cCwgTmdGb3JtXTtcbiAgICB2YXIgUkVBQ1RJVkVfRFJJVkVOX0RJUkVDVElWRVMgPSBbRm9ybUNvbnRyb2xEaXJlY3RpdmUsIEZvcm1Hcm91cERpcmVjdGl2ZSwgRm9ybUNvbnRyb2xOYW1lLCBGb3JtR3JvdXBOYW1lLCBGb3JtQXJyYXlOYW1lXTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtb2R1bGUgdXNlZCBmb3Igc2hhcmluZyBkaXJlY3RpdmVzIGJldHdlZW4gRm9ybXNNb2R1bGUgYW5kIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAgICAgKi9cbiAgICB2YXIgSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBTSEFSRURfRk9STV9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogU0hBUkVEX0ZPUk1fRElSRUNUSVZFUyxcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmcgbW9kdWxlIGZvciBmb3Jtcy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1zTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRm9ybXNNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgRm9ybXNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogVEVNUExBVEVfRFJJVkVOX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSYWRpb0NvbnRyb2xSZWdpc3RyeV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSwgVEVNUExBVEVfRFJJVkVOX0RJUkVDVElWRVNdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybXNNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIEZvcm1zTW9kdWxlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVGhlIG5nIG1vZHVsZSBmb3IgcmVhY3RpdmUgZm9ybXMuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBSZWFjdGl2ZUZvcm1zTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVhY3RpdmVGb3Jtc01vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtSRUFDVElWRV9EUklWRU5fRElSRUNUSVZFU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtGb3JtQnVpbGRlciwgUmFkaW9Db250cm9sUmVnaXN0cnldLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW0ludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIFJFQUNUSVZFX0RSSVZFTl9ESVJFQ1RJVkVTXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFJlYWN0aXZlRm9ybXNNb2R1bGU7XG4gICAgfSgpKTtcblxuICAgIGV4cG9ydHMuQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlID0gQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUgPSBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZTtcbiAgICBleHBvcnRzLkNoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IgPSBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIGV4cG9ydHMuQ29udHJvbENvbnRhaW5lciA9IENvbnRyb2xDb250YWluZXI7XG4gICAgZXhwb3J0cy5OR19WQUxVRV9BQ0NFU1NPUiA9IE5HX1ZBTFVFX0FDQ0VTU09SO1xuICAgIGV4cG9ydHMuRGVmYXVsdFZhbHVlQWNjZXNzb3IgPSBEZWZhdWx0VmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLk5nQ29udHJvbCA9IE5nQ29udHJvbDtcbiAgICBleHBvcnRzLk5nQ29udHJvbFN0YXR1cyA9IE5nQ29udHJvbFN0YXR1cztcbiAgICBleHBvcnRzLk5nQ29udHJvbFN0YXR1c0dyb3VwID0gTmdDb250cm9sU3RhdHVzR3JvdXA7XG4gICAgZXhwb3J0cy5OZ0Zvcm0gPSBOZ0Zvcm07XG4gICAgZXhwb3J0cy5OZ01vZGVsID0gTmdNb2RlbDtcbiAgICBleHBvcnRzLk5nTW9kZWxHcm91cCA9IE5nTW9kZWxHcm91cDtcbiAgICBleHBvcnRzLlJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IgPSBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIGV4cG9ydHMuRm9ybUNvbnRyb2xEaXJlY3RpdmUgPSBGb3JtQ29udHJvbERpcmVjdGl2ZTtcbiAgICBleHBvcnRzLkZvcm1Db250cm9sTmFtZSA9IEZvcm1Db250cm9sTmFtZTtcbiAgICBleHBvcnRzLkZvcm1Hcm91cERpcmVjdGl2ZSA9IEZvcm1Hcm91cERpcmVjdGl2ZTtcbiAgICBleHBvcnRzLkZvcm1BcnJheU5hbWUgPSBGb3JtQXJyYXlOYW1lO1xuICAgIGV4cG9ydHMuRm9ybUdyb3VwTmFtZSA9IEZvcm1Hcm91cE5hbWU7XG4gICAgZXhwb3J0cy5OZ1NlbGVjdE9wdGlvbiA9IE5nU2VsZWN0T3B0aW9uO1xuICAgIGV4cG9ydHMuU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IgPSBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLlNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IgPSBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIGV4cG9ydHMuTWF4TGVuZ3RoVmFsaWRhdG9yID0gTWF4TGVuZ3RoVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuTWluTGVuZ3RoVmFsaWRhdG9yID0gTWluTGVuZ3RoVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuUGF0dGVyblZhbGlkYXRvciA9IFBhdHRlcm5WYWxpZGF0b3I7XG4gICAgZXhwb3J0cy5SZXF1aXJlZFZhbGlkYXRvciA9IFJlcXVpcmVkVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuRm9ybUJ1aWxkZXIgPSBGb3JtQnVpbGRlcjtcbiAgICBleHBvcnRzLkFic3RyYWN0Q29udHJvbCA9IEFic3RyYWN0Q29udHJvbDtcbiAgICBleHBvcnRzLkZvcm1BcnJheSA9IEZvcm1BcnJheTtcbiAgICBleHBvcnRzLkZvcm1Db250cm9sID0gRm9ybUNvbnRyb2w7XG4gICAgZXhwb3J0cy5Gb3JtR3JvdXAgPSBGb3JtR3JvdXA7XG4gICAgZXhwb3J0cy5OR19BU1lOQ19WQUxJREFUT1JTID0gTkdfQVNZTkNfVkFMSURBVE9SUztcbiAgICBleHBvcnRzLk5HX1ZBTElEQVRPUlMgPSBOR19WQUxJREFUT1JTO1xuICAgIGV4cG9ydHMuVmFsaWRhdG9ycyA9IFZhbGlkYXRvcnM7XG4gICAgZXhwb3J0cy5Gb3Jtc01vZHVsZSA9IEZvcm1zTW9kdWxlO1xuICAgIGV4cG9ydHMuUmVhY3RpdmVGb3Jtc01vZHVsZSA9IFJlYWN0aXZlRm9ybXNNb2R1bGU7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvZm9ybXMvYnVuZGxlcy9mb3Jtcy51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2hvbWUnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2hvbWUuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2hvbWUuY29tcG9uZW50Lmxlc3MnKV0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBIb21lQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBuZ09uSW5pdCgpOiB2b2lkIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aW1nIGNsYXNzPVxcXCJob21lLWltYWdlXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2hvbWUvaG9tZS5qcGdcIikgKyBcIlxcXCIvPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9ob21lLmpwZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2hvbWUvaG9tZS5qcGdcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9ob21lLmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5ob21lLWltYWdle3dpZHRoOjEwMCU7Ym94LXNoYWRvdzowIDFweCAycHggMCByZ2JhKDM0LDM2LDM4LC4xNSk7Ym9yZGVyOjFweCBzb2xpZCAjMDAwMDRkfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlci9saWIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWJvdXQnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Fib3V0LmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9hYm91dC5jb21wb25lbnQubGVzcycpXVxufSlcbmV4cG9ydCBjbGFzcyBBYm91dENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+QWJvdXQgVXM8L2gxPlxcbjxwPklsbGlub2lzIFVsdGltYXRlIGlzIG9uZSBvZiB0aGUgcHJlbWllciB1bHRpbWF0ZSBwcm9ncmFtcyBpbiB0aGUgTWlkd2VzdCBhbmQgZnJlcXVlbnRseSByYW5rcyBpbiB0aGUgTmF0aW9uYWwgdG9wIDI1LiBXZSBzdHJpdmUgdG8gY29udGVuZCB3aXRoIHRoZSBiZXN0IHByb2dyYW1zIGluIHRoZSBjb3VudHJ5IGFuZCBxdWFsaWZ5IHRvIGNvbXBldGUgYXQgTmF0aW9uYWxzIHJlZ3VsYXJ5LiBXZSBhcmUgYSBwcm9ncmFtIHRoYXQgcHJpZGVzIGl0c2VsZiBvbiBkZXZlbG9waW5nIHBsYXllcnMgd2hvIGNvbWUgdG8gSWxsaW5vaXMgd2l0aCBubyBleHBlcmllbmNlIHBsYXlpbmcgY29tcGV0aXRpdmUgdWx0aW1hdGUuIFdlIHRlYWNoIGFsbCBsZXZlbHMgb2YgdWx0aW1hdGUsIGZyb20gdGhlIGJhc2ljcyBvZiB0aHJvd2luZyBhIGZvcmVoYW5kIGFsbCB0aGUgd2F5IHRvIHRocm93aW5nIGJvbWJzIGluIHRoZSB3b3JzdCBvZiB3ZWF0aGVyLjwvcD5cXG48aDIgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+TWlzc2lvbiBTdGF0ZW1lbnQ8L2gyPlxcbjxwPldlIHdhbnQgdG8gY29tcGV0ZSBhdCB0aGUgaGlnaGVzdCBsZXZlbCBwb3NzaWJsZSBpbiBjb2xsZWdlIHVsdGltYXRlIHdoaWxlIHJlbWFpbmluZyByZXNwZWN0ZnVsIHRvIG91ciBvcHBvbmVudHMuICBXZSB3YW50IHRvIGRldmVsb3AgYWxsIG91ciBvZiBwbGF5ZXJzIHRvIGJlY29tZSB0aGUgYmVzdCB0aGV5IGNhbiBiZSBhdCB1bHRpbWF0ZSwgYXMgd2VsbCBhcyBwbGF5ZXJzIHdobyBleGVtcGxpZnkgdGhlIHRydWUgbWVhbmluZyBvZiBzcG9ydHNtYW5zaGlwLCB3aGljaCBpcyBwaXZvdGFsIHRvIHRoZSBwcm9ncmVzcyBvZiB1bHRpbWF0ZSBmcmlzYmVlIGluIGl0cyBjdXJyZW50IHN0YXRlLjwvcD5cXG48aDIgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+VGVhbSBTdHJ1Y3R1cmUvQWZmaWxpYXRpb24gd2l0aCBVbml2ZXJzaXR5PC9oMj5cXG48cD5PdXIgdGVhbSBpcyBhIFJlZ2lzdGVyZWQgU3R1ZGVudCBPcmdhbml6YXRpb24gKFJTTykgYXQgdGhlIFVuaXZlcnNpdHkgb2YgSWxsaW5vaXMgYW5kIHdlIGFyZSBjbGFzc2lmaWVkIGFzIGEgY2x1YiBzcG9ydC4gV2UgcmVjZWl2ZSBzb21lIGZ1bmRpbmcgZnJvbSB0aGUgVW5pdmVyc2l0eSB0aGF0IGhlbHBzIHBheSBmb3Igb3VyIHRyYXZlbCBjb3N0cyBhbmQgaG90ZWxzIHdoaWxlIHdlIGFyZSBhdCB0b3VybmFtZW50cy48L3A+XFxuPHA+V2UgYXJlIGEgbWVtYmVyIG9mIHRoZSBVU0FVICBDb2xsZWdlIFNlcmllcyBhbmQgY29tcGV0ZSBpbiBhIHNlcmllcyBvZiB0b3VybmFtZW50cyB0aGF0ICBjdWxtaW5hdGUgaW4gdGhlIENvbGxlZ2UgQ2hhbXBpb25zaGlwcyBoZWxkIGV2ZXJ5IHllYXIgZHVyaW5nIE1lbW9yaWFsIERheSB3ZWVrZW5kLiBNb3N0LCBpZiBub3QgYWxsLCBzdGF0ZSBzY2hvb2xzIGhhdmUgZXN0YWJsaXNoZWQgdWx0aW1hdGUgdGVhbXMgYW5kIG1hbnkgc21hbGxlciBzY2hvb2xzIGhhdmUgdGVhbXMgYXMgd2VsbC4gIFdlIGNvbXBldGUgaW4gdGhlIElsbGlub2lzIGNvbmZlcmVuY2Ugd2hpY2ggaXMgYXMgeW91IGNhbiBndWVzcywgdGhlIHNjaG9vbHMgaW4gdGhlIHN0YXRlIG9mIElsbGlub2lzLiBUaGUgbmV4dCBsYXJnZXN0IGRpdmlzaW9uIGlzIHRoZSBHcmVhdCBMYWtlcyBSZWdpb24sIHdoaWNoIGluY2x1ZGVzIHRoZSBzdGF0ZXMgb2YgSWxsaW5vaXMsIEluZGlhbmEsIE1pY2hpZ2FuLCBhbmQgS2VudHVja3kuIFRoZSBmaW5hbCBzdGVwIGlzIHRoZSBhZm9yZW1lbnRpb25lZCBOYXRpb25hbCBDaGFtcGlvbnNoaXBzLjwvcD5cXG48cD5PdXIgcHJvZ3JhbSBpcyBzcGxpdCB1cCBpbnRvIHR3byB0ZWFtcywgQSBhbmQgQi4gT3VyIEEgdGVhbSBpcyBhIGdyb3VwIG9mIGluZGl2aWR1YWxzIHdobyBhcmUgdmVyeSBkZWRpY2F0ZWQgdG8gdGhlIHRlYW0gYW5kIHdobyBwdXQgaW4gYSBsYXJnZSBhbW91bnQgb2YgdGltZSBmb3IgcHJhY3RpY2VzIGFzIHdlbGwgYXMgdHJhaW5pbmcgb3V0c2lkZSBvZiBwcmFjdGljZXMuIE91ciBCIHRlYW0gaXMgbW9yZSBvcmllbnRlZCB0b3dhcmRzIHRoZSBkZXZlbG9wbWVudCBvZiB5b3VuZ2VyIG9yIGluZXhwZXJpZW5jZWQgcGxheWVycy4gQiB0ZWFtIHByb3ZpZGVzIGEgbXVjaCBtb3JlIHJlbGF4ZWQgYXRtb3NwaGVyZSBidXQgc3RpbGwgcmVtYWlucyBjb21wZXRpdGl2ZSB3aXRoIGFsbCBvdGhlciBCIHRlYW1zIGluIHRoZSByZWdpb24sIGFuZCBldmVuIGJlYXRzIHNvbWUgc21hbGxlciBzY2hvb2xzJyBBIHRlYW1zLjwvcD5cXG48cD5BIHRlYW0gaGFzIHRyeW91dHMgZWFjaCB5ZWFyLCBjb25zaXN0aW5nIG9mIHRocmVlIHRvIGZvdXIgdG91cm5hbWVudHMgaW4gdGhlIGZhbGwuIFRoZSBmaXJzdCByb3VuZCBvZiBjdXRzIHdpbGwgdXN1YWxseSBiZSBtYWRlIGFmdGVyIHRoZSBzZWNvbmQgdG91cm5hbWVudC4gVGhlIHRyeW91dCByb3N0ZXIgd2lsbCB0aGVuIGJlIG5hcnJvd2VkIGRvd24gdG8gb25lIHRlYW0gYmVmb3JlIHRoZSBmaW5hbCB0b3VybmFtZW50IG9mIHRoZSBmYWxsLCB2aWEgY3V0cyBvbiBhIHJvbGxpbmcgYmFzaXMuIFBsYXllcnMgbWF5IGJlIG1vdmVkIGJldHdlZW4gdGhlIEEgYW5kIEIgdGVhbSByb3N0ZXJzIGFzIG5lY2Vzc2FyeS48L3A+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vYWJvdXQuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJwe3RleHQtYWxpZ246bGVmdH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vcG9zdGNzcy1sb2FkZXIvbGliIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvYWJvdXQvYWJvdXQuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFNwcmVhZHNoZWV0U2VydmljZSB9IGZyb20gJy4uL2dsb2JhbC9zZXJ2aWNlL2dvb2dsZS1zcHJlYWRzaGVldC5zZXJ2aWNlJztcbmltcG9ydCB7IEd0bVV0aWwgfSBmcm9tICcuLi9nbG9iYWwvdXRpbC9ndG0udXRpbCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncHJvc3BlY3RpdmUtcGxheWVycycsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQubGVzcycpXVxufSlcbmV4cG9ydCBjbGFzcyBQcm9zcGVjdGl2ZVBsYXllcnNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIC8vIEFQSSB1cmwgZm9yIG91ciBwZXJzb25hbCBzZXJ2ZXJcbiAgICBwcml2YXRlIGdvb2dsZVNoZWV0c0FwaVVybCA9ICdodHRwczovL25pY2stcHJvei1ub2RlLXNlcnZlci5oZXJva3VhcHAuY29tL3NoZWV0cy8xMWlqckhveXNpSXdzRmZFZ2diU05NOVk4VnZ6VTY1amV1aFEzdmtWNUZHdy9zaGVldEluZGV4LzIvcm93cy8nO1xuICAgIC8vIEFQSSB1cmwgZm9yIG91ciBiYWNrdXAgc2VydmVyIChzaGVldHN1IEFQSSlcbiAgICAvLyBwcml2YXRlIGdvb2dsZVNoZWV0c0JhY2t1cEFwaVVybCA9ICdodHRwczovL3NoZWV0c3UuY29tL2FwaXMvdjEuMC83YTAzMGFlNjBiN2QnO1xuICAgIHByaXZhdGUgZ29vZ2xlU2hlZXRzQmFja3VwQXBpVXJsID0gJyc7XG5cbiAgICAvLyBFcnJvciBtZXNzYWdlc1xuICAgIHByaXZhdGUgdmFsaWRhdGlvbkVycm9yczogc3RyaW5nID0gJ1BsZWFzZSBkbyBub3QgbGVhdmUgYW55IHJlcXVpcmVkIGZpZWxkcyBibGFuay4nO1xuICAgIHByaXZhdGUgc3VibWlzc2lvbkVycm9yOiBzdHJpbmcgPSAnQ291bGQgbm90IHN1Ym1pdCB0aGUgZm9ybSAgZHVlIHRvIGEgc2VydmVyIGVycm9yLiBQbGVhc2UgdHJ5IGFnYWluIHNvb24gb3IgY29udGFjdCB0aGUgd2ViIGFkbWlucy4nO1xuXG4gICAgLy8gR1RNIHZhcmlhYmxlc1xuICAgIHByaXZhdGUgc3RhdGljIGd0bUV2ZW50TmFtZTogc3RyaW5nID0gJ1Byb3NwZWN0IEZvcm0gU3VibWl0JztcbiAgICBwcml2YXRlIHN0YXRpYyBndG1WYXJpYWJsZU5hbWU6IHN0cmluZyA9ICdwcm9zcGVjdC1mb3JtJztcblxuICAgIC8vIEZpcnN0IG5hbWUgaW5wdXRcbiAgICBwcml2YXRlIGZpcnN0TmFtZTogc3RyaW5nO1xuICAgIC8vIExhc3QgbmFtZSBpbnB1dFxuICAgIHByaXZhdGUgbGFzdE5hbWU6IHN0cmluZztcbiAgICAvLyBSZWFzb24gaW5wdXRcbiAgICBwcml2YXRlIGVtYWlsQWRkcmVzczogc3RyaW5nO1xuICAgIC8vIFRpbWUgaW5wdXRcbiAgICBwcml2YXRlIGhvbWV0b3duOiBzdHJpbmc7XG4gICAgLy8gRGF5IGlucHV0XG4gICAgcHJpdmF0ZSBoaWdoc2Nob29sOiBzdHJpbmc7XG4gICAgLy8gTW9udGggaW5wdXRcbiAgICBwcml2YXRlIG1ham9yOiBzdHJpbmc7XG4gICAgLy8gRXhwZXJpZW5jZSBpbnB1dFxuICAgIHByaXZhdGUgZXhwZXJpZW5jZTogc3RyaW5nO1xuICAgIC8vIE90aGVyIENsdWJzIGlucHV0XG4gICAgcHJpdmF0ZSBvdGhlckNsdWJzOiBzdHJpbmc7XG4gICAgLy8gQ29udGFjdCBpbnB1dFxuICAgIHByaXZhdGUgY29udGFjdDogc3RyaW5nID0gJ1llcyc7XG4gICAgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIGlmIG91ciBmb3JtIGlzIGluIHRoZSBwcm9jZXNzIG9mIHN1Ym1pdHRpbmcgKHRvIHNob3cgb3VyIGxvYWRpbmcgaWNvbilcbiAgICBwcml2YXRlIGZvcm1Jc1N1Ym1pdHRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAvLyBCb29sZWFuIGluZGljYXRpbmcgaWYgb3VyIGZvcm0gd2FzIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQgKHRvIHNob3cgb3VyIHN1Y2Nlc3MgbWVzc2FnZSlcbiAgICBwcml2YXRlIHN1Ym1pdFN1Y2Nlc3M6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAvLyBGb3JtIGVycm9ycyBvdXRwdXRcbiAgICBwcml2YXRlIGZvcm1FcnJvcnM6IHN0cmluZztcblxuICAgIC8vIENvbnN0cnVjdG9yIHdpdGggb3VyIGh0dHAgc2VydmljZSBpbmplY3RlZFxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgc3ByZWFkc2hlZXRTZXJ2aWNlOiBTcHJlYWRzaGVldFNlcnZpY2UpIHt9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHt9XG5cbiAgICBoYW5kbGVTdWJtaXQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnN1Ym1pdFN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuZm9ybUlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtRXJyb3JzID0gdGhpcy52YWxpZGF0aW9uRXJyb3JzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JtSXNTdWJtaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBUaW1lc3RhbXA6IGRhdGUudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnRmlyc3QgTmFtZSc6IHRoaXMuZmlyc3ROYW1lLFxuICAgICAgICAgICAgICAgICdMYXN0IE5hbWUnOiB0aGlzLmxhc3ROYW1lLFxuICAgICAgICAgICAgICAgICdFbWFpbCBBZGRyZXNzJzogdGhpcy5lbWFpbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgSG9tZXRvd246IHRoaXMuaG9tZXRvd24sXG4gICAgICAgICAgICAgICAgSGlnaHNjaG9vbDogdGhpcy5oaWdoc2Nob29sLFxuICAgICAgICAgICAgICAgIE1ham9yOiB0aGlzLm1ham9yLFxuICAgICAgICAgICAgICAgIEV4cGVyaWVuY2U6IHRoaXMuZXhwZXJpZW5jZSxcbiAgICAgICAgICAgICAgICAnT3RoZXIgQ2x1YnMnOiB0aGlzLm90aGVyQ2x1YnMsXG4gICAgICAgICAgICAgICAgJ0NvbnRhY3QgTWUnOiB0aGlzLmNvbnRhY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN1Ym1pdFBsYXllckZvcm0oZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJtaXRzIG91ciBmb3JtIHRvIHRoZSBzcHJlYWRzaGVldCBieSBjYWxsaW5nIG91ciBzZXJ2aWNlIG1ldGhvZC5cbiAgICAgKiBPbiBzdWNjZXNzLCB3ZSBzaG93IG91ciBzdWNjZXNzIG1lc3NhZ2UuXG4gICAgICogT24gZmFpbHVyZSwgd2UgaGlkZSBvdXIgc3VibWl0dGluZyBkaWFsb2cgYW5kIHNob3cgb3VyIHN1Ym1pc3Npb24gZXJyb3IgdG8gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAtIGRhdGEgdG8gc3VibWl0IHRvIG91ciBzcHJlYWRzaGVldFxuICAgICAqL1xuICAgIHByaXZhdGUgc3VibWl0UGxheWVyRm9ybShkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgLy8gUHVzaCBvdXIgZm9ybSBkYXRhIHRvIHRoZSBkYXRhIGxheWVyIGZvciBHb29nbGUgVGFnIE1hbmFnZXIgdG8gY29uc3VtZVxuICAgICAgICBHdG1VdGlsLnB1c2hPYmplY3RUb0RhdGFMYXllcihQcm9zcGVjdGl2ZVBsYXllcnNDb21wb25lbnQuZ3RtRXZlbnROYW1lLCBQcm9zcGVjdGl2ZVBsYXllcnNDb21wb25lbnQuZ3RtVmFyaWFibGVOYW1lLCBkYXRhKTtcblxuICAgICAgICB0aGlzLnNwcmVhZHNoZWV0U2VydmljZVxuICAgICAgICAgICAgLnBvc3RSb3dUb1NwcmVhZHNoZWV0KHRoaXMuZ29vZ2xlU2hlZXRzQXBpVXJsLCB0aGlzLmdvb2dsZVNoZWV0c0JhY2t1cEFwaVVybCwgZGF0YSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rm9ybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VibWl0U3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Jc1N1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1FcnJvcnMgPSB0aGlzLnN1Ym1pc3Npb25FcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBvdXIgaW5wdXQgZmllbGRzLCBlcnJvcnMsIGFuZCByZXNldHMgb3VyIGZvcm0gaXMgc3VibWl0dGluZyBmbGFnLlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVzZXRGb3JtKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZpcnN0TmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmVtYWlsQWRkcmVzcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaG9tZXRvd24gPSBudWxsO1xuICAgICAgICB0aGlzLmhpZ2hzY2hvb2wgPSBudWxsO1xuICAgICAgICB0aGlzLm1ham9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5leHBlcmllbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vdGhlckNsdWJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JtRXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JtSXNTdWJtaXR0aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnJvbnQtZW5kIHZhbGlkYXRpb24gZm9yIG91ciBmb3JtLlxuICAgICAqIE91ciBmb3JtIGlzIHZhbGlkIG9ubHkgaWYgYWxsIGZpZWxkcyBhcmUgcG9wdWxhdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgZm9ybSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgcHJpdmF0ZSBmb3JtSXNWYWxpZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuZmlyc3ROYW1lICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuZmlyc3ROYW1lICE9ICcnICYmXG4gICAgICAgICAgICB0aGlzLmxhc3ROYW1lICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMubGFzdE5hbWUgIT0gJycgJiZcbiAgICAgICAgICAgIHRoaXMuZW1haWxBZGRyZXNzICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuZW1haWxBZGRyZXNzICE9ICcnICYmXG4gICAgICAgICAgICB0aGlzLmhvbWV0b3duICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuaG9tZXRvd24gIT0gJycgJiZcbiAgICAgICAgICAgIHRoaXMuaGlnaHNjaG9vbCAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLmhpZ2hzY2hvb2wgIT0gJycgJiZcbiAgICAgICAgICAgIHRoaXMubWFqb3IgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5tYWpvciAhPSAnJyAmJlxuICAgICAgICAgICAgdGhpcy5leHBlcmllbmNlICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuZXhwZXJpZW5jZSAhPSAnJyAmJlxuICAgICAgICAgICAgdGhpcy5vdGhlckNsdWJzICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMub3RoZXJDbHVicyAhPSAnJyAmJlxuICAgICAgICAgICAgdGhpcy5jb250YWN0ICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuY29udGFjdCAhPSAnJ1xuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSGVhZGVycywgSHR0cCB9IGZyb20gJ0Bhbmd1bGFyL2h0dHAnO1xuXG4vKipcbiAqIFNlcnZpY2UgdG8gaW50ZXJhY3Qgd2l0aCBvdXIgR29vZ2xlIHNwcmVhZHNoZWV0LlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU3ByZWFkc2hlZXRTZXJ2aWNlIHtcbiAgICAvLyBIVFRQIGhlYWRlcnNcbiAgICBwcml2YXRlIGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSk7XG5cbiAgICAvLyBDb25zdHJ1Y3RvciB3aXRoIG91ciBodHRwIHNlcnZpY2UgaW5qZWN0ZWRcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHA6IEh0dHApIHt9XG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBwb3N0IHRoZSBkYXRhIHBhc3NlZCBpbiB0byBvdXIgc3ByZWFkc2hlZXQuXG4gICAgICogUmVqZWN0cyB0aGUgcHJvbWlzZSBpZiB0aGVyZSBpcyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcGlVcmwgLSB1cmwgb2YgdGhlIGdvb2dsZSBzaGVldHMgQVBJXG4gICAgICogQHBhcmFtIGJhY2t1cEFwaVVybCAtIHVybCBvZiBodGUgZ29vZ2xlIHNoZWV0cyBiYWNrdXAgQVBJXG4gICAgICogQHBhcmFtIGRhdGEgLSBkYXRhIHRvIGFkZCB0byBvdXIgc3ByZWFkc2hlZXRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxKU09OPn0gLSBQcm9taXNlIGhvbGRpbmcgdGhlIHN1Y2Nlc3NmdWxseSBwb3N0ZWQgb2JqZWN0LCBvciBhIHJlamVjdGVkIHByb21pc2Ugd2l0aCBhbiBlcnJvclxuICAgICAqL1xuICAgIHB1YmxpYyBwb3N0Um93VG9TcHJlYWRzaGVldChhcGlVcmw6IHN0cmluZywgYmFja3VwQXBpVXJsOiBzdHJpbmcsIGRhdGE6IE9iamVjdCk6IFByb21pc2U8SlNPTj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5odHRwXG4gICAgICAgICAgICAucG9zdChhcGlVcmwsIGRhdGEsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pXG4gICAgICAgICAgICAudG9Qcm9taXNlKClcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgLmNhdGNoKFNwcmVhZHNoZWV0U2VydmljZS5oYW5kbGVFcnJvcik7XG4gICAgICAgIC8vIC5jYXRjaCgoKSA9PiB0aGlzLnBvc3RSb3dUb1NwcmVhZHNoZWV0QmFja3VwKGJhY2t1cEFwaVVybCwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHBvc3QgdGhlIGRhdGEgcGFzc2VkIGluIHRvIG91ciBiYWNrdXAgc3ByZWFkc2hlZXQuXG4gICAgICogVGhpcyBpcyBhIGJhY2t1cCBwb3N0IGluIGNhc2Ugb3VyIHBlcnNvbmFsIHNlcnZlciBmYWlscy5cbiAgICAgKiBSZWplY3RzIHRoZSBwcm9taXNlIGlmIHRoZXJlIGlzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhY2t1cEFwaVVybCAtIHVybCBvZiBodGUgZ29vZ2xlIHNoZWV0cyBiYWNrdXAgQVBJXG4gICAgICogQHBhcmFtIGRhdGEgLSBkYXRhIHRvIGFkZCB0byBvdXIgc3ByZWFkc2hlZXRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxKU09OPn0gLSBQcm9taXNlIGhvbGRpbmcgdGhlIHN1Y2Nlc3NmdWxseSBwb3N0ZWQgb2JqZWN0LCBvciBhIHJlamVjdGVkIHByb21pc2Ugd2l0aCBhbiBlcnJvclxuICAgICAqL1xuICAgIHB1YmxpYyBwb3N0Um93VG9TcHJlYWRzaGVldEJhY2t1cChiYWNrdXBBcGlVcmw6IHN0cmluZywgZGF0YTogT2JqZWN0KTogUHJvbWlzZTxKU09OPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBcbiAgICAgICAgICAgIC5wb3N0KGJhY2t1cEFwaVVybCwgZGF0YSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSlcbiAgICAgICAgICAgIC50b1Byb21pc2UoKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAuY2F0Y2goU3ByZWFkc2hlZXRTZXJ2aWNlLmhhbmRsZUVycm9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFsbCByc3ZwIHNlcnZpY2UgZXJyb3JzIChhZnRlciBvdXIgYmFja3VwIGNhbGwpIHdoZW4gaW50ZXJmYWNpbmdcbiAgICAgKiB3aXRoIHRoZSBnb29nbGUgc3ByZWFkc2hlZXQgYXBpLiBXZSBsb2cgdGhlIGVycm9yIGFuZCByZWplY3QgdGhlIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBFcnJvciB0byBsb2cgYW5kIHJlamVjdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IC0gQSByZWplY3RlZCBwcm9taXNlXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgaGFuZGxlRXJyb3IoZXJyb3I6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIHdoZW4gYXR0ZW1wdGluZyB0byBzZW5kIGRhdGEgdG8gb3VyIHNwcmVhZHNoZWV0OiAnLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2dsb2JhbC9zZXJ2aWNlL2dvb2dsZS1zcHJlYWRzaGVldC5zZXJ2aWNlLnRzIiwiLyoqXG4gKiBVdGlsIGZvciBpbnRlcmFjdGluZyB3aXRoIEdvb2dsZSBUYWcgTWFuYWdlciAoR1RNKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEd0bVV0aWwge1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBjdXN0b20gR1RNIGRhdGEgdG8gdGhlIGRhdGEgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gbmFtZSBvZiB0aGUgZXZlbnQuIFRoaXMgaXMgdGhlIEN1c3RvbSBFdmVudCBuYW1lIHNwZWNpZmllZCBpbiBhIEdUTSB0cmlnZ2VyXG4gICAgICogQHBhcmFtIHZhcmlhYmxlTmFtZSAtIGRhdGEgbGF5ZXIgdmFyaWFibGUgbmFtZS4gVGhpcyBpcyB0aGUgRGF0YSBMYXllciBWYXJpYWJsZSBuYW1lIGluIGEgR1RNIGN1c3RvbSB2YXJpYWJsZVxuICAgICAqIEBwYXJhbSBkYXRhIC0gZGF0YSBvYmplY3QgdG8gcHVzaCB0byBHVE0uIFdlIHN0cmluZ2lmeSB0aGUgb2JqZWN0IHNvIHRoYXQgaXQgaXMgcmVhZGFibGVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHB1c2hPYmplY3RUb0RhdGFMYXllcihldmVudE5hbWU6IHN0cmluZywgdmFyaWFibGVOYW1lOiBzdHJpbmcsIGRhdGE6IE9iamVjdCk6IHZvaWQge1xuICAgICAgICAvLyBJbml0aWFsaXplIG91ciBkYXRhIGxheWVyLCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICAgICAgKDxhbnk+d2luZG93KS5kYXRhTGF5ZXIgPSAoPGFueT53aW5kb3cpLmRhdGFMYXllciB8fCBbXTtcblxuICAgICAgICAvLyBQdXNoIG91ciBHVE0gb2JqZWN0IHdpdGggdGhlIGV2ZW50IGRhdGEgcGFzc2VkIGluXG4gICAgICAgICg8YW55PndpbmRvdykuZGF0YUxheWVyLnB1c2goeyBldmVudDogZXZlbnROYW1lLCBbdmFyaWFibGVOYW1lXTogSlNPTi5zdHJpbmdpZnkoZGF0YSkgfSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2dsb2JhbC91dGlsL2d0bS51dGlsLnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjwhLS1IZWFkZXItLT5cXG48aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+UHJvc3BlY3RpdmUgUGxheWVyczwvaDE+XFxuPHA+SWxsaW5vaXMgVWx0aW1hdGUgaGFzIGhhZCBhIGxvbmcgaGlzdG9yeSBzaW5jZSBpdHMgaW5jZXB0aW9uIGluIHRoZSBlYXJseSAxOTkwcyBhbmQgbm93IGNvbnNpc3RlbnRseSBjb21wZXRlcyB3aXRoIGJlc3QgY29tcGV0aXRpb24gYXJvdW5kIHRoZSBjb3VudHJ5LiBJbGxpbm9pcyBoYXMgcXVhbGlmaWVkIGZvciBuYXRpb25hbCBjaGFtcGlvbnNoaXBzIGZyZXF1ZW50bHkgYmVoaW5kIG91ciBkZWRpY2F0aW9uLCBkZXRlcm1pbmF0aW9uLCBhbmQgZGlzdGluZ3Vpc2hlZCBjaGFyYWN0ZXIgb24gYW5kIG9mZiB0aGUgZmllbGQuIElsbGlub2lzIGFsdW1uaSBoYXZlIGdvbmUgb24gdG8gcGxheSBmb3IgbmF0aW9uYWxzIGNhbGliZXIgY2x1YiB0ZWFtcyBzdWNoIGFzIENoaWNhZ28gTWFjaGluZSwgTWlubmVhcG9saXMgRHJhZyAnbiBUaHJ1c3QsIENpbmNpbm5hdGkgU3RlYW1ib2F0LCBBdGxhbnRhIENoYWluIExpZ2h0bmluZywgYW5kIFNhbiBGcmFuY2lzY28gQmxhY2tiaXJkLiBBbHVtbmkgaGF2ZSBwbGF5ZWQgb24gcHJvZmVzc2lvbmFsIEFVREwgdGVhbXMgc3VjaCBhcyB0aGUgQ2hpY2FnbyBXaWxkZmlyZSwgTWlubmVzb3RhIFdpbmRjaGlsbCwgQ2luY2lubmF0aSBSZXZvbHV0aW9uLCBhbmQgdGhlIFNhbiBKb3NlIFNwaWRlcnMuIFRoZXkgaGF2ZSBhbHNvIGNyZWF0ZWQgYW5kIGNhcHRhaW5lZCBjbHViIHRlYW1zIGluY2x1ZGluZyBDaGljYWdvIE1hY2hpbmUsIEJsYWNrIE1hcmtldCBVbHRpbWF0ZSwgYW5kIEJlYWNoZnJvbnQgVWx0aW1hdGUsIGFuZCBoYXZlIGdvbmUgb24gdG8gY29hY2ggY29sbGVnZSB1bHRpbWF0ZSBhdCB0aGUgVW5pdmVyc2l0eSBvZiBJbGxpbm9pcywgdGhlIFVuaXZlcnNpdHkgb2YgQ2hpY2FnbywgTm9ydGh3ZXN0ZXJuIFVuaXZlcnNpdHksIGFuZCB0aGUgVW5pdmVyc2l0eSBvZiBLZW50dWNreS4gSXQncyBzYWZlIHRvIHNheSB0aGF0IG9uY2UgeW91IHBsYXkgdWx0aW1hdGUgYXQgSWxsaW5vaXMgeW91IGFyZSBvcGVuZWQgdXAgdG8gYSB3b3JsZCBvZiBvcHBvcnR1bml0eSB0aHJvdWdoIG91ciBhbHVtbmkgbmV0d29yaywgd2hvIGFyZSBtb3JlIHRoYW4gd2lsbGluZyB0byBhc3Npc3QgeW91IG9uIHlvdXIgam91cm5leSB0aG91Z2ggdWx0aW1hdGUgZHVyaW5nIGFuZCBiZXlvbmQgeW91ciBjb2xsZWdlIHllYXJzLjwvcD5cXG48cD5XaGlsZSB5b3UgYXJlIGF0IElsbGlub2lzIHlvdSB3aWxsIGVuam95IGEgbnVtYmVyIG9mIGV4cGVyaWVuY2VzLiBUaGlzIHJhbmdlcyBmcm9tIHRlYW0gc29jaWFscyB0byBzdHVkeSBncm91cHMgYW5kIGZyb20gcHJhY3RpY2VzIGluIElyd2luIEZpZWxkaG91c2UgdG8gcGxheWluZyBnYW1lcyBvbiB0aGUgc2hvcmVzIG9mIFNhbiBEaWVnby4gWW91ciB0ZWFtbWF0ZXMgd29uJ3Qgb25seSBiZSB5b3VyIGJlc3QgZnJpZW5kcywgdGhleSB3aWxsIGJlIGZhbWlseS4gWW91IHdpbGwgbGVhcm4gdGhlIHZhcmlvdXMgd2F5cyB1bHRpbWF0ZSBpcyBwbGF5ZWQsIGhvdyB0byBleHBhbmQgeW91ciB0aHJvd2luZyBhcnNlbmFsLCBob3cgdG8gaW1wcm92ZSB5b3VyIGF0aGxldGljaXNtLCBhbmQgaG93IHRvIHRha2UgeW91ciBnYW1lIHRvIHRoZSBuZXh0IGxldmVsLiBBIG1ham9yaXR5IG9mIG91ciB0ZWFtIGRpZG4ndCBwbGF5IG9yZ2FuaXplZCB1bHRpbWF0ZSBiZWZvcmUgY29taW5nIHRvIGNvbGxlZ2UsIGFuZCBhcmUgbm93IHNvbWUgb2YgdGhlIGJlc3QgcGxheWVycyBpbiB0aGUgR3JlYXQgTGFrZXMgcmVnaW9uIChzZWUgb3VyIEFsbC1SZWdpb25zIGhvbm9ycyBwYWdlKS48L3A+XFxuPHA+V2UgZW5jb3VyYWdlIHByb3NwZWN0aXZlIHBsYXllcnMgdG8gZmlsbCBvdXQgb3VyIGludGVyZXN0IGZvcm0gYW5kIHRvIHJlYWNoIG91dCB0byB0aGUgY2FwdGFpbnMgZXNwZWNpYWxseSBpZiB5b3Ugd2lsbCBiZSBvbiBjYW1wdXMuIFdlIGFyZSBtb3JlIHRoYW4gaGFwcHkgdG8gbWVldCB1cCBhbmQgZGlzY3VzcyB3aGF0IElsbGlub2lzIGNhbiBkbyBmb3IgeW91LCBhbmQgdG8gc2VlIHdoYXQgeW91IGNhbiBkbyB0byBiZSByZWFkeSBmb3IgSWxsaW5vaXMgb25jZSB5b3UgZ2V0IG9uIGNhbXB1cy4gT3VyIGNvbnRhY3QgaW5mb3JtYXRpb24gaXMgYmVsb3cuIFRoYW5rIHlvdSBmb3IgdGFraW5nIHRoZSB0aW1lIHRvIHZpc2l0IG91ciB3ZWJzaXRlLCBhbmQgd2UgaG9wZSB0byBoZWFyIGZyb20geW91IHNvb24uPC9wPlxcbjwhLS1Gb3JtLS0+XFxuPGZvcm0gY2xhc3M9XFxcInVpIGZvcm1cXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidHdvIGZpZWxkc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+Rmlyc3QgTmFtZSA8c3BhbiBjbGFzcz1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJmaXJzdE5hbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcImZpcnN0LW5hbWVcXFwiIHBsYWNlaG9sZGVyPVxcXCJGaXJzdCBOYW1lXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD5MYXN0IE5hbWUgPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwibGFzdE5hbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcImxhc3QtbmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIkxhc3QgTmFtZVxcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInR3byBmaWVsZHNcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxhYmVsPkVtYWlsIEFkZHJlc3MgPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwiZW1haWxBZGRyZXNzXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJlbWFpbC1hZGRyZXNzXFxcIiBwbGFjZWhvbGRlcj1cXFwiRW1haWwgQWRkcmVzc1xcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+V2hhdCBpcyB5b3VyIEhvbWV0b3duPyA8c3BhbiBjbGFzcz1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJob21ldG93blxcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwiaG9tZS10b3duXFxcIiBwbGFjZWhvbGRlcj1cXFwiSG9tZXRvd25cXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0d28gZmllbGRzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD5XaGF0IGhpZ2ggc2Nob29sIGRpZCB5b3UgYXR0ZW5kPyA8c3BhbiBjbGFzcz1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJoaWdoc2Nob29sXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJoaWdoc2Nob29sXFxcIiBwbGFjZWhvbGRlcj1cXFwiSGlnaCBTY2hvb2xcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxhYmVsPldoYXQgbWFqb3IgYXJlIHlvdSBwbGFubmluZyBvbiBnb2luZyBpbnRvPyA8c3BhbiBjbGFzcz1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJtYWpvclxcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwibWFqb3JcXFwiIHBsYWNlaG9sZGVyPVxcXCJNYWpvclxcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICA8bGFiZWw+SG93IGxvbmcgaGF2ZSB5b3UgcGxheWVkIHVsdGltYXRlL3doYXQga2luZCBvZiBleHBlcmllbmNlIGRvIHlvdSBoYXZlPyA8c3BhbiBjbGFzcz1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD5cXG4gICAgICAgICAgICA8dGV4dGFyZWEgWyhuZ01vZGVsKV09XFxcImV4cGVyaWVuY2VcXFwiIG5hbWU9XFxcImV4cGVyaWVuY2VcXFwiIHJvd3M9XFxcIjJcXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICA8bGFiZWw+V2hhdCBvdGhlciBjbHVicy9vcmdhbml6YXRpb25zIGFyZSB5b3UgcGxhbm5pbmcgb24gam9pbmluZyB3aGVuIHlvdSBhcnJpdmUgb24gY2FtcHVzPyA8c3BhbiBjbGFzcz1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD5cXG4gICAgICAgICAgICA8dGV4dGFyZWEgWyhuZ01vZGVsKV09XFxcIm90aGVyQ2x1YnNcXFwiIG5hbWU9XFxcIm90aGVyLWNsdWJzXFxcIiByb3dzPVxcXCIyXFxcIj48L3RleHRhcmVhPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpbmxpbmUgZmllbGRzXFxcIj5cXG4gICAgICAgICAgICA8bGFiZWw+V291bGQgeW91IGJlIGFscmlnaHQgd2l0aCBhIGNhcHRhaW4gb3IgY29hY2ggcmVhY2hpbmcgb3V0IHRvIHlvdT8gPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aSByYWRpbyBjaGVja2JveFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgaWQ9XFxcImNvbnRhY3QteWVzXFxcIiBbKG5nTW9kZWwpXT1cXFwiY29udGFjdFxcXCIgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcImNvbnRhY3RcXFwiIHZhbHVlPVxcXCJZZXNcXFwiIGNoZWNrZWQ9XFxcImNoZWNrZWRcXFwiIHRhYmluZGV4PVxcXCIwXFxcIiBjbGFzcz1cXFwiaGlkZGVuXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImNvbnRhY3QteWVzXFxcIj5ZZXM8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVpIHJhZGlvIGNoZWNrYm94XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwiY29udGFjdC1ub1xcXCIgWyhuZ01vZGVsKV09XFxcImNvbnRhY3RcXFwiIHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJjb250YWN0XFxcIiB2YWx1ZT1cXFwiTm9cXFwiIHRhYmluZGV4PVxcXCIwXFxcIiBjbGFzcz1cXFwiaGlkZGVuXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImNvbnRhY3Qtbm9cXFwiPk5vPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPGJ1dHRvbiAoY2xpY2spPVxcXCJoYW5kbGVTdWJtaXQoJGV2ZW50KVxcXCIgY2xhc3M9XFxcInVpIGJ1dHRvbiBzdWJtaXQtYnV0dG9uXFxcIiB0eXBlPVxcXCJzdWJtaXRcXFwiPlN1Ym1pdDwvYnV0dG9uPlxcbiAgICA8IS0tRXJyb3IvU3VjY2VzcyBNZXNzYWdlcy0tPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aSBlcnJvciBtZXNzYWdlXFxcIiAqbmdJZj1cXFwiZm9ybUVycm9yc1xcXCI+XFxuICAgICAgICA8cD57e2Zvcm1FcnJvcnN9fTwvcD5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpIHN1Y2Nlc3MgbWVzc2FnZVxcXCIgKm5nSWY9XFxcInN1Ym1pdFN1Y2Nlc3NcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5Gb3JtIFN1Ym1pdHRlZDwvZGl2PlxcbiAgICAgICAgPHA+VGhlIGZvcm0gd2FzIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQhIFRoYW5rcyBmb3IgdGFraW5nIHRoZSB0aW1lIHRvIGZpbGwgaXQgb3V0LjwvcD5cXG4gICAgPC9kaXY+XFxuICAgIDwhLS1TdWJtaXR0aW5nIExvYWRlci0tPlxcbiAgICA8ZGl2ICpuZ0lmPVxcXCJmb3JtSXNTdWJtaXR0aW5nXFxcIiBjbGFzcz1cXFwidWkgYWN0aXZlIGludmVydGVkIGRpbW1lclxcXCI+PGRpdiBjbGFzcz1cXFwidWkgdGV4dCBsb2FkZXJcXFwiPlN1Ym1pdHRpbmc8L2Rpdj48L2Rpdj5cXG48L2Zvcm0+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3Byb3NwZWN0aXZlLXBsYXllcnMvcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3Byb3NwZWN0aXZlLXBsYXllcnMvcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnN1Ym1pdC1idXR0b257bWFyZ2luLWJvdHRvbTo0NXB4fWxhYmVsLHB7dGV4dC1hbGlnbjpsZWZ0fS51aS5mb3Jte21hcmdpbjoyMHB4IGF1dG99LnVpLmZvcm0gLnVpLmVycm9yLm1lc3NhZ2UsLnVpLmZvcm0gLnVpLnN1Y2Nlc3MubWVzc2FnZXtkaXNwbGF5OmJsb2NrfS51aS5mb3JtIC51aS5lcnJvci5tZXNzYWdlIHAsLnVpLmZvcm0gLnVpLnN1Y2Nlc3MubWVzc2FnZSBwe3RleHQtYWxpZ246Y2VudGVyfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlci9saWIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnY29udGFjdCcsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vY29udGFjdC5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vY29udGFjdC5jb21wb25lbnQubGVzcycpXVxufSlcbmV4cG9ydCBjbGFzcyBDb250YWN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBuZ09uSW5pdCgpOiB2b2lkIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvY29udGFjdC9jb250YWN0LmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+Q29udGFjdCBVczwvaDE+XFxuPHA+Rm9yIGFueSBjb21tdW5pY2F0aW9uIGRpcmVjdGVkIGF0IHRoZSBlbnRpcmUgcHJvZ3JhbSwgcGFydGljdWxhcmx5IGluZm9ybWF0aW9uIHJlZ2FyZGluZyB0b3VybmFtZW50cywgcGxlYXNlIGNvbnRhY3QgdXMgYXQgdGhpcyBlbWFpbDo8L3A+XFxuXFxuPHAgY2xhc3M9XFxcInByb2dyYW1cXFwiPjxhIGhyZWYgPSBcXFwibWFpbHRvOiBpbGxpbml1bHRpQGdtYWlsLmNvbVxcXCI+aWxsaW5pdWx0aUBnbWFpbC5jb208L2E+PC9wPlxcblxcblxcbjxwPkZvciBhbnkgcXVlc3Rpb25zIHJlZ2FyZGluZyBwcmFjdGljZSBvciBjbHViIGRldGFpbHMsIGZlZWwgZnJlZSB0byBjb250YWN0IGFueSBvZiB0aGUgY3VycmVudCBjYXB0YWluczo8L3A+XFxuXFxuPHAgY2xhc3M9XFxcImNhcHRhaW5cXFwiPjxhIGhyZWYgPSBcXFwibWFpbHRvOiBqb2V5a2VubmVkeTMzM0BnbWFpbC5jb21cXFwiPkpvZXkgS2VubmVkeTwvYT48L3A+XFxuPHAgY2xhc3M9XFxcImNhcHRhaW5cXFwiPjxhIGhyZWYgPSBcXFwibWFpbHRvOiByZWlkYW1hcnRpbkBnbWFpbC5jb21cXFwiPlJlaWQgTWFydGluPC9hPjwvcD5cXG48cCBjbGFzcz1cXFwiY2FwdGFpblxcXCI+PGEgaHJlZiA9IFxcXCJtYWlsdG86IGFydXp6bzJAaWxsaW5vaXMuZWR1XFxcIj5BbnRob255IFJ1enpvPC9hPjwvcD5cXG5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvY29udGFjdC9jb250YWN0LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vY29udGFjdC5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvY29udGFjdC9jb250YWN0LmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuY2FwdGFpbnttYXJnaW4tYm90dG9tOjB9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyL2xpYiEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0ICcuL3NoYXJlZC1zdHlsZS9zdHlsZXMuY3NzJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhcHAnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2FwcC5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vYXBwLmNvbXBvbmVudC5sZXNzJyldXG59KVxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2FwcC5jb21wb25lbnQudHMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL3N0eWxlcy5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL3N0eWxlcy5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi9zdHlsZXMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvc2hhcmVkLXN0eWxlL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImJvZHl7YmFja2dyb3VuZC1pbWFnZTp1cmwoXCIgKyByZXF1aXJlKFwiLi4vLi4vcHVibGljL2Fzc2V0cy9pbWFnZXMvZ2xvYmFsL2JhY2tncm91bmQuanBnXCIpICsgXCIpO2ZvbnQtZmFtaWx5OlF1YXR0cm9jZW50byxzZXJpZjt0ZXh0LWFsaWduOmNlbnRlcjtvdmVyZmxvdy15OnNjcm9sbH1we3RleHQtaW5kZW50OjI1cHg7cGFkZGluZzo1cHh9YXtjb2xvcjojZmY2MjI2fWE6aG92ZXJ7Y29sb3I6IzAwMDA0ZH1pbnB1dHtmb250LWZhbWlseTpRdWF0dHJvY2VudG8sc2VyaWYhaW1wb3J0YW50fWlucHV0OmZvY3Vze2JvcmRlci1jb2xvcjojZmY2MjI2IWltcG9ydGFudH0udWkuaGVhZGVye2ZvbnQtZmFtaWx5Ok9zd2FsZCxzYW5zLXNlcmlmO2NvbG9yOiMwMDAwNGQ7bGV0dGVyLXNwYWNpbmc6MXB4fS51aS50YWJsZSB0ZCwudWkudGFibGUgdHJ7dGV4dC1hbGlnbjpjZW50ZXI7Ym9yZGVyLXRvcDowfS51aS5zZWNvbmRhcnkucG9pbnRpbmcubWVudXstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS51aS5zZWNvbmRhcnkucG9pbnRpbmcubWVudSAuaXRlbS5hY3RpdmV7Ym9yZGVyLWNvbG9yOiMwMDAwNGR9LmJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOiNmZjYyMjYhaW1wb3J0YW50O2NvbG9yOiNmZmYhaW1wb3J0YW50fS5yZXF1aXJlZHtjb2xvcjojZmY2MjI2fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlci9saWIhLi9zcmMvYXBwL3NoYXJlZC1zdHlsZS9zdHlsZXMuY3NzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvYmFja2dyb3VuZC5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9nbG9iYWwvYmFja2dyb3VuZC5qcGdcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8bWFpbiBjbGFzcz1cXFwibWFpbi1jb250YWluZXJcXFwiPlxcbiAgICA8cGFnZS1mcmFtZT48L3BhZ2UtZnJhbWU+XFxuPC9tYWluPlxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9hcHAuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9hcHAuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2FwcC5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLm1haW4tY29udGFpbmVye2hlaWdodDoxMDAlfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlci9saWIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9hcHAuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBZ21Db3JlTW9kdWxlIH0gZnJvbSAnYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZSc7XG5pbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgUHJhY3RpY2VDb21wb25lbnQgfSBmcm9tICcuL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUb3VybmFtZW50c0NvbXBvbmVudCB9IGZyb20gJy4vdG91cm5hbWVudHMvdG91cm5hbWVudHMuY29tcG9uZW50JztcbmltcG9ydCB7IFJvc3RlckNvbXBvbmVudCB9IGZyb20gJy4vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgQWJzZW50Q29tcG9uZW50IH0gZnJvbSAnLi9hYnNlbnQvYWJzZW50LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBSb3V0ZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgUk9VVEVTIH0gZnJvbSAnLi4vYXBwLnJvdXRlcyc7XG5pbXBvcnQgeyBTcHJlYWRzaGVldFNlcnZpY2UgfSBmcm9tICcuLi9nbG9iYWwvc2VydmljZS9nb29nbGUtc3ByZWFkc2hlZXQuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBCcm93c2VyTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgQWdtQ29yZU1vZHVsZS5mb3JSb290KHtcbiAgICAgICAgICAgIGFwaUtleTogJ0FJemFTeUJSSVhBazV4ZHZuM2V6eXBzU2U1NWY4ZFpoY0hoZUFaOCdcbiAgICAgICAgfSksXG4gICAgICAgIFJvdXRlck1vZHVsZS5mb3JSb290KFJPVVRFUylcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1ByYWN0aWNlQ29tcG9uZW50LCBUb3VybmFtZW50c0NvbXBvbmVudCwgUm9zdGVyQ29tcG9uZW50LCBBYnNlbnRDb21wb25lbnRdLFxuICAgIHByb3ZpZGVyczogW1NwcmVhZHNoZWV0U2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgVGVhbU1vZHVsZSB7fVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3RlYW0vdGVhbS5tb2R1bGUudHMiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG4vLyBtYWluIG1vZHVsZXNcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZGlyZWN0aXZlcycpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc2VydmljZXMnKSk7XG4vLyBHb29nbGUgTWFwcyB0eXBlc1xuLy8gY29yZSBtb2R1bGVcbi8vIHdlIGV4cGxpY2l0bHkgZXhwb3J0IHRoZSBtb2R1bGUgaGVyZSB0byBwcmV2ZW50IHRoaXMgSW9uaWMgMiBidWc6XG4vLyBodHRwOi8vc3RldmVtaWNoZWxvdHRpLmNvbS9pbnRlZ3JhdGUtYW5ndWxhci0yLWdvb2dsZS1tYXBzLWludG8taW9uaWMtMi9cbnZhciBjb3JlX21vZHVsZV8xID0gcmVxdWlyZSgnLi9jb3JlLW1vZHVsZScpO1xuZXhwb3J0cy5BZ21Db3JlTW9kdWxlID0gY29yZV9tb2R1bGVfMS5BZ21Db3JlTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGdvb2dsZV9tYXBfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXAgPSBnb29nbGVfbWFwXzEuU2VibUdvb2dsZU1hcDtcbnZhciBnb29nbGVfbWFwX2NpcmNsZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtY2lyY2xlJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBDaXJjbGUgPSBnb29nbGVfbWFwX2NpcmNsZV8xLlNlYm1Hb29nbGVNYXBDaXJjbGU7XG52YXIgZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtaW5mby13aW5kb3cnKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgPSBnb29nbGVfbWFwX2luZm9fd2luZG93XzEuU2VibUdvb2dsZU1hcEluZm9XaW5kb3c7XG52YXIgZ29vZ2xlX21hcF9rbWxfbGF5ZXJfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwLWttbC1sYXllcicpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwS21sTGF5ZXIgPSBnb29nbGVfbWFwX2ttbF9sYXllcl8xLlNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbnZhciBnb29nbGVfbWFwX21hcmtlcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtbWFya2VyJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBNYXJrZXIgPSBnb29nbGVfbWFwX21hcmtlcl8xLlNlYm1Hb29nbGVNYXBNYXJrZXI7XG52YXIgZ29vZ2xlX21hcF9wb2x5Z29uXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5Z29uJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBQb2x5Z29uID0gZ29vZ2xlX21hcF9wb2x5Z29uXzEuU2VibUdvb2dsZU1hcFBvbHlnb247XG52YXIgZ29vZ2xlX21hcF9wb2x5bGluZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUnKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlsaW5lID0gZ29vZ2xlX21hcF9wb2x5bGluZV8xLlNlYm1Hb29nbGVNYXBQb2x5bGluZTtcbnZhciBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCcpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludCA9IGdvb2dsZV9tYXBfcG9seWxpbmVfcG9pbnRfMS5TZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9nb29nbGUtbWFwcy1hcGktd3JhcHBlcicpO1xudmFyIGNpcmNsZV9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9jaXJjbGUtbWFuYWdlcicpO1xudmFyIGluZm9fd2luZG93X21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL2luZm8td2luZG93LW1hbmFnZXInKTtcbnZhciBtYXJrZXJfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvbWFya2VyLW1hbmFnZXInKTtcbnZhciBwb2x5Z29uX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlnb24tbWFuYWdlcicpO1xudmFyIHBvbHlsaW5lX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlsaW5lLW1hbmFnZXInKTtcbnZhciBrbWxfbGF5ZXJfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi8uLi9zZXJ2aWNlcy9tYW5hZ2Vycy9rbWwtbGF5ZXItbWFuYWdlcicpO1xuLyoqXG4gKiBTZWJNR29vZ2xlTWFwIHJlbmRlcnMgYSBHb29nbGUgTWFwLlxuICogKipJbXBvcnRhbnQgbm90ZSoqOiBUbyBiZSBhYmxlIHNlZSBhIG1hcCBpbiB0aGUgYnJvd3NlciwgeW91IGhhdmUgdG8gZGVmaW5lIGEgaGVpZ2h0IGZvciB0aGUgQ1NTXG4gKiBjbGFzcyBgc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lcmAuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgU2VibUdvb2dsZU1hcCB9IGZyb20gJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgZGlyZWN0aXZlczogW1NlYm1Hb29nbGVNYXBdLFxuICogIHN0eWxlczogW2BcbiAqICAgIC5zZWJtLWdvb2dsZS1tYXAtY29udGFpbmVyIHtcbiAqICAgICAgaGVpZ2h0OiAzMDBweDtcbiAqICAgIH1cbiAqIGBdLFxuICogIHRlbXBsYXRlOiBgXG4gKiAgICA8c2VibS1nb29nbGUtbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cbiAqICAgIDwvc2VibS1nb29nbGUtbWFwPlxuICogIGBcbiAqIH0pXG4gKiBgYGBcbiAqL1xudmFyIFNlYm1Hb29nbGVNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXAoX2VsZW0sIF9tYXBzV3JhcHBlcikge1xuICAgICAgICB0aGlzLl9lbGVtID0gX2VsZW07XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvbmdpdHVkZSB0aGF0IGRlZmluZXMgdGhlIGNlbnRlciBvZiB0aGUgbWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb25naXR1ZGUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhdGl0dWRlIHRoYXQgZGVmaW5lcyB0aGUgY2VudGVyIG9mIHRoZSBtYXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhdGl0dWRlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIFRoZSBkZWZhdWx0IHpvb20gbGV2ZWwgaXMgOC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuem9vbSA9IDg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzL2Rpc2FibGVzIGlmIG1hcCBpcyBkcmFnZ2FibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHpvb20gYW5kIGNlbnRlciBvbiBkb3VibGUgY2xpY2suIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZURvdWJsZUNsaWNrWm9vbSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcy9kaXNhYmxlcyBhbGwgZGVmYXVsdCBVSSBvZiB0aGUgR29vZ2xlIG1hcC4gUGxlYXNlIG5vdGU6IFdoZW4gdGhlIG1hcCBpcyBjcmVhdGVkLCB0aGlzXG4gICAgICAgICAqIHZhbHVlIGNhbm5vdCBnZXQgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZURlZmF1bHRVSSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZmFsc2UsIGRpc2FibGVzIHNjcm9sbHdoZWVsIHpvb21pbmcgb24gdGhlIG1hcC4gVGhlIHNjcm9sbHdoZWVsIGlzIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsd2hlZWwgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZmFsc2UsIHByZXZlbnRzIHRoZSBtYXAgZnJvbSBiZWluZyBjb250cm9sbGVkIGJ5IHRoZSBrZXlib2FyZC4gS2V5Ym9hcmQgc2hvcnRjdXRzIGFyZVxuICAgICAgICAgKiBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlbmFibGVkL2Rpc2FibGVkIHN0YXRlIG9mIHRoZSBab29tIGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb21Db250cm9sID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0eWxlcyB0byBhcHBseSB0byBlYWNoIG9mIHRoZSBkZWZhdWx0IG1hcCB0eXBlcy4gTm90ZSB0aGF0IGZvciBTYXRlbGxpdGUvSHlicmlkIGFuZCBUZXJyYWluXG4gICAgICAgICAqIG1vZGVzLCB0aGVzZSBzdHlsZXMgd2lsbCBvbmx5IGFwcGx5IHRvIGxhYmVscyBhbmQgZ2VvbWV0cnkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0cnVlIGFuZCB0aGUgbGF0aXR1ZGUgYW5kL29yIGxvbmdpdHVkZSB2YWx1ZXMgY2hhbmdlcywgdGhlIEdvb2dsZSBNYXBzIHBhblRvIG1ldGhvZCBpc1xuICAgICAgICAgKiB1c2VkIHRvXG4gICAgICAgICAqIGNlbnRlciB0aGUgbWFwLiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNNYXBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlUGFubmluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZSBvZiB0aGUgU3RyZWV0IFZpZXcgUGVnbWFuIGNvbnRyb2wuXG4gICAgICAgICAqIFRoaXMgY29udHJvbCBpcyBwYXJ0IG9mIHRoZSBkZWZhdWx0IFVJLCBhbmQgc2hvdWxkIGJlIHNldCB0byBmYWxzZSB3aGVuIGRpc3BsYXlpbmcgYSBtYXAgdHlwZVxuICAgICAgICAgKiBvbiB3aGljaCB0aGUgU3RyZWV0IFZpZXcgcm9hZCBvdmVybGF5IHNob3VsZCBub3QgYXBwZWFyIChlLmcuIGEgbm9uLUVhcnRoIG1hcCB0eXBlKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RyZWV0Vmlld0NvbnRyb2wgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdmlld3BvcnQgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXRCb3VuZHMgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZSBvZiB0aGUgU2NhbGUgY29udHJvbC4gVGhpcyBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2FsZUNvbnRyb2wgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbml0aWFsIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2YgdGhlIE1hcCB0eXBlIGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcFR5cGVDb250cm9sID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrIG9uIGFcbiAgICAgICAgICogbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgcmlnaHQtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXG4gICAgICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBSaWdodENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXG4gICAgICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBEYmxDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIGNlbnRlciBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZW50ZXJDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB2aWV3cG9ydCBib3VuZHMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBtYXAgYmVjb21lcyBpZGxlIGFmdGVyIHBhbm5pbmcgb3Igem9vbWluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWRsZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHpvb20gbGV2ZWwgaGFzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb21DaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRvZG86IHRoaXMgc2hvdWxkIGJlIHNvbHZlZCB3aXRoIGEgbmV3IGNvbXBvbmVudCBhbmQgYSB2aWV3Q2hpbGQgZGVjb3JhdG9yXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9lbGVtLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXItaW5uZXInKTtcbiAgICAgICAgdGhpcy5faW5pdE1hcEluc3RhbmNlKGNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5faW5pdE1hcEluc3RhbmNlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyLmNyZWF0ZU1hcChlbCwge1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogdGhpcy5sYXRpdHVkZSB8fCAwLCBsbmc6IHRoaXMubG9uZ2l0dWRlIHx8IDAgfSxcbiAgICAgICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgICAgIG1pblpvb206IHRoaXMubWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4Wm9vbSxcbiAgICAgICAgICAgIGRpc2FibGVEZWZhdWx0VUk6IHRoaXMuZGlzYWJsZURlZmF1bHRVSSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRoaXMuZHJhZ2dhYmxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlQ3Vyc29yOiB0aGlzLmRyYWdnYWJsZUN1cnNvcixcbiAgICAgICAgICAgIGRyYWdnaW5nQ3Vyc29yOiB0aGlzLmRyYWdnaW5nQ3Vyc29yLFxuICAgICAgICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IHRoaXMua2V5Ym9hcmRTaG9ydGN1dHMsXG4gICAgICAgICAgICB6b29tQ29udHJvbDogdGhpcy56b29tQ29udHJvbCxcbiAgICAgICAgICAgIHN0eWxlczogdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICBzdHJlZXRWaWV3Q29udHJvbDogdGhpcy5zdHJlZXRWaWV3Q29udHJvbCxcbiAgICAgICAgICAgIHNjYWxlQ29udHJvbDogdGhpcy5zY2FsZUNvbnRyb2wsXG4gICAgICAgICAgICBtYXBUeXBlQ29udHJvbDogdGhpcy5tYXBUeXBlQ29udHJvbFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX2hhbmRsZU1hcENlbnRlckNoYW5nZSgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVNYXBab29tQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZU1hcE1vdXNlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUJvdW5kc0NoYW5nZSgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVJZGxlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgfTtcbiAgICAvKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hcE9wdGlvbnNDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbihjaGFuZ2VzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl91cGRhdGVNYXBPcHRpb25zQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBTZWJtR29vZ2xlTWFwLl9tYXBPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMTsgfSk7XG4gICAgICAgIG9wdGlvbktleXMuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBvcHRpb25zW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7IH0pO1xuICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5zZXRNYXBPcHRpb25zKG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYSByZXNpemUgZXZlbnQgb24gdGhlIGdvb2dsZSBtYXAgaW5zdGFuY2UuXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBnZXRzIHJlc29sdmVkIGFmdGVyIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLnRyaWdnZXJSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE5vdGU6IFdoZW4gd2Ugd291bGQgdHJpZ2dlciB0aGUgcmVzaXplIGV2ZW50IGFuZCBzaG93IHRoZSBtYXAgaW4gdGhlIHNhbWUgdHVybiAod2hpY2ggaXMgYVxuICAgICAgICAvLyBjb21tb24gY2FzZSBmb3IgdHJpZ2dlcmluZyBhIHJlc2l6ZSBldmVudCksIHRoZW4gdGhlIHJlc2l6ZSBldmVudCB3b3VsZCBub3RcbiAgICAgICAgLy8gd29yayAodG8gc2hvdyB0aGUgbWFwKSwgc28gd2UgdHJpZ2dlciB0aGUgZXZlbnQgaW4gYSB0aW1lb3V0LlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLnRyaWdnZXJNYXBFdmVudCgncmVzaXplJykudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snbGF0aXR1ZGUnXSA9PSBudWxsICYmIGNoYW5nZXNbJ2xvbmdpdHVkZSddID09IG51bGwgJiZcbiAgICAgICAgICAgIGNoYW5nZXNbJ2ZpdEJvdW5kcyddID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIHBvc2l0aW9uIHVwZGF0ZSBuZWVkZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBwcmVmZXIgZml0Qm91bmRzIGluIGNoYW5nZXNcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2ZpdEJvdW5kcyddICYmIHRoaXMuZml0Qm91bmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpdEJvdW5kcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sYXRpdHVkZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMubG9uZ2l0dWRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdDZW50ZXIgPSB7XG4gICAgICAgICAgICBsYXQ6IHRoaXMubGF0aXR1ZGUsXG4gICAgICAgICAgICBsbmc6IHRoaXMubG9uZ2l0dWRlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy51c2VQYW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5wYW5UbyhuZXdDZW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIuc2V0Q2VudGVyKG5ld0NlbnRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9maXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZVBhbm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcHNXcmFwcGVyLnBhblRvQm91bmRzKHRoaXMuZml0Qm91bmRzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5maXRCb3VuZHModGhpcy5maXRCb3VuZHMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUuX2hhbmRsZU1hcENlbnRlckNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9tYXBzV3JhcHBlci5zdWJzY3JpYmVUb01hcEV2ZW50KCdjZW50ZXJfY2hhbmdlZCcpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWFwc1dyYXBwZXIuZ2V0Q2VudGVyKCkudGhlbihmdW5jdGlvbiAoY2VudGVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGF0aXR1ZGUgPSBjZW50ZXIubGF0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9uZ2l0dWRlID0gY2VudGVyLmxuZygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNlbnRlckNoYW5nZS5lbWl0KHsgbGF0OiBfdGhpcy5sYXRpdHVkZSwgbG5nOiBfdGhpcy5sb25naXR1ZGUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLnB1c2gocyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5faGFuZGxlQm91bmRzQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcyA9IHRoaXMuX21hcHNXcmFwcGVyLnN1YnNjcmliZVRvTWFwRXZlbnQoJ2JvdW5kc19jaGFuZ2VkJykuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9tYXBzV3JhcHBlci5nZXRCb3VuZHMoKS50aGVuKGZ1bmN0aW9uIChib3VuZHMpIHsgX3RoaXMuYm91bmRzQ2hhbmdlLmVtaXQoYm91bmRzKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKHMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUuX2hhbmRsZU1hcFpvb21DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzID0gdGhpcy5fbWFwc1dyYXBwZXIuc3Vic2NyaWJlVG9NYXBFdmVudCgnem9vbV9jaGFuZ2VkJykuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9tYXBzV3JhcHBlci5nZXRab29tKCkudGhlbihmdW5jdGlvbiAoeikge1xuICAgICAgICAgICAgICAgIF90aGlzLnpvb20gPSB6O1xuICAgICAgICAgICAgICAgIF90aGlzLnpvb21DaGFuZ2UuZW1pdCh6KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9oYW5kbGVJZGxlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzID0gdGhpcy5fbWFwc1dyYXBwZXIuc3Vic2NyaWJlVG9NYXBFdmVudCgnaWRsZScpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IF90aGlzLmlkbGUuZW1pdCh2b2lkIDApOyB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9oYW5kbGVNYXBNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgZW1pdHRlcjogdGhpcy5tYXBDbGljayB9LFxuICAgICAgICAgICAgeyBuYW1lOiAncmlnaHRjbGljaycsIGVtaXR0ZXI6IHRoaXMubWFwUmlnaHRDbGljayB9LFxuICAgICAgICBdO1xuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBfdGhpcy5fbWFwc1dyYXBwZXIuc3Vic2NyaWJlVG9NYXBFdmVudChlLm5hbWUpLnN1YnNjcmliZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB7IGNvb3JkczogeyBsYXQ6IGV2ZW50LmxhdExuZy5sYXQoKSwgbG5nOiBldmVudC5sYXRMbmcubG5nKCkgfSB9O1xuICAgICAgICAgICAgICAgIGUuZW1pdHRlci5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLnB1c2gocyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFwIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgY2FuIGNoYW5nZSBvdmVyIHRpbWVcbiAgICAgKi9cbiAgICBTZWJtR29vZ2xlTWFwLl9tYXBPcHRpb25zQXR0cmlidXRlcyA9IFtcbiAgICAgICAgJ2Rpc2FibGVEb3VibGVDbGlja1pvb20nLCAnc2Nyb2xsd2hlZWwnLCAnZHJhZ2dhYmxlJywgJ2RyYWdnYWJsZUN1cnNvcicsICdkcmFnZ2luZ0N1cnNvcicsXG4gICAgICAgICdrZXlib2FyZFNob3J0Y3V0cycsICd6b29tQ29udHJvbCcsICdzdHlsZXMnLCAnc3RyZWV0Vmlld0NvbnRyb2wnLCAnem9vbScsICdtYXBUeXBlQ29udHJvbCcsXG4gICAgICAgICdtaW5ab29tJywgJ21heFpvb20nXG4gICAgXTtcbiAgICBTZWJtR29vZ2xlTWFwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkNvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIG1hcmtlcl9tYW5hZ2VyXzEuTWFya2VyTWFuYWdlciwgaW5mb193aW5kb3dfbWFuYWdlcl8xLkluZm9XaW5kb3dNYW5hZ2VyLCBjaXJjbGVfbWFuYWdlcl8xLkNpcmNsZU1hbmFnZXIsIHBvbHlsaW5lX21hbmFnZXJfMS5Qb2x5bGluZU1hbmFnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uX21hbmFnZXJfMS5Qb2x5Z29uTWFuYWdlciwga21sX2xheWVyX21hbmFnZXJfMS5LbWxMYXllck1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJywgJ3pvb20nLCAnbWluWm9vbScsICdtYXhab29tJywgJ2RyYWdnYWJsZTogbWFwRHJhZ2dhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlRG91YmxlQ2xpY2tab29tJywgJ2Rpc2FibGVEZWZhdWx0VUknLCAnc2Nyb2xsd2hlZWwnLCAnYmFja2dyb3VuZENvbG9yJywgJ2RyYWdnYWJsZUN1cnNvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZHJhZ2dpbmdDdXJzb3InLCAna2V5Ym9hcmRTaG9ydGN1dHMnLCAnem9vbUNvbnRyb2wnLCAnc3R5bGVzJywgJ3VzZVBhbm5pbmcnLCAnc3RyZWV0Vmlld0NvbnRyb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpdEJvdW5kcycsICdzY2FsZUNvbnRyb2wnLCAnbWFwVHlwZUNvbnRyb2wnXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXBDbGljaycsICdtYXBSaWdodENsaWNrJywgJ21hcERibENsaWNrJywgJ2NlbnRlckNoYW5nZScsICdpZGxlJywgJ2JvdW5kc0NoYW5nZScsICd6b29tQ2hhbmdlJ1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbY2xhc3Muc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lcl0nOiAndHJ1ZScgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbXCJcXG4gICAgLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXItaW5uZXIge1xcbiAgICAgIHdpZHRoOiBpbmhlcml0O1xcbiAgICAgIGhlaWdodDogaW5oZXJpdDtcXG4gICAgfVxcbiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRlbnQge1xcbiAgICAgIGRpc3BsYXk6bm9uZTtcXG4gICAgfVxcbiAgXCJdLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdiBjbGFzcz0nc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lci1pbm5lcic+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9J3NlYm0tZ29vZ2xlLW1hcC1jb250ZW50Jz5cXG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgIDwvZGl2PlxcbiAgXCJcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBTZWJtR29vZ2xlTWFwO1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcCA9IFNlYm1Hb29nbGVNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb29nbGUtbWFwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIG1hcHNfYXBpX2xvYWRlcl8xID0gcmVxdWlyZSgnLi9tYXBzLWFwaS1sb2FkZXIvbWFwcy1hcGktbG9hZGVyJyk7XG4vKipcbiAqIFdyYXBwZXIgY2xhc3MgdGhhdCBoYW5kbGVzIHRoZSBjb21tdW5pY2F0aW9uIHdpdGggdGhlIEdvb2dsZSBNYXBzIEphdmFzY3JpcHRcbiAqIEFQSSB2M1xuICovXG52YXIgR29vZ2xlTWFwc0FQSVdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdvb2dsZU1hcHNBUElXcmFwcGVyKF9sb2FkZXIsIF96b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xvYWRlciA9IF9sb2FkZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFwID1cbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IF90aGlzLl9tYXBSZXNvbHZlciA9IHJlc29sdmU7IH0pO1xuICAgIH1cbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY3JlYXRlTWFwID0gZnVuY3Rpb24gKGVsLCBtYXBPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZXIubG9hZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoZWwsIG1hcE9wdGlvbnMpO1xuICAgICAgICAgICAgX3RoaXMuX21hcFJlc29sdmVyKG1hcCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnNldE1hcE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobSkgeyBtLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGdvb2dsZSBtYXAgbWFya2VyIHdpdGggdGhlIG1hcCBjb250ZXh0XG4gICAgICovXG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmNyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBvcHRpb25zLm1hcCA9IG1hcDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVJbmZvV2luZG93ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KG9wdGlvbnMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBnb29nbGUubWFwLkNpcmNsZSBmb3IgdGhlIGN1cnJlbnQgbWFwLlxuICAgICAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVDaXJjbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgb3B0aW9ucy5tYXAgPSBtYXA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZShvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY3JlYXRlUG9seWxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVNYXAoKS50aGVuKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKG9wdGlvbnMpO1xuICAgICAgICAgICAgbGluZS5zZXRNYXAobWFwKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVQb2x5Z29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlTWFwKCkudGhlbihmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBnb29nbGUubWFwcy5Qb2x5Z29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgcG9seWdvbi5zZXRNYXAobWFwKTtcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgZ2l2ZW4gY29vcmRpbmF0ZXMgYXJlIGluc2l0ZSBhIFBvbHlnb24gcGF0aC5cbiAgICAgKi9cbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY29udGFpbnNMb2NhdGlvbiA9IGZ1bmN0aW9uIChsYXRMbmcsIHBvbHlnb24pIHtcbiAgICAgICAgcmV0dXJuIGdvb2dsZS5tYXBzLmdlb21ldHJ5LnBvbHkuY29udGFpbnNMb2NhdGlvbihsYXRMbmcsIHBvbHlnb24pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnN1YnNjcmliZVRvTWFwRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGFyZykgeyBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChhcmcpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGxhdExuZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLnNldENlbnRlcihsYXRMbmcpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5nZXRab29tID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLmdldFpvb20oKTsgfSk7IH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIG1hcC5nZXRCb3VuZHMoKTsgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uICh6b29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7IHJldHVybiBtYXAuc2V0Wm9vbSh6b29tKTsgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLmdldENlbnRlcigpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5wYW5UbyA9IGZ1bmN0aW9uIChsYXRMbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIG1hcC5wYW5UbyhsYXRMbmcpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5maXRCb3VuZHMgPSBmdW5jdGlvbiAobGF0TG5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7IHJldHVybiBtYXAuZml0Qm91bmRzKGxhdExuZyk7IH0pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnBhblRvQm91bmRzID0gZnVuY3Rpb24gKGxhdExuZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLnBhblRvQm91bmRzKGxhdExuZyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmF0aXZlIEdvb2dsZSBNYXBzIE1hcCBpbnN0YW5jZS4gQmUgY2FyZWZ1bCB3aGVuIHVzaW5nIHRoaXMgaW5zdGFuY2UgZGlyZWN0bHkuXG4gICAgICovXG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmdldE5hdGl2ZU1hcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcDsgfTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgZ2l2ZW4gZXZlbnQgbmFtZSBvbiB0aGUgbWFwIGluc3RhbmNlLlxuICAgICAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS50cmlnZ2VyTWFwRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtLCBldmVudE5hbWUpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IG1hcHNfYXBpX2xvYWRlcl8xLk1hcHNBUElMb2FkZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBHb29nbGVNYXBzQVBJV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLkdvb2dsZU1hcHNBUElXcmFwcGVyID0gR29vZ2xlTWFwc0FQSVdyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb29nbGUtbWFwcy1hcGktd3JhcHBlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9nb29nbGUtbWFwcy1hcGktd3JhcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE1hcHNBUElMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcHNBUElMb2FkZXIoKSB7XG4gICAgfVxuICAgIE1hcHNBUElMb2FkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTWFwc0FQSUxvYWRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYXBzQVBJTG9hZGVyO1xufSgpKTtcbmV4cG9ydHMuTWFwc0FQSUxvYWRlciA9IE1hcHNBUElMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBzLWFwaS1sb2FkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL21hcHMtYXBpLWxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEgPSByZXF1aXJlKCcuLi9nb29nbGUtbWFwcy1hcGktd3JhcHBlcicpO1xudmFyIENpcmNsZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENpcmNsZU1hbmFnZXIoX2FwaVdyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX2FwaVdyYXBwZXIgPSBfYXBpV3JhcHBlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9jaXJjbGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5hZGRDaXJjbGUgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHRoaXMuX2NpcmNsZXMuc2V0KGNpcmNsZSwgdGhpcy5fYXBpV3JhcHBlci5jcmVhdGVDaXJjbGUoe1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogY2lyY2xlLmxhdGl0dWRlLCBsbmc6IGNpcmNsZS5sb25naXR1ZGUgfSxcbiAgICAgICAgICAgIGNsaWNrYWJsZTogY2lyY2xlLmNsaWNrYWJsZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogY2lyY2xlLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBjaXJjbGUuZWRpdGFibGUsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IGNpcmNsZS5maWxsQ29sb3IsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogY2lyY2xlLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgcmFkaXVzOiBjaXJjbGUucmFkaXVzLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IGNpcmNsZS5zdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IGNpcmNsZS5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlUG9zaXRpb246IGNpcmNsZS5zdHJva2VQb3NpdGlvbixcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogY2lyY2xlLnN0cm9rZVdlaWdodCxcbiAgICAgICAgICAgIHZpc2libGU6IGNpcmNsZS52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBjaXJjbGUuekluZGV4XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjaXJjbGUgZnJvbSB0aGUgbWFwLlxuICAgICAqL1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUNpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgYy5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICBfdGhpcy5fY2lyY2xlcy5kZWxldGUoY2lyY2xlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKGNpcmNsZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5nZXRCb3VuZHMoKTsgfSk7XG4gICAgfTtcbiAgICA7XG4gICAgQ2lyY2xlTWFuYWdlci5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmdldENlbnRlcigpOyB9KTtcbiAgICB9O1xuICAgIDtcbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRSYWRpdXMgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuZ2V0UmFkaXVzKCk7IH0pO1xuICAgIH07XG4gICAgQ2lyY2xlTWFuYWdlci5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldENlbnRlcih7IGxhdDogY2lyY2xlLmxhdGl0dWRlLCBsbmc6IGNpcmNsZS5sb25naXR1ZGUgfSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldEVkaXRhYmxlID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldEVkaXRhYmxlKGNpcmNsZS5lZGl0YWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zZXREcmFnZ2FibGUoY2lyY2xlLmRyYWdnYWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuc2V0VmlzaWJsZShjaXJjbGUudmlzaWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldFJhZGl1cyA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zZXRSYWRpdXMoY2lyY2xlLnJhZGl1cyk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNpcmNsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoZSk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaXJjbGVNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIENpcmNsZU1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIENpcmNsZU1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5DaXJjbGVNYW5hZ2VyID0gQ2lyY2xlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNpcmNsZS1tYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL2NpcmNsZS1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJyk7XG52YXIgbWFya2VyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vbWFya2VyLW1hbmFnZXInKTtcbnZhciBJbmZvV2luZG93TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5mb1dpbmRvd01hbmFnZXIoX21hcHNXcmFwcGVyLCBfem9uZSwgX21hcmtlck1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlciA9IF9tYXJrZXJNYW5hZ2VyO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93cyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUluZm9XaW5kb3cgPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaVdpbmRvdyA9IHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KTtcbiAgICAgICAgaWYgKGlXaW5kb3cgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaW5mbyB3aW5kb3cgYWxyZWFkeSBkZWxldGVkXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlXaW5kb3cudGhlbihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9pbmZvV2luZG93cy5kZWxldGUoaW5mb1dpbmRvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5mb1dpbmRvd3MuZ2V0KGluZm9XaW5kb3cpLnRoZW4oZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2V0UG9zaXRpb24oe1xuICAgICAgICAgICAgbGF0OiBpbmZvV2luZG93LmxhdGl0dWRlLFxuICAgICAgICAgICAgbG5nOiBpbmZvV2luZG93LmxvbmdpdHVkZVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gKGluZm9XaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2V0WkluZGV4KGluZm9XaW5kb3cuekluZGV4KTsgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChpbmZvV2luZG93KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKGluZm9XaW5kb3cuaG9zdE1hcmtlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9tYXJrZXJNYW5hZ2VyLmdldE5hdGl2ZU1hcmtlcihpbmZvV2luZG93Lmhvc3RNYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gdy5vcGVuKG1hcCwgbWFya2VyKTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gdy5vcGVuKG1hcCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChpbmZvV2luZG93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAodykgeyByZXR1cm4gdy5jbG9zZSgpOyB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKGluZm9XaW5kb3csIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KS50aGVuKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmFkZEluZm9XaW5kb3cgPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGluZm9XaW5kb3cuY29udGVudCxcbiAgICAgICAgICAgIG1heFdpZHRoOiBpbmZvV2luZG93Lm1heFdpZHRoLFxuICAgICAgICAgICAgekluZGV4OiBpbmZvV2luZG93LnpJbmRleCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvV2luZG93LmxhdGl0dWRlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgaW5mb1dpbmRvdy5sb25naXR1ZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0geyBsYXQ6IGluZm9XaW5kb3cubGF0aXR1ZGUsIGxuZzogaW5mb1dpbmRvdy5sb25naXR1ZGUgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mb1dpbmRvd1Byb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVJbmZvV2luZG93KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93cy5zZXQoaW5mb1dpbmRvdywgaW5mb1dpbmRvd1Byb21pc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEdvb2dsZSBNYXBzIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gSW5mb1dpbmRvdyBhcyBhbiBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGluZm9XaW5kb3cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIGkuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoZSk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBtYXJrZXJfbWFuYWdlcl8xLk1hcmtlck1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW5mb1dpbmRvd01hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5JbmZvV2luZG93TWFuYWdlciA9IEluZm9XaW5kb3dNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mby13aW5kb3ctbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4vLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbnZhciBNYXJrZXJNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXJrZXJNYW5hZ2VyKF9tYXBzV3JhcHBlciwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFya2VycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcik7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG1hcmtlciBhbHJlYWR5IGRlbGV0ZWRcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBtLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWFya2Vycy5kZWxldGUobWFya2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU1hcmtlclBvc2l0aW9uID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnNldFBvc2l0aW9uKHsgbGF0OiBtYXJrZXIubGF0aXR1ZGUsIGxuZzogbWFya2VyLmxvbmdpdHVkZSB9KTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVUaXRsZSA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRUaXRsZShtYXJrZXIudGl0bGUpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUxhYmVsID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IG0uc2V0TGFiZWwobWFya2VyLmxhYmVsKTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVEcmFnZ2FibGUgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2V0RHJhZ2dhYmxlKG1hcmtlci5kcmFnZ2FibGUpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUljb24gPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2V0SWNvbihtYXJrZXIuaWNvblVybCk7IH0pO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUudXBkYXRlT3BhY2l0eSA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRPcGFjaXR5KG1hcmtlci5vcGFjaXR5KTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVWaXNpYmxlID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnNldFZpc2libGUobWFya2VyLnZpc2libGUpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVpJbmRleCA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRaSW5kZXgobWFya2VyLnpJbmRleCk7IH0pO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUuYWRkTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICB2YXIgbWFya2VyUHJvbWlzZSA9IHRoaXMuX21hcHNXcmFwcGVyLmNyZWF0ZU1hcmtlcih7XG4gICAgICAgICAgICBwb3NpdGlvbjogeyBsYXQ6IG1hcmtlci5sYXRpdHVkZSwgbG5nOiBtYXJrZXIubG9uZ2l0dWRlIH0sXG4gICAgICAgICAgICBsYWJlbDogbWFya2VyLmxhYmVsLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBtYXJrZXIuZHJhZ2dhYmxlLFxuICAgICAgICAgICAgaWNvbjogbWFya2VyLmljb25VcmwsXG4gICAgICAgICAgICBvcGFjaXR5OiBtYXJrZXIub3BhY2l0eSxcbiAgICAgICAgICAgIHZpc2libGU6IG1hcmtlci52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBtYXJrZXIuekluZGV4LFxuICAgICAgICAgICAgdGl0bGU6IG1hcmtlci50aXRsZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWFya2Vycy5zZXQobWFya2VyLCBtYXJrZXJQcm9taXNlKTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLmdldE5hdGl2ZU1hcmtlciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcik7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBtYXJrZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZlci5uZXh0KGUpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE1hcmtlck1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIE1hcmtlck1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5NYXJrZXJNYW5hZ2VyID0gTWFya2VyTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcmtlci1tYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL21hcmtlci1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJyk7XG52YXIgUG9seWdvbk1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvbHlnb25NYW5hZ2VyKF9tYXBzV3JhcHBlciwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fcG9seWdvbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS5hZGRQb2x5Z29uID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHBvbHlnb25Qcm9taXNlID0gdGhpcy5fbWFwc1dyYXBwZXIuY3JlYXRlUG9seWdvbih7XG4gICAgICAgICAgICBjbGlja2FibGU6IHBhdGguY2xpY2thYmxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBwYXRoLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBwYXRoLmVkaXRhYmxlLFxuICAgICAgICAgICAgZmlsbENvbG9yOiBwYXRoLmZpbGxDb2xvcixcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBwYXRoLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgZ2VvZGVzaWM6IHBhdGguZ2VvZGVzaWMsXG4gICAgICAgICAgICBwYXRoczogcGF0aC5wYXRocyxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBwYXRoLnN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogcGF0aC5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBwYXRoLnN0cm9rZVdlaWdodCxcbiAgICAgICAgICAgIHZpc2libGU6IHBhdGgudmlzaWJsZSxcbiAgICAgICAgICAgIHpJbmRleDogcGF0aC56SW5kZXgsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wb2x5Z29ucy5zZXQocGF0aCwgcG9seWdvblByb21pc2UpO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVBvbHlnb24gPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLnRoZW4oZnVuY3Rpb24gKGwpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IGwuc2V0UGF0aHMocG9seWdvbi5wYXRocyk7IH0pOyB9KTtcbiAgICB9O1xuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRQb2x5Z29uT3B0aW9ucyA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29ucy5nZXQocGF0aCkudGhlbihmdW5jdGlvbiAobCkgeyBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZVBvbHlnb24gPSBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG0gPSB0aGlzLl9wb2x5Z29ucy5nZXQocGF0aHMpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbC5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3BvbHlnb25zLmRlbGV0ZShwYXRocyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb2x5Z29uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlRXZlbnRPYnNlcnZhYmxlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMuX3BvbHlnb25zLmdldChwYXRoKS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgbC5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChlKTsgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgUG9seWdvbk1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFBvbHlnb25NYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuUG9seWdvbk1hbmFnZXIgPSBQb2x5Z29uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlnb24tbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5Z29uLW1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKTtcbnZhciBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xID0gcmVxdWlyZSgnLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbnZhciBQb2x5bGluZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvbHlsaW5lTWFuYWdlcihfbWFwc1dyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgUG9seWxpbmVNYW5hZ2VyLl9jb252ZXJ0UG9pbnRzID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBsaW5lLl9nZXRQb2ludHMoKS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyBsYXQ6IHBvaW50LmxhdGl0dWRlLCBsbmc6IHBvaW50LmxvbmdpdHVkZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICBQb2x5bGluZU1hbmFnZXIucHJvdG90eXBlLmFkZFBvbHlsaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBQb2x5bGluZU1hbmFnZXIuX2NvbnZlcnRQb2ludHMobGluZSk7XG4gICAgICAgIHZhciBwb2x5bGluZVByb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVQb2x5bGluZSh7XG4gICAgICAgICAgICBjbGlja2FibGU6IGxpbmUuY2xpY2thYmxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBsaW5lLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBsaW5lLmVkaXRhYmxlLFxuICAgICAgICAgICAgZ2VvZGVzaWM6IGxpbmUuZ2VvZGVzaWMsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogbGluZS5zdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IGxpbmUuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogbGluZS5zdHJva2VXZWlnaHQsXG4gICAgICAgICAgICB2aXNpYmxlOiBsaW5lLnZpc2libGUsXG4gICAgICAgICAgICB6SW5kZXg6IGxpbmUuekluZGV4LFxuICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVzLnNldChsaW5lLCBwb2x5bGluZVByb21pc2UpO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVQb2x5bGluZVBvaW50cyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYXRoID0gUG9seWxpbmVNYW5hZ2VyLl9jb252ZXJ0UG9pbnRzKGxpbmUpO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGZ1bmN0aW9uIChsKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyBsLnNldFBhdGgocGF0aCk7IH0pOyB9KTtcbiAgICB9O1xuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUuc2V0UG9seWxpbmVPcHRpb25zID0gZnVuY3Rpb24gKGxpbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSkudGhlbihmdW5jdGlvbiAobCkgeyBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVQb2x5bGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtID0gdGhpcy5fcG9seWxpbmVzLmdldChsaW5lKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLnRoZW4oZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGwuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9wb2x5bGluZXMuZGVsZXRlKGxpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fcG9seWxpbmVzLmdldChsaW5lKS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgbC5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChlKTsgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFBvbHlsaW5lTWFuYWdlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xLkdvb2dsZU1hcHNBUElXcmFwcGVyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5OZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gUG9seWxpbmVNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuUG9seWxpbmVNYW5hZ2VyID0gUG9seWxpbmVNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9seWxpbmUtbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4vLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbi8qKlxuICogTWFuYWdlcyBhbGwgS01MIExheWVycyBmb3IgYSBHb29nbGUgTWFwIGluc3RhbmNlLlxuICovXG52YXIgS21sTGF5ZXJNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLbWxMYXllck1hbmFnZXIoX3dyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIgPSBfd3JhcHBlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9sYXllcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgS01MIExheWVyIHRvIHRoZSBtYXAuXG4gICAgICovXG4gICAgS21sTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5hZGRLbWxMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICB2YXIgbmV3TGF5ZXIgPSB0aGlzLl93cmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuS21sTGF5ZXIoe1xuICAgICAgICAgICAgICAgIGNsaWNrYWJsZTogbGF5ZXIuY2xpY2thYmxlLFxuICAgICAgICAgICAgICAgIG1hcDogbSxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVZpZXdwb3J0OiBsYXllci5wcmVzZXJ2ZVZpZXdwb3J0LFxuICAgICAgICAgICAgICAgIHNjcmVlbk92ZXJsYXlzOiBsYXllci5zY3JlZW5PdmVybGF5cyxcbiAgICAgICAgICAgICAgICBzdXBwcmVzc0luZm9XaW5kb3dzOiBsYXllci5zdXBwcmVzc0luZm9XaW5kb3dzLFxuICAgICAgICAgICAgICAgIHVybDogbGF5ZXIudXJsLFxuICAgICAgICAgICAgICAgIHpJbmRleDogbGF5ZXIuekluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xheWVycy5zZXQobGF5ZXIsIG5ld0xheWVyKTtcbiAgICB9O1xuICAgIEttbExheWVyTWFuYWdlci5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChsYXllciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKS50aGVuKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgS21sTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVLbWxMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICBsLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIF90aGlzLl9sYXllcnMuZGVsZXRlKGxheWVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR29vZ2xlIE1hcHMgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBLbWxMYXllciBhcyBhbiBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgS21sTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsYXllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMuX2xheWVycy5nZXQobGF5ZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZlci5uZXh0KGUpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLbWxMYXllck1hbmFnZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgS21sTGF5ZXJNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBLbWxMYXllck1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5LbWxMYXllck1hbmFnZXIgPSBLbWxMYXllck1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rbWwtbGF5ZXItbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9rbWwtbGF5ZXItbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNpcmNsZV9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9jaXJjbGUtbWFuYWdlcicpO1xudmFyIFNlYm1Hb29nbGVNYXBDaXJjbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBDaXJjbGUoX21hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlciA9IF9tYW5hZ2VyO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBDaXJjbGUgaGFuZGxlcyBtb3VzZSBldmVudHMuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGRyYWcgdGhpcyBjaXJjbGUgb3ZlciB0aGUgbWFwLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGVkaXQgdGhpcyBjaXJjbGUgYnkgZHJhZ2dpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIHNob3duIGF0XG4gICAgICAgICAqIHRoZSBjZW50ZXIgYW5kIGFyb3VuZCB0aGUgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2lyY2xlLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByYWRpdXMgaW4gbWV0ZXJzIG9uIHRoZSBFYXJ0aCdzIHN1cmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3Ryb2tlIHBvc2l0aW9uLiBEZWZhdWx0cyB0byBDRU5URVIuXG4gICAgICAgICAqIFRoaXMgcHJvcGVydHkgaXMgbm90IHN1cHBvcnRlZCBvbiBJbnRlcm5ldCBFeHBsb3JlciA4IGFuZCBlYXJsaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHJva2VQb3NpdGlvbiA9ICdDRU5URVInO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0cm9rZSB3aWR0aCBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0cm9rZVdlaWdodCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgY2lyY2xlIGlzIHZpc2libGUgb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGNpcmNsZSdzIGNlbnRlciBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZW50ZXJDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaXJjbGVDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNpcmNsZURibENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcmVwZWF0ZWRseSBmaXJlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnRW5kID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIGNpcmNsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlZG93biBldmVudCBpcyBmaXJlZCBvbiB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vtb3ZlIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlTW92ZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIGNpcmNsZSBtb3VzZW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW91c2VPdXQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBjaXJjbGUgbW91c2VvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZU92ZXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZVVwID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgY2lyY2xlJ3MgcmFkaXVzIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1c0NoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGNpcmNsZSBpcyByaWdodC1jbGlja2VkIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yaWdodENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fY2lyY2xlQWRkZWRUb01hbmFnZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXZlbnRTdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5hZGRDaXJjbGUodGhpcyk7XG4gICAgICAgIHRoaXMuX2NpcmNsZUFkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudExpc3RlbmVycygpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jaXJjbGVBZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLnNldENlbnRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snZWRpdGFibGUnXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5zZXRFZGl0YWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snZHJhZ2dhYmxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIuc2V0RHJhZ2dhYmxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd2aXNpYmxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIuc2V0VmlzaWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1sncmFkaXVzJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIuc2V0UmFkaXVzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNpcmNsZU9wdGlvbnNDaGFuZ2VzKGNoYW5nZXMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcENpcmNsZS5wcm90b3R5cGUuX3VwZGF0ZUNpcmNsZU9wdGlvbnNDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFNlYm1Hb29nbGVNYXBDaXJjbGUuX21hcE9wdGlvbnMuaW5kZXhPZihrKSAhPT0gLTE7IH0pO1xuICAgICAgICBvcHRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHsgb3B0aW9uc1trXSA9IGNoYW5nZXNba10uY3VycmVudFZhbHVlOyB9KTtcbiAgICAgICAgaWYgKG9wdGlvbktleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5fcmVnaXN0ZXJFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZXZlbnRzLnNldCgnY2VudGVyX2NoYW5nZWQnLCB0aGlzLmNlbnRlckNoYW5nZSk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ2NsaWNrJywgdGhpcy5jaXJjbGVDbGljayk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ2RibGNsaWNrJywgdGhpcy5jaXJjbGVEYmxDbGljayk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ2RyYWcnLCB0aGlzLmRyYWcpO1xuICAgICAgICBldmVudHMuc2V0KCdkcmFnZW5kJywgdGhpcy5kcmFnRW5kKTtcbiAgICAgICAgZXZlbnRzLnNldCgnZHJhZ1N0YXJ0JywgdGhpcy5kcmFnU3RhcnQpO1xuICAgICAgICBldmVudHMuc2V0KCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlRG93bik7XG4gICAgICAgIGV2ZW50cy5zZXQoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlKTtcbiAgICAgICAgZXZlbnRzLnNldCgnbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0KTtcbiAgICAgICAgZXZlbnRzLnNldCgnbW91c2VvdmVyJywgdGhpcy5tb3VzZU92ZXIpO1xuICAgICAgICBldmVudHMuc2V0KCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwKTtcbiAgICAgICAgZXZlbnRzLnNldCgncmFkaXVzX2NoYW5nZWQnLCB0aGlzLnJhZGl1c0NoYW5nZSk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ3JpZ2h0Y2xpY2snLCB0aGlzLnJpZ2h0Q2xpY2spO1xuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRFbWl0dGVyLCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgIF90aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMucHVzaChfdGhpcy5fbWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUoZXZlbnROYW1lLCBfdGhpcykuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGl1c19jaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYW5hZ2VyLmdldFJhZGl1cyhfdGhpcykudGhlbihmdW5jdGlvbiAocmFkaXVzKSB7IHJldHVybiBldmVudEVtaXR0ZXIuZW1pdChyYWRpdXMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXJfY2hhbmdlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbWFuYWdlci5nZXRDZW50ZXIoX3RoaXMpLnRoZW4oZnVuY3Rpb24gKGNlbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudEVtaXR0ZXIuZW1pdCh7IGxhdDogY2VudGVyLmxhdCgpLCBsbmc6IGNlbnRlci5sbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCh7IGNvb3JkczogeyBsYXQ6IHZhbHVlLmxhdExuZy5sYXQoKSwgbG5nOiB2YWx1ZS5sYXRMbmcubG5nKCkgfSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocykgeyBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgICAgICB0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLnJlbW92ZUNpcmNsZSh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGlzIENpcmNsZS5cbiAgICAgKi9cbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYW5hZ2VyLmdldEJvdW5kcyh0aGlzKTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYW5hZ2VyLmdldENlbnRlcih0aGlzKTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLl9tYXBPcHRpb25zID0gW1xuICAgICAgICAnZmlsbENvbG9yJywgJ2ZpbGxPcGFjaXR5JywgJ3N0cm9rZUNvbG9yJywgJ3N0cm9rZU9wYWNpdHknLCAnc3Ryb2tlUG9zaXRpb24nLCAnc3Ryb2tlV2VpZ2h0JyxcbiAgICAgICAgJ3Zpc2libGUnLCAnekluZGV4J1xuICAgIF07XG4gICAgU2VibUdvb2dsZU1hcENpcmNsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VibS1nb29nbGUtbWFwLWNpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xhdGl0dWRlJywgJ2xvbmdpdHVkZScsICdjbGlja2FibGUnLCAnZHJhZ2dhYmxlOiBjaXJjbGVEcmFnZ2FibGUnLCAnZWRpdGFibGUnLCAnZmlsbENvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsT3BhY2l0eScsICdyYWRpdXMnLCAnc3Ryb2tlQ29sb3InLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VQb3NpdGlvbicsICdzdHJva2VXZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc2libGUnLCAnekluZGV4J1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2VudGVyQ2hhbmdlJywgJ2NpcmNsZUNsaWNrJywgJ2NpcmNsZURibENsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnU3RhcnQnLCAnbW91c2VEb3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncmFkaXVzQ2hhbmdlJywgJ3JpZ2h0Q2xpY2snXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogY2lyY2xlX21hbmFnZXJfMS5DaXJjbGVNYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBDaXJjbGU7XG59KCkpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwQ2lyY2xlID0gU2VibUdvb2dsZU1hcENpcmNsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtY2lyY2xlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1jaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBpbmZvX3dpbmRvd19tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyJyk7XG52YXIgaW5mb1dpbmRvd0lkID0gMDtcbi8qKlxuICogU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgcmVuZGVycyBhIGluZm8gd2luZG93IGluc2lkZSBhIHtAbGluayBTZWJtR29vZ2xlTWFwTWFya2VyfSBvciBzdGFuZGFsb25lLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIsIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93IH0gZnJvbVxuICogJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgZGlyZWN0aXZlczogW1NlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIsIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93XSxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlYm0tZ29vZ2xlLW1hcCBbbGF0aXR1ZGVdPVwibGF0XCIgW2xvbmdpdHVkZV09XCJsbmdcIiBbem9vbV09XCJ6b29tXCI+XG4gKiAgICAgIDxzZWJtLWdvb2dsZS1tYXAtbWFya2VyIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFtsYWJlbF09XCInTSdcIj5cbiAqICAgICAgICA8c2VibS1nb29nbGUtbWFwLWluZm8td2luZG93IFtkaXNhYmxlQXV0b1Bhbl09XCJ0cnVlXCI+XG4gKiAgICAgICAgICBIaSwgdGhpcyBpcyB0aGUgY29udGVudCBvZiB0aGUgPHN0cm9uZz5pbmZvIHdpbmRvdzwvc3Ryb25nPlxuICogICAgICAgIDwvc2VibS1nb29nbGUtbWFwLWluZm8td2luZG93PlxuICogICAgICA8L3NlYm0tZ29vZ2xlLW1hcC1tYXJrZXI+XG4gKiAgICA8L3NlYm0tZ29vZ2xlLW1hcD5cbiAqICBgXG4gKiB9KVxuICogYGBgXG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcEluZm9XaW5kb3coX2luZm9XaW5kb3dNYW5hZ2VyLCBfZWwpIHtcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvd01hbmFnZXIgPSBfaW5mb1dpbmRvd01hbmFnZXI7XG4gICAgICAgIHRoaXMuX2VsID0gX2VsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgb3BlbiBzdGF0ZSBmb3IgdGhlIEluZm9XaW5kb3cuIFlvdSBjYW4gYWxzbyBjYWxsIHRoZSBvcGVuKCkgYW5kIGNsb3NlKCkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBpbmZvIHdpbmRvdyBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZm9XaW5kb3dDbG9zZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3dBZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pZCA9IChpbmZvV2luZG93SWQrKykudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWJtLWdvb2dsZS1tYXAtaW5mby13aW5kb3ctY29udGVudCcpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93TWFuYWdlci5hZGRJbmZvV2luZG93KHRoaXMpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93QWRkZWRUb01hbmFnZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl91cGRhdGVPcGVuU3RhdGUoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudExpc3RlbmVycygpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5mb1dpbmRvd0FkZGVkVG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSAmJiB0eXBlb2YgdGhpcy5sYXRpdHVkZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmxvbmdpdHVkZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLnNldFBvc2l0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd6SW5kZXgnXSkge1xuICAgICAgICAgICAgdGhpcy5faW5mb1dpbmRvd01hbmFnZXIuc2V0WkluZGV4KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydpc09wZW4nXSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlT3BlblN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0SW5mb1dpbmRvd09wdGlvbnMoY2hhbmdlcyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuX3JlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnY2xvc2VjbGljaycsIHRoaXMpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLmluZm9XaW5kb3dDbG9zZS5lbWl0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLl91cGRhdGVPcGVuU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNPcGVuID8gdGhpcy5vcGVuKCkgOiB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuX3NldEluZm9XaW5kb3dPcHRpb25zID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93Ll9pbmZvV2luZG93T3B0aW9uc0lucHV0cy5pbmRleE9mKGspICE9PSAtMTsgfSk7XG4gICAgICAgIG9wdGlvbktleXMuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBvcHRpb25zW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7IH0pO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93TWFuYWdlci5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGluZm8gd2luZG93LlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW5mb1dpbmRvd01hbmFnZXIub3Blbih0aGlzKTsgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGluZm8gd2luZG93LlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmNsb3NlKHRoaXMpLnRoZW4oZnVuY3Rpb24gKCkgeyBfdGhpcy5pbmZvV2luZG93Q2xvc2UuZW1pdCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZDsgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1NlYm1Hb29nbGVNYXBJbmZvV2luZG93LScgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmRlbGV0ZUluZm9XaW5kb3codGhpcyk7IH07XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cuX2luZm9XaW5kb3dPcHRpb25zSW5wdXRzID0gWydkaXNhYmxlQXV0b1BhbicsICdtYXhXaWR0aCddO1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkNvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAtaW5mby13aW5kb3cnLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFsnbGF0aXR1ZGUnLCAnbG9uZ2l0dWRlJywgJ2Rpc2FibGVBdXRvUGFuJywgJ2lzT3BlbicsICd6SW5kZXgnLCAnbWF4V2lkdGgnXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWydpbmZvV2luZG93Q2xvc2UnXSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz0nc2VibS1nb29nbGUtbWFwLWluZm8td2luZG93LWNvbnRlbnQnPlxcbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgPC9kaXY+XFxuICBcIlxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogaW5mb193aW5kb3dfbWFuYWdlcl8xLkluZm9XaW5kb3dNYW5hZ2VyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5FbGVtZW50UmVmLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93O1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgPSBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtaW5mby13aW5kb3cuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWluZm8td2luZG93LmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIga21sX2xheWVyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vLi4vc2VydmljZXMvbWFuYWdlcnMva21sLWxheWVyLW1hbmFnZXInKTtcbnZhciBsYXllcklkID0gMDtcbnZhciBTZWJtR29vZ2xlTWFwS21sTGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBLbWxMYXllcihfbWFuYWdlcikge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyID0gX21hbmFnZXI7XG4gICAgICAgIHRoaXMuX2FkZGVkVG9NYW5hZ2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lkID0gKGxheWVySWQrKykudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGxheWVyIHJlY2VpdmVzIG1vdXNlIGV2ZW50cy4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGlucHV0IG1hcCBpcyBjZW50ZXJlZCBhbmQgem9vbWVkIHRvIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgKiBsYXllci5cbiAgICAgICAgICogSWYgdGhpcyBvcHRpb24gaXMgc2V0IHRvIHRydWUsIHRoZSB2aWV3cG9ydCBpcyBsZWZ0IHVuY2hhbmdlZCwgdW5sZXNzIHRoZSBtYXAncyBjZW50ZXIgYW5kIHpvb21cbiAgICAgICAgICogd2VyZSBuZXZlciBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXNlcnZlVmlld3BvcnQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gcmVuZGVyIHRoZSBzY3JlZW4gb3ZlcmxheXMuIERlZmF1bHQgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NyZWVuT3ZlcmxheXMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VwcHJlc3MgdGhlIHJlbmRlcmluZyBvZiBpbmZvIHdpbmRvd3Mgd2hlbiBsYXllciBmZWF0dXJlcyBhcmUgY2xpY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcHJlc3NJbmZvV2luZG93cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgS01MIGRvY3VtZW50IHRvIGRpc3BsYXkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpJbmRleCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBmZWF0dXJlIGluIHRoZSBsYXllciBpcyBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXllckNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgS01MIGxheWVycyBkZWZhdWx0IHZpZXdwb3J0IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0Vmlld3BvcnRDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBLTUwgbGF5ZXIgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgICAqIEF0IHRoaXMgcG9pbnQgaXQgaXMgc2FmZSB0byByZWFkIHRoZSBzdGF0dXMgcHJvcGVydHkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBsYXllciBsb2FkZWRcbiAgICAgICAgICogc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkZWRUb01hbmFnZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYW5hZ2VyLmFkZEttbExheWVyKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRlZFRvTWFuYWdlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvbHlnb25PcHRpb25zKGNoYW5nZXMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLnByb3RvdHlwZS5fdXBkYXRlUG9seWdvbk9wdGlvbnMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBTZWJtR29vZ2xlTWFwS21sTGF5ZXIuX2ttbExheWVyT3B0aW9ucy5pbmRleE9mKGspICE9PSAtMTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaykge1xuICAgICAgICAgICAgb2JqW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBLbWxMYXllci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxheWVyQ2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RlZmF1bHR2aWV3cG9ydF9jaGFuZ2VkJywgaGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGVmYXVsdFZpZXdwb3J0Q2hhbmdlLmVtaXQoKTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnc3RhdHVzX2NoYW5nZWQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdGF0dXNDaGFuZ2UuZW1pdCgpOyB9IH0sXG4gICAgICAgIF07XG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9tYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZShvYmoubmFtZSwgX3RoaXMpLnN1YnNjcmliZShvYmouaGFuZGxlcik7XG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKG9zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJTZWJtR29vZ2xlTWFwS21sTGF5ZXItXCIgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLmRlbGV0ZUttbExheWVyKHRoaXMpO1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBhbGwgcmVnaXN0ZXJlZCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLl9rbWxMYXllck9wdGlvbnMgPSBbJ2NsaWNrYWJsZScsICdwcmVzZXJ2ZVZpZXdwb3J0JywgJ3NjcmVlbk92ZXJsYXlzJywgJ3N1cHByZXNzSW5mb1dpbmRvd3MnLCAndXJsJywgJ3pJbmRleCddO1xuICAgIFNlYm1Hb29nbGVNYXBLbWxMYXllci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VibS1nb29nbGUtbWFwLWttbC1sYXllcicsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydjbGlja2FibGUnLCAncHJlc2VydmVWaWV3cG9ydCcsICdzY3JlZW5PdmVybGF5cycsICdzdXBwcmVzc0luZm9XaW5kb3dzJywgJ3VybCcsICd6SW5kZXgnXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWydsYXllckNsaWNrJywgJ2RlZmF1bHRWaWV3cG9ydENoYW5nZScsICdzdGF0dXNDaGFuZ2UnXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGttbF9sYXllcl9tYW5hZ2VyXzEuS21sTGF5ZXJNYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBLbWxMYXllciA9IFNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAta21sLWxheWVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1rbWwtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBtYXJrZXJfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvbWFya2VyLW1hbmFnZXInKTtcbnZhciBnb29nbGVfbWFwX2luZm9fd2luZG93XzEgPSByZXF1aXJlKCcuL2dvb2dsZS1tYXAtaW5mby13aW5kb3cnKTtcbnZhciBtYXJrZXJJZCA9IDA7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBNYXJrZXIgcmVuZGVycyBhIG1hcCBtYXJrZXIgaW5zaWRlIGEge0BsaW5rIFNlYm1Hb29nbGVNYXB9LlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIgfSBmcm9tICdhbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxuICogIGRpcmVjdGl2ZXM6IFtTZWJtR29vZ2xlTWFwLCBTZWJtR29vZ2xlTWFwTWFya2VyXSxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlYm0tZ29vZ2xlLW1hcCBbbGF0aXR1ZGVdPVwibGF0XCIgW2xvbmdpdHVkZV09XCJsbmdcIiBbem9vbV09XCJ6b29tXCI+XG4gKiAgICAgIDxzZWJtLWdvb2dsZS1tYXAtbWFya2VyIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFtsYWJlbF09XCInTSdcIj5cbiAqICAgICAgPC9zZWJtLWdvb2dsZS1tYXAtbWFya2VyPlxuICogICAgPC9zZWJtLWdvb2dsZS1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGBgYFxuICovXG52YXIgU2VibUdvb2dsZU1hcE1hcmtlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcE1hcmtlcihfbWFya2VyTWFuYWdlcikge1xuICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyID0gX21hcmtlck1hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgbWFya2VyIGNhbiBiZSBkcmFnZ2VkLiBEZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSBtYXJrZXIgaXMgdmlzaWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBvcGVuIHRoZSBjaGlsZCBpbmZvIHdpbmRvdyB3aGVuIHRoZSBtYXJrZXIgaXMgY2xpY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbkluZm9XaW5kb3cgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1hcmtlcidzIG9wYWNpdHkgYmV0d2VlbiAwLjAgYW5kIDEuMC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgbWFya2VycyBhcmUgZGlzcGxheWVkIG9uIHRoZSBtYXAgaW4gb3JkZXIgb2YgdGhlaXIgekluZGV4LCB3aXRoIGhpZ2hlciB2YWx1ZXMgZGlzcGxheWluZyBpblxuICAgICAgICAgKiBmcm9udCBvZiBtYXJrZXJzIHdpdGggbG93ZXIgdmFsdWVzLiBCeSBkZWZhdWx0LCBtYXJrZXJzIGFyZSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvIHRoZWlyXG4gICAgICAgICAqIHZlcnRpY2FsIHBvc2l0aW9uIG9uIHNjcmVlbiwgd2l0aCBsb3dlciBtYXJrZXJzIGFwcGVhcmluZyBpbiBmcm9udCBvZiBtYXJrZXJzIGZ1cnRoZXIgdXAgdGhlXG4gICAgICAgICAqIHNjcmVlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuekluZGV4ID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcmtlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFya2VyQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdFbmQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIG1vdXNlcyBvdmVyIHRoZSBtYXJrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlT3ZlciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgbW91c2VzIG91dHNpZGUgdGhlIG1hcmtlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW91c2VPdXQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuX2lkID0gKG1hcmtlcklkKyspLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5mb1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZm9XaW5kb3cuaG9zdE1hcmtlciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sYXRpdHVkZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMubG9uZ2l0dWRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlcikge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlci5hZGRNYXJrZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xhdGl0dWRlJ10gfHwgY2hhbmdlc1snbG9uZ2l0dWRlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlTWFya2VyUG9zaXRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ3RpdGxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlVGl0bGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xhYmVsJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlTGFiZWwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2RyYWdnYWJsZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZURyYWdnYWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snaWNvblVybCddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZUljb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ29wYWNpdHknXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlci51cGRhdGVPcGFjaXR5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd2aXNpYmxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlVmlzaWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snekluZGV4J10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlWkluZGV4KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjcyA9IHRoaXMuX21hcmtlck1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKCdjbGljaycsIHRoaXMpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3BlbkluZm9XaW5kb3cgJiYgX3RoaXMuaW5mb1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5mb1dpbmRvdy5vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5tYXJrZXJDbGljay5lbWl0KG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChjcyk7XG4gICAgICAgIHZhciBkcyA9IHRoaXMuX21hcmtlck1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKCdkcmFnZW5kJywgdGhpcylcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmRyYWdFbmQuZW1pdCh7IGNvb3JkczogeyBsYXQ6IGUubGF0TG5nLmxhdCgpLCBsbmc6IGUubGF0TG5nLmxuZygpIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKGRzKTtcbiAgICAgICAgdmFyIG1vdmVyID0gdGhpcy5fbWFya2VyTWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUoJ21vdXNlb3ZlcicsIHRoaXMpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5tb3VzZU92ZXIuZW1pdCh7IGNvb3JkczogeyBsYXQ6IGUubGF0TG5nLmxhdCgpLCBsbmc6IGUubGF0TG5nLmxuZygpIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKG1vdmVyKTtcbiAgICAgICAgdmFyIG1vdXQgPSB0aGlzLl9tYXJrZXJNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnbW91c2VvdXQnLCB0aGlzKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMubW91c2VPdXQuZW1pdCh7IGNvb3JkczogeyBsYXQ6IGUubGF0TG5nLmxhdCgpLCBsbmc6IGUubGF0TG5nLmxuZygpIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKG1vdXQpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWQ7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1NlYm1Hb29nbGVNYXBNYXJrZXItJyArIHRoaXMuX2lkLnRvU3RyaW5nKCk7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLmRlbGV0ZU1hcmtlcih0aGlzKTtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAtbWFya2VyJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGF0aXR1ZGUnLCAnbG9uZ2l0dWRlJywgJ3RpdGxlJywgJ2xhYmVsJywgJ2RyYWdnYWJsZTogbWFya2VyRHJhZ2dhYmxlJywgJ2ljb25VcmwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5JbmZvV2luZG93JywgJ29wYWNpdHknLCAndmlzaWJsZScsICd6SW5kZXgnXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFsnbWFya2VyQ2xpY2snLCAnZHJhZ0VuZCcsICdtb3VzZU92ZXInLCAnbW91c2VPdXQnXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcE1hcmtlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBtYXJrZXJfbWFuYWdlcl8xLk1hcmtlck1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaW5mb1dpbmRvdyc6IFt7IHR5cGU6IGNvcmVfMS5Db250ZW50Q2hpbGQsIGFyZ3M6IFtnb29nbGVfbWFwX2luZm9fd2luZG93XzEuU2VibUdvb2dsZU1hcEluZm9XaW5kb3csXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gU2VibUdvb2dsZU1hcE1hcmtlcjtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBNYXJrZXIgPSBTZWJtR29vZ2xlTWFwTWFya2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z29vZ2xlLW1hcC1tYXJrZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLW1hcmtlci5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIHBvbHlnb25fbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvcG9seWdvbi1tYW5hZ2VyJyk7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBQb2x5Z29uIHJlbmRlcnMgYSBwb2x5Z29uIG9uIGEge0BsaW5rIFNlYm1Hb29nbGVNYXB9XG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgU2VibUdvb2dsZU1hcCwgU2VibUdvb2dsZVBvbHlnb24sIExhdExuZ0xpdGVyYWwgfSBmcm9tICdhbmd1bGFyMi1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgc3R5bGVzOiBbYFxuICogICAgLnNlbWItbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlbWItbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cbiAqICAgICAgPHNlbWItbWFwLXBvbHlnb24gW3BhdGhzXT1cInBhdGhzXCI+XG4gKiAgICAgIDwvc2VtYi1tYXAtcG9seWdvbj5cbiAqICAgIDwvc2VtYi1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBNeU1hcENtcCB7XG4gKiAgIGxhdDogbnVtYmVyID0gMDtcbiAqICAgbG5nOiBudW1iZXIgPSAwO1xuICogICB6b29tOiBudW1iZXIgPSAxMDtcbiAqICAgcGF0aHM6IEFycmF5PExhdExuZ0xpdGVyYWw+ID0gW1xuICogICAgIHsgbGF0OiAwLCAgbG5nOiAxMCB9LFxuICogICAgIHsgbGF0OiAwLCAgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiAxMCwgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiAxMCwgbG5nOiAxMCB9LFxuICogICAgIHsgbGF0OiAwLCAgbG5nOiAxMCB9XG4gKiAgIF1cbiAqICAgLy8gTmVzdGluZyBwYXRocyB3aWxsIGNyZWF0ZSBhIGhvbGUgd2hlcmUgdGhleSBvdmVybGFwO1xuICogICBuZXN0ZWRQYXRoczogQXJyYXk8QXJyYXk8TGF0TG5nTGl0ZXJhbD4+ID0gW1tcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMTAgfSxcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMjAgfSxcbiAqICAgICB7IGxhdDogMTAsIGxuZzogMjAgfSxcbiAqICAgICB7IGxhdDogMTAsIGxuZzogMTAgfSxcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMTAgfVxuICogICBdLCBbXG4gKiAgICAgeyBsYXQ6IDAsIGxuZzogMTUgfSxcbiAqICAgICB7IGxhdDogMCwgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiA1LCBsbmc6IDIwIH0sXG4gKiAgICAgeyBsYXQ6IDUsIGxuZzogMTUgfSxcbiAqICAgICB7IGxhdDogMCwgbG5nOiAxNSB9XG4gKiAgIF1dXG4gKiB9XG4gKiBgYGBcbiAqL1xudmFyIFNlYm1Hb29nbGVNYXBQb2x5Z29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWJtR29vZ2xlTWFwUG9seWdvbihfcG9seWdvbk1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIgPSBfcG9seWdvbk1hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIFBvbHlnb24gaGFuZGxlcyBtb3VzZSBldmVudHMuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGRyYWcgdGhpcyBzaGFwZSBvdmVyIHRoZSBtYXAuIFRoZSBnZW9kZXNpY1xuICAgICAgICAgKiBwcm9wZXJ0eSBkZWZpbmVzIHRoZSBtb2RlIG9mIGRyYWdnaW5nLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGVkaXQgdGhpcyBzaGFwZSBieSBkcmFnZ2luZyB0aGUgY29udHJvbFxuICAgICAgICAgKiBwb2ludHMgc2hvd24gYXQgdGhlIHZlcnRpY2VzIGFuZCBvbiBlYWNoIHNlZ21lbnQuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0cnVlLCBlZGdlcyBvZiB0aGUgcG9seWdvbiBhcmUgaW50ZXJwcmV0ZWQgYXMgZ2VvZGVzaWMgYW5kIHdpbGxcbiAgICAgICAgICogZm9sbG93IHRoZSBjdXJ2YXR1cmUgb2YgdGhlIEVhcnRoLiBXaGVuIGZhbHNlLCBlZGdlcyBvZiB0aGUgcG9seWdvbiBhcmVcbiAgICAgICAgICogcmVuZGVyZWQgYXMgc3RyYWlnaHQgbGluZXMgaW4gc2NyZWVuIHNwYWNlLiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGFcbiAgICAgICAgICogZ2VvZGVzaWMgcG9seWdvbiBtYXkgYXBwZWFyIHRvIGNoYW5nZSB3aGVuIGRyYWdnZWQsIGFzIHRoZSBkaW1lbnNpb25zXG4gICAgICAgICAqIGFyZSBtYWludGFpbmVkIHJlbGF0aXZlIHRvIHRoZSBzdXJmYWNlIG9mIHRoZSBlYXJ0aC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlb2Rlc2ljID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3JkZXJlZCBzZXF1ZW5jZSBvZiBjb29yZGluYXRlcyB0aGF0IGRlc2lnbmF0ZXMgYSBjbG9zZWQgbG9vcC5cbiAgICAgICAgICogVW5saWtlIHBvbHlsaW5lcywgYSBwb2x5Z29uIG1heSBjb25zaXN0IG9mIG9uZSBvciBtb3JlIHBhdGhzLlxuICAgICAgICAgKiAgQXMgYSByZXN1bHQsIHRoZSBwYXRocyBwcm9wZXJ0eSBtYXkgc3BlY2lmeSBvbmUgb3IgbW9yZSBhcnJheXMgb2ZcbiAgICAgICAgICogTGF0TG5nIGNvb3JkaW5hdGVzLiBQYXRocyBhcmUgY2xvc2VkIGF1dG9tYXRpY2FsbHk7IGRvIG5vdCByZXBlYXQgdGhlXG4gICAgICAgICAqIGZpcnN0IHZlcnRleCBvZiB0aGUgcGF0aCBhcyB0aGUgbGFzdCB2ZXJ0ZXguIFNpbXBsZSBwb2x5Z29ucyBtYXkgYmVcbiAgICAgICAgICogZGVmaW5lZCB1c2luZyBhIHNpbmdsZSBhcnJheSBvZiBMYXRMbmdzLiBNb3JlIGNvbXBsZXggcG9seWdvbnMgbWF5XG4gICAgICAgICAqIHNwZWNpZnkgYW4gYXJyYXkgb2YgYXJyYXlzLiBBbnkgc2ltcGxlIGFycmF5cyBhcmUgY29udmVydGVkIGludG8gQXJyYXlzLlxuICAgICAgICAgKiBJbnNlcnRpbmcgb3IgcmVtb3ZpbmcgTGF0TG5ncyBmcm9tIHRoZSBBcnJheSB3aWxsIGF1dG9tYXRpY2FsbHkgdXBkYXRlXG4gICAgICAgICAqIHRoZSBwb2x5Z29uIG9uIHRoZSBtYXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdGhzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9seUNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIGRibGNsaWNrIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5RGJsQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyByZXBlYXRlZGx5IGZpcmVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBwb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5RHJhZyA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlnb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlEcmFnRW5kID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIHBvbHlnb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlEcmFnU3RhcnQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vkb3duIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VEb3duID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9seU1vdXNlTW92ZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIFBvbHlnb24gbW91c2VvdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlNb3VzZU91dCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIFBvbHlnb24gbW91c2VvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VPdmVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VVcCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW4gaXMgZmlyZWQgd2hlbiB0aGUgUG9seWdvbiBpcyByaWdodC1jbGlja2VkIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5UmlnaHRDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWdvbi5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWdvbi5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BvbHlnb25NYW5hZ2VyLnNldFBvbHlnb25PcHRpb25zKHRoaXMsIHRoaXMuX3VwZGF0ZVBvbHlnb25PcHRpb25zKGNoYW5nZXMpKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIuYWRkUG9seWdvbih0aGlzKTtcbiAgICAgICAgdGhpcy5fcG9seWdvbkFkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5Q2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RiY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEYmxDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZycsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seURyYWcuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdlbmQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEcmFnRW5kLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEcmFnU3RhcnQuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlZG93bicsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seU1vdXNlRG93bi5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5TW91c2VNb3ZlLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seU1vdXNlT3V0LmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlNb3VzZU92ZXIuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNldXAnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlNb3VzZVVwLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5UmlnaHRDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICBdO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9wb2x5Z29uTWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUob2JqLm5hbWUsIF90aGlzKS5zdWJzY3JpYmUob2JqLmhhbmRsZXIpO1xuICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChvcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlnb24ucHJvdG90eXBlLl91cGRhdGVQb2x5Z29uT3B0aW9ucyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjaGFuZ2VzKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gU2VibUdvb2dsZU1hcFBvbHlnb24uX3BvbHlnb25PcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaykge1xuICAgICAgICAgICAgb2JqW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlnb24ucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWQ7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIuZGVsZXRlUG9seWdvbih0aGlzKTtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gcy51bnN1YnNjcmliZSgpOyB9KTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLl9wb2x5Z29uT3B0aW9uc0F0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdjbGlja2FibGUnLCAnZHJhZ2dhYmxlJywgJ2VkaXRhYmxlJywgJ2ZpbGxDb2xvcicsICdmaWxsT3BhY2l0eScsICdnZW9kZXNpYycsICdpY29uJywgJ21hcCcsXG4gICAgICAgICdwYXRocycsICdzdHJva2VDb2xvcicsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdlaWdodCcsICd2aXNpYmxlJywgJ3pJbmRleCcsICdkcmFnZ2FibGUnLFxuICAgICAgICAnZWRpdGFibGUnLCAndmlzaWJsZSdcbiAgICBdO1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLW1hcC1wb2x5Z29uJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xpY2thYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkcmFnZ2FibGU6IHBvbHlEcmFnZ2FibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2VkaXRhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsQ29sb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGxPcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZW9kZXNpYycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF0aHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VXZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3pJbmRleCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb2x5Q2xpY2snLCAncG9seURibENsaWNrJywgJ3BvbHlEcmFnJywgJ3BvbHlEcmFnRW5kJywgJ3BvbHlNb3VzZURvd24nLCAncG9seU1vdXNlTW92ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9seU1vdXNlT3V0JywgJ3BvbHlNb3VzZU92ZXInLCAncG9seU1vdXNlVXAnLCAncG9seVJpZ2h0Q2xpY2snXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHBvbHlnb25fbWFuYWdlcl8xLlBvbHlnb25NYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBQb2x5Z29uO1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlnb24gPSBTZWJtR29vZ2xlTWFwUG9seWdvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtcG9seWdvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIHBvbHlsaW5lX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlsaW5lLW1hbmFnZXInKTtcbnZhciBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEgPSByZXF1aXJlKCcuL2dvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQnKTtcbnZhciBwb2x5bGluZUlkID0gMDtcbi8qKlxuICogU2VibUdvb2dsZU1hcFBvbHlsaW5lIHJlbmRlcnMgYSBwb2x5bGluZSBvbiBhIHtAbGluayBTZWJtR29vZ2xlTWFwfVxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVQb2x5bGluZSwgU2VibUdvb2dsZVBvbHlsaW5lUG9pbnQgfSBmcm9tXG4gKiAnYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZSc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcbiAqICBkaXJlY3RpdmVzOiBbU2VibUdvb2dsZU1hcCwgU2VibUdvb2dsZVBvbHlsaW5lLCBTZWJtR29vZ2xlUG9seWxpbmVQb2ludF0sXG4gKiAgc3R5bGVzOiBbYFxuICogICAgLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXIge1xuICogICAgICBoZWlnaHQ6IDMwMHB4O1xuICogICAgfVxuICogYF0sXG4gKiAgdGVtcGxhdGU6IGBcbiAqICAgIDxzZWJtLWdvb2dsZS1tYXAgW2xhdGl0dWRlXT1cImxhdFwiIFtsb25naXR1ZGVdPVwibG5nXCIgW3pvb21dPVwiem9vbVwiPlxuICogICAgICA8c2VibS1nb29nbGUtbWFwLXBvbHlsaW5lPlxuICogICAgICAgICAgPHNlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCBbbGF0aXR1ZGVdPVwibGF0QVwiIFtsb25naXR1ZGVdPVwibG5nQVwiPlxuICogICAgICAgICAgPC9zZWJtLWdvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQ+XG4gKiAgICAgICAgICA8c2VibS1nb29nbGUtbWFwLXBvbHlsaW5lLXBvaW50IFtsYXRpdHVkZV09XCJsYXRCXCIgW2xvbmdpdHVkZV09XCJsbmdCXCI+XG4gKiAgICAgICAgICA8L3NlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludD5cbiAqICAgICAgPC9zZWJtLWdvb2dsZS1tYXAtcG9seWxpbmU+XG4gKiAgICA8L3NlYm0tZ29vZ2xlLW1hcD5cbiAqICBgXG4gKiB9KVxuICogYGBgXG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwUG9seWxpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBQb2x5bGluZShfcG9seWxpbmVNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlciA9IF9wb2x5bGluZU1hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIFBvbHlsaW5lIGhhbmRsZXMgbW91c2UgZXZlbnRzLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBkcmFnIHRoaXMgc2hhcGUgb3ZlciB0aGUgbWFwLiBUaGUgZ2VvZGVzaWMgcHJvcGVydHkgZGVmaW5lcyB0aGVcbiAgICAgICAgICogbW9kZSBvZiBkcmFnZ2luZy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBlZGl0IHRoaXMgc2hhcGUgYnkgZHJhZ2dpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIHNob3duIGF0IHRoZVxuICAgICAgICAgKiB2ZXJ0aWNlcyBhbmQgb24gZWFjaCBzZWdtZW50LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdHJ1ZSwgZWRnZXMgb2YgdGhlIHBvbHlnb24gYXJlIGludGVycHJldGVkIGFzIGdlb2Rlc2ljIGFuZCB3aWxsIGZvbGxvdyB0aGUgY3VydmF0dXJlIG9mXG4gICAgICAgICAqIHRoZSBFYXJ0aC4gV2hlbiBmYWxzZSwgZWRnZXMgb2YgdGhlIHBvbHlnb24gYXJlIHJlbmRlcmVkIGFzIHN0cmFpZ2h0IGxpbmVzIGluIHNjcmVlbiBzcGFjZS5cbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBzaGFwZSBvZiBhIGdlb2Rlc2ljIHBvbHlnb24gbWF5IGFwcGVhciB0byBjaGFuZ2Ugd2hlbiBkcmFnZ2VkLCBhcyB0aGUgZGltZW5zaW9uc1xuICAgICAgICAgKiBhcmUgbWFpbnRhaW5lZCByZWxhdGl2ZSB0byB0aGUgc3VyZmFjZSBvZiB0aGUgZWFydGguIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW9kZXNpYyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHBvbHlsaW5lIGlzIHZpc2libGUgb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVEYmxDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHJlcGVhdGVkbHkgZmlyZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIHBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lRHJhZyA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lRHJhZ0VuZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBwb2x5bGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZURyYWdTdGFydCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZWRvd24gZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lTW91c2VEb3duID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVNb3VzZU1vdmUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBQb2x5bGluZSBtb3VzZW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZU1vdXNlT3V0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWxpbmUgbW91c2VvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lTW91c2VPdmVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZU1vdXNlVXAgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVuIGlzIGZpcmVkIHdoZW4gdGhlIFBvbHlsaW5lIGlzIHJpZ2h0LWNsaWNrZWQgb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVSaWdodENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVBZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuX2lkID0gKHBvbHlsaW5lSWQrKykudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gcG9pbnQucG9zaXRpb25DaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IF90aGlzLl9wb2x5bGluZU1hbmFnZXIudXBkYXRlUG9seWxpbmVQb2ludHMoX3RoaXMpOyB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wb2x5bGluZUFkZGVkVG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSB0aGlzLnBvaW50cy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcG9seWxpbmVNYW5hZ2VyLnVwZGF0ZVBvbHlsaW5lUG9pbnRzKF90aGlzKTsgfSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVNYW5hZ2VyLnVwZGF0ZVBvbHlsaW5lUG9pbnRzKHRoaXMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5fcG9seWxpbmVBZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBTZWJtR29vZ2xlTWFwUG9seWxpbmUuX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTE7IH0pO1xuICAgICAgICBvcHRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHsgcmV0dXJuIG9wdGlvbnNba10gPSBjaGFuZ2VzW2tdLmN1cnJlbnRWYWx1ZTsgfSk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlci5zZXRQb2x5bGluZU9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb2x5bGluZU1hbmFnZXIuYWRkUG9seWxpbmUodGhpcyk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lQWRkZWRUb01hbmFnZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lQ2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RiY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVEYmxDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZycsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZURyYWcuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdlbmQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVEcmFnRW5kLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVEcmFnU3RhcnQuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlZG93bicsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZU1vdXNlRG93bi5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lTW91c2VNb3ZlLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZU1vdXNlT3V0LmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVNb3VzZU92ZXIuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNldXAnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVNb3VzZVVwLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lUmlnaHRDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICBdO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9wb2x5bGluZU1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKG9iai5uYW1lLCBfdGhpcykuc3Vic2NyaWJlKG9iai5oYW5kbGVyKTtcbiAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25zLnB1c2gob3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvdG90eXBlLl9nZXRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb2x5bGluZU1hbmFnZXIuZGVsZXRlUG9seWxpbmUodGhpcyk7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGFsbCByZWdpc3RlcmVkIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUuX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdkcmFnZ2FibGUnLCAnZWRpdGFibGUnLCAndmlzaWJsZScsICdnZW9kZXNpYycsICdzdHJva2VDb2xvcicsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdlaWdodCcsXG4gICAgICAgICd6SW5kZXgnXG4gICAgXTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3NlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZScsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsaWNrYWJsZScsICdkcmFnZ2FibGU6IHBvbHlsaW5lRHJhZ2dhYmxlJywgJ2VkaXRhYmxlJywgJ2dlb2Rlc2ljJywgJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VXZWlnaHQnLCAnc3Ryb2tlT3BhY2l0eScsICd2aXNpYmxlJywgJ3pJbmRleCdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmVDbGljaycsICdsaW5lRGJsQ2xpY2snLCAnbGluZURyYWcnLCAnbGluZURyYWdFbmQnLCAnbGluZU1vdXNlRG93bicsICdsaW5lTW91c2VNb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lTW91c2VPdXQnLCAnbGluZU1vdXNlT3ZlcicsICdsaW5lTW91c2VVcCcsICdsaW5lUmlnaHRDbGljaydcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHBvbHlsaW5lX21hbmFnZXJfMS5Qb2x5bGluZU1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdwb2ludHMnOiBbeyB0eXBlOiBjb3JlXzEuQ29udGVudENoaWxkcmVuLCBhcmdzOiBbZ29vZ2xlX21hcF9wb2x5bGluZV9wb2ludF8xLlNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50LF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBQb2x5bGluZTtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBQb2x5bGluZSA9IFNlYm1Hb29nbGVNYXBQb2x5bGluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtcG9seWxpbmUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50IHJlcHJlc2VudHMgb25lIGVsZW1lbnQgb2YgYSBwb2x5bGluZSB3aXRoaW4gYSAge0BsaW5rXG4gKiBTZW1iR29vZ2xlTWFwUG9seWxpbmV9XG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZWQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snbGF0aXR1ZGUnXSB8fCBjaGFuZ2VzWydsb25naXR1ZGUnXSkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIGxhdDogY2hhbmdlc1snbGF0aXR1ZGUnXS5jdXJyZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgbG5nOiBjaGFuZ2VzWydsb25naXR1ZGUnXS5jdXJyZW50VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlZC5lbWl0KHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ3NlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCcgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnbGF0aXR1ZGUnOiBbeyB0eXBlOiBjb3JlXzEuSW5wdXQgfSxdLFxuICAgICAgICAnbG9uZ2l0dWRlJzogW3sgdHlwZTogY29yZV8xLklucHV0IH0sXSxcbiAgICAgICAgJ3Bvc2l0aW9uQ2hhbmdlZCc6IFt7IHR5cGU6IGNvcmVfMS5PdXRwdXQgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50O1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQgPSBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lLXBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9nb29nbGUtbWFwcy1hcGktd3JhcHBlcicpO1xuZXhwb3J0cy5Hb29nbGVNYXBzQVBJV3JhcHBlciA9IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXI7XG52YXIgY2lyY2xlX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMvY2lyY2xlLW1hbmFnZXInKTtcbmV4cG9ydHMuQ2lyY2xlTWFuYWdlciA9IGNpcmNsZV9tYW5hZ2VyXzEuQ2lyY2xlTWFuYWdlcjtcbnZhciBpbmZvX3dpbmRvd19tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hbmFnZXJzL2luZm8td2luZG93LW1hbmFnZXInKTtcbmV4cG9ydHMuSW5mb1dpbmRvd01hbmFnZXIgPSBpbmZvX3dpbmRvd19tYW5hZ2VyXzEuSW5mb1dpbmRvd01hbmFnZXI7XG52YXIgbWFya2VyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMvbWFya2VyLW1hbmFnZXInKTtcbmV4cG9ydHMuTWFya2VyTWFuYWdlciA9IG1hcmtlcl9tYW5hZ2VyXzEuTWFya2VyTWFuYWdlcjtcbnZhciBwb2x5Z29uX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMvcG9seWdvbi1tYW5hZ2VyJyk7XG5leHBvcnRzLlBvbHlnb25NYW5hZ2VyID0gcG9seWdvbl9tYW5hZ2VyXzEuUG9seWdvbk1hbmFnZXI7XG52YXIgcG9seWxpbmVfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyJyk7XG5leHBvcnRzLlBvbHlsaW5lTWFuYWdlciA9IHBvbHlsaW5lX21hbmFnZXJfMS5Qb2x5bGluZU1hbmFnZXI7XG52YXIga21sX2xheWVyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMva21sLWxheWVyLW1hbmFnZXInKTtcbmV4cG9ydHMuS21sTGF5ZXJNYW5hZ2VyID0ga21sX2xheWVyX21hbmFnZXJfMS5LbWxMYXllck1hbmFnZXI7XG52YXIgbGF6eV9tYXBzX2FwaV9sb2FkZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyJyk7XG5leHBvcnRzLkdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbCA9IGxhenlfbWFwc19hcGlfbG9hZGVyXzEuR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sO1xuZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyA9IGxhenlfbWFwc19hcGlfbG9hZGVyXzEuTEFaWV9NQVBTX0FQSV9DT05GSUc7XG5leHBvcnRzLkxhenlNYXBzQVBJTG9hZGVyID0gbGF6eV9tYXBzX2FwaV9sb2FkZXJfMS5MYXp5TWFwc0FQSUxvYWRlcjtcbnZhciBtYXBzX2FwaV9sb2FkZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL21hcHMtYXBpLWxvYWRlcicpO1xuZXhwb3J0cy5NYXBzQVBJTG9hZGVyID0gbWFwc19hcGlfbG9hZGVyXzEuTWFwc0FQSUxvYWRlcjtcbnZhciBub29wX21hcHNfYXBpX2xvYWRlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbm9vcC1tYXBzLWFwaS1sb2FkZXInKTtcbmV4cG9ydHMuTm9PcE1hcHNBUElMb2FkZXIgPSBub29wX21hcHNfYXBpX2xvYWRlcl8xLk5vT3BNYXBzQVBJTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGJyb3dzZXJfZ2xvYmFsc18xID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3Nlci1nbG9iYWxzJyk7XG52YXIgbWFwc19hcGlfbG9hZGVyXzEgPSByZXF1aXJlKCcuL21hcHMtYXBpLWxvYWRlcicpO1xuKGZ1bmN0aW9uIChHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wpIHtcbiAgICBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2xbR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW1wiSFRUUFwiXSA9IDFdID0gXCJIVFRQXCI7XG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkhUVFBTXCJdID0gMl0gPSBcIkhUVFBTXCI7XG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkFVVE9cIl0gPSAzXSA9IFwiQVVUT1wiO1xufSkoZXhwb3J0cy5Hb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wgfHwgKGV4cG9ydHMuR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sID0ge30pKTtcbnZhciBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wgPSBleHBvcnRzLkdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbDtcbi8qKlxuICogVG9rZW4gZm9yIHRoZSBjb25maWcgb2YgdGhlIExhenlNYXBzQVBJTG9hZGVyLiBQbGVhc2UgcHJvdmlkZSBhbiBvYmplY3Qgb2YgdHlwZSB7QGxpbmtcbiAqIExhenlNYXBzQVBJTG9hZGVyQ29uZmlnfS5cbiAqL1xuZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyA9IG5ldyBjb3JlXzEuT3BhcXVlVG9rZW4oJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzIExBWllfTUFQU19BUElfQ09ORklHJyk7XG52YXIgTGF6eU1hcHNBUElMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXp5TWFwc0FQSUxvYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXp5TWFwc0FQSUxvYWRlcihjb25maWcsIHcsIGQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgdGhpcy5fd2luZG93UmVmID0gdztcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWYgPSBkO1xuICAgIH1cbiAgICBMYXp5TWFwc0FQSUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmlwdCA9IHRoaXMuX2RvY3VtZW50UmVmLmdldE5hdGl2ZURvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIHZhciBjYWxsYmFja05hbWUgPSBcImFuZ3VsYXIyR29vZ2xlTWFwc0xhenlNYXBzQVBJTG9hZGVyXCI7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLl9nZXRTY3JpcHRTcmMoY2FsbGJhY2tOYW1lKTtcbiAgICAgICAgdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5fd2luZG93UmVmLmdldE5hdGl2ZVdpbmRvdygpW2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoKSB7IHJlc29sdmUoKTsgfTtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7IHJlamVjdChlcnJvcik7IH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kb2N1bWVudFJlZi5nZXROYXRpdmVEb2N1bWVudCgpLmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlO1xuICAgIH07XG4gICAgTGF6eU1hcHNBUElMb2FkZXIucHJvdG90eXBlLl9nZXRTY3JpcHRTcmMgPSBmdW5jdGlvbiAoY2FsbGJhY2tOYW1lKSB7XG4gICAgICAgIHZhciBwcm90b2NvbFR5cGUgPSAodGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5wcm90b2NvbCkgfHwgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFBTO1xuICAgICAgICB2YXIgcHJvdG9jb2w7XG4gICAgICAgIHN3aXRjaCAocHJvdG9jb2xUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5BVVRPOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5IVFRQOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHA6JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFBTOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHBzOic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvc3RBbmRQYXRoID0gdGhpcy5fY29uZmlnLmhvc3RBbmRQYXRoIHx8ICdtYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzJztcbiAgICAgICAgdmFyIHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgICAgICAgdjogdGhpcy5fY29uZmlnLmFwaVZlcnNpb24gfHwgJzMnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrTmFtZSxcbiAgICAgICAgICAgIGtleTogdGhpcy5fY29uZmlnLmFwaUtleSxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5fY29uZmlnLmNsaWVudElkLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5fY29uZmlnLmNoYW5uZWwsXG4gICAgICAgICAgICBsaWJyYXJpZXM6IHRoaXMuX2NvbmZpZy5saWJyYXJpZXMsXG4gICAgICAgICAgICByZWdpb246IHRoaXMuX2NvbmZpZy5yZWdpb24sXG4gICAgICAgICAgICBsYW5ndWFnZTogdGhpcy5fY29uZmlnLmxhbmd1YWdlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhxdWVyeVBhcmFtcylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHF1ZXJ5UGFyYW1zW2tdICE9IG51bGw7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgYXJyYXlzXG4gICAgICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pICYmIHF1ZXJ5UGFyYW1zW2tdLmxlbmd0aCA+IDApO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgLy8gam9pbiBhcnJheXMgYXMgY29tbWEgc2VwZXJhdGVkIHN0cmluZ3NcbiAgICAgICAgICAgIHZhciBpID0gcXVlcnlQYXJhbXNba107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGtleTogaywgdmFsdWU6IGkuam9pbignLCcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGssIHZhbHVlOiBxdWVyeVBhcmFtc1trXSB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmtleSArIFwiPVwiICsgZW50cnkudmFsdWU7IH0pXG4gICAgICAgICAgICAuam9pbignJicpO1xuICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBcIi8vXCIgKyBob3N0QW5kUGF0aCArIFwiP1wiICsgcGFyYW1zO1xuICAgIH07XG4gICAgTGF6eU1hcHNBUElMb2FkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTGF6eU1hcHNBUElMb2FkZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IGJyb3dzZXJfZ2xvYmFsc18xLldpbmRvd1JlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBicm93c2VyX2dsb2JhbHNfMS5Eb2N1bWVudFJlZiwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBMYXp5TWFwc0FQSUxvYWRlcjtcbn0obWFwc19hcGlfbG9hZGVyXzEuTWFwc0FQSUxvYWRlcikpO1xuZXhwb3J0cy5MYXp5TWFwc0FQSUxvYWRlciA9IExhenlNYXBzQVBJTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eS1tYXBzLWFwaS1sb2FkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBXaW5kb3dSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd1JlZigpIHtcbiAgICB9XG4gICAgV2luZG93UmVmLnByb3RvdHlwZS5nZXROYXRpdmVXaW5kb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3c7IH07XG4gICAgcmV0dXJuIFdpbmRvd1JlZjtcbn0oKSk7XG5leHBvcnRzLldpbmRvd1JlZiA9IFdpbmRvd1JlZjtcbnZhciBEb2N1bWVudFJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9jdW1lbnRSZWYoKSB7XG4gICAgfVxuICAgIERvY3VtZW50UmVmLnByb3RvdHlwZS5nZXROYXRpdmVEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50OyB9O1xuICAgIHJldHVybiBEb2N1bWVudFJlZjtcbn0oKSk7XG5leHBvcnRzLkRvY3VtZW50UmVmID0gRG9jdW1lbnRSZWY7XG5leHBvcnRzLkJST1dTRVJfR0xPQkFMU19QUk9WSURFUlMgPSBbV2luZG93UmVmLCBEb2N1bWVudFJlZl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLWdsb2JhbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvdXRpbHMvYnJvd3Nlci1nbG9iYWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogV2hlbiB1c2luZyB0aGUgTm9PcE1hcHNBUElMb2FkZXIsIHRoZSBHb29nbGUgTWFwcyBBUEkgbXVzdCBiZSBhZGRlZCB0byB0aGUgcGFnZSB2aWEgYSBgPHNjcmlwdD5gXG4gKiBUYWcuXG4gKiBJdCdzIGltcG9ydGFudCB0aGF0IHRoZSBHb29nbGUgTWFwcyBBUEkgc2NyaXB0IGdldHMgbG9hZGVkIGZpcnN0IG9uIHRoZSBwYWdlLlxuICovXG52YXIgTm9PcE1hcHNBUElMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vT3BNYXBzQVBJTG9hZGVyKCkge1xuICAgIH1cbiAgICBOb09wTWFwc0FQSUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cuZ29vZ2xlIHx8ICF3aW5kb3cuZ29vZ2xlLm1hcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR29vZ2xlIE1hcHMgQVBJIG5vdCBsb2FkZWQgb24gcGFnZS4gTWFrZSBzdXJlIHdpbmRvdy5nb29nbGUubWFwcyBpcyBhdmFpbGFibGUhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBOb09wTWFwc0FQSUxvYWRlcjtcbn0oKSk7XG5leHBvcnRzLk5vT3BNYXBzQVBJTG9hZGVyID0gTm9PcE1hcHNBUElMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub29wLW1hcHMtYXBpLWxvYWRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbm9vcC1tYXBzLWFwaS1sb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBnb29nbGVfbWFwX2ttbF9sYXllcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAta21sLWxheWVyJyk7XG52YXIgZ29vZ2xlX21hcF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAnKTtcbnZhciBnb29nbGVfbWFwX2NpcmNsZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtY2lyY2xlJyk7XG52YXIgZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtaW5mby13aW5kb3cnKTtcbnZhciBnb29nbGVfbWFwX21hcmtlcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtbWFya2VyJyk7XG52YXIgZ29vZ2xlX21hcF9wb2x5Z29uXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5Z29uJyk7XG52YXIgZ29vZ2xlX21hcF9wb2x5bGluZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUnKTtcbnZhciBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCcpO1xudmFyIGxhenlfbWFwc19hcGlfbG9hZGVyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9sYXp5LW1hcHMtYXBpLWxvYWRlcicpO1xudmFyIGxhenlfbWFwc19hcGlfbG9hZGVyXzIgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9sYXp5LW1hcHMtYXBpLWxvYWRlcicpO1xudmFyIG1hcHNfYXBpX2xvYWRlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbWFwcy1hcGktbG9hZGVyJyk7XG52YXIgYnJvd3Nlcl9nbG9iYWxzXzEgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXItZ2xvYmFscycpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY29yZURpcmVjdGl2ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZ29vZ2xlX21hcF8xLlNlYm1Hb29nbGVNYXAsIGdvb2dsZV9tYXBfbWFya2VyXzEuU2VibUdvb2dsZU1hcE1hcmtlciwgZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xLlNlYm1Hb29nbGVNYXBJbmZvV2luZG93LCBnb29nbGVfbWFwX2NpcmNsZV8xLlNlYm1Hb29nbGVNYXBDaXJjbGUsXG4gICAgICAgIGdvb2dsZV9tYXBfcG9seWdvbl8xLlNlYm1Hb29nbGVNYXBQb2x5Z29uLCBnb29nbGVfbWFwX3BvbHlsaW5lXzEuU2VibUdvb2dsZU1hcFBvbHlsaW5lLCBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEuU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQsIGdvb2dsZV9tYXBfa21sX2xheWVyXzEuU2VibUdvb2dsZU1hcEttbExheWVyXG4gICAgXTtcbn1cbmV4cG9ydHMuY29yZURpcmVjdGl2ZXMgPSBjb3JlRGlyZWN0aXZlcztcbjtcbi8qKlxuICogVGhlIGFuZ3VsYXIyLWdvb2dsZS1tYXBzIGNvcmUgbW9kdWxlLiBDb250YWlucyBhbGwgRGlyZWN0aXZlcy9TZXJ2aWNlcy9QaXBlc1xuICogb2YgdGhlIGNvcmUgbW9kdWxlLiBQbGVhc2UgdXNlIGBBZ21Db3JlTW9kdWxlLmZvclJvb3QoKWAgaW4geW91ciBhcHAgbW9kdWxlLlxuICovXG52YXIgQWdtQ29yZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWdtQ29yZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxlYXNlIHVzZSB0aGlzIG1ldGhvZCB3aGVuIHlvdSByZWdpc3RlciB0aGUgbW9kdWxlIGF0IHRoZSByb290IGxldmVsLlxuICAgICAqL1xuICAgIEFnbUNvcmVNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uIChsYXp5TWFwc0FQSUxvYWRlckNvbmZpZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEFnbUNvcmVNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IGJyb3dzZXJfZ2xvYmFsc18xLkJST1dTRVJfR0xPQkFMU19QUk9WSURFUlMuY29uY2F0KFtcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IG1hcHNfYXBpX2xvYWRlcl8xLk1hcHNBUElMb2FkZXIsIHVzZUNsYXNzOiBsYXp5X21hcHNfYXBpX2xvYWRlcl8xLkxhenlNYXBzQVBJTG9hZGVyIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBsYXp5X21hcHNfYXBpX2xvYWRlcl8yLkxBWllfTUFQU19BUElfQ09ORklHLCB1c2VWYWx1ZTogbGF6eU1hcHNBUElMb2FkZXJDb25maWcgfVxuICAgICAgICAgICAgXSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBZ21Db3JlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nTW9kdWxlLCBhcmdzOiBbeyBkZWNsYXJhdGlvbnM6IGNvcmVEaXJlY3RpdmVzKCksIGV4cG9ydHM6IGNvcmVEaXJlY3RpdmVzKCkgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBBZ21Db3JlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIEFnbUNvcmVNb2R1bGU7XG59KCkpO1xuZXhwb3J0cy5BZ21Db3JlTW9kdWxlID0gQWdtQ29yZU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUtbW9kdWxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2NvcmUtbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUFJBQ1RJQ0VfREFUQSB9IGZyb20gJy4vZGF0YS9wcmFjdGljZS5kYXRhJztcbmltcG9ydCB7IFByYWN0aWNlIH0gZnJvbSAnLi9tb2RlbC9wcmFjdGljZS5tb2RlbCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncHJhY3RpY2UnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3ByYWN0aWNlLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9wcmFjdGljZS5jb21wb25lbnQubGVzcycpXVxufSlcbmV4cG9ydCBjbGFzcyBQcmFjdGljZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgLy8gUHJhY3RpY2UgZGF0YSB0byBpbmplY3QgaW50byBvdXIgdGVtcGxhdGVcbiAgICBwcml2YXRlIHByYWN0aWNlRGF0YTogUHJhY3RpY2VbXSA9IFBSQUNUSUNFX0RBVEE7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9wcmFjdGljZS5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBQcmFjdGljZSB9IGZyb20gJy4uL21vZGVsL3ByYWN0aWNlLm1vZGVsJztcblxuZXhwb3J0IGNvbnN0IFBSQUNUSUNFX0RBVEE6IFByYWN0aWNlW10gPSBbXG4gICAge1xuICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgd2hhdDogJ05vcm1hbCBQcmFjdGljZScsXG4gICAgICAgIHRpbWU6ICc0OjMwUE0tN1BNJyxcbiAgICAgICAgd2hlbjogJ01vbmRheXMgJiBXZWRuZXNkYXlzJyxcbiAgICAgICAgbG9jYXRpb25MYWJlbDogJ0NvbXBsZXggRmllbGRzJyxcbiAgICAgICAgbG9jYXRpb25MaW5rOlxuICAgICAgICAgICAgJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20vbWFwcy9wbGFjZS9GbG9yaWRhK2FuZCtMaW5jb2xuK1BsYXlpbmcrRmllbGQvQDQwLjA5NjY5NjQsLTg4LjIyNDI4MDYsMTZ6L2RhdGE9ITRtNSExbTIhMm0xITFzY29tcGxleCtmaWVsZHMhM20xITFzMHgwMDAwMDAwMDAwMDAwMDAwOjB4MTM2MzM4NDA4OTZlMjViZidcbiAgICB9LFxuICAgIC8ve1xuICAgIC8vc2Vhc29uOiAnRmFsbCcsXG4gICAgLy93aGF0OiAnV2Vla2VuZCBJbnZpdGUgUHJhY3RpY2UnLFxuICAgIC8vdGltZTogJ1RCRCcsXG4gICAgLy93aGVuOiAnV2Vla2VuZHMnLFxuICAgIC8vbG9jYXRpb25MYWJlbDogJ0NvbXBsZXggRmllbGRzJyxcbiAgICAvL2xvY2F0aW9uTGluazpcbiAgICAvLydodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvcGxhY2UvRmxvcmlkYSthbmQrTGluY29sbitQbGF5aW5nK0ZpZWxkL0A0MC4wOTY2OTY0LC04OC4yMjQyODA2LDE2ei9kYXRhPSE0bTUhMW0yITJtMSExc2NvbXBsZXgrZmllbGRzITNtMSExczB4MDAwMDAwMDAwMDAwMDAwMDoweDEzNjMzODQwODk2ZTI1YmYnXG4gICAgLy99LFxuICAgIHtcbiAgICAgICAgc2Vhc29uOiAnV2ludGVyJyxcbiAgICAgICAgd2hhdDogJ05vcm1hbCBQcmFjdGljZScsXG4gICAgICAgIHRpbWU6ICc5OjMwUE0tMTJBTScsXG4gICAgICAgIHdoZW46ICdNb25kYXlzICYgV2VkbmVzZGF5cycsXG4gICAgICAgIGxvY2F0aW9uTGFiZWw6ICdBcm1vcnknLFxuICAgICAgICBsb2NhdGlvbkxpbms6XG4gICAgICAgICAgICAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL3BsYWNlL0FybW9yeS9ANDAuMTA1NDAyLC04OC4yMzU1MzQsMTd6L2RhdGE9ITNtMSE1czB4ODgwY2Q3M2I4YzRmYmI3ZDoweGE4NDg5MDExMGFmZDA5OTAhNG03ITFtNCEzbTMhMXMweDg4MGNkNzNhMTZjMWQ3OGY6MHhlMWJiMDA5MjI1ZmMxMjI1ITJzRStBcm1vcnkrQXZlLCtDaGFtcGFpZ24sK0lMKzYxODIwITNiMSEzbTEhMXMweDAwMDAwMDAwMDAwMDAwMDA6MHgwYjIxZDU2ZjJiOTUxOTc4J1xuICAgIH0sXG4gICAge1xuICAgICAgICBzZWFzb246ICdXaW50ZXInLFxuICAgICAgICB3aGF0OiAnSW5kb29yIEZpZWxkIFByYWN0aWNlJyxcbiAgICAgICAgdGltZTogJzlQTS0xMVBNJyxcbiAgICAgICAgd2hlbjogJ1RodXJzZGF5cycsXG4gICAgICAgIGxvY2F0aW9uTGFiZWw6ICdJcndpbiBGYWNpbGl0eScsXG4gICAgICAgIGxvY2F0aW9uTGluazpcbiAgICAgICAgICAgICdodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvcGxhY2UvSXJ3aW4rSW5kb29yK0Zvb3RiYWxsK0ZhY2lsaXR5LCtVbml2ZXJzaXR5K29mK0lsbGlub2lzK2F0K1VyYmFuYS1DaGFtcGFpZ24sK0NoYW1wYWlnbiwrSUwrNjE4MjAvQDQwLjEwMDY0NzUsLTg4LjIzNDIyMDQsMTd6L2RhdGE9ITNtMSE0YjEhNG02ITFtMyEzbTIhMXMweDg4MGNkNzI0YTkyNjU1ZTk6MHhhNTNjMDUyNTA0NjgyNmZhITJzVW5pdmVyc2l0eStvZitJbGxpbm9pcythdCtVcmJhbmEtQ2hhbXBhaWduITNtMSExczB4ODgwY2Q3MjUyOTJjMDJiZDoweDE4ZjVhMDNkYWFkODY3N2EnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgIHdoYXQ6ICdOb3JtYWwgUHJhY3RpY2UnLFxuICAgICAgICB0aW1lOiAnNDozMFBNLTdQTScsXG4gICAgICAgIHdoZW46ICdNb25kYXlzICYgV2VkbmVzZGF5cycsXG4gICAgICAgIGxvY2F0aW9uTGFiZWw6ICdDb21wbGV4IEZpZWxkcycsXG4gICAgICAgIGxvY2F0aW9uTGluazpcbiAgICAgICAgICAgICdodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvcGxhY2UvRmxvcmlkYSthbmQrTGluY29sbitQbGF5aW5nK0ZpZWxkL0A0MC4wOTY2OTY0LC04OC4yMjQyODA2LDE2ei9kYXRhPSE0bTUhMW0yITJtMSExc2NvbXBsZXgrZmllbGRzITNtMSExczB4MDAwMDAwMDAwMDAwMDAwMDoweDEzNjMzODQwODk2ZTI1YmYnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgIHdoYXQ6ICdOb3JtYWwgUHJhY3RpY2UnLFxuICAgICAgICB0aW1lOiAnMTFBTS0xUE0nLFxuICAgICAgICB3aGVuOiAnTm9uLVRvdXJuYW1lbnQgV2Vla2VuZHMnLFxuICAgICAgICBsb2NhdGlvbkxhYmVsOiAnQ29tcGxleCBGaWVsZHMnLFxuICAgICAgICBsb2NhdGlvbkxpbms6XG4gICAgICAgICAgICAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL3BsYWNlL0Zsb3JpZGErYW5kK0xpbmNvbG4rUGxheWluZytGaWVsZC9ANDAuMDk2Njk2NCwtODguMjI0MjgwNiwxNnovZGF0YT0hNG01ITFtMiEybTEhMXNjb21wbGV4K2ZpZWxkcyEzbTEhMXMweDAwMDAwMDAwMDAwMDAwMDA6MHgxMzYzMzg0MDg5NmUyNWJmJ1xuICAgIH1cbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9kYXRhL3ByYWN0aWNlLmRhdGEudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPCEtLUhlYWRlci0tPlxcbjxoMSBjbGFzcz1cXFwidWkgaGVhZGVyXFxcIj5QcmFjdGljZTwvaDE+XFxuPCEtLVRhYmxlLS0+XFxuPHRhYmxlIGNsYXNzPVxcXCJ1aSBjZWxsZWQgdGFibGVcXFwiPlxcbiAgICA8dGhlYWQ+XFxuICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRoPlNlYXNvbjwvdGg+XFxuICAgICAgICAgICAgPHRoPldoYXQ8L3RoPlxcbiAgICAgICAgICAgIDx0aD5UaW1lPC90aD5cXG4gICAgICAgICAgICA8dGg+V2hlbjwvdGg+XFxuICAgICAgICAgICAgPHRoPkxvY2F0aW9uPC90aD5cXG4gICAgICAgIDwvdHI+XFxuICAgIDwvdGhlYWQ+XFxuICAgIDx0Ym9keT5cXG4gICAgICAgIDx0ciAqbmdGb3I9XFxcImxldCBwcmFjdGljZVJvdyBvZiBwcmFjdGljZURhdGFcXFwiPlxcbiAgICAgICAgICAgIDx0ZD57e3ByYWN0aWNlUm93LnNlYXNvbn19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+e3twcmFjdGljZVJvdy53aGF0fX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e3ByYWN0aWNlUm93LnRpbWV9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7cHJhY3RpY2VSb3cud2hlbn19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+PGEgY2xhc3M9XFxcInByYWN0aWNlLWxvY2F0aW9uLWxpbmtcXFwiIGhyZWY9XFxcInt7cHJhY3RpY2VSb3cubG9jYXRpb25MaW5rfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj57e3ByYWN0aWNlUm93LmxvY2F0aW9uTGFiZWx9fTwvYT48L3RkPlxcbiAgICAgICAgPC90cj5cXG4gICAgPC90Ym9keT5cXG48L3RhYmxlPlxcblxcbjxpZnJhbWUgc3JjPVxcXCJodHRwczovL2NhbGVuZGFyLmdvb2dsZS5jb20vY2FsZW5kYXIvYi8xL2VtYmVkP2hlaWdodD02MDAmYW1wO3drc3Q9MSZhbXA7Ymdjb2xvcj0lMjNmZmZmZmYmYW1wO2N0ej1BbWVyaWNhJTJGQ2hpY2FnbyZhbXA7c3JjPWFXeHNhVzV2YVhNdVpXUjFYemh4TkhVd1l6TTJhVGxoYnpCbmFqSXdPWE5uZEROek1HcHpRR2R5YjNWd0xtTmhiR1Z1WkdGeUxtZHZiMmRzWlM1amIyMCZhbXA7c3JjPWFXeHNhVzV2YVhNdVpXUjFYemczZFhGelptSnJiekJoWmpVMFptTnVOREZ1ZFdGbmJHVnJRR2R5YjNWd0xtTmhiR1Z1WkdGeUxtZHZiMmRzWlM1amIyMCZhbXA7Y29sb3I9JTIzMzNCNjc5JmFtcDtjb2xvcj0lMjNFNEM0NDEmYW1wO3Nob3dUaXRsZT0wJmFtcDtzaG93TmF2PTEmYW1wO3Nob3dEYXRlPTEmYW1wO3Nob3dQcmludD0wJmFtcDtzaG93VGFicz0xJmFtcDtzaG93Q2FsZW5kYXJzPTEmYW1wO3Nob3dUej0xJmFtcDttb2RlPVdFRUtcXFwiIHN0eWxlPVxcXCJib3JkZXItd2lkdGg6MFxcXCIgd2lkdGg9XFxcIjk1MFxcXCIgaGVpZ2h0PVxcXCI2NTBcXFwiIGZyYW1lYm9yZGVyPVxcXCIwXFxcIiBzY3JvbGxpbmc9XFxcIm5vXFxcIj48L2lmcmFtZT5cXG5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9wcmFjdGljZS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL3ByYWN0aWNlLmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC90ZWFtL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJ0cnt0ZXh0LWFsaWduOmNlbnRlcn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vcG9zdGNzcy1sb2FkZXIvbGliIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9wcmFjdGljZS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuaW1wb3J0IHsgVE9VUk5BTUVOVFNfREFUQSB9IGZyb20gJy4vZGF0YS90b3VybmFtZW50cy5kYXRhJztcbmltcG9ydCB7IFRvdXJuYW1lbnRZZWFyIH0gZnJvbSAnLi9tb2RlbC90b3VybmFtZW50LXllYXIubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3RvdXJuYW1lbnRzJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi90b3VybmFtZW50cy5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vdG91cm5hbWVudHMuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5leHBvcnQgY2xhc3MgVG91cm5hbWVudHNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIC8vIFRvdXJuYW1lbnQgZGF0YSB0byBpbmplY3QgaW50byBvdXIgdGVtcGxhdGVcbiAgICBwcml2YXRlIHRvdXJuYW1lbnREYXRhOiBUb3VybmFtZW50WWVhcltdID0gVE9VUk5BTUVOVFNfREFUQTtcbiAgICAvLyBTdWJzY3JpcHRpb24gdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHRvdXJuYW1lbnQgeWVhcilcbiAgICBwcml2YXRlIHJvdXRlUGFyYW1zU3Vic2NyaXB0aW9uOiBhbnk7XG4gICAgLy8gQ3VycmVudCB0b3VybmFtZW50IHllYXJcbiAgICBwcml2YXRlIHllYXI6IG51bWJlcjtcblxuICAgIC8vIEluamVjdCB0aGUgQWN0aXZhdGVkUm91dGUgaW50byBvdXIgY29tcG9uZW50XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZTogQWN0aXZhdGVkUm91dGUpIHt9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHRvdXJuYW1lbnQgeWVhcikuXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucm91dGVQYXJhbXNTdWJzY3JpcHRpb24gPSB0aGlzLnJvdXRlLnBhcmFtcy5zdWJzY3JpYmUoKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgLy8gKCspIGNvbnZlcnRzIHN0cmluZyAneWVhcicgdG8gYSBudW1iZXJcbiAgICAgICAgICAgIHRoaXMueWVhciA9ICtwYXJhbXNbJ3llYXInXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHRvdXJuYW1lbnQgeWVhcikuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucm91dGVQYXJhbXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBUb3VybmFtZW50WWVhciB9IGZyb20gJy4uL21vZGVsL3RvdXJuYW1lbnQteWVhci5tb2RlbCc7XG5cbmV4cG9ydCBjb25zdCBUT1VSTkFNRU5UU19EQVRBOiBUb3VybmFtZW50WWVhcltdID0gW1xuICAgIHtcbiAgICAgICAgeWVhcjogMjAxOSxcbiAgICAgICAgdG91cm5hbWVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdTdGFubGV5IEN1cCcsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICcnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdTZXB0LiAxNXRoLTE2dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnTm9ybWFsLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnTm8gV2lzY29uc2VxdWVuY2VzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9ub3dpc2NvbnNlcXVlbmNlcy51bHRpbWF0ZWNlbnRyYWwuY29tLycsXG4gICAgICAgICAgICAgICAgd2hlbjogJ09jdC4gNnRoLTd0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdIYXJ0bGFuZCwgV0knLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJ0NhbmNlbGxlZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnTWlzc291cmkgTG92ZXMgQ29tcGFueScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6XG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5mYWNlYm9vay5jb20vTWlzc291cmlMb3Zlc0NvbXBhbnkyMDE4Lz9fX3RuX189a0MtUiZlaWQ9QVJELUtnbGlienZudEZpd2sySklET0Q3eWx6ZUN2WU1idlNCXzk5X1ZNMVVTVk52SGhVSS14Yng5XzVkYVZpR3NodWJwNDhFQU9fSmVlUU4maGNfcmVmPUFSVEpYWm9hUmdyZnAxUzdaRzd3RkVMcngxNlp6cUNRRmNWR2MwUVRnSlJUWFlEaVF6TzV2dno3Qzd3OTh4bEd3bFEmZnJlZj1uZiZfX3h0c19fWzBdPTY4LkFSQ3l1bEtrR2RpTGFMNVJZX2V3QkpKV21Ja1BkWG1ZanlsVmJVMWV2aE9BOGFvRG8yXzRkMS1nVWowSzRYaWNJWS1IRmdOR3JxY2tnaXhyVVdGOHdMbFlMRU9FYmpHSkVMclBWTFFKV05RZC02ak5rc0Jvb2lSck1YREdQSmx1VmdlLTJQQmRVUWlsSnJyTGF0UF9aY0poVllsNTUxZUZzb3A4TlJKYklGVENxSVBzZGFLYmo4R2dlaTRmdks0YlpDS216NzEzemtVZWJBeWcwd29zc0hoYnNSamhmUU92WEs1UXc0SzAxU3FMX09PS1M2VFdYQWlDTmdvNWxQZmpZdlh5djhET0padTF5Zkp4cUJxWEdsdEQ1Z0owMUFQQW9FYm45TVdBTmw0VlB1YnBuQ0pUeVlzREMwNEFDNHNCV2dwZ3RLc1dDQ2t1TlNWQVZVMCcsXG4gICAgICAgICAgICAgICAgd2hlbjogJ05vdmVtYmVyIDNyZC00dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ1QtVG93biBUaHJvd2Rvd24nLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cHM6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvVC1Ub3duLVRocm93ZG93bi8nLFxuICAgICAgICAgICAgICAgIHdoZW46ICdKYW4uIDI2dGgtMjd0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdUdXNjYWxvb3NhLCBBTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnM3JkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogYFByZXNpZGVudCdzIERheSBJbnZpdGVgLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cHM6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvUHJlc2lkZW50cy1EYXktSW52aXRlLTIwMTkvJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnRmViLiAxNnRoLTE4dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnU2FuIERpZWdvLCBDQScsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMTB0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdDZW50ZXgnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cHM6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvQ2VudGV4LTIwMTktTWVuLS8nLFxuICAgICAgICAgICAgICAgIHdoZW46ICdNYXJjaCAxNnRoLTE3dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnQXVzdGluLCBUWCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnOXRoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0h1Y2sgRmlubicsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwczovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9IdWNrLUZpbm4tWFhJSUkvJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnTWFyY2ggMzB0aC0zMXN0JyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1N0LiBDaGFybGVzLCBNTycsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMm5kJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0lsbGlub2lzIENvbmZlcmVuY2VzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHBzOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0lsbGlub2lzLUQtSS1Db2xsZWdlLU1lbnMtQ0MtMjAxOS8nLFxuICAgICAgICAgICAgICAgIHdoZW46ICdBcHJpbCAxM3RoLTE0dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnUmFudG91bCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJ1QtMm5kKidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdHcmVhdCBMYWtlcyBSZWdpb25hbHMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cHM6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvR3JlYXQtTGFrZXMtRC1JLUNvbGxlZ2UtTWVucy1SZWdpb25hbHMtMjAxOS8nLFxuICAgICAgICAgICAgICAgIHdoZW46ICdBcHJpbCAyN3RoLTI4dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnSm9saWV0LCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnM3JkJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTgsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnQm9pbGVyIEJyZWFrYXdheScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwczovL2JvaWxlcmxpbmsucHVyZHVlLmVkdS9ldmVudC85NzI5MjAnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdTZXB0LiAxNnRoLTE3dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnV2VzdCBMYWZheWV0dGUsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdObyBXaXNjb25zZXF1ZW5jZXMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL25vd2lzY29uc2VxdWVuY2VzLnVsdGltYXRlY2VudHJhbC5jb20nLFxuICAgICAgICAgICAgICAgIHdoZW46ICdPY3QuIDd0aC04dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnSGFydGxhbmQsIFdJJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdNaXNzb3VyaSBMb3ZlcyBDb21wYW55JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly91bHRpbWF0ZS5taXNzb3VyaS5lZHUvbWxjLzIwMTcvJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnTm92LiA0dGgtNXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ0NvbHVtYmlhLCBNTycsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdNaWQtQXRsYW50aWMgV2FybXVwJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHBzOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL01pZC1BdGxhbnRpYy1XYXJtdXAtMjAxOC8nLFxuICAgICAgICAgICAgICAgIHdoZW46ICdGZWIuIDNyZC00dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnV2lsbGlhbXNidXJnLCBWQScsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMXN0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogYFByZXNpZGVudCdzIERheSBJbnZpdGVgLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cHM6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvUHJlc2lkZW50cy1EYXktSW52aXRhdGlvbmFsLVRvdXJuYW1lbnQtMjAxOC8nLFxuICAgICAgICAgICAgICAgIHdoZW46ICdGZWIuIDE3dGgtMTl0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdTYW4gRGllZ28sIENBJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICc5dGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnQ2VudGV4JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHBzOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL01lbnMtQ2VudGV4LTIwMTgvJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnTWFyY2ggMTB0aC0xMXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ0F1c3RpbiwgVFgnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJzZ0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdIdWNrIEZpbm4nLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cHM6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvSHVjay1GaW5uLTIwMTgvJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnTWFyY2ggMzFzdC1BcHJpbCAxc3QnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnU3QuIExvdWlzLCBNTycsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMTN0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdJbGxpbm9pcyBDb25mZXJlbmNlcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwczovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9JbGxpbm9pcy1ELUktQ29sbGVnZS1NZW5zLUNDLTIwMTgvJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnQXByaWwgMTR0aC0xNXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1JhbnRvdWwsIElMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICcybmQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnR3JlYXQgTGFrZXMgUmVnaW9uYWxzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHBzOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0dyZWF0LUxha2VzLUQtSS1Db2xsZWdlLU1lbnMtUmVnaW9uYWxzLTIwMTgvJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnQXByaWwgMjh0aC0yOXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ0JyaWdodG9uLCBNSScsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnVC0zcmQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNyxcbiAgICAgICAgdG91cm5hbWVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdCb2lsZXIgQnJlYWthd2F5JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHBzOi8vYm9pbGVybGluay5wdXJkdWUuZWR1L29yZ2FuaXphdGlvbi9tZW5zdWx0aW1hdGUvY2FsZW5kYXIvZGV0YWlscy85NzI5MjAnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdTZXB0LiAxN3RoLTE4dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnV2VzdCBMYWZheWV0dGUsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdObyBXaXNjb25zZXF1ZW5jZXMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL25vd2lzY29uc2VxdWVuY2VzLnVsdGltYXRlY2VudHJhbC5jb20nLFxuICAgICAgICAgICAgICAgIHdoZW46ICdPY3QuIDh0aC05dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnSGFydGxhbmQsIFdJJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdNaXNzb3VyaSBMb3ZlcyBDb21wYW55JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly91bHRpbWF0ZS5taXNzb3VyaS5lZHUvbWxjLzIwMTYnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdOb3YuIDV0aC02dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogYFByZXNpZGVudCdzIERheSBJbnZpdGVgLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9QcmVzaWRlbnRzLURheS1Ub3VybmFtZW50LTIwMTcnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdGZWIuIDE3dGgtMjB0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdTYW4gRGllZ28sIENBJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICc1dGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnQ2VudGV4JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvQ2VudGV4LTIwMTctT3BlbicsXG4gICAgICAgICAgICAgICAgd2hlbjogJ01hcmNoIDEwdGgtMTN0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdBdXN0aW4sIFRYJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICc3dGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnSHVjayBGaW5uJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvSHVjay1GaW5uLTIwMTcnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdBcHJpbCAxc3QtMm5kJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1N0LiBMb3VpcywgTU8nLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJzExdGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnSWxsaW5vaXMgQ29uZmVyZW5jZXMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9JbGxpbm9pcy1ELUktQ29sbGVnZS1NZW5zLUNDLTIwMTcnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdBcHJpbCAyMm5kLTIzcmQnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnUmFudG91bCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJzJuZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdHcmVhdCBMYWtlcyBSZWdpb25hbHMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9HcmVhdC1MYWtlcy1ELUktQ29sbGVnZS1NZW5zLVJlZ2lvbmFscy0yMDE3JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnTWF5IDZ0aC03dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnRmFpciBPYWtzLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnNnRoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnQm9pbGVyIEJyZWFrYXdheScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwczovL3d3dy5yZWRkaXQuY29tL3IvdWx0aW1hdGUvY29tbWVudHMvMzhneTcyL25ld19maWVsZHNfYm9pbGVyX2JyZWFrYXdheV8yMDE1X2hvc3RlZF9ieV91bmR1ZScsXG4gICAgICAgICAgICAgICAgd2hlbjogJ1NlcHQuIDE5dGgtMjB0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdXZXN0ZmllbGQsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdIdWNrIG9mIHRoZSBJcmlzaCcsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwczovL25kdWx0aW1hdGUud29yZHByZXNzLmNvbS9ob3RpJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnT2N0LiAzcmQtNHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1NvdXRoIEJlbmQsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdDaGljYWdvIEludml0ZScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vd3d3LmNoaWNhZ29pbnZpdGUuY29tJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnT2N0LiAxN3RoLTE4dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnUm9ja2ZvcmQsIElMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdNaXNzb3VyaSBMb3ZlcyBDb21wYW55JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly91bHRpd29ybGQuY29tLzIwMTUvMTEvMTIvbWlzc291cmktbG92ZXMtY29tcGFueS0yMDE1LXRvdXJuYW1lbnQtcmVjYXAtbWVucycsXG4gICAgICAgICAgICAgICAgd2hlbjogJ05vdi4gN3RoLTh0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdDb2x1bWJpYSwgTU8nLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJzEwdGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnRmxvcmlkYSBXYXJtdXAnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9XYXJtLXVwLUEtRmxvcmlkYS1BZmZhaXItMjAxNicsXG4gICAgICAgICAgICAgICAgd2hlbjogJ0ZlYi4gMTF0aC0xNHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1RhbXBhLCBGTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMTV0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdFYXN0ZXJucycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0NvbGxlZ2UtRWFzdGVybnMtMjAxNicsXG4gICAgICAgICAgICAgICAgd2hlbjogJ01hcmNoIDE4dGgtMjB0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdOb3J0aCBNeXJ0bGUgQmVhY2gsIFNDJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICcxOXRoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0h1Y2sgRmlubicsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0h1Y2stRmlubi1YWC0yMDE2JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnRmViLiAxMXRoLTE0dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnU3QuIExvdWlzLCBNTycsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMTF0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdJbGxpbm9pcyBDb25mZXJlbmNlcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0lsbGlub2lzLUQtSS1Db2xsZWdlLU1lbnMtQ0MtMjAxNicsXG4gICAgICAgICAgICAgICAgd2hlbjogJ0FwcmlsIDE2dGgtMTd0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdSYW50b3VsLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnM3JkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0dyZWF0IExha2VzIFJlZ2lvbmFscycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0dyZWF0LUxha2VzLUQtSS1Db2xsZWdlLU1lbnMtUmVnaW9uYWxzLTIwMTYnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdBcHJpbCAzMHRoLU1heSAxc3QnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnRmFpciBPYWtzLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnM3JkJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTUsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnSHVjayBvZiB0aGUgSXJpc2gnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cHM6Ly9uZHVsdGltYXRlLndvcmRwcmVzcy5jb20vd2hpdGVzbW9rZScsXG4gICAgICAgICAgICAgICAgd2hlbjogJ1NlcHQuIDI3dGgtMjh0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdTb3V0aCBCZW5kLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnR2xvcnkgRGF5cycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vd3d3LnN1bi11bHRpbWF0ZS5vcmcvZ2xvcnktZGF5cy5odG1sJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnT2N0LiA0dGgtNXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1JvY2tmb3JkLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnSWxsaW5vaXMgSW52aXRlJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHBzOi8vaWxsaW5vaXMuY29sbGVnaWF0ZWxpbmsubmV0L29yZ2FuaXphdGlvbi9pbGxpbm9pc21lbnN1bHRpbWF0ZWZyaXNiZWV0ZWFtL2NhbGVuZGFyL2RldGFpbHMvNTA0MjA0JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnT2N0LiAxOHRoLTE5dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnUmFudG91bCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ01pc3NvdXJpIExvdmVzIENvbXBhbnknLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL3VsdGl3b3JsZC5jb20vMjAxNC8xMS8wNi9taXNzb3VyaS1sb3Zlcy1jb21wYW55LTIwMTQtdG91cm5hbWVudC1wcmV2aWV3LW1lbnMnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdOb3YuIDh0aC05dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0Zsb3JpZGEgV2FybXVwJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvV2FybS1VcC1BLUZsb3JpZGEtQWZmYWlyLTIwMTUnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdGZWIuIDEzdGgtMTV0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdUYW1wYSwgRkwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJzEzdGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnQ2VudGV4IEludml0ZScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0NlbnRleC1JbnZpdGUtMjAxNScsXG4gICAgICAgICAgICAgICAgd2hlbjogJ01hcmNoIDE0dGgtMTV0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdBdXN0aW4sIFRYJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICcxN3RoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0Vhc3Rlcm5zJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvRWFzdGVybnMtMjAxNScsXG4gICAgICAgICAgICAgICAgd2hlbjogJ01hcmNoIDI3dGgtMjl0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdOb3J0aCBNeXJ0bGUgQmVhY2gsIFNDJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICcxN3RoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0lsbGlub2lzIENvbmZlcmVuY2VzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvSWxsaW5vaXMtRC1JLUNvbGxlZ2UtTWVucy1DQy0yMDE1JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnQXByaWwgMTF0aC0xMnRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1JhbnRvdWwsIElMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICcybmQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnR3JlYXQgTGFrZXMgUmVnaW9uYWxzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvR3JlYXQtTGFrZXMtRC1JLUNvbGxlZ2UtTWVucy1SZWdpb25hbHMtMjAxNScsXG4gICAgICAgICAgICAgICAgd2hlbjogJ0FwcmlsIDI1dGgtMjZ0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdSb2NrZm9yZCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJzFzdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdELUkgTmF0aW9uYWwgQ2hhbXBpb25zaGlwcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL1VTQS1VbHRpbWF0ZS1ELUktQ29sbGVnZS1DaGFtcGlvbnNoaXBzLTIwMTUnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdNYXkgMjJuZC0yNXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ01pbHdhdWtlZSwgV0knLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJzEzdGgnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNCxcbiAgICAgICAgdG91cm5hbWVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdCb2lsZXIgQnJlYWthd2F5JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTM0MjInLFxuICAgICAgICAgICAgICAgIHdoZW46ICdPY3QuIDV0aC02dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnV2VzdCBMYWZheWV0dGUsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdJbGxpbm9pcyBJbnZpdGUnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMzM1MCcsXG4gICAgICAgICAgICAgICAgd2hlbjogJ09jdC4gMTJ0aC0xM3RoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1JhbnRvdWwsIElMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdNaWNoaWdhbiBSb3VuZCBSb2JpbicsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICcnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdPY3QuIDIwdGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnQW5uIEFyYm9yLCBNSScsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnR2xvcnkgRGF5cycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMvI2NvbGxlZ2Utb3Blbi90b3VybmFtZW50LzEzNDk5JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnT2N0LiAyNnRoLTI3dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnUm9ja2ZvcmQsIElMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdNaXNzb3VyaSBMb3ZlcyBDb21wYW55JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTQwMTcnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdOb3YuIDl0aC0xMHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ0NvbHVtYmlhLCBNTycsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMTN0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdDYXQgRmlnaHQnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9DYXQtRmlnaHQnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdGZWIuIDIybmQtMjNyZCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdMZXhpbmd0b24sIEtZJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICcxc3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnRWFzdGVybnMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9FYXN0ZXJucy1hbmQtRElJSS1FYXN0ZXJucycsXG4gICAgICAgICAgICAgICAgd2hlbjogJ01hcmNoIDIybmQtMjNyZCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdMaXR0bGUgUml2ZXIsIFNDJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICcxM3RoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0lsbGlub2lzIENvbmZlcmVuY2VzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvSWxsaW5vaXMtRC1JLUNvbGxlZ2UtTWVucy1DQycsXG4gICAgICAgICAgICAgICAgd2hlbjogJ0FwcmlsIDEydGgtMTN0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdSYW50b3VsLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMXN0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0dyZWF0IExha2VzIFJlZ2lvbmFscycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0dyZWF0LUxha2VzLUQtSS1Db2xsZWdlLU1lbnMtUmVnaW9uYWxzJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnQXByaWwgMjZ0aC0yN3RoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1JvY2tmb3JkLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnNXRoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTMsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnQm9pbGVyIEJyZWFrYXdheScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMyMDEyLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMTQzMicsXG4gICAgICAgICAgICAgICAgd2hlbjogJ1NlcHQuIDIybmQtMjNyZCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdXZXN0IExhZmF5ZXR0ZSwgSU4nLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0lsbGlub2lzIEludml0ZScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMyMDEyLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMTQ3NicsXG4gICAgICAgICAgICAgICAgd2hlbjogJ09jdC4gMTN0aC0xNHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1JhbnRvdWwsIElMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdNaXNzb3VyaSBMb3ZlcyBDb21wYW55JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3JlczIwMTIvI2NvbGxlZ2Utb3Blbi90b3VybmFtZW50LzExNjU3JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnTm92LiAxMHRoLTExdGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0h1Y2sgRmlubicsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMvI2NvbGxlZ2Utb3Blbi90b3VybmFtZW50LzEyMTE1JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnTWFyY2ggOXRoLTEwdGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnQ2hlc3RlcmZpZWxkLCBNTycsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMTN0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICdDZW50ZXgnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMjcwNycsXG4gICAgICAgICAgICAgICAgd2hlbjogJ01hcmNoIDE2dGgtMTd0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdBdXN0aW4sIFRYJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICc0dGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAnSWxsaW5vaXMgQ29uZmVyZW5jZXMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMjYwNCcsXG4gICAgICAgICAgICAgICAgd2hlbjogJ0FwcmlsIDEzdGgtMTR0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdSYW50b3VsLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMXN0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0dyZWF0IExha2VzIFJlZ2lvbmFscycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMvI2NvbGxlZ2Utb3Blbi90b3VybmFtZW50LzEyNjY3JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAnQXByaWwgMjd0aC0yOHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ1JvY2tmb3JkLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAnMXN0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogJ0QtSSBOYXRpb25hbCBDaGFtcGlvbnNoaXBzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTI2ODYnLFxuICAgICAgICAgICAgICAgIHdoZW46ICdNYXkgMjR0aC0yN3RoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ01hZGlzb24sIFdJJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICcxN3RoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3RvdXJuYW1lbnRzL2RhdGEvdG91cm5hbWVudHMuZGF0YS50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8IS0tSGVhZGVyLS0+XFxuPGgxIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPlRvdXJuYW1lbnRzPC9oMT5cXG48IS0tTWVudS0tPlxcbjxkaXYgY2xhc3M9XFxcInVpIHNlY29uZGFyeSBwb2ludGluZyBtZW51XFxcIj5cXG4gICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIHJvdXRlckxpbms9XFxcIi90b3VybmFtZW50cy8yMDEzXFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogeWVhciA9PT0gMjAxM31cXFwiPjIwMTM8L2E+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvdG91cm5hbWVudHMvMjAxNFxcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTR9XFxcIj4yMDE0PC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiaXRlbVxcXCIgcm91dGVyTGluaz1cXFwiL3RvdXJuYW1lbnRzLzIwMTVcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDE1fVxcXCI+MjAxNTwvYT5cXG4gICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIHJvdXRlckxpbms9XFxcIi90b3VybmFtZW50cy8yMDE2XFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogeWVhciA9PT0gMjAxNn1cXFwiPjIwMTY8L2E+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvdG91cm5hbWVudHMvMjAxN1xcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTd9XFxcIj4yMDE3PC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiaXRlbVxcXCIgcm91dGVyTGluaz1cXFwiL3RvdXJuYW1lbnRzLzIwMThcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDE4fVxcXCI+MjAxODwvYT5cXG4gICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIHJvdXRlckxpbms9XFxcIi90b3VybmFtZW50cy8yMDE5XFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogeWVhciA9PT0gMjAxOX1cXFwiPjIwMTk8L2E+XFxuPC9kaXY+XFxuPCEtLVRhYmxlLS0+XFxuPG5nLWNvbnRhaW5lciAqbmdGb3I9XFxcImxldCB0b3VybmFtZW50WWVhciBvZiB0b3VybmFtZW50RGF0YVxcXCI+XFxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XFxcInRvdXJuYW1lbnRZZWFyLnllYXIgPT09IHllYXJcXFwiPlxcbiAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJ1aSBjZWxsZWQgdGFibGVcXFwiICpuZ0lmPVxcXCJ0b3VybmFtZW50RGF0YVxcXCI+XFxuICAgICAgICAgICAgPHRoZWFkPlxcbiAgICAgICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICAgICAgICA8dGg+U2Vhc29uPC90aD5cXG4gICAgICAgICAgICAgICAgICAgIDx0aD5OYW1lPC90aD5cXG4gICAgICAgICAgICAgICAgICAgIDx0aD5XaGVuPC90aD5cXG4gICAgICAgICAgICAgICAgICAgIDx0aD5Mb2NhdGlvbjwvdGg+XFxuICAgICAgICAgICAgICAgICAgICA8dGg+UmVzdWx0PC90aD5cXG4gICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICA8L3RoZWFkPlxcbiAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgPHRyICpuZ0Zvcj1cXFwibGV0IHRvdXJuYW1lbnQgb2YgdG91cm5hbWVudFllYXIudG91cm5hbWVudHNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7dG91cm5hbWVudC5zZWFzb259fTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPCEtLU9ubHkgcmVuZGVyIGEgbGluayBpZiB0aGVyZSBpcyBvbmUgcHJvdmlkZWQgaW4gdGhlIGRhdGEsIG90aGVyd2lzZSBqdXN0IHJlbmRlciB0aGUgdGV4dC0tPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJ0b3VybmFtZW50LWluZm8tbGlua1xcXCIgKm5nSWY9XFxcInRvdXJuYW1lbnQubmFtZUxpbmtcXFwiIGhyZWY9XFxcInt7dG91cm5hbWVudC5uYW1lTGlua319XFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+e3t0b3VybmFtZW50Lm5hbWVMYWJlbH19PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XFxcIiF0b3VybmFtZW50Lm5hbWVMaW5rXFxcIj57e3RvdXJuYW1lbnQubmFtZUxhYmVsfX08L25nLWNvbnRhaW5lcj5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3t0b3VybmFtZW50LndoZW59fTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3t0b3VybmFtZW50LmxvY2F0aW9ufX08L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7dG91cm5hbWVudC5yZXN1bHR9fTwvdGQ+XFxuICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgIDwvdGFibGU+XFxuICAgICAgICAqIEJyYWNrZXQgcGxheSBub3QgY29tcGxldGVkIGR1ZSB0byBpbmNsZW1lbnQgd2VhdGhlclxcbiAgICA8L25nLWNvbnRhaW5lcj5cXG48L25nLWNvbnRhaW5lcj5cXG5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi90b3VybmFtZW50cy5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlci9saWIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3RvdXJuYW1lbnRzL3RvdXJuYW1lbnRzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuaW1wb3J0IHsgUm9zdGVyWWVhciB9IGZyb20gJy4vbW9kZWwvcm9zdGVyLXllYXIubW9kZWwnO1xuaW1wb3J0IHsgUk9TVEVSX0RBVEEgfSBmcm9tICcuL2RhdGEvcm9zdGVycy5kYXRhJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdyb3N0ZXInLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3Jvc3Rlci5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vcm9zdGVyLmNvbXBvbmVudC5sZXNzJyldXG59KVxuZXhwb3J0IGNsYXNzIFJvc3RlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgLy8gUm9zdGVyIGRhdGEgdG8gaW5qZWN0IGludG8gb3VyIHRlbXBsYXRlXG4gICAgcHJpdmF0ZSByb3N0ZXJEYXRhOiBSb3N0ZXJZZWFyW10gPSBST1NURVJfREFUQTtcbiAgICAvLyBTdWJzY3JpcHRpb24gdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHJvc3RlciB5ZWFyKVxuICAgIHByaXZhdGUgcm91dGVQYXJhbXNTdWJzY3JpcHRpb246IGFueTtcbiAgICAvLyBDdXJyZW50IHJvc3RlciB5ZWFyXG4gICAgcHJpdmF0ZSB5ZWFyOiBudW1iZXI7XG5cbiAgICAvLyBJbmplY3QgdGhlIEFjdGl2YXRlZFJvdXRlIGludG8gb3VyIGNvbXBvbmVudFxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcm91dGU6IEFjdGl2YXRlZFJvdXRlKSB7fVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIG91ciByb3V0ZSBwYXJhbWV0ZXJzIChyb3N0ZXIgeWVhcikuXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucm91dGVQYXJhbXNTdWJzY3JpcHRpb24gPSB0aGlzLnJvdXRlLnBhcmFtcy5zdWJzY3JpYmUoKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgLy8gKCspIGNvbnZlcnRzIHN0cmluZyAneWVhcicgdG8gYSBudW1iZXJcbiAgICAgICAgICAgIHRoaXMueWVhciA9ICtwYXJhbXNbJ3llYXInXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHJvc3RlciB5ZWFyKS5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9yb3N0ZXIuY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgUm9zdGVyWWVhciB9IGZyb20gJy4uL21vZGVsL3Jvc3Rlci15ZWFyLm1vZGVsJztcblxuZXhwb3J0IGNvbnN0IFJPU1RFUl9EQVRBOiBSb3N0ZXJZZWFyW10gPSBbXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE5LFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTkuanBnJyxcbiAgICAgICAgcGxheWVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnR3JlZ29yeSBTY2h3YXJ6JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnR3JhZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdEcmFrZSBIaWxsJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0JlbiBTYWJvdXJpbionLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQXNhIEJvd2VuJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDYsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0phY29iIEN1dGhiZXJ0JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0FsZXggTGl1JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDgsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0RldmluIEtlbGx5JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDEzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdSZWlkIE1hcnRpbionLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTb3Bob21vcmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMTQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0FpZGFuIExldmluJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDE5LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdKb2V5IEtlbm5lZHknLFxuICAgICAgICAgICAgICAgIHllYXI6ICdGcmVzaG1hbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyMCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnUnlhbiBLYW50b3InLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMjEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0JlbiBMZWUnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMjIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0x1Y2FzIEdvdWdoJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDI0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdKb3NoIERlZW1hbionLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMzEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0ZyYW5rIERvcmUnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMzIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0RhbWFuIE11bHllJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnRnJlc2htYW4nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMzUsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0NhbWVyb24gSGFydG1hbicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9obiBLdWxpa293c2tpJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDQwLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdSaXNoYXYgUm91dCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NvcGhvbW9yZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA0NixcbiAgICAgICAgICAgICAgICBuYW1lOiAnTmF0ZSBXaWxsaXMnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdHcmFkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDc0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBbnRob255IFJ1enpvJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDgyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCcmFuZG9uIENhcnJlbCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0RhbmllbCBNY0RvbmFsZCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0NvYWNoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTgsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAxOC5qcGcnLFxuICAgICAgICBwbGF5ZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdEcmFrZSBIaWxsJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogYEJlbiAnQmVlZicgU2Fib3VyaW5gLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQXNhIEJvd2VuJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnRnJlc2htYW4nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNixcbiAgICAgICAgICAgICAgICBuYW1lOiAnSmFjb2IgQ3V0aGJlcnQnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnS2V2aW4gTGluJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDgsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0RldmluIEtlbGx5JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDEzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdXYWx0ZXIgSmFza293aWFrJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDE5LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdKYWNvYiBLb21lbmRhKicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyMCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnUnlhbiBLYW50b3InLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMjMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0hlY3RvciBNb3Jlbm8nLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMjQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0pvc2ggRGVlbWFuKicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnRnJhbmsgRG9yZScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQ2FtZXJvbiBIYXJ0bWFuJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDM2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdEYWx0b24gQ2hhZmZlZScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0dyYWQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMzgsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0pvaG4gS3VsaWtvd3NraScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA0NyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnR3JhbnQgV2hpdG1hbicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA1NSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTXVycmF5IENoZW4nLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNzQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0FudGhvbnkgUnV6em8nLFxuICAgICAgICAgICAgICAgIHllYXI6ICdGcmVzaG1hbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA4OSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnUmVpZCBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgIHllYXI6ICdGcmVzaG1hbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA5NixcbiAgICAgICAgICAgICAgICBuYW1lOiAnRGlyayBIdXNlbWFubicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0RhbmllbCBNY0RvbmFsZCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0NvYWNoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTcsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAxNy5qcGcnLFxuICAgICAgICBwbGF5ZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6IGBCZW4gJ0JlZWYnIFNhYm91cmluYCxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0NvZHkgR3JheScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0dyYWQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNixcbiAgICAgICAgICAgICAgICBuYW1lOiAnSmFjb2IgQ3V0aGJlcnQnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTb3Bob21vcmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnS2V2aW4gTGluJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDgsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0RldmluIEtlbGx5JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDEzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdXYWx0ZXIgSmFza293aWFrJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDE4LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdIZWN0b3IgTW9yZW5vJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDE5LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdKYWNvYiBLb21lbmRhKicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSmFycmVkIEVsbGlvdHQnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMjQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0pvc2ggRGVlbWFuJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDI4LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdGcmFuayBEb3JlJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDI5LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCZW4gRm9zdGVyKicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSmFjb2IgVHJ1ZWInLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMzUsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0NhbWVyb24gSGFydG1hbicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NvcGhvbW9yZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9obiBLdWxpa293c2tpJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDQ3LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdHcmFudCBXaGl0bWFuJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDgxLFxuICAgICAgICAgICAgICAgIG5hbWU6IGBDaHJpcyAnQm9va3MnIEJ1Y2h0YSpgLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogOTUsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1RhdCBTaGluZycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0VyaWsgSHVlbWlsbGVyJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnQ29hY2gnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNixcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDE2LmpwZycsXG4gICAgICAgIHBsYXllcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ05pY2sgUHJvem9yb3Zza3kqJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0JlbiBTYWJvdXJpbicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0ZyZXNobWFuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0NvZHkgR3JheScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0dyYWQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBDb3Ntb3MnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnS2V2aW4gTGluJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDgsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0pvaG5ueSBTYW5pYXQnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMTAsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0phY29iIEtvbWVuZGEnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTb3Bob21vcmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMTIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0thbiBaaSBZYW5nJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDEzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdNYXJrIFBldGVyc29uJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDE3LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdQcmF5YWcgUGF0ZWwqJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDE4LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBbGV4IEd1eScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSmFycmVkIEVsbGlvdHQnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMjQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0pvc2ggRGVlbWFuJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnRnJlc2htYW4nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMjcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1dpbHNvbiBXYW5nJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDI5LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCZW4gRm9zdGVyJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDM3LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdXYWx0ZXIgSmFza293aWFrJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnRnJlc2htYW4nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMzgsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0phY29iIFRydWViJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDQxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdEZXZpbiBLZWxseScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0ZyZXNobWFuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDQ0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdSeWFuIEthbnRvcicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0ZyZXNobWFuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDQ4LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdIZWN0b3IgTW9yZW5vJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDcxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCb2JieSBHYXpkemlhaycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA4MSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQ2hyaXMgQnVjaHRhKicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA4OCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnVGltIENodScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA5NSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnVGF0IFNoaW5nJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDk3LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdKYWNvYiBDdXRoYmVydCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0ZyZXNobWFuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWF0dCBXZXN0JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnQXNzaXN0YW50IENvYWNoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnRXJpayBIdWVtaWxsZXInLFxuICAgICAgICAgICAgICAgIHllYXI6ICdDb2FjaCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE1LFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTUuanBnJyxcbiAgICAgICAgcGxheWVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWF4IFdpbGxpcycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdOaWNrIFByb3pvcm92c2t5KicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIFBvaGxpbmcnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWF0dCBXZXN0JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnR3JhZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA4LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdKb2huIFNhbmlhdConLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMTAsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0pvZSBNb3lsZXMnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMTEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0pvbiBNY2tveScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnS2FuIFppIFlhbmcnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMTMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ01hcmsgUGV0ZXJzb24nLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMTcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1ByYXlhZyBQYXRlbCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnRXJpYyBCdWx0bWFuJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDIxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdKYXJyZWQgRWxsaW90dCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NvcGhvbW9yZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnVHlsZXIgRGVOb295ZXInLFxuICAgICAgICAgICAgICAgIHllYXI6ICdHcmFkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDI3LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdXaWxzb24gV2FuZycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyOSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQmVuIEZvc3RlcicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NvcGhvbW9yZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWFydHkgTWFya2Vuc29uKicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnR3JhbnQgSGFsbGFuJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDQ2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdLZXZpbiBCaXJjaG9rJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDY5LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdKYWNvYiBLb21lbmRhJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnRnJlc2htYW4nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNzUsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0VyaWMgQmFkZ2VyJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnR3JhZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA4MSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQ2hyaXMgQnVjaHRhJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDk3LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdLZXZpbiBMaW4nLFxuICAgICAgICAgICAgICAgIHllYXI6ICdGcmVzaG1hbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ01hdHQgU3R1cGNhJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnQ29hY2gnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNCxcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDE0LmpwZycsXG4gICAgICAgIHBsYXllcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDAsXG4gICAgICAgICAgICAgICAgbmFtZTogJ01heCBXaWxsaXMnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTmljayBQcm96b3JvdnNreScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NvcGhvbW9yZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdTZWFuIEhpbGwnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBQb2hsaW5nJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDYsXG4gICAgICAgICAgICAgICAgbmFtZTogJ05pY2sgT28nLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9obm55IFNhbmlhdCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NvcGhvbW9yZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxMCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9lIE1veWxlcycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9uIE1ja295JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDEyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdLYW4gWmkgWWFuZycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NvcGhvbW9yZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxNyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnUHJheWFnIFBhdGVsJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDE4LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdFcmljIEJ1bHRtYW4qJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDIxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdDaHJpcyBCdWNodGEnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdGcmVzaG1hbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnQnJpYW4gUmF0aHVuZGUnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMjMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0dyZWcgSGlsbCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSmltIFJpZGRsZScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyNyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnV2lsc29uIFdhbmcnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTb3Bob21vcmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMzAsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1N0ZXZlIEJyYW5kJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnR3JhZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWFydHkgTWFya2Vuc29uKicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnR3JhbnQgSGFsbGFuJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDM5LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdSb3NzIFR1dHRsZScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA0NCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBDb3Ntb3MnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTb3Bob21vcmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNDYsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0tldmluIEJpcmNob2snLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNjQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ05lYWwgUGhlbHBzKicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0dyYWQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNjksXG4gICAgICAgICAgICAgICAgbmFtZTogJ1R5bGVyIERlTm9veWVyJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnR3JhZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA4MSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQXJ0aHVyIERpbmcnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTb3Bob21vcmUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdXYWxkZW4gTmVsc29uJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnQ29hY2gnXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDEzLmpwZycsXG4gICAgICAgIHBsYXllcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ05pY2sgUHJvem9yb3Zza3knLFxuICAgICAgICAgICAgICAgIHllYXI6ICdGcmVzaG1hbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdTZWFuIEhpbGwnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnUm9iIERyZWllcicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCcmFkIEJvbGxpZ2VyJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDksXG4gICAgICAgICAgICAgICAgbmFtZTogJ1ByZXN0b24gR291bHNvbicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9uIE1ja295JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDEyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdEZXJlayBZYW4nLFxuICAgICAgICAgICAgICAgIHllYXI6ICdGcmVzaG1hbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnRXJpYyBCdWx0bWFuJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDIwLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdUeWxlciBBbmRlcnNvbicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnQnJpYW4gUmF0aHVuZGUnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMjMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1J5YW4gU21pdGgqJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnR3JhZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyNyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnV2lsc29uIFdhbmcnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdGcmVzaG1hbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzMCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQ29saW4gUmVpZConLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMzQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgUG9obGluZycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NvcGhvbW9yZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAzNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWFydHkgTWFya2Vuc29uJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDM5LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdSb3NzIFR1dHRsZScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA0NCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTmF0ZSBHaWJib25zKicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA0NSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnR3JlZyBIaWxsJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDY0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdOZWFsIFBoZWxwcyonLFxuICAgICAgICAgICAgICAgIHllYXI6ICdHcmFkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDY1LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIENvc21vcycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0ZyZXNobWFuJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDg3LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBZGFtIFdyaWdodCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA5OSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9obm55IFNhbmlhdCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1dhbGRlbiBOZWxzb24nLFxuICAgICAgICAgICAgICAgIHllYXI6ICdDb2FjaCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDExLFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTEuanBnJyxcbiAgICAgICAgcGxheWVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9lIFNpZHJ5cycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA1LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdKYWNrIEtyaWVnZXInLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnS3lsZSBNY0tpbmxleScsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0dyYWQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMTMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1RvbSBSdWR3aWNrJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDE0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBdXN0aW4gTGllbicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQWxleCBLb21pc2FyeicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxNixcbiAgICAgICAgICAgICAgICBuYW1lOiAnQW5keSBLaWxpbnNraXMnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMTgsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0t1cnQgWm9lbGxpY2snLFxuICAgICAgICAgICAgICAgIHllYXI6ICdHcmFkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDIyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCcmlhbiBDaHJ5c2xlcicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0dyYWQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMjMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1J5YW4gU21pdGgnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdHcmFkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDI1LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdNYXJrIEhpcnNjaG1hbicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyNyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQ2hyaXMgSGlkYWthJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnR3JhZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyOSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWF0dCBLdXJsZXknLFxuICAgICAgICAgICAgICAgIHllYXI6ICdHcmFkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDMyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdDaHJpcyBLdmlzdGFkJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDMzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdEb24gTWNEb25hbGQnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdHcmFkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDM2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCcmlhbiBQaWVyY2UnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogNDcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0pvbiBIYXRjaGVyJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDYxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCcmlhbiBQaGVsYW4nLFxuICAgICAgICAgICAgICAgIHllYXI6ICdHcmFkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDY0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdOZWFsIFBoZWxwcyonLFxuICAgICAgICAgICAgICAgIHllYXI6ICdTZW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogODAsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0pvbiBPZ3JvZG5paycsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0dyYWQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogODEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1N1bGV5bWFuIEFobWFkJyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU2VuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDg0LFxuICAgICAgICAgICAgICAgIG5hbWU6IGBDaGFybGllIE8nQnJpZW5gLFxuICAgICAgICAgICAgICAgIHllYXI6ICdHcmFkJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IDg3LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBZGFtIFdyaWdodCcsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0p1bmlvcidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiA4OCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnS2V2aW4gQnJ1bnMnLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogOTAsXG4gICAgICAgICAgICAgICAgbmFtZTogJ1phY2hhcnkgRnJhbnR6JyxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnSnVuaW9yJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnV2FsZGVuIE5lbHNvbicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ0NvYWNoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9kYXRhL3Jvc3RlcnMuZGF0YS50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8IS0tSGVhZGVyLS0+XFxuPGgxIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPlJvc3RlcjwvaDE+XFxuPCEtLU1lbnUtLT5cXG48ZGl2IGNsYXNzPVxcXCJ1aSBzZWNvbmRhcnkgcG9pbnRpbmcgbWVudVxcXCI+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvcm9zdGVyLzIwMTFcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDExfVxcXCI+MjAxMTwvYT5cXG4gICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIHJvdXRlckxpbms9XFxcIi9yb3N0ZXIvMjAxM1xcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTN9XFxcIj4yMDEzPC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiaXRlbVxcXCIgcm91dGVyTGluaz1cXFwiL3Jvc3Rlci8yMDE0XFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogeWVhciA9PT0gMjAxNH1cXFwiPjIwMTQ8L2E+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvcm9zdGVyLzIwMTVcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDE1fVxcXCI+MjAxNTwvYT5cXG4gICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIHJvdXRlckxpbms9XFxcIi9yb3N0ZXIvMjAxNlxcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTZ9XFxcIj4yMDE2PC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiaXRlbVxcXCIgcm91dGVyTGluaz1cXFwiL3Jvc3Rlci8yMDE3XFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogeWVhciA9PT0gMjAxN31cXFwiPjIwMTc8L2E+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvcm9zdGVyLzIwMThcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDE4fVxcXCI+MjAxODwvYT5cXG4gICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIHJvdXRlckxpbms9XFxcIi9yb3N0ZXIvMjAxOVxcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTl9XFxcIj4yMDE5PC9hPlxcbjwvZGl2PlxcbjwhLS1UYWJsZS0tPlxcbjxuZy1jb250YWluZXIgKm5nRm9yPVxcXCJsZXQgcm9zdGVyWWVhciBvZiByb3N0ZXJEYXRhXFxcIj5cXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cXFwicm9zdGVyWWVhci55ZWFyID09PSB5ZWFyXFxcIj5cXG4gICAgICAgIDxpbWcgc3JjPVxcXCJ7e3Jvc3RlclllYXIuaW1hZ2VQYXRofX1cXFwiLz5cXG4gICAgICAgIDx0YWJsZSBjbGFzcz1cXFwidWkgY2VsbGVkIHRhYmxlXFxcIj5cXG4gICAgICAgICAgICA8dGhlYWQ+XFxuICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgIDx0aD4jPC90aD5cXG4gICAgICAgICAgICAgICAgICAgIDx0aD5OYW1lPC90aD5cXG4gICAgICAgICAgICAgICAgICAgIDx0aD5ZZWFyPC90aD5cXG4gICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICA8L3RoZWFkPlxcbiAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgPHRyICpuZ0Zvcj1cXFwibGV0IHBsYXllciBvZiByb3N0ZXJZZWFyLnBsYXllcnNcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7cGxheWVyLm51bWJlcn19PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgIDx0ZD57e3BsYXllci5uYW1lfX08L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7cGxheWVyLnllYXJ9fTwvdGQ+XFxuICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgIDwvdGFibGU+XFxuICAgICAgICA8cD4oKikgaW5kaWNhdGVzIGNhcHRhaW4gZm9yIHRoYXQgeWVhcjwvcD5cXG4gICAgPC9uZy1jb250YWluZXI+XFxuPC9uZy1jb250YWluZXI+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9yb3N0ZXIuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImltZ3t3aWR0aDo3NSU7Ym9yZGVyOjFweCBzb2xpZCAjMDAwMDRkO2JvcmRlci1yYWRpdXM6LjI4NTcxNDI5ZW19cHt0ZXh0LWFsaWduOmxlZnQ7dGV4dC1pbmRlbnQ6MH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vcG9zdGNzcy1sb2FkZXIvbGliIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvdGVhbS9yb3N0ZXIvcm9zdGVyLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgU3ByZWFkc2hlZXRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZ2xvYmFsL3NlcnZpY2UvZ29vZ2xlLXNwcmVhZHNoZWV0LnNlcnZpY2UnO1xuaW1wb3J0IHsgR3RtVXRpbCB9IGZyb20gJy4uLy4uL2dsb2JhbC91dGlsL2d0bS51dGlsJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhYnNlbnQnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Fic2VudC5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vYWJzZW50LmNvbXBvbmVudC5sZXNzJyldXG59KVxuZXhwb3J0IGNsYXNzIEFic2VudENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuICAgIC8vIEFQSSB1cmwgZm9yIG91ciBwZXJzb25hbCBzZXJ2ZXJcbiAgICBwcml2YXRlIGdvb2dsZVNoZWV0c0FwaVVybCA9ICdodHRwczovL25pY2stcHJvei1ub2RlLXNlcnZlci5oZXJva3VhcHAuY29tL3NoZWV0cy8xMWlqckhveXNpSXdzRmZFZ2diU05NOVk4VnZ6VTY1amV1aFEzdmtWNUZHdy9zaGVldEluZGV4LzEvcm93cy8nO1xuICAgIC8vIEFQSSB1cmwgZm9yIG91ciBiYWNrdXAgc2VydmVyIChzaGVldHN1IEFQSSlcbiAgICAvLyBwcml2YXRlIGdvb2dsZVNoZWV0c0JhY2t1cEFwaVVybCA9ICdodHRwczovL3NoZWV0c3UuY29tL2FwaXMvdjEuMC83YTAzMGFlNjBiN2QnO1xuICAgIHByaXZhdGUgZ29vZ2xlU2hlZXRzQmFja3VwQXBpVXJsID0gJyc7XG5cbiAgICAvLyBFcnJvciBtZXNzYWdlc1xuICAgIHByaXZhdGUgdmFsaWRhdGlvbkVycm9yczogc3RyaW5nID0gJ1BsZWFzZSBkbyBub3QgbGVhdmUgYW55IHJlcXVpcmVkIGZpZWxkcyBibGFuay4nO1xuICAgIHByaXZhdGUgc3VibWlzc2lvbkVycm9yOiBzdHJpbmcgPSAnQ291bGQgbm90IHN1Ym1pdCB0aGUgZm9ybSAgZHVlIHRvIGEgc2VydmVyIGVycm9yLiBQbGVhc2UgdHJ5IGFnYWluIHNvb24gb3IgY29udGFjdCB0aGUgd2ViIGFkbWlucy4nO1xuXG4gICAgLy8gR1RNIHZhcmlhYmxlc1xuICAgIHByaXZhdGUgc3RhdGljIGd0bUV2ZW50TmFtZTogc3RyaW5nID0gJ0Fic2VudCBGb3JtIFN1Ym1pdCc7XG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3RtVmFyaWFibGVOYW1lOiBzdHJpbmcgPSAnYWJzZW50LWZvcm0nO1xuXG4gICAgLy8gRmlyc3QgbmFtZSBpbnB1dFxuICAgIHByaXZhdGUgZmlyc3ROYW1lOiBzdHJpbmc7XG4gICAgLy8gTGFzdCBuYW1lIGlucHV0XG4gICAgcHJpdmF0ZSBsYXN0TmFtZTogc3RyaW5nO1xuICAgIC8vIFJlYXNvbiBpbnB1dFxuICAgIHByaXZhdGUgcmVhc29uOiBzdHJpbmc7XG4gICAgLy8gVGltZSBpbnB1dFxuICAgIHByaXZhdGUgdGltZTogc3RyaW5nO1xuICAgIC8vIERheSBpbnB1dFxuICAgIHByaXZhdGUgZGF5OiBudW1iZXI7XG4gICAgLy8gTW9udGggaW5wdXRcbiAgICBwcml2YXRlIG1vbnRoOiBudW1iZXI7XG4gICAgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIGlmIG91ciBmb3JtIGlzIGluIHRoZSBwcm9jZXNzIG9mIHN1Ym1pdHRpbmcgKHRvIHNob3cgb3VyIGxvYWRpbmcgaWNvbilcbiAgICBwcml2YXRlIGZvcm1Jc1N1Ym1pdHRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAvLyBCb29sZWFuIGluZGljYXRpbmcgaWYgb3VyIGZvcm0gd2FzIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQgKHRvIHNob3cgb3VyIHN1Y2Nlc3MgbWVzc2FnZSlcbiAgICBwcml2YXRlIHN1Ym1pdFN1Y2Nlc3M6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAvLyBGb3JtIGVycm9ycyBvdXRwdXRcbiAgICBwcml2YXRlIGZvcm1FcnJvcnM6IHN0cmluZztcblxuICAgIC8vIE1vbnRoIGRyb3Bkb3duXG4gICAgQFZpZXdDaGlsZCgnbW9udGhEcm9wZG93bicpXG4gICAgcHJpdmF0ZSBtb250aERyb3Bkb3duOiBFbGVtZW50UmVmO1xuXG4gICAgLy8gQ29uc3RydWN0b3Igd2l0aCBvdXIgaHR0cCBzZXJ2aWNlIGluamVjdGVkXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBzcHJlYWRzaGVldFNlcnZpY2U6IFNwcmVhZHNoZWV0U2VydmljZSkge31cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgJCh0aGlzLm1vbnRoRHJvcGRvd24ubmF0aXZlRWxlbWVudCkuZHJvcGRvd24oKTtcbiAgICB9XG5cbiAgICBoYW5kbGVTdWJtaXQoZXZlbnQ6IGFueSwgbW9udGhJbnB1dDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubW9udGggPSBtb250aElucHV0O1xuICAgICAgICB0aGlzLnN1Ym1pdFN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuZm9ybUlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtRXJyb3JzID0gdGhpcy52YWxpZGF0aW9uRXJyb3JzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JtSXNTdWJtaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBUaW1lc3RhbXA6IGRhdGUudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnRmlyc3QgTmFtZSc6IHRoaXMuZmlyc3ROYW1lLFxuICAgICAgICAgICAgICAgICdMYXN0IE5hbWUnOiB0aGlzLmxhc3ROYW1lLFxuICAgICAgICAgICAgICAgIFRpbWU6IHRoaXMudGltZSxcbiAgICAgICAgICAgICAgICBEYXRlOiBgJHt0aGlzLm1vbnRofS8ke3RoaXMuZGF5fWAsXG4gICAgICAgICAgICAgICAgUmVhc29uOiB0aGlzLnJlYXNvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3VibWl0QWJzZW50Rm9ybShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1Ym1pdHMgb3VyIGZvcm0gdG8gdGhlIHNwcmVhZHNoZWV0IGJ5IGNhbGxpbmcgb3VyIHNlcnZpY2UgbWV0aG9kLlxuICAgICAqIE9uIHN1Y2Nlc3MsIHdlIHNob3cgb3VyIGNvbmZpcm1hdGlvbiBtb2RhbCBhbmQgcmVzZXQgb3VyIHJzdnAgbW9kYWwuXG4gICAgICogT24gZmFpbHVyZSwgd2UgaGlkZSBvdXIgc3VibWl0dGluZyBkaWFsb2cgYW5kIHNob3cgb3VyIHN1Ym1pc3Npb24gZXJyb3IgdG8gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAtIGRhdGEgdG8gc3VibWl0IHRvIG91ciBzcHJlYWRzaGVldFxuICAgICAqL1xuICAgIHByaXZhdGUgc3VibWl0QWJzZW50Rm9ybShkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgLy8gUHVzaCBvdXIgZm9ybSBkYXRhIHRvIHRoZSBkYXRhIGxheWVyIGZvciBHb29nbGUgVGFnIE1hbmFnZXIgdG8gY29uc3VtZVxuICAgICAgICBHdG1VdGlsLnB1c2hPYmplY3RUb0RhdGFMYXllcihBYnNlbnRDb21wb25lbnQuZ3RtRXZlbnROYW1lLCBBYnNlbnRDb21wb25lbnQuZ3RtVmFyaWFibGVOYW1lLCBkYXRhKTtcblxuICAgICAgICB0aGlzLnNwcmVhZHNoZWV0U2VydmljZVxuICAgICAgICAgICAgLnBvc3RSb3dUb1NwcmVhZHNoZWV0KHRoaXMuZ29vZ2xlU2hlZXRzQXBpVXJsLCB0aGlzLmdvb2dsZVNoZWV0c0JhY2t1cEFwaVVybCwgZGF0YSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rm9ybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VibWl0U3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Jc1N1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1FcnJvcnMgPSB0aGlzLnN1Ym1pc3Npb25FcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBvdXIgaW5wdXQgZmllbGRzLCBlcnJvcnMsIGFuZCByZXNldHMgb3VyIGZvcm0gaXMgc3VibWl0dGluZyBmbGFnLlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVzZXRGb3JtKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZpcnN0TmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYXNvbiA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb250aCA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9ybUVycm9ycyA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9ybUlzU3VibWl0dGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZyb250LWVuZCB2YWxpZGF0aW9uIGZvciBvdXIgZm9ybS5cbiAgICAgKiBPdXIgZm9ybSBpcyB2YWxpZCBvbmx5IGlmIGFsbCBmaWVsZHMgYXJlIHBvcHVsYXRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIGZvcm0gaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHByaXZhdGUgZm9ybUlzVmFsaWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmZpcnN0TmFtZSAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLmZpcnN0TmFtZSAhPSAnJyAmJlxuICAgICAgICAgICAgdGhpcy5sYXN0TmFtZSAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLmxhc3ROYW1lICE9ICcnICYmXG4gICAgICAgICAgICB0aGlzLnJlYXNvbiAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLnJlYXNvbiAhPSAnJyAmJlxuICAgICAgICAgICAgdGhpcy50aW1lICE9IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMudGltZSAhPSAnJyAmJlxuICAgICAgICAgICAgdGhpcy5tb250aCAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLm1vbnRoID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5kYXkgIT0gbnVsbFxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL2Fic2VudC9hYnNlbnQuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjwhLS1IZWFkZXItLT5cXG48aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+UHJhY3RpY2UgQWJzZW5jZSBGb3JtPC9oMT5cXG48IS0tU3VibWl0dGluZyBMb2FkZXItLT5cXG48ZGl2ICpuZ0lmPVxcXCJmb3JtSXNTdWJtaXR0aW5nXFxcIiBjbGFzcz1cXFwidWkgYWN0aXZlIGludmVydGVkIGRpbW1lclxcXCI+PGRpdiBjbGFzcz1cXFwidWkgdGV4dCBsb2FkZXJcXFwiPlN1Ym1pdHRpbmc8L2Rpdj48L2Rpdj5cXG48IS0tRm9ybS0tPlxcbjxmb3JtIGNsYXNzPVxcXCJ1aSBmb3JtXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidHdvIGZpZWxkc1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPkZpcnN0IE5hbWUgPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJmaXJzdE5hbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcImZpcnN0LW5hbWVcXFwiIHBsYWNlaG9sZGVyPVxcXCJGaXJzdCBOYW1lXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgIDxsYWJlbD5MYXN0IE5hbWUgPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJsYXN0TmFtZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwibGFzdC1uYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiTGFzdCBOYW1lXFxcIj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgPGxhYmVsPlJlYXNvbiBmb3IgbWlzc2luZyBvciBiZWluZyBsYXRlIHRvIHByYWN0aWNlIDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJyZWFzb25cXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcInJlYXNvblxcXCIgcGxhY2Vob2xkZXI9XFxcIkJldHRlciBiZSBnb29kLi4uXFxcIj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgIDxsYWJlbD5Gcm9tIHdoYXQgdGltZSB0byB3aGF0IHRpbWUgaXMgeW91ciBjb25mbGljdD8gPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcInRpbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcInRpbWVcXFwiIHBsYWNlaG9sZGVyPVxcXCJUaW1lXFxcIj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInR3byBmaWVsZHNcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxhYmVsPlByYWN0aWNlIGRhdGUgPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwiZGF5XFxcIiBtYXhsZW5ndGg9XFxcIjJcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcImRheVxcXCIgcGxhY2Vob2xkZXI9XFxcIkRheSAoMC0zMSlcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxhYmVsPiZuYnNwOzwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDxkaXYgI21vbnRoRHJvcGRvd24gY2xhc3M9XFxcInVpIHNlYXJjaCBzZWxlY3Rpb24gZHJvcGRvd25cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0ICNtb250aElucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgbmFtZT1cXFwibW9udGhcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImRyb3Bkb3duIGljb25cXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRlZmF1bHQgdGV4dFxcXCI+TW9udGg8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lbnVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjAxXFxcIj5KYW51YXJ5PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgZGF0YS12YWx1ZT1cXFwiMDJcXFwiPkZlYnJ1YXJ5PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgZGF0YS12YWx1ZT1cXFwiMDNcXFwiPk1hcmNoPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgZGF0YS12YWx1ZT1cXFwiMDRcXFwiPkFwcmlsPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgZGF0YS12YWx1ZT1cXFwiMDVcXFwiPk1heTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjA2XFxcIj5KdW5lPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgZGF0YS12YWx1ZT1cXFwiMDdcXFwiPkp1bHk8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBkYXRhLXZhbHVlPVxcXCIwOFxcXCI+QXVndXN0PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgZGF0YS12YWx1ZT1cXFwiMDlcXFwiPlNlcHRlbWJlcjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjEwXFxcIj5PY3RvYmVyPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgZGF0YS12YWx1ZT1cXFwiMTFcXFwiPk5vdmVtYmVyPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgZGF0YS12YWx1ZT1cXFwiMTJcXFwiPkRlY2VtYmVyPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxidXR0b24gKGNsaWNrKT1cXFwiaGFuZGxlU3VibWl0KCRldmVudCwgbW9udGhJbnB1dC52YWx1ZSlcXFwiIGNsYXNzPVxcXCJ1aSBidXR0b24gc3VibWl0LWJ1dHRvblxcXCIgdHlwZT1cXFwic3VibWl0XFxcIj5TdWJtaXQ8L2J1dHRvbj5cXG4gICAgPCEtLUVycm9yL1N1Y2Nlc3MgTWVzc2FnZXMtLT5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWkgZXJyb3IgbWVzc2FnZVxcXCIgKm5nSWY9XFxcImZvcm1FcnJvcnNcXFwiPlxcbiAgICAgICAgPHA+e3tmb3JtRXJyb3JzfX08L3A+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aSBzdWNjZXNzIG1lc3NhZ2VcXFwiICpuZ0lmPVxcXCJzdWJtaXRTdWNjZXNzXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImhlYWRlclxcXCI+Rm9ybSBTdWJtaXR0ZWQ8L2Rpdj5cXG4gICAgICAgIDxwPlRoZSBmb3JtIHdhcyBzdWNjZXNzZnVsbHkgc3VibWl0dGVkLiBTdG9wIG1pc3NpbmcgcHJhY3RpY2UuPC9wPlxcbiAgICA8L2Rpdj5cXG48L2Zvcm0+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9hYnNlbnQuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5zdWJtaXQtYnV0dG9ue21hcmdpbi1ib3R0b206NDVweH1sYWJlbHt0ZXh0LWFsaWduOmxlZnR9LnVpLmZvcm17d2lkdGg6ODAlO21hcmdpbjowIGF1dG99LnVpLmZvcm0gLnVpLmVycm9yLm1lc3NhZ2UsLnVpLmZvcm0gLnVpLnN1Y2Nlc3MubWVzc2FnZXtkaXNwbGF5OmJsb2NrfS51aS5mb3JtIC51aS5lcnJvci5tZXNzYWdlIHAsLnVpLmZvcm0gLnVpLnN1Y2Nlc3MubWVzc2FnZSBwe3RleHQtYWxpZ246Y2VudGVyfS51aS5zZWFyY2guc2VsZWN0aW9uLmRyb3Bkb3duLmFjdGl2ZS52aXNpYmxlLC51aS5zZWxlY3Rpb24uYWN0aXZlLmRyb3Bkb3duIC5tZW51LC51aS5zZWxlY3Rpb24uYWN0aXZlLmRyb3Bkb3duOmhvdmVye2JvcmRlci1jb2xvcjojZmY2MjI2fS51aS5kcm9wZG93bnttaW4td2lkdGg6aW5oZXJpdH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vcG9zdGNzcy1sb2FkZXIvbGliIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gUm91dGUgQ29uZmlndXJhdGlvblxuaW1wb3J0IHsgUm91dGVzIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEhvbWVDb21wb25lbnQgfSBmcm9tICcuL2hvbWUvaG9tZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgQWJvdXRDb21wb25lbnQgfSBmcm9tICcuL2Fib3V0L2Fib3V0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQcm9zcGVjdGl2ZVBsYXllcnNDb21wb25lbnQgfSBmcm9tICcuL3Byb3NwZWN0aXZlLXBsYXllcnMvcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29udGFjdENvbXBvbmVudCB9IGZyb20gJy4vY29udGFjdC9jb250YWN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQcmFjdGljZUNvbXBvbmVudCB9IGZyb20gJy4vdGVhbS9wcmFjdGljZS9wcmFjdGljZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgVG91cm5hbWVudHNDb21wb25lbnQgfSBmcm9tICcuL3RlYW0vdG91cm5hbWVudHMvdG91cm5hbWVudHMuY29tcG9uZW50JztcbmltcG9ydCB7IFJvc3RlckNvbXBvbmVudCB9IGZyb20gJy4vdGVhbS9yb3N0ZXIvcm9zdGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBBYnNlbnRDb21wb25lbnQgfSBmcm9tICcuL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGVhbUhpc3RvcnlDb21wb25lbnQgfSBmcm9tICcuL2hpc3RvcnkvdGVhbS1oaXN0b3J5L3RlYW0taGlzdG9yeS5jb21wb25lbnQnO1xuaW1wb3J0IHsgQXdhcmRzQ29tcG9uZW50IH0gZnJvbSAnLi9oaXN0b3J5L2F3YXJkcy9hd2FyZHMuY29tcG9uZW50JztcbmltcG9ydCB7IFJlc3VsdHNDb21wb25lbnQgfSBmcm9tICcuL2hpc3RvcnkvcmVzdWx0cy9yZXN1bHRzLmNvbXBvbmVudCc7XG5cbmV4cG9ydCBjb25zdCBST1VURVM6IFJvdXRlcyA9IFtcbiAgICB7IHBhdGg6ICcnLCByZWRpcmVjdFRvOiAnaG9tZScsIHBhdGhNYXRjaDogJ2Z1bGwnIH0sXG4gICAgeyBwYXRoOiAnaG9tZScsIGNvbXBvbmVudDogSG9tZUNvbXBvbmVudCB9LFxuICAgIHsgcGF0aDogJ3ByYWN0aWNlJywgY29tcG9uZW50OiBQcmFjdGljZUNvbXBvbmVudCB9LFxuICAgIHsgcGF0aDogJ2Fic2VudCcsIGNvbXBvbmVudDogQWJzZW50Q29tcG9uZW50IH0sXG4gICAgeyBwYXRoOiAnY29udGFjdCcsIGNvbXBvbmVudDogQ29udGFjdENvbXBvbmVudCB9LFxuICAgIHsgcGF0aDogJ2hvbWUnLCBjb21wb25lbnQ6IEhvbWVDb21wb25lbnQgfSxcbiAgICB7IHBhdGg6ICdhYm91dCcsIGNvbXBvbmVudDogQWJvdXRDb21wb25lbnQgfSxcbiAgICB7IHBhdGg6ICdwcm9zcGVjdHMnLCBjb21wb25lbnQ6IFByb3NwZWN0aXZlUGxheWVyc0NvbXBvbmVudCB9LFxuICAgIHsgcGF0aDogJ3RvdXJuYW1lbnRzLzp5ZWFyJywgY29tcG9uZW50OiBUb3VybmFtZW50c0NvbXBvbmVudCB9LFxuICAgIHsgcGF0aDogJ3Jvc3Rlci86eWVhcicsIGNvbXBvbmVudDogUm9zdGVyQ29tcG9uZW50IH0sXG4gICAgeyBwYXRoOiAnaGlzdG9yeS86eWVhcicsIGNvbXBvbmVudDogVGVhbUhpc3RvcnlDb21wb25lbnQgfSxcbiAgICB7IHBhdGg6ICdhd2FyZHMnLCBjb21wb25lbnQ6IEF3YXJkc0NvbXBvbmVudCB9LFxuICAgIHsgcGF0aDogJ3Jlc3VsdHMnLCBjb21wb25lbnQ6IFJlc3VsdHNDb21wb25lbnQgfSxcbiAgICB7IHBhdGg6ICcqKicsIGNvbXBvbmVudDogSG9tZUNvbXBvbmVudCB9XG5dO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2FwcC5yb3V0ZXMudHMiLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIE9uSW5pdCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEhpc3RvcnlZZWFyIH0gZnJvbSAnLi9tb2RlbC9oaXN0b3J5LXllYXIubW9kZWwnO1xuaW1wb3J0IHsgSElTVE9SWV9EQVRBIH0gZnJvbSAnLi9kYXRhL2hpc3RvcnkteWVhci5kYXRhJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd0ZWFtLWhpc3RvcnknLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3RlYW0taGlzdG9yeS5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5sZXNzJyldXG59KVxuZXhwb3J0IGNsYXNzIFRlYW1IaXN0b3J5Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0IHtcbiAgICAvLyBSZXN1bHRzIGRhdGEgdG8gaW5qZWN0IGludG8gb3VyIHRlbXBsYXRlXG4gICAgcHJpdmF0ZSBoaXN0b3J5RGF0YTogSGlzdG9yeVllYXJbXSA9IEhJU1RPUllfREFUQTtcbiAgICAvLyBTdWJzY3JpcHRpb24gdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHRvdXJuYW1lbnQgeWVhcilcbiAgICBwcml2YXRlIHJvdXRlUGFyYW1zU3Vic2NyaXB0aW9uOiBhbnk7XG4gICAgLy8gQ3VycmVudCB0b3VybmFtZW50IHllYXJcbiAgICBwcml2YXRlIHllYXI6IG51bWJlcjtcblxuICAgIC8vIFllYXIgZHJvcGRvd25zXG4gICAgQFZpZXdDaGlsZCgnMTk5NGRyb3Bkb3duJylcbiAgICBwcml2YXRlIGZpcnN0RHJvcGRvd246IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgnMjAwMGRyb3Bkb3duJylcbiAgICBwcml2YXRlIHNlY29uZERyb3Bkb3duOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJzIwMTBkcm9wZG93bicpXG4gICAgcHJpdmF0ZSB0aGlyZERyb3Bkb3duOiBFbGVtZW50UmVmO1xuXG4gICAgLy8gSW5qZWN0IHRoZSBBY3RpdmF0ZWRSb3V0ZSBpbnRvIG91ciBjb21wb25lbnRcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSkge31cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgJCh0aGlzLmZpcnN0RHJvcGRvd24ubmF0aXZlRWxlbWVudCkuZHJvcGRvd24oe30pO1xuICAgICAgICAkKHRoaXMuc2Vjb25kRHJvcGRvd24ubmF0aXZlRWxlbWVudCkuZHJvcGRvd24oe30pO1xuICAgICAgICAkKHRoaXMudGhpcmREcm9wZG93bi5uYXRpdmVFbGVtZW50KS5kcm9wZG93bih7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIG91ciByb3V0ZSBwYXJhbWV0ZXJzICh0b3VybmFtZW50IHllYXIpLlxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJvdXRlUGFyYW1zU3Vic2NyaXB0aW9uID0gdGhpcy5yb3V0ZS5wYXJhbXMuc3Vic2NyaWJlKChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIC8vICgrKSBjb252ZXJ0cyBzdHJpbmcgJ3llYXInIHRvIGEgbnVtYmVyXG4gICAgICAgICAgICB0aGlzLnllYXIgPSArcGFyYW1zWyd5ZWFyJ107XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIHRvIG91ciByb3V0ZSBwYXJhbWV0ZXJzICh0b3VybmFtZW50IHllYXIpLlxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJvdXRlUGFyYW1zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvdGVhbS1oaXN0b3J5L3RlYW0taGlzdG9yeS5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBIaXN0b3J5WWVhciB9IGZyb20gJy4uL21vZGVsL2hpc3RvcnkteWVhci5tb2RlbCc7XG5cbmV4cG9ydCBjb25zdCBISVNUT1JZX0RBVEE6IEhpc3RvcnlZZWFyW10gPSBbXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE3LFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTcuanBnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+PC9wPlxuICAgICAgICBgXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAxNi5qcGcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5JbGxpbm9pcyBVbHRpbWF0ZSBjYW1lIGludG8gdGhlIDIwMTYgc2Vhc29uIHdpdGggYSB0YXN0ZSBvZiBzdWNjZXNzIGFuZCBiaWcgc2hvZXMgdG8gZmlsbC4gUmV0dXJuaW5nIGNhcHRhaW4gTmljayBQcm96b3JvdnNreSBhbmQgbmV3IGNhcHRhaW5zIFByYXlhZyBQYXRlbCBhbmQgQ2hyaXMgQnVjaHRhIHdlcmUgdGFza2VkIHdpdGggdGhlIGRpZmZpY3VsdCBwcm9zcGVjdCBvZiByZXBsYWNpbmcgdGhlIDEyIGdyYWR1YXRpbmcgcGxheWVycyBhcyB3ZWxsIGFzIGNvYWNoIE1hdHQgU3R1cGNhLiBCb29tbGFuZCBjb2FjaCBFcmlrIEh1ZW1pbGxlciBhbmQgcmVjZW50IGFsdW0gTWF0dCBXZXN0IHdlcmUgYWJsZSB0byBmaWxsIHRoZSBsZWFkZXJzaGlwIHZvaWQgYXMgdGhlIHRlYW0gbG9va2VkIHRvIHJlbG9hZCBmb3IgYW5vdGhlciBydW4gYXQgTmF0aW9uYWxzLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSB0cnlvdXRzIGZvciB0aGUgdGVhbSB3ZXJlIHZlcnkgY29tcGV0aXRpdmUsIHdpdGggdGhlIGJpZ2dlc3QgaW5jb21pbmcgY2xhc3MgaW4gcmVjZW50IG1lbW9yeS4gVGhlIGZpbmFsIHJvc3RlciBpbmNsdWRlZCA3IHJvb2tpZXMsIDEgZ3JhZCBzdHVkZW50LCA1IGZvcm1lciBCb29tbGFuZCBwbGF5ZXJzLCBhbmQgMTIgcmV0dXJuZXJzLiBUaGUgbmV3ZXN0IGl0ZXJhdGlvbiBvZiBJbGxpbm9pcyBVbHRpbWF0ZSB0ZXN0ZWQgdGhlbXNlbHZlcyBhdCBNaXNzb3VyaSBMb3ZlcyBDb21wYW55LCBidXQgcmV0dXJuZWQgd2l0aCBzaG91bGRlciBpbmp1cmllcyB0byBzZW5pb3JzIE5pY2sgUHJvem9yb3Zza3kgYW5kIEFsZXggR3V5IHRoYXQgd291bGQgaGFtcGVyIHRoZW0gZm9yIHRoZSByZXN0IG9mIHRoZSBzZWFzb24uPC9wPlxuICAgICAgICAgICAgPHA+VGhpcyBzcHJpbmcgc2Vhc29uIGhhZCB0aGUgdGVhbSBoZWFkaW5nIHRvIEZsb3JpZGEsIFNvdXRoIENhcm9saW5hLCBhbmQgTWlzc291cmkgaW4gc2VhcmNoIG9mIGVsaXRlIGNvbXBldGl0aW9uLjwvcD5cbiAgICAgICAgICAgIDxwPk1pZCBGZWJydWFyeSBoYWQgdGhlIHRlYW0gZmx5aW5nIHNvdXRoIHRvIGNvbXBldGUgYXQgV2FybSBVcC4gVW5mb3J0dW5hdGVseSwgdGhlIHdlZWsgcHJpb3IgaGFkIGdyYWQgc3R1ZGVudCBDb2R5IEdyYXkgYnJlYWtpbmcgaGlzIGhhbmQgaW4gSXJ3aW4gYW5kIHNlbmlvciBXaWxzb24gV2FuZyBwdWxsaW5nIGhpcyBoYW1zdHJpbmcgaW4gdGhlIEFybW9yeSwgYm90aCBiaWcgaGFuZGxlciBsb3NzZXMuIE9uIFNhdHVyZGF5LCB0aGUgdGVhbSBzdGFydGVkIHdpdGggMTAtMTMgYW5kIDExLTEzIGxvc3NlcyB0byBUZXhhcyBhbmQgRmxvcmlkYSBTdGF0ZS4gVGhlIHRoaXJkIGdhbWUgb2YgdGhlIGRheSB3YXMgYWdhaW5zdCBwZXJlbm5pYWwgcG93ZXJob3VzZSBQaXR0c2J1cmdoLiBJbGxpbm9pcyBjYW1lIG91dCBzbG9wcHkgYW5kIHdhcyBwcmVzc3VyZWQgaW50byBtYWtpbmcgbWFueSBlcnJvcnMsIHJlc3VsdGluZyBpbiBhIDEtNyBzY29yZSBhdCBoYWxmIGFuZCBhbiBlbWJhcnJhc3NpbmcgMi0xMiBsb3NzLCBmaW5pc2hpbmcgMC00IG9uIHRoZSBkYXkgYWZ0ZXIgYW5vdGhlciBsb3NzIHRvIEJZVS4gU2F0dXJkYXkgc3RhcnRlZCBvZmYgYmV0dGVyIHdpdGggYSAxMy01IHdpbiBvdmVyIGhvc3QgU291dGggRmxvcmlkYSwgYnV0IHdhcyBmb2xsb3dlZCBieSBiaWcgbG9zc2VzIHRvIFZpcmdpbmlhIFRlY2ggYW5kIEF1YnVybi4gSWxsaW5vaXMgZmluaXNoZWQgdGhlIHRvdXJuYW1lbnQgMi03LCB3aXRoIGEgdW5pdmVyc2UgbG9zcyB0byBpbiByZWdpb24gcml2YWwgTm9ydGh3ZXN0ZXJuIGFuZCBvbmx5IHdpbnMgY29taW5nIGFnYWluc3QgU291dGggRmxvcmlkYS48L3A+XG4gICAgICAgICAgICA8cD5XaXRoIG1vc3Qgb2YgdGhlIHRlYW0gZmluYWxseSBoZWFsdGh5LCB0aGUgdGVhbSBtYWRlIHRoZSB0cmlwIHRvIEVhc3Rlcm5zIGZvciB0aGUgc2Vjb25kIHRvdXJuYW1lbnQgb2YgdGhlIHNlYXNvbi4gVGhlIGZpcnN0IGdhbWUgb2YgdGhlIHRvdXJuYW1lbnQgd2FzIGEgcmVtYXRjaCBhZ2FpbnN0IFBpdHRzYnVyZ2guIFRoaXMgdGltZSwgSWxsaW5vaXMgd2FzIHByZXBhcmVkIGZvciB0aGUgaW50ZW5zaXR5IGFuZCB3YXMgYWJsZSB0byBtYWtlIGl0IGEgY2xvc2VyIGdhbWUsIGJ1dCBzdGlsbCBsb3N0IDEyLTE1LiBBbm90aGVyIHJlbWF0Y2ggYWdhaW5zdCBWaXJnaW5pYSBUZWNoIGVuZGVkIHNpbWlsYXJseSwgbG9zaW5nIDExLTE0LCBhbmQgdGhlIHRlYW0gZW5kZWQgU2F0dXJkYXkgMC00LCB3aXRoIGEgMTAtMTUgbG9zcyB0byBVTkMgRGFya3NpZGUgYW5kIGFuIDExLTEzIGxvc3MgdG8gcmVnaW9uYWwgcml2YWwgTWljaGlnYW4uIE9uIGEgd2V0LCBjb2xkLCBhbmQgd2luZHkgU3VuZGF5LCBJbGxpbm9pcyB3YXMgbm90IGFibGUgdG8gY29tZSBvdXQgd2l0aCBhbnkgZmlyZSBhbmQgbG9zdCBiYWRseSB0byBKYW1lcyBNYWRpc29uIGFuZCBDb25uZWN0aWN1dCwgZ29pbmcgMC02IG9uIHRoZSB3ZWVrZW5kLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSBmaW5hbCByZWd1bGFyIHNlYXNvbiB0b3VybmFtZW50IG9mIHRoZSB5ZWFyIHdhcyBIdWNrIEZpbm4gYW5kIHRoZSBib3lzIGZyb20gSWxsaW5vaXMgbG9va2VkIHRvIGJvdW5jZSBiYWNrIGZyb20gYSBzbyBmYXIgdW5zdWNjZXNzZnVsIHJlZ3VsYXIgc2Vhc29uLiBXaXRoIGEgbWluZHNldCBvZiBpbXByb3ZpbmcgZm9yIHRoZSBzZXJpZXMgdGhlIElsbGluaSBjYW1lIG91dCB3aXRoIGEgNy0wIGxlYWQgYXQgaGFsZiBvbiBJbmRpYW5hIGFuZCBjbG9zZWQgaXQgb3V0IHdpdGggYW4gMTEtNCB3aW4uIERheXRvbiB3YXMgdGhlIG5leHQgZ2FtZSwgd2hpY2ggd2FzIGEgMTMtNCB3aW4gZm9yIHRoZSBJbGxpbmkgd2hpY2ggbWVhbnQgdGhhdCB0aGV5IHdvdWxkIHBsYXkgTWFyeWxhbmQgZm9yIHRoZSBwb29sLiBBbmtsZSBpbmp1cmllcyB0byBQcmF5YWcgUGF0ZWwgYW5kIEJlbiBGb3N0ZXIgbWVhbnQgdGhhdCB0aGUgTyBsaW5lIHdhcyBwbGF5aW5nIHdpdGhvdXQgdHdvIGtleSBjb250cmlidXRvcnMsIGJ1dCB0aGUgdGVhbSB3YXMgYWJsZSB0byB0b3VnaCBvdXQgYSAxNC0xMSB3aW4sIHNldHRpbmcgdXAgYSBjcm9zc292ZXIgZ2FtZSBhZ2FpbnN0IElsbGlub2lzIFN0YXRlLiBJbiBhIHZlcnkgd2luZHkgZ2FtZSwgSWxsaW5vaXMgdHJpdW1waGVkIG92ZXIgdGhlaXIgaW4gc3RhdGUgY29tcGV0aXRvcnMgaW4gYSAxMC02IHZpY3RvcnksIHNlY3VyaW5nIGEgcXVhcnRlcmZpbmFscyBiZXJ0aC4gVGhlIHRlYW0gY2xvc2VkIG91dCB0aGUgdG91cm5hbWVudCB3aXRoIGxvc3NlcyB0byBBcmthbnNhcyBhbmQgUHVyZHVlLCBhbmQgcHJlcGFyZWQgdGhlbXNlbHZlcyBmb3IgQ29uZmVyZW5jZXMuPC9wPlxuICAgICAgICAgICAgPHA+T25jZSBhZ2FpbiwgUmFudG91bCB3YXMgaG9zdCB0byBDb25mZXJlbmNlcywgYnV0IHRoaXMgdGltZSB0aGVyZSBjb3VsZCBiZSBubyBjb21wbGFpbnRzIGFib3V0IHRoZSB3ZWF0aGVyLiBJbGxpbm9pcyBzdGFydGVkIG91dCBzdHJvbmcgd2l0aCBjb21mb3J0YWJsZSB3aW5zIG92ZXIgdGhlIHJlc3Qgb2YgdGhlIHBvb2wsIGluY2x1ZGluZyBhbiAxMS00IHZpY3Rvcnkgb3ZlciBVQ2hpY2Fnby4gV2lubmluZyB0aGUgcG9vbCBsaW5lZCB1cCBhIHNlbWlmaW5hbCBnYW1lIGFnYWluc3QgSWxsaW5vaXMgU3RhdGUsIHdoaWNoIHdhcyB3b24gaGFuZGlseSAxMy03IGFuZCBzZXQgdXAgYSBjbGFzc2ljIElsbGlub2lzIC0gTm9ydGh3ZXN0ZXJuIHJlbWF0Y2guIFVuZm9ydHVuYXRlbHksIHRoZSB0ZWFtIHN0cnVnZ2xlZCB0byBmaW5kIHRoZSBlbmR6b25lIGFuZCBmb3IgdGhlIHNlY29uZCB5ZWFyIGluIGEgcm93LCBsb3N0IHRvIE5vcnRod2VzdGVybiBhdCBDb25mZXJlbmNlcy4gSW4gdGhlIDJuZCBwbGFjZSBtYXRjaCBhZ2FpbnN0IFVDaGljYWdvLCBJbGxpbm9pcyB3YXMgdW5hYmxlIHRvIGZpbmQgYSBncm9vdmUgYW5kIGxvc3QgOS0xMS4gV2l0aCBSZWdpb25hbHMgaW4gdHdvIHdlZWtzIGFuZCBvbmx5IG9uZSBiaWQgZm9yIHRoZSByZWdpb24sIElsbGlub2lzIGhhZCBhIGxvdCBvZiB3b3JrIHRvIGRvLjwvcD5cbiAgICAgICAgICAgIDxwPkluIGEgY2hhbmdlIG9mIHBhY2UsIFJlZ2lvbmFscyB3YXMgbm90IGhvc3RlZCBpbiBSb2NrZm9yZCwgYnV0IGluIEZhaXIgT2FrcywgSW5kaWFuYS4gVGhlIGNvbmRpdGlvbnMgd2VyZSB0ZXJyaWJsZSwgbG93IHRlbXBlcmF0dXJlcyBjb3VwbGVkIHdpdGggaGVhdnkgd2luZCBhbmQgcmFpbiBtZWFudCB0aGF0IGl0IHdvdWxkIGJlIGRpZmZpY3VsdCBnZXR0aW5nIGEgZ29vZCBncmlwLiBJbiB0aGUgZmlyc3QgZ2FtZSBhZ2FpbnN0IEtlbnR1Y2t5LCBib3RoIE8gYW5kIEQgbGluZSB3ZXJlIGFibGUgdG8gcGVyZm9ybSB3ZWxsLCBnaXZpbmcgdXAgbm8gYnJlYWtzIGFuZCBoYW5kaW5nIG91dCBhIGZldyBvZiB0aGVpciBvd24gYW5kIGZpbmlzaGluZyB3aXRoIGEgc2NvcmUgb2YgMTItNi4gVGhlIHRyZW5kIGNvbnRpbnVlZCBhZ2FpbnN0IEluZGlhbmEsIHdpdGggSWxsaW5vaXMgd2lubmluZyAxMy02LiBOZXh0IHVwIHdhcyBOb3RyZSBEYW1lLCBhIHJlbWF0Y2ggb2YgbGFzdCB5ZWFy4oCZcyBmaW5hbHMsIHdpbm5lciB0YWtlcyB0aGUgcG9vbCBhbmQgcXVhcnRlcmZpbmFscyBiZXJ0aC4gQSBjb21wbGV0ZWx5IHVwd2luZC9kb3dud2luZCBnYW1lIGZvdW5kIHRoZSBkIGxpbmUgd2l0aCBvcHBvcnR1bml0aWVzIHRvIGJyZWFrLCBidXQgbmV2ZXIgYWJsZSB0byBmaW5pc2ggdGhlIGpvYi4gV2l0aCBuZWl0aGVyIHRlYW0gYmVpbmcgYnJva2VuLCBOb3RyZSBEYW1lIHdvbiB0aGUgZmxpcCBhbmQgdGhlIGdhbWUsIDktMTAuIElsbGlub2lzIGZpbmlzaGVkIHVwIHRoZSBkYXkgd2l0aCBhIDEzLTUgd2luIG92ZXIgTWljaGlnYW4gU3RhdGUgdG8gc2V0IHVwIGEgcXVhcnRlcmZpbmFscyBtYXRjaHVwIGFnYWluc3QgTm9ydGh3ZXN0ZXJuLjwvcD5cbiAgICAgICAgICAgIDxwPkNvbmRpdGlvbnMgb24gU3VuZGF5IHdlcmUgYmV0dGVyIGFuZCB3aXRoIGEgbGl0dGxlIHN1cHBvcnQgZnJvbSBXYWxkZW4gTmVsc29uLCB0aGUgdGVhbSB3YXMgcmVhZHkgdG8gYXZlbmdlIHRoZWlyIHJlY2VudCBsb3NzZXMuIElsbGlub2lzIHN0YXJ0ZWQgb24gRCBhbmQgTm9ydGh3ZXN0ZXJuIGNhbWUgb3V0IHdpdGggYW4gYnJlYWsgZWFybHkgaW4gdGhlIGdhbWUsIGJ1dCB0aGUgdGVhbSBmb3VnaHQgYmFjayBhbmQgYnJlYWtzIHdlcmUgdHJhZGVkIHRvIGhhdmUgaXQgYmUgb24gc2VydmUgYXQgaGFsZi4gVGhlIHNlY29uZCBoYWxmIGNvbW1lbmNlZCB3aXRoIG1vcmUgb2YgYSBjbGVhbmVyIGdhbWUsIHdpdGggYm90aCB0ZWFtcyB0cmFkaW5nIG9mZmVuc2l2ZSBob2xkcy4gQSBjaGFuY2UgYXQgYSBicmVhayBkdWUgdG8gYSBOaWNrIFBybyBza3kgd2FzIGNhbGxlZCBiYWNrIG9uIGEgY29udHJvdmVyc2lhbCBvYnNlcnZlciBydWxpbmcgYW5kIHRoZSBnYW1lIHJlYWNoZWQgc29mdGNhcCB3aXRoIHRoZSBzY29yZSAxMC0xMS4gQ2hyaXMgQnVjaHRhIHRpZWQgdXAgdGhlIHNjb3JlIHdpdGggYSBodWNrIGZyb20gS2V2aW4gTGluIGFuZCB0aGUgZCBsaW5lIHdlbnQgb3V0IHRvIHRyeSBhbmQgYnJlYWsgd2l0aCB0aGUgc2Vhc29uIG9uIHRoZSBsaW5lLiBBZnRlciBhIHR1cm4gZnJvbSBOb3J0aHdlc3Rlcm4sIElsbGlub2lzIHdvcmtlZCB0aGUgZGlzYyBkb3duIHRoZSBmaWVsZCBhbmQgcm9va2llIEphY29iIEN1dGhiZXJ0IHRvb2sgYSB0aW1lb3V0IG91dHNpZGUgb2YgdGhlIGVuZHpvbmUuIE9uZSBlbmR6b25lIHNldCBsYXRlciwgUHJheWFnIGZvdW5kIEN1dGhiZXJ0IGZvciB0aGUgd2luLCBzZW5kaW5nIElsbGlub2lzIHRvIHRoZSBzZW1pZmluYWxzLjwvcD5cbiAgICAgICAgICAgIDxwPkR1ZSB0byB0aGUgbG9zcyBpbiBwb29sIHBsYXksIElsbGlub2lz4oCZcyBtYXRjaHVwIGluIHRoZSBzZW1pZmluYWxzIHdhcyBNaWNoaWdhbi4gRGVzcGl0ZSB0aGUgdG91Z2ggZ2FtZSBiZWZvcmUsIElsbGlub2lzIGhhZCB0byBjb21lIG91dCBob3QgaWYgdGhleSB3YW50ZWQgdG8gd2luIHRoZSBnYW1lLiBNaWNoaWdhbiBjYW1lIG91dCBvZiB0aGUgZ2F0ZSBmYXN0LCBzY29yaW5nIG9uIGEgaHVjay4gSWxsaW5vaXMgZm9sbG93ZWQgc3VpdCwgYW5kIHRoZSB0d28gdGVhbXMgdHJhZGVkIG9mZmVuc2l2ZSBob2xkcyB1bnRpbCBNaWNoaWdhbiBicm9rZSBmb3IgMy01LiBBcyB0aGUgZ2FtZSB3ZW50IG9uLCB0aGUgZGVmZW5zaXZlIHByZXNzdXJlIGZyb20gTWljaGlnYW4gaW50ZW5zaWZpZWQgYW5kIElsbGlub2lz4oCZIG8gbGluZSB3YXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIGdvYWxzIHRoYXQgTWljaGlnYW7igJlzIG8gbGluZSB3YXMgcHV0dGluZyBvdXQuIENvbWluZyBvdXQgb2YgaGFsZiBhdCA1LTgsIElsbGlub2lzIHR1cm5lZCBhbmQgd2FzIGJyb2tlbiBhZ2Fpbi4gQSBsYXRlIGluanVyeSB0byBQcmF5YWcgcHVzaGVkIHRoZSBob3BlIG9mIGEgY29tZWJhY2sgYSBsaXR0bGUgZnVydGhlciBvdXQgb2YgcmVhY2ggYW5kIGEgc2VuaW9yIGQgbGluZSB3YXMgdW5hYmxlIHRvIGtlZXAgTWljaGlnYW4gZnJvbSBzZWl6aW5nIHRoZSB2aWN0b3J5IDEwLTE1LiBNaWNoaWdhbiB3ZW50IG9uIHRvIGRlZmVhdCBOb3RyZSBEYW1lIDE1LTkgdG8gdGFrZSB0aGUgYmlkIHRvIE5hdGlvbmFscy4gSWxsaW5vaXMgZmluaXNoZWQgdGhlIHNlYXNvbiB3aXRoIGEgMTEtMTAgdmljdG9yeSBvdmVyIFB1cmR1ZSBmb3IgM3JkIGluIHRoZSByZWdpb24uPC9wPlxuICAgICAgICAgICAgPHA+Q2FwdGFpbiBOaWNrIFByb3pvcm92c2t5IGFuZCBKb2huIFNhbmlhdCByZWNlaXZlZCAxc3QgdGVhbSBBbGwtUmVnaW9uIGhvbm9ycyBhbmQgQ2FwdGFpbiBQcmF5YWcgUGF0ZWwgcmVjZWl2ZWQgMm5kIHRlYW0gQWxsLVJlZ2lvbi4gQmVuIFNhYm91cmluIGFuZCBKYWNvYiBDdXRoYmVydCB3ZXJlIHZvdGVkIEFsbC1GcmVzaG1lbiBmb3IgdGhlIHJlZ2lvbiwgd2l0aCBCZW4gd2lubmluZyBGcmVzaG1hbiBvZiB0aGUgWWVhci48L3A+XG4gICAgICAgIGBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNSxcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDE1LmpwZycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPkFmdGVyIHRoZSB3b3JzdCByZWdpb25hbHMgcGVyZm9ybWFuY2Ugc2luY2UgMjAwNiwgSWxsaW5vaXMgZW50ZXJlZCB0aGUgMjAxNSBzZWFzb24gd2l0aCBhIG5ldyBsb29raW5nIHRlYW0gYW5kIGEgbmV3IG1pbmRzZXQuIE1ham9yIGxvc3NlcyBpbmNsdWRlZCBsb25nIHRpbWUgY29hY2ggV2FsZGVuIE5lbHNvbiwgYXMgd2VsbCBhcyBPLWxpbmUgc3RhcnMgTmVhbCBQaGVscHMsIEJyaWFuIFJhdGh1bmRlLCBhbmQgU2VhbiBIaWxsLiBNYXJ0eSBNYXJrZW5zb24gcmV0dXJuZWQgYXMgY2FwdGFpbiBhbmQgd2FzIGpvaW5lZCBieSBmaXJzdC10aW1lcnMgSm9obm55IFNhbmlhdCBhbmQgTmljayBQcm96b3JvdnNreS48L3A+XG4gICAgICAgICAgICA8cD5UaGUgbWFqb3IgY2hhbmdlIHRvIHRoZSB0ZWFtIGNhbWUgaW4gdGhlIGZvcm0gb2YgcmV0dXJuaW5nIGNvYWNoLCBNYXR0IFN0dXBjYS4gTWF0dCBjb2FjaGVkIHRoZSB0ZWFtIGZyb20gMjAwNi0yMDA5IGFuZCBicm91Z2h0IHRoZW0gdG8gTmF0aW9uYWxzIHR3aWNlLCBmaW5pc2hpbmcgaW4gNXRoIHBsYWNlIGluIDIwMDguIFRoZSBleHBlcmllbmNlZCBjb2FjaCBnYXZlIHRoZSB0ZWFtIHRoZSBuZWNlc3NhcnkgbGVhZGVyc2hpcCBuZWVkZWQgdG8gcmVidWlsZCB0aGUgY2x1YiBmb3IgYSBwb3NzaWJsZSBOYXRpb25hbHMgcnVuIGFnYWluLjwvcD5cbiAgICAgICAgICAgIDxwPkFzIGFsd2F5cywgdGhlIGZhbGwgdHJ5b3V0cyB3ZXJlIGNvbXBldGl0aXZlIGFuZCBleGNpdGluZywgd2l0aCBhbm90aGVyIHN0cm9uZyByb29raWUgY2xhc3MgYW5kIG1hbnkgQi10ZWFtZXJzIGFuZCBvdXRzaWRlcnMgam9pbmluZyB0aGUgc2NlbmUuIFdoZW4gaXQgd2FzIGFsbCBzYWlkIGFuZCBkb25lLCB0aGUgZmluYWwgcm9zdGVyIGNvbnNpc3RlZCBvZiAyMyBwZW9wbGUuIFRoZSByb3N0ZXIgaW5jbHVkZWQgMiByb29raWVzLCA1IEItdGVhbWVycywgMTUgcmV0dXJuZXJzLCBhbmQgMSB0cmFuc2ZlciBzdHVkZW50LiBOZXcgYWRkaXRpb25zIGluY2x1ZGVkIFZhbHBhcmFpc28gc3R1ZCwgTWF0dCBXZXN0LCBiYXNrZXRiYWxsIGNyb3Nzb3ZlciBKYXJyZWQgRWxsaW90LCBsb3ZhYmxlIHNwaXJpdCBsZWFkZXIgRXJpYyBCYWRnZXIsIGFuZCByb29raWVzIEtldmluIExpbiBhbmQgSmFjb2IgS29tZW5kYS48L3A+XG4gICAgICAgICAgICA8cD5Db21lIGVuZCBvZiBmYWxsLCBJbGxpbm9pcyB3YXMgcmUtYXJtZWQgYW5kIHJlYWR5IGZvciBhbm90aGVyIHJ1biBmb3IgTmF0aW9uYWxzIGluIHRoZSBzcHJpbmcgc2Vhc29uLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSBzcHJpbmcgc2Vhc29uIHNjaGVkdWxlIHdhcyBwZXJoYXBzIG9uZSBvZiBJbGxpbm9pcycgbW9zdCBidXN5LiBUaGUgdGVhbSB3YXMgc2NoZWR1bGVkIHRvIGF0dGVuZCAzIG9mIHRoZSBoaWdoZXN0IGxldmVsIHRvdXJuYW1lbnRzIGFyb3VuZCB0aGUgY291bnRyeSwgaW5jbHVkaW5nIHRvdXJuYW1lbnRzIGluIFRleGFzLCBGbG9yaWRhLCBhbmQgU291dGggQ2Fyb2xpbmEuPC9wPlxuICAgICAgICAgICAgPHA+V2hlbiBGZWJydWFyeSBjYW1lIGFyb3VuZCwgaXQgd2FzIHRpbWUgdG8gaGVhZCBzb3V0aCB0byBUYW1wYSBmb3IgdGhlIGZpcnN0IHNwcmluZyB0b3VybmFtZW50LCBGbG9yaWRhIFdhcm0tVXAuIEZvciB0aGUgZmlyc3QgdGltZSwgdGhlIHRlYW0gdHJhdmVsZWQgYnkgYWlyIHRvIGEgdG91cm5hbWVudC4gV2FybS1VcCwgYSB0aHJlZSBkYXkgdG91cm5hbWVudCwgcHJvdmVkIHRvIGJlIGEgdXNlZnVsIGxlc3NvbiB0byB0aGUgdGVhbS4gT24gZGF5IG9uZSwgdGhlIElsbGluaSB3ZW50IDEtMyB3aXRoIG9ubHkgb25lIHdpbiBpbiBhIG5pZ2h0IGdhbWUgdnMuIENvcm5lbGwuIEl0IHdhcyBhIGRpc2FwcG9pbnRpbmcgcGVyZm9ybWFuY2UsIGJ1dCBkYXkgdHdvIHNwZWx0IGRpZmZlcmVudCBzdG9yaWVzIGZvciBJbGxpbm9pcy4gU2F0dXJkYXkgbW9ybmluZywgVGhlIElsbGluaSB3b3VsZCBwbGF5IHRoZSByZXZlcmVkIE5hdGlvbmFscyB0ZWFtIFVDRiBpbiBhIGdhbWUgdGhhdCB3YXMgcmVjb3JkZWQgYnkgVWx0aXdvcmxkLiBUaGUgSWxsaW5pIHdlcmUgbm8gZG91YnQgdW5kZXJkb2dzLCBidXQgZm91Z2h0IGhhcmQgdG8gdGFrZSBhIGxlYWQgb24gdGhlIERvZ3Mgb2YgV2FyLiBNYWpvciBwbGF5cyBpbmNsdWRlZCBhIENhbGxhaGFuIGJ5IGhhbmRsZXIgUHJheWFnIFBhdGVsIGFuZCBhIGh1Y2sgYnJlYWstc2NvcmUgYnkgTWF4IFdpbGxpcyB0byByb29raWUgSmFjb2IgS29tZW5kYS4gVGhlIERvZ3Mgb2YgV2FyIGZvdWdodCwgYnV0IHRoZSBJbGxpbmkgcHVsbGVkIHRocm91Z2gsIHdpbm5pbmcgdGhlIGdhbWUgMTMtOSBhbmQgY2xhaW1pbmcgb25lIG9mIHRoZSBiaWdnZXN0IHVwc2V0cyBvZiB0aGUgdG91cm5hbWVudC4gSWxsaW5vaXMgd291bGQgY3J1aXNlIHRvIHR3byBtb3JlIHdpbnMgdGhhdCBkYXksIGZpbmlzaGluZyAzLTAgZm9yIFNhdHVyZGF5LiBXaXRoIGVtb3Rpb25zIGhpZ2ggYnV0IGxlZ3MgdGlyZWQsIHRoZSBJbGxpbmkgZmluaXNoZWQgb2ZmIHRoZSBsb25nIHdlZWtlbmQgd2l0aCBhIHRvdWdoIGxvc3MgYWdhaW5zdCBHZW9yZ2V0b3duIGFuZCBhIHdpbiBhZ2FpbnN0IFdpc2NvbnNpbi1NaWx3YXVrZWUgb24gU3VuZGF5IHRvIGVuZCBGbG9yaWRhIFdhcm0gdXAuIFRoZXkgZmluaXNoZWQgNS00IG9uIHRoZSB3ZWVrZW5kLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSBuZXh0IGJpZyB0b3VybmFtZW50IHdhcyB0aGUgZmFtb3VzIENlbnRleCBpbnZpdGUgaW4gQXVzdGluLCBUZXhhcy4gVGhlIHRlYW0gd2FzIHNlZWRlZCA5dGggb3ZlcmFsbCBvdXQgb2YgMjAgYWZ0ZXIgdGhlaXIgaW1wcmVzc2l2ZSB3aW4gYWdhaW5zdCBDZW50cmFsIEZsb3JpZGEgYmFjayBhdCBXYXJtLVVwLiBXaXRoIGhpZ2ggZXhwZWN0YXRpb25zLCB0aGUgSWxsaW5pIHdvdWxkIGp1bXAgcmlnaHQgaW50byBpdCwgcGxheWluZyBvbmUgb2YgdGhlIGJlc3QgdGVhbXMgb2YgMjAxNSwgTm9ydGgtQ2Fyb2xpbmEgV2lsbWluZ3Rvbi4gVGhlIGZpcnN0IHBvaW50IG9mIHRoZSBnYW1lIHdvdWxkIHByb3ZlIHRvIGJlIHNvbWV3aGF0IG9mIGEgdGhlbWUgZm9yIHRoZSBJbGxpbmkgdGhhdCB3ZWVrZW5kLCBhcyB0b3AgY3V0dGVyIE5pY2sgUHJvem9yb3Zza3kgd291bGQgZ28gZG93biB3aXRoIGEga25lZSBpbmp1cnkuIFRoZSBJbGxpbmkgY291bGQgbm90IHVwc2V0IHRoZSBiaWcgZG9nIHRoaXMgdGltZSB0aG91Z2gsIGFzIFdpbG1pbmd0b24gd29uIGNvbWZvcnRhYmx5IGF0IDExLTMuPC9wPlxuICAgICAgICAgICAgPHA+QXMgdGhlIGRheSB3ZW50IG9uLCB0aGUgaW5qdXJpZXMgY29udGludWVkLiBOZWFybHkgaGFsZiBvZiB0aGUgSWxsaW5pIHNxdWFkIHdvdWxkIGdvIGRvd24gdGhhdCBkYXkuIFRoZSBwYWluIGFsc28gc2hvd2VkIGluIHRoZSBzY29yZXMsIGFzIHRoZSBJbGxpbmkgd291bGQgbG9zZSB0byBUZXhhcyAxMi01IGFuZCBmYWxsIHRvIHR3byBsb3dlci1zZWVkZWQgdGVhbXMgQXJrYW5zYXMgYW5kIElvd2EuIFRoZXkgZmluaXNoZWQgMC00IG9uIFNhdHVyZGF5LiA8L3A+XG4gICAgICAgICAgICA8cD5JbiB0aGUgbG9zZXIncyBicmFja2V0IG9uIFN1bmRheSwgSWxsaW5vaXMgd291bGQgZ28gMy0wIHdpdGggd2lucyBvdmVyIENhbGlmb3JuaWEsIElvd2EgU3RhdGUsIGFuZCBXaXNjb25zaW4tTWlsd2F1a2VlLiA8L3A+XG4gICAgICAgICAgICA8cD5UaGUgZmluYWxlIG9mIHRoZSBzcHJpbmcgdG91cm5hbWVudHMgd2FzIHRoZSB2ZXJ5IGNvbXBldGl0aXZlIEVhc3Rlcm5zIGluIE5vcnRoIE15cnRsZSBCZWFjaCwgU291dGggQ2Fyb2xpbmEsIHdoaWNoIGEgeWVhciBlYXJsaWVyIHdhcyB3b24gYnkgR3JlYXQgTGFrZXMgcmVnaW9uIHJpdmFsIE1pY2hpZ2FuLiBUaGUgSWxsaW5pIHdlbnQgaW50byB0aGUgdG91cm5hbWVudCB3aXRoIGEgYml0IG9mIGEgZGlmZmVyZW50IGxvb2ssIGFzIEJvb21sYW5kIGNvYWNoIEVyaWsgSHVlbWlsbGVyIHdvdWxkIGZpbGwgaW4gZm9yIGNvYWNoIE1hdHQgU3R1cGNhIGFzIHdlbGwgYXMgbnVtZXJvdXMgaW5qdXJlZCBhbmQgYWJzZW50IHBsYXllcnMgcmV0dXJuaW5nIHRvIHRoZSBzcXVhZC4gVGhleSB3ZXJlIHNlZWRlZCBhcyB0aGUgMjAgc2VlZCwgd2l0aCBub3doZXJlIHRvIGdvIGJ1dCB1cC48L3A+XG4gICAgICAgICAgICA8cD5JbiBhIGhpZ2hseSBjb21wZXRpdGl2ZSBwb29sLCB0aGUgSWxsaW5pIHdvdWxkIHN0YXJ0IG9mZiBhZ2FpbnN0IHRoZSAyMDEyLTIwMTMgbmF0aW9uYWwgY2hhbXBpb25zLCBQaXR0c2J1cmdoLiBQaXR0IGhhZCB3b24gZXZlcnkgdG91cm5hbWVudCB1cCB0byB0aGlzIHBvaW50LiBUaGUgSWxsaW5pIHRvb2sgYWR2YW50YWdlIG9mIFBpdHRzIG1hbnkgc2xvcHB5IG1pc3Rha2VzLCBidXQgY291bGQgbm90IGNvbWUgYXdheSB3aXRoIGFub3RoZXIgdXBzZXQsIGZhbGxpbmcgMTUtMTAuIFRoZSB0cm91YmxlcyBjb250aW51ZWQsIHdpdGggbG9zc2VzIHRvIENhcmxldG9uIENvbGxlZ2UsIFVNYXNzLCBhbmQgR2VvcmdpYS4gVGhpcyBwdXQgdGhlIElsbGluaSdzIGZpcnN0IGRheSByZWNvcmQgYXQgYSB0cm91YmxpbmcgMS0xMiBvbiB0aGUgc2Vhc29uLjwvcD5cbiAgICAgICAgICAgIDxwPlN1bmRheSB3b3VsZCBwcm92ZSB0byBiZSBhbiBpbXBvcnRhbnQgZGF5IGZvciB0aGUgSWxsaW5pLiBEZXNwaXRlIHRoZSB0cm91YmxlcyBvbiBEYXkgMXMsIHRoZSBJbGxpbmkgaGFkIHBsYXllZCB3ZWxsIHRoZSBzZWNvbmQgZGF5IG9mIHRvdXJuYW1lbnRzIGFsbCBzZWFzb24sIHdpdGggYSA2LTAgcmVjb3JkLiBBcyB0aGUgbGFzdCByYW5rZWQgc2VlZCBhdCB0aGUgdG91cm5hbWVudCwgdGhleSB3b3VsZCBmaWdodCB0byBicmVhayBzZWVkIGFnYWluc3QgTkMgU3RhdGUsIENvbG9yYWRvIFN0YXRlLCBhbmQgMTAtc2VlZGVkIEF1YnVybi48L3A+XG4gICAgICAgICAgICA8cD5XaXRoIG1hbnkgZGlmZmVyZW50IHBvc2l0aW9uIGNoYW5nZXMsIHRoZSBJbGxpbmkgY2FtZSBvdXQgd2l0aCBhIG5ldyBmaXJlLCBnb2luZyAzLTAgYWdhaW4gb24gU3VuZGF5IGFuZCB0YWtpbmcgb3V0IHRoZSBjb21wZXRpdGlvbiBoYW5kaWx5LiBXaXRoIHRoaXMsIHRoZSBJbGxpbmkgc3ByaW5nIHJlZ3VsYXIgc2Vhc29uIHdvdWxkIGNvbWUgdG8gYW4gZW5kLiBUaGV5IHdvdWxkIGZpbmlzaCB3aXRoIGEgMTAtMTIgcmVjb3JkLCB3aXRoIG9ubHkgb25lIG9mIHRob3NlIHdpbnMgY29taW5nIG9uIGRheSBvbmUgb2YgYSB0b3VybmFtZW50LiBUaGlzIGlzc3VlIHdvdWxkIGJlIGluIHRoZSBiYWNrIG9mIGV2ZXJ5b25lJ3MgaGVhZCBnb2luZyBpbnRvIHRoZSBwb3N0c2Vhc29uLjwvcD5cbiAgICAgICAgICAgIDxwPlNlY3Rpb25hbHMsIGFzIGFsd2F5cywgd2FzIGhlbGQgaW4gUmFudG91bCwgSUwuIFRoZSBJbGxpbmkgY2FtZSBpbiBhcyB0aGUgZmF2b3JpdGUsIHdpdGggTm9ydGh3ZXN0ZXJuIGFuZCBVQ2hpY2FnbyBzaXR0aW5nIGNsb3NlIGJlaGluZC4gVGhlIElsbGluaSB3b3VsZCByb3VnaCBvdXQgd2lucyBhZ2FpbnN0IEVhc3Rlcm4gSWxsaW5vaXMgYW5kIFNvdXRoZXJuIElsbGlub2lzIGJlZm9yZSB0YWtpbmcgb24gVUNoaWNhZ28sIHdobyBoYWQgZW5kZWQgdGhlaXIgMjAxNCBzZWFzb24gZHJhbWF0aWNhbGx5IGxhc3QgeWVhciBhdCByZWdpb25hbHMuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIGdhbWUgd2FzIHVwIGFuZCBkb3duIGJ1dCBldmVudHVhbGx5IGVuZGVkIGluIGFub3RoZXIgY3J1c2hpbmcgbG9zcyBmb3IgdGhlIElsbGluaSBvbiB1bml2ZXJzZSBwb2ludC4gVGhpcyBzZW50IHRoZSBJbGxpbmkgaW50byBTdW5kYXkgd2l0aCBhIGZpcnN0IHJvdW5kIG1hdGNoIGFnYWluc3Qgb3RoZXIgcml2YWwgTm9ydGh3ZXN0ZXJuLCB3aG8gdGhlIHRlYW0gaGFkbid0IHBsYXllZCBzaW5jZSBsYXN0IHllYXIuIFRoZSBnYW1lIHdhcyBjbG9zZSBlYXJseSBvbiwgYnV0IHRoZSB1cHN0YXRlIHJpdmFscyBwdWxsZWQgYWhlYWQgYW5kIGV2ZW50dWFsbHkgdG9vayB0aGUgZ2FtZSAxNS05LiBJdCB3YXMgdGhlIHNlY29uZCB2ZXJ5IGFsYXJtaW5nIGxvc3MgaW4gYSByb3cgZm9yIHRoZSBJbGxpbmksIGFuZCBmb3IgdGhlIGZpcnN0IHRpbWUgaW4geWVhcnMsIHdvdWxkIGVsaW1pbmF0ZSB0aGVtIGZyb20gd2lubmluZyBzZWN0aW9uYWxzLjwvcD5cbiAgICAgICAgICAgIDxwPkRlc3BpdGUgdGhpcyBuZXdzLCB0aGUgSWxsaW5pIHRvb2sgZG93biBJbGxpbm9pcyBTdGF0ZSBpbiB0aGUgbmV4dCBnYW1lIHRvIGVuc3VyZSBhbm90aGVyIGdhbWUgYWdhaW5zdCBVQ2hpY2FnbyBmb3Igc2Vjb25kIHBsYWNlIGluIHRoZSBzZWN0aW9uLiBJbiB0aGUgZ2FtZSB0aGF0IGhhZCBhIGdhbWUgdG8gZ28gYXRtb3NwaGVyZSwgdGhlIElsbGluaSBmaW5hbGx5IHdlcmUgYWJsZSB0byBoaXQgb24gYWxsIGN5bGluZGVycywgYmxvd2luZyBvdXQgdGhlaXIgcmVjZW50IHJpdmFscyAxNS02IGFuZCB0YWtpbmcgc2Vjb25kIHBsYWNlIGF0IHNlY3Rpb25hbHMuIEl0IHdvdWxkIHByb3ZlIHRvIGJlIHNvbWV3aGF0IG9mIGEgd2VpZ2h0IGxpZnRlZCBvZmYgZXZlcnlvbmUncyBiYWNrIGdvaW5nIGludG8gcmVnaW9uYWxzLCBidXQgdGhlcmUgd2FzIHN0aWxsIG11Y2ggd29yayB0byBiZSBkb25lLjwvcD5cbiAgICAgICAgICAgIDxwPlJlZ2lvbmFscyB3YXMgYmFjayBhdCBSb2NrZm9yZCwgYSBwbGFjZSBvZiBtYW55IGVtb3Rpb25zIGZvciBtb3N0IElsbGlub2lzIHBsYXllcnMuIElsbGlub2lzIGNhbWUgaW4gYXMgdGhlIDMgc2VlZDsgaW4gYSBwb29sIHdpdGggUHVyZHVlLCBHcmFuZCBWYWxsZXksIGFuZCBhZ2FpbiwgVUNoaWNhZ28uIFRoZSByZWNlbnQgdXBzIGFuZCBkb3ducyBvZiB0aGUgSWxsaW5vaXMgc2Vhc29uLCBhcyB3ZWxsIGFzIGluc3BpcmluZyBtZXNzYWdlcyBieSBjb2FjaCBTdHVwY2EgYW5kIHNvbWUgb2YgdGhlIHBsYXllcnMsIGhhZCB0aGUgdGVhbSBmb2N1c2VkIGFzIGV2ZXIuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIGZpcnN0IGdhbWUgYWdhaW5zdCBQdXJkdWUgc2F3IHRoZSBPLUxpbmUgaW4gY3J1aXNlIGNvbnRyb2wgd2l0aCBhIGxldmVsIG9mIGNvbnNpc3RlbmN5IG5vdCBzZWVuIGJlZm9yZSBpbiB0aGUgc2Vhc29uLiBXaXRoIGEgZmV3IGJyZWFrcyBtaXhlZCBpbiwgdGhlIElsbGluaSB0b29rIHRoZSBmaXJzdCBnYW1lIG9mIHRoZSBkYXkgMTEtOC4gV2l0aCBhbiBlYXNpZXIgMTMtNiB3aW4gYWdhaW5zdCBHcmFuZCBWYWxsZXkgU3RhdGUsIElsbGlub2lzIHdvdWxkIHBsYXkgdGhlaXIgZmluYWwgZ2FtZSBvZiB0aGUgZGF5IGFnYWluc3QgVUNoaWNhZ28uIFRoZSBnYW1lIHdhcyBwbGF5ZWQganVzdCBhIGZldyBmaWVsZHMgYXdheSBmcm9tIHdoZXJlIENoaWNhZ28gZW5kZWQgSWxsaW5vaXMgc2Vhc29uIG9uZSB5ZWFyIHByaW9yLiBFbW90aW9ucyByYW4gaGlnaCBhZ2FpbiwgYnV0IHRoZSBJbGxpbmkgZmluYWxseSBwdXQgVUNoaWNhZ28gdG8gcmVzdCBpbiBhbiAxMS01IHZpY3RvcnkuIEl0IHdhcyBhIGJpZyBzdGF0ZW1lbnQgZm9yIElsbGlub2lzIGFuZCBzZW50IHRoZW0gaW50byBTdW5kYXkncyBjaGFtcGlvbnNoaXAgYnJhY2tldCByaWRpbmcgaGlnaC48L3A+XG4gICAgICAgICAgICA8cD5JbGxpbm9pcyB3ZW50IGludG8gU3VuZGF5IHN0aWxsIG5vdCBoYXZpbmcgYmVlbiBicm9rZW4geWV0LCBhIHRydWUgdGVzdGFtZW50IHRvIHRoZWlyIE8tbGluZSdzIGltcHJvdmVkIGZvY3VzLiBUaGUgZmlyc3QgZ2FtZSBvZiB0aGUgZGF5IHdhcyBhZ2FpbnN0IGxhc3QgeWVhcidzIHNlY29uZCBOYXRpb25hbHMgdGVhbSBmcm9tIHRoZSByZWdpb24sIEVhc3Rlcm4gTWljaGlnYW4uIFRoZSBnYW1lIHdhcyB0aWdodCB0aHJvdWdob3V0IHdpdGggYm90aCBPLWxpbmVzIHRyYWRpbmcsIGJ1dCB0aGUgSWxsaW5pIHB1bGxlZCB0aHJvdWdoIHRvIHdpbiB0aGUgZ2FtZSAxNS0xMi4gVGhlIGdhbWUgc2F3IHRoZSBJbGxpbmkgbGV0IHVwIG9uZSBicmVhaywgd2hpY2ggd2FzIHRoZSBmaXJzdCBicmVhayBhbGxvd2VkIGFsbCB3ZWVrZW5kLjwvcD5cbiAgICAgICAgICAgIDxwPlRoaXMgc2VudCB0aGUgdGVhbSBpbnRvIHNlbWlzIGFnYWluc3QgdGhlaXIgYXRobGV0aWMsIEJpZyAxMCBjb3VudGVycGFydHMsIEluZGlhbmEuIEluZGlhbmEsIGZvciB0aGUgbW9zdCBwYXJ0LCB3YXMgY29tcGxldGVseSB1bmZhbWlsaWFyIHRvIHRoZSBJbGxpbmkncyBwbGF5IHN0eWxlIGdvaW5nIGludG8gdGhlIG1hdGNodXAuIFdpdGggdGhlICdnYW1lIHRvIGdvJyBpbiB0aGUgYmFjayBvZiBldmVyeW9uZSdzIGhlYWRzLCB0aGUgSWxsaW5pIHBvdXJlZCBvbiB0aGUgcG9pbnRzIGFuZCB3b24gMTUtNSwgY2xhaW1pbmcgdGhlaXIgYmlnZ2VzdCB2aWN0b3J5IG9mIHRoZSB0b3VybmFtZW50LiBUaGUgRC1MaW5lIHNoaW5lZCB0aGlzIGdhbWUsIGdpdmluZyB0aGUgTy1saW5lIGEgbXVjaCBuZWVkZWQgcmVzdCBoZWFkaW5nIGludG8gdGhlIGJpZ2dlc3QgZ2FtZSBvZiB0aGUgc2Vhc29uLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSAnZ2FtZSB0byBnbycgc2F3IHRoZSBJbGxpbmkgZmFjZSB1cCBhZ2FpbnN0IGEgdGVhbSB0aGV5IG5ldmVyIHdvdWxkIGhhdmUgZXhwZWN0ZWQuIEluIHN1cnByaXNpbmcgZmFzaGlvbiwgdGhlIHNjcmFwcHkgYW5kIGVuZXJnaXplZCBOb3RyZSBEYW1lIHdvdWxkIHN0YW5kIGFzIHRoZWlyIGxhc3QgdGVzdCBvZiB0aGUgc2Vhc29uLiBUaGUgb3RoZXIgc2lkZSBvZiB0aGUgYnJhY2tldCB3b3VsZCBwcm92ZSB0byBiZSBvbmUgdG8gcmVtZW1iZXIsIGFzIE5vdHJlIERhbWUgaGFkIGJlYXRlbiByaXZhbCBNaWNoaWdhbiBhZnRlciBNaWNoaWdhbiBoYWQgYmVhdGVuIE5vcnRod2VzdGVybiBvbiBkb3VibGUgZ2FtZSBwb2ludCB0aGUgZ2FtZSBiZWZvcmUuIEl0IHdhcyB3aW4gb3IgZ28gaG9tZSBmb3IgdGhlIElsbGluaS48L3A+XG4gICAgICAgICAgICA8cD5UaGUgZ2FtZSB3YXMgYSBzcGVjdGFjbGUsIHdpdGggbWFueSBvZiB0aGUgcHJvZ3JhbSdzIGFsdW1uaSBhbmQgaGFsZiB0aGUgcmVnaW9uIHdhdGNoaW5nLiBBbmQgd2l0aCBleHBlY3RhdGlvbnMgc2V0IG9uIE5hdGlvbmFscywgdGhlIElsbGluaSBkZWxpdmVyZWQsIHdpbm5pbmcgdGhlIGdhbWUgMTUtNyBhbmQgcHVuY2hpbmcgdGhlaXIgdGlja2V0IHRvIE1pbHdhdWtlZSBmb3IgTmF0aW9uYWxzLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSB2aWN0b3J5IHdhcyBhIGh1Z2Ugb25lIGZvciB0aGUgcHJvZ3JhbSBhbmQgaXQgcHJvdmVkIHRvIGJlIGEgaHVnZSBzd2luZyBpbiB0aGUgZXZlbnR1YWwgQ29hY2ggb2YgdGhlIFllYXIgYXdhcmQgd29uIGJ5IElsbGlub2lzIGNvYWNoLCBNYXR0IFN0dXBjYS4gSWxsaW5vaXMgZW5kZWQgdGhlIHdlZWtlbmQgNi0wLCBhbmQgdW5iZWxpZXZhYmx5LCBvbmx5IGFsbG93ZWQgMSBicmVhayBhbGwgd2Vla2VuZC48L3A+XG4gICAgICAgICAgICA8cD5UaGUgSWxsaW5pIHdlcmUgaGVhZGVkIHRvIE5hdGlvbmFscyEhITwvcD5cbiAgICAgICAgICAgIDxwPkFmdGVyIGZhaWxpbmcgdG8gcmVhY2ggTmF0aW9uYWxzIHRoZSB5ZWFyIGVhcmxpZXIsIElsbGlub2lzIHJldHVybmVkIGFuZCB3ZXJlIHNlZWRlZCAxOXRoIGFtb25nIHRoZSBjb21wZXRpdGlvbi4gVGhlIElsbGluaSwgaGF2aW5nIHN0cnVnZ2xlZCBhZ2FpbnN0IHRvcCBjb21wZXRpdGlvbiBlYXJsaWVyIGluIHRoZSBzZWFzb24sIHdlcmUgaGlnaGx5IGZvY3VzZWQgZ29pbmcgaW50byBOYXRpb25hbHMuPC9wPlxuICAgICAgICAgICAgPHA+VW51c3VhbCBjaXJjdW1zdGFuY2VzIGF0IG90aGVyIHJlZ2lvbmFscyBwdXQgdGhlIElsbGluaSBpbiB3aGF0IHdhcyBjb25zaWRlcmVkIG9uZSBvZiB0aGUgYmVzdCBOYXRpb25hbHMgcG9vbHMgZXZlciwgUG9vbCBDLiBUaGVpciBwb29sIGluY2x1ZGVkIE1hcnlsYW5kLCBPcmVnb24sIEZsb3JpZGEgU3RhdGUsIGFuZCBVTkMuIElsbGlub2lzIGhhZCBub3QgcGxheWVkIGFueSBvZiB0aG9zZSB0ZWFtcyBkdXJpbmcgdGhlIHJlZ3VsYXIgc2Vhc29uLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSBmaXJzdCBnYW1lIHdhcyBhZ2FpbnN0IE1hcnlsYW5kLCB3aG9zZSBzdGFyIHBsYXllciBhbmQgQ2FsbGFoYW4gbm9taW5lZSwgd2FzIGJyb3RoZXJzIHdpdGggb25lIG9mIElsbGlub2lzJyByb29raWVzLiBUaGUgZ2FtZSB3YXMgaGVhdGVkIHRob3VnaCwgd2l0aCBoaWdobGlnaHRzIGluY2x1ZGluZyBhIHdpbGQgc2t5IGJ5IFR5bGVyICdEdXRjaCcgRGVOb295ZXIgYW5kIGEgaGFuZGJsb2NrIG9mIE1hcnlsYW5kJ3Mgc3RhciBieSBQcmF5YWcgUGF0ZWwuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIGdhbWUgY2FtZSBkb3duIHRvIHRoZSB3aXJlLCBidXQgc2F3IHRoZSBJbGxpbmkgYXMgdGhlIHNsaW0gdmljdG9ycyAxNS0xMywgd2l0aCBmb3JtZXIgTmF0aW9uYWxzIHNjb3JpbmcgdG9wLWxpc3RlciBOaWNrIFByb3pvcm92c2t5IGNhdGNoaW5nIHRoZSBmaW5hbCBwb2ludCB0byBwdXQgdGhlIElsbGluaSAxLTAgb24gdGhlIHdlZWtlbmQuIEl0IHdhcyBhIHdpbiBmb3IgdGhlIElsbGluaSB0aGF0IHNwb2tlIHZvbHVtZXMgdG8gdGhlIGlkZWEgdGhhdCB0aGV5IHRydWx5IGJlbG9uZ2VkIHRoZXJlLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSBuZXh0IG1hdGNodXAgd2FzIHVuZGVyIHRoZSBsaWdodHMgb24gdGhlIGJpZyBmaWVsZCBhZ2FpbnN0IFVOQy4gSWxsaW5vaXMgZmFjZWQgYW5vdGhlciB0b3AgbGV2ZWwgcGxheWVyLCB0aGUgZXZlbnR1YWwgQ2FsbGFoYW4gd2lubmVyLCBKb24gTmV0aGVyY3V0dC4gTmV0aGVyY3V0dCBhbmQgaGlzIFVOQyBEYXJrc2lkZSBzcXVhZCBoYWQgYmVlbiBvbmUgb2YgdGhlIGhpZ2hlc3QgcmFua2VkIHRlYW1zIGdvaW5nIGludG8gdGhlIHRvdXJuYW1lbnQgYW5kIGxvb2tlZCBldmVuIHN0cm9uZ2VyIHdpdGggdGhlIHJldHVybiBvZiB0aGUgbWlnaHR5IGN1dHRlciwgQmVuIFNuZWxsLiA8L3A+XG4gICAgICAgICAgICA8cD5Db25zaWRlcmVkIHRoZSB1bmRlcmRvZ3MgYnkgZmFyLCBJbGxpbm9pcyBqdW1wZWQgb3V0IHRvIGEgcXVpY2sgMi0wIGxlYWQsIGJyZWFraW5nIHRoZSBzZWVtaW5nbHkgdW5zdG9wcGFibGUgVU5DIE8tbGluZS4gVGhlIGVhcmx5IHN0YXJ0IHByb3ZlZCB0byBiZSBpbXBvcnRhbnQgYXMgRGFya3NpZGUgZm91Z2h0IGJhY2sgYW5kIHRvb2sgdGhlIGhhbGYgYnkgb25seSBvbmUgcG9pbnQuIFRoZSBnYW1lIHdhcyBjbG9zZXIgdGhhbiBhbnlvbmUgY291bGQgaGF2ZSBwcmVkaWN0ZWQuPC9wPlxuICAgICAgICAgICAgPHA+QnV0IGl0IHdhcyBub3QgZW5vdWdoIHRvIHRha2UgZG93biB0aGUgQXRsYW50aWMgQ29hc3QgY2hhbXBzLCBhcyBEYXJrc2lkZSB0b29rIHRoZSBnYW1lIDE1LTEyLiBOZXRoZXJjdXR0IHByb3ZlZCB0byBiZSBoeXBlZCBjb3JyZWN0bHksIGJ1dCB0aGUgSWxsaW5pIHN0aWxsIHBsYXllZCBzdHJvbmcgcmVnYXJkbGVzcy48L3A+XG4gICAgICAgICAgICA8cD5EYXkgMiBzYXcgdGhlIElsbGluaSBpbiBhIGh1Z2Ugc3BvdGxpZ2h0LCBmYWNpbmcgT3JlZ29uIEVnbyB0byBzdGFydCB0aGUgZGF5LiBUaGUgcm9hZCB0byBOYXRpb25hbHMgaGFkIGJlZW4gc2hha3kgZm9yIEVnbywgYXMgdGhlaXIgc3RydWdnbGVzIGF0IHJlZ2lvbmFscyB3ZXJlIHRoZSBzb2xlIHJlYXNvbiB0aGV5IGhhZCBldmVuIGJlZW4gcGxhY2VkIGludG8gUG9vbCBDIGFzIHRoZSBzaG9ja2luZyAxNSBzZWVkLiBUaGV5IHNhdCAwLTIgb24gdGhlIHdlZWtlbmQsIGFuZCB3ZXJlIGluIGEgZG8tb3ItZGllIHNpdHVhdGlvbiBmb3IgdGhlaXIgc2Vhc29uLiBGaXR0aW5nbHksIHRoZSBJbGxpbmkgbWF0Y2hlZCB1cCBhZ2FpbnN0IHRoZW0gd2l0aCBhIGNoYW5jZSB0byBlbmQgdGhlaXIgc2Vhc29uLCBhbmQgYSBjaGFuY2UgdG8gZW5kIHRoZSBjb2xsZWdlIGNhcmVlciBvZiBvbmUgb2YgdGhlIGdhbWVzJyBtb3N0IHdlbGwta25vd24gcGxheWVycywgRHlsYW4gRnJlZWNoaWxkLjwvcD5cbiAgICAgICAgICAgIDxwPkZyZWVjaGlsZCBhbmQgdGhlIGFtcGVkIHVwIEVnbyBzcXVhZCBjYW1lIG91dCBzdHJvbmcsIHRha2luZyBhbiBlYXJseSBhbmQgY29tbWFuZGluZyBsZWFkLiBUaGVyZSB3ZXJlIHNvbWUgZ2xpbW1lcnMgb2YgaG9wZSBmb3IgSWxsaW5vaXMsIGJ1dCBub25lIHByb3ZlZCBzdHJvbmcgZW5vdWdoIHRvIGdldCB0aGVtIGNsb3NlLCBhcyBFZ28gd29uIHRoZSBnYW1lIGhhbmRpbHkgMTUtNy4gVGhpcyBwdXQgdGhlIElsbGluaSBhdCAxLTIsIGFuZCBrZXB0IHRoZSBzZWFzb24gYWxpdmUgZm9yIE9yZWdvbi48L3A+XG4gICAgICAgICAgICA8cD5UaGUgZmluYWwgZ2FtZSBvZiBwb29sIHBsYXkgY2FtZSBhZ2FpbnN0IENocmlzIExhcm9xdWUgYW5kIEZsb3JpZGEgU3RhdGUuIEEgeWVhciBlYXJsaWVyLCBJbGxpbm9pcyBoYWQgbG9zdCBhIHRvdWdoIGdhbWUgb24gZG91YmxlIGdhbWUgcG9pbnQgYWdhaW5zdCBGU1UgYXQgRWFzdGVybnMuIElsbGlub2lzIHlldCBhZ2FpbiB3YXMgYSBoZWF2eSB1bmRlcmRvZy4gVGhleSBtYW5hZ2VkIHRvIGtlZXAgaXQgY2xvc2UgZm9yIG1vc3QgdGhlIGdhbWUsIGJ1dCBGU1UncyBzdGFyLXN0dWRkZWQgdGVhbSBwcm92ZWQgdG9vIHN0cm9uZyBhcyBGU1UgdG9vayB0aGUgZ2FtZSAxNS0xMS4gSXQgd2FzIGFub3RoZXIgZ2FtZSB2ZXJ5IGNsb3NlIGF0IGhhbGYgZm9yIElsbGlub2lzLCB3aGljaCB3YXMgcHJvbWlzaW5nLiBUaGUgbG9zcyB3b3VsZCBwdXQgSWxsaW5vaXMgb3V0IG9mIGNvbnRlbnRpb24gdG8gbW92ZSBpbnRvIHRoZSBuZXh0IHJvdW5kIG9mIHBsYXkuPC9wPlxuICAgICAgICAgICAgPHA+SW4gdGhlIGZpbmFsIGdhbWUgb2YgdGhlIHNlYXNvbiwgSWxsaW5vaXMgd291bGQgcGxheSBDaW5jaW5uYXRpLiBXaXRoIGEgd2luLCB0aGV5IHdvdWxkIGNsYWltIGEgdGllIGZvciAxM3RoIHBsYWNlLiBXaXRoIGEgbG9zcywgdGhleSB3b3VsZCBmaW5pc2ggMTd0aCBhdCBOYXRpb25hbHMgZm9yIHRoZSA1dGggdGltZSBpbiBhIHJvdywgcGVyaGFwcyBwcm92aW5nIHRoZSAnY3Vyc2Ugb2YgSWxsaW5vaXMtdGggcGxhY2UnIHRvIGJlIHRydWUuPC9wPlxuICAgICAgICAgICAgPHA+QnV0IHRoZSBJbGxpbmkgaGFkIG5vIHBsYW5zIHRvIHNldHRsZSBmb3IgdGhhdCwgYXMgdGhleSB0b29rIHRoZSBnYW1lIDE1LTEyIHdpdGggYSBiaXQgb2YgYSBsYXRlIHN1cmdlLiBUaGUgZ2FtZSBwcm92ZWQgdG8gYmUgYW4gSWxsaW5pIGNsYXNzaWMsIHdpdGggYSBnb2FsIGxpbmUgRCBieSBNYXJrIFBldGVyc29uIGFuZCBhIGJvb2tlbmRzIHBvaW50IGZyb20gS2FuenkuIFRoZSB3aW4gd2FzIHRvcHBlZCBvZmYgd2l0aCBOaWNrIFByb3pvcm92c2t5IGNhdGNoaW5nIHRoZSBnYW1lIHdpbm5pbmcgY2F0Y2gsIHNlbmRpbmcgdGhlIGZhbnMgaG9tZSBoYXBweSBhbmQgZW5kaW5nIGFuIGV4Y2VsbGVudCBJbGxpbm9pcyBzZWFzb24uPC9wPlxuICAgICAgICAgICAgPHA+SWxsaW5vaXMgYnJva2UgdGhlICdjdXJzZScgYW5kIGZpbmlzaGVkIDEzdGgsIHRoZWlyIGJlc3QgTmF0aW9uYWxzIHBlcmZvcm1hbmNlIHNpbmNlIDIwMDguPC9wPlxuICAgICAgICAgICAgPHA+Tm90IHN1cnByaXNpbmdseSwgdGhyZWUgb2YgdGhlIGZpbmFsIGZvdXIgdGVhbXMgd2VyZSBmcm9tIFBvb2wgQywgYW5kIHRoZSBjaGFtcGlvbnNoaXAgc2F3IFVOQyBtYXRjaCB1cCBhZ2FpbnN0IE9yZWdvbi4gVU5DIHdvdWxkIHdpbiBhZ2FpbiwgYmxvd2luZyBvdXQgT3JlZ29uIDE1LTYuIEluIHRoZSBlbmQsIGl0IHdhcyBhY3R1YWxseSBJbGxpbm9pcyB3aG8gaGFkIHB1dCB0aGUgbW9zdCBwb2ludHMgdXAgb24gdGhlIGV2ZW50dWFsIGNoYW1waW9ucywgd2l0aCAxMiBwb2ludHMuIE5pY2sgUHJvem9yb3Zza3kgZmluaXNoZWQgcG9vbCBwbGF5IHRpZWQgZm9yIHRoZSBsZWFkIGluIGdvYWxzIHNjb3JlZCBhdCAyNC4gTW9zdCBpbXBvcnRhbnRseSwgSWxsaW5vaXMgYnJva2Ugc2VlZCwgZ2FpbmluZyB0aGUgcmVzcGVjdCBkZXNlcnZlZCBhbmQgYWNoaWV2aW5nIHRoZWlyIGdvYWxzLiBUaGUgMTMgc2VuaW9ycyBsZWF2aW5nIHdlcmUgc2VudCBob21lIGhhcHB5LjwvcD5cbiAgICAgICAgICAgIDxwPk1hdHQgV2VzdCBhbmQgTmljayBQcm96b3JvdnNreSB3b24gMXN0IHRlYW0gYWxsIHJlZ2lvbiBob25vcnMuIEtldmluIExpbiB3b24gRnJlc2htYW4gb2YgdGhlIFJlZ2lvbi4gVGhlIE1hdHQgU3R1cGNhIGRlc2VydmVkbHkgd29uIENvYWNoIG9mIHRoZSB5ZWFyLjwvcD5cbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE0LFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTQuanBnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+SWxsaW5vaXMgZW50ZXJlZCB0aGUgc2Vhc29uIGhvcGluZyB0byByZXR1cm4gdG8gTmF0aW9uYWxzLiBUaGUgdGVhbSBsb3N0IDMgdGltZSBjYXB0YWluIGFuZCBQbGF5ZXIgb2YgdGhlIFJlZ2lvbiwgUnlhbiAnS2VubmVkeScgU21pdGguIFJldHVybmluZyBjYXB0YWluIGFuZCBNYWNoaW5lIHN0YXIgTmVhbCBQaGVscHMgd2FzIGpvaW5lZCBieSBmaXJzdCB0aW1lIGp1bmlvciBjYXB0YWlucyBNYXJ0eSBNYXJrZW5zb24gYW5kIEVyaWMgQnVsdG1hbi4gVGhlIGNhcHRhaW5pbmcgdGVhbSB3YXMgeW91bmcgYW5kIGluZXhwZXJpZW5jZWQgYnV0IFdhbGRlbiBOZWxzb24gcmV0dXJuZWQgZ2l2aW5nIHRoZSB0ZWFtIGhvcGUuPC9wPlxuICAgICAgICAgICAgPHA+QXQgTUxDIHRoZSB0ZWFtIHdhcyBhYmxlIHRvIGV4Y2VlZCBleHBlY3RhdGlvbnMgYnkgZmluaXNoaW5nIGluIDJuZCBwbGFjZSwgbG9zaW5nIHRvIHRoZSBldmVudHVhbCBOYXRpb25hbCBDaGFtcGlvbnMgQ29sb3JhZG8gTWFtYWJpcmQgaW4gdGhlIGZpbmFscy4gVGhpcyB3aW4gaW4gYWRkaXRpb24gdG8gdGhlIHByZXZpb3VzIHllYXIncyBuYXRpb25hbHMgYmlydGggZ2F2ZSB0aGUgdGVhbSBhIGNvY2tpbmVzcyB0aGV5IHdlcmUgdW5hYmxlIHRvIHNoZWQuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIHNwcmluZyBzY2hlZHVsZSB3YXMgYSB3ZWFrIG9uZSBjb21wYXJlZCB0byB5ZWFycycgcGFzdC4gVGhlIHRlYW0gb25seSBhdHRlbmRlZCB0d28gdG91cm5hbWVudHMsIEh1Y2sgRmlubiBhbmQgRWFzdGVybnMuIFRoZSB0ZWFtIHdhcyBhYmxlIHRvIGVhc2lseSB3aW4gS2F0IEZpZ2h0IHdoaWNoIGZ1cnRoZXIgYm9vc3RlZCB0aGUgdGVhbSdzIGVnby4gQXQgRWFzdGVybnMgdGhleSBmZWxsIHNob3J0IGluIFBvb2wgcGxheSBsb3NpbmcgdG8gUGl0dCwgRmxvcmlkYSBTdGF0ZSwgTHV0aGVyLCBhbmQgQ2VudHJhbCBGbG9yaWRhLiBCdXQgd29uIDEzdGggcGxhY2Ugd2l0aCB3aW5zIGFnYWluc3QgTWFzc2FjaHVzZXR0cyBhbmQgTHV0aGVyLjwvcD5cbiAgICAgICAgICAgIDxwPklsbGlub2lzIHdhcyBhYmxlIHRvIGNvbWZvcnRhYmxlIHdpbiB0aGUgSWxsaW5vaXMgQ29uZmVyZW5jZSBDaGFtcGlvbnNoaXBzIHdpdGggYSB3aW4gaW4gdGhlIGZpbmFscyBvdmVyIE5vcnRod2VzdGVybi4gVGhlIEdyZWF0IExha2VzIGVhcm5lZCB0d28gYmlkcyB0byBuYXRpb25hbHMgdGhhbmtzIHRvIE5vcnRod2VzdGVybiBhbmQgTWljaGlnYW4uIElsbGlub2lzIHdvbiB0aGVpciBwb29sIGFuZCBzZXQgdGhlbXNlbHZlcyB1cCBmb3IgYSBzaG90IGF0IE5hdGlvbmFscy4gTm9ydGh3ZXN0ZXJuIGxlYXJuZWQgZnJvbSB0aGVpciBDb25mZXJlbmNlIGxvc3MgYW5kIHdhcyBhYmxlIHRvIGFkYXB0IHRvIHNsb3cgZG93biB0aGUgSWxsaW5vaXMgb2ZmZW5zZSBmb3JjaW5nIElsbGlub2lzIHRvIGZpZ2h0IHRocm91Z2ggdGhlIGJhY2tkb29yLiBUaGV5IG5leHQgcGxheWVkIENoaWNhZ28gaW4gYSB3aW5keSBnYW1lIGluIHdoaWNoIGJvdGggdGVhbXMgYXR0ZW1wdGVkIHRvIHNjb3JlIHdpdGggNTAvNTAgc2hvdHMuIFRoZXNlIGNvbmRpdGlvbnMgc3RvcHBlZCBJbGxpbm9pcycgaGlnaCBzcGVlZCBvZmZlbnNlIGFuZCBnYXZlIENoaWNhZ28gYSBjaGFuY2UgdG8gaGF2ZSBtYW55IG9wcG9ydHVuaXRpZXMgb24gZGVmZW5zZS4gQ2hpY2FnbyBmaW5hbGx5IGZpbmlzaGVkIHRoZSBnYW1lIHdpdGggYSBzdGFsbCA5IGp1bXAgYmFsbCBpbiB0aGUgZW5kem9uZSBmaW5pc2hpbmcgSWxsaW5vaXMnIHNlYXNvbi48L3A+XG4gICAgICAgIGBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDEzLmpwZycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPkFmdGVyIHRoZSBkaXNhcHBvaW50aW5nIGFuZCBoZWFydGJyZWFraW5nIGZpbmlzaCBpbiAyMDEyLCBJbGxpbm9pcyBsb3N0IGEgaHVnZSBjaHVuayBvZiB2ZXRlcmFuIHRhbGVudCBhbmQgaGFkIHRvIHJlbG9hZCBmb3IgMjAxMy4gUnlhbiBTbWl0aCB3YXMgY2FwdGFpbiBmb3IgdGhlIDNyZCB5ZWFyIGluIGEgcm93IGFuZCB3YXMgam9pbmVkIGJ5IHRocmVlIGZpcnN0IHllYXIgY2FwdGFpbnMgaW4gTmVhbCBQaGVscHMsIENvbGluIFJlaWQgYW5kIE5hdGhhbiBHaWJib25zLiBUaGUgY2FwdGFpbnMgYW5kIHRoZSBzZW5pb3JzIG9uIHRoZSB0ZWFtIHVzZWQgdGhlIHByZXZpb3VzIHllYXIncyBmaW5pc2ggYXMgbW90aXZhdGlvbiBhbmQgc2V0IHRoZSB0b25lIGF0IHByYWN0aWNlcyB0aHJvdWdob3V0IHRoZSB3aG9sZSB5ZWFyLjwvcD4gICAgXG4gICAgICAgICAgICA8cD5UcnlvdXRzIHdlcmUgY29tcGxldGVkIHNob2NraW5nbHkgZWFybHkgZm9yIHRoZSAybmQgeWVhciBpbiBhIHJvdy4gV2l0aCBzbyBtYW55IG9wZW4gc3BvdHMsIElsbGlub2lzIHdhcyBmb3J0dW5hdGUgdG8gcmVjZWl2ZSBhIHZlcnkgZGVlcCBhbmQgdGFsZW50ZWQgZnJlc2htYW4gY2xhc3MuIEZpdmUgZnJlc2htYW4gbWFkZSB0aGUgQS10ZWFtLCB3aXRoIHRocmVlIG9mIHRoZW0gYWxsIGNvbWluZyBmcm9tIHRoZSBzYW1lIGhpZ2ggc2Nob29sLiBBIGxhcmdlIGNodW5rIG9mIHRoZSB0ZWFtIHdlcmUgc3RlcHBpbmcgaW50byBuZXcgcm9sZXMgb3Igd2VyZSBuZXcgdG8gY29sbGVnZSB1bHRpbWF0ZSBhbHRvZ2V0aGVyLiBUaGV5IHdvdWxkIGJlIGZvcmNlZCB0byBhY2NsaW1hdGUgYW5kIGFkanVzdCBxdWlja2x5IGlmIElsbGlub2lzIHdlcmUgdG8gbWVldCBpdCdzIGdvYWxzIGZvciB0aGUgeWVhci48L3A+ICAgIFxuICAgICAgICAgICAgPHA+QXQgSHVjayBGaW5uLCBJbGxpbm9pcyBjYW1lIGluIHZlcnkgb3ZlciBjb25maWRlbnQgYW5kIHdlcmUgcHVuaXNoZWQgYnkgdGhlIGZyaXNiZWUgZ29kcyBmb3IgdGhlaXIgaHVicmlzLiBUaGV5IHRob3VnaHQgdGhleSBjb3VsZCB3YWxrIGludG8gdGhlIHRvdXJuYW1lbnQgYW5kIGRvIHdlbGwuIFRoZXkgZ290IGEgaHVnZSB3YWtlIHVwIGNhbGwgb24gU2F0dXJkYXkgd2l0aCB0aHJlZSBsb3NzZXMgaW5jbHVkaW5nIGEgcG90ZW50aWFsIGNhbmRpZGF0ZSBmb3Igd29yc3QgbG9zcyBvZiB0aGUgcHJvZ3JhbS4gQW5vdGhlciBibGVtaXNoIG9uIENvYWNoIFdhbGRlbiBOZWxzb24ncyBjb2FjaGluZyByZWNvcmQuIElsbGlub2lzIHVzZWQgdGhlaXIgcGVyZm9ybWFuY2Ugb24gU2F0dXJkYXkgb2YgSHVjayBGaW5uIGFzIGNhdXNlIGZvciBwZW5hbmNlIGFuZCB0b3VnaGVkIG91dCBhbiB1bmRlZmVhdGVkIFN1bmRheSB0aHJvdWdoIGF0cm9jaW91cyB3ZWF0aGVyIGNvbmRpdGlvbnMuPC9wPiAgICBcbiAgICAgICAgICAgIDxwPlRoZSBuZXh0IHdlZWtlbmQgYXQgQ2VudGV4LCBJbGxpbm9pcyBjYW1lIG91dCB3aXRoIGEgcmVuZXdlZCBmb2N1cyBhbmQgc2Vuc2Ugb2YgdXJnZW5jeS4gVGhleSBncml0dGVkIG91dCBhIHNlbWlmaW5hbHMgZmluaXNoIGluY2x1ZGluZyBzcGxpdHRpbmcgdHdvIHVuaXZlcnNlIHBvaW50IGdhbWVzIGFnYWluc3QgSGFydmFyZC4gVGhpcyB0b3VybmFtZW50IGdhdmUgcGVvcGxlIG9uIHRoZSB0ZWFtIHJlYXNvbiB0byBiZWxpZXZlIGFuZCBzaG93ZWQgd2hhdCB0aGUgdGVhbSB3YXMgY2FwYWJsZSBvZi48L3A+ICAgIFxuICAgICAgICAgICAgPHA+U2VjdGlvbmFscyB3YXMgaGVsZCBpbiBDaGljYWdvLiBUaGVyZSB3ZXJlIHNvbWUgdG91Z2ggZ2FtZXMsIGJ1dCBJbGxpbm9pcyB3b24gdGhlaXIgdGhpcmQgY29uc2VjdXRpdmUgY29uZmVyZW5jZSBjaGFtcGlvbnNoaXAuIEFmdGVyIHdpbm5pbmcgdGhlIHRvdXJuYW1lbnQsIElsbGlub2lzIGRpZCBoaWxsIHNwcmludHMgdG8gaGVscCBnZXQgbWVudGFsbHkgcHJlcGFyZWQgZm9yIHRoZSBibG9vZGJhdGggb2YgYSAxIGJpZCByZWdpb24uPC9wPiAgICBcbiAgICAgICAgICAgIDxwPklsbGlub2lzIGNhbWUgaW50byBSZWdpb25hbHMgYXMgdGhlICMyIHNlZWQgYW5kIGtuZXcgd2hhdCB0aGV5IGhhZCB0byBkby4gSnVzdCBsaWtlIDIwMTEsIHRoZSBmb3JtYXQgd2FzIHBvb2wgcGxheSBvbiBTYXR1cmRheSB3aXRoIGJyYWNrZXQgcGxheSBvbiBTdW5kYXkuIFRoZSBmaXJzdCB0d28gZ2FtZXMgd2VyZSBjb21mb3J0YWJsZSB2aWN0b3JpZXMuIFRoZSB0aGlyZCBwb29sIHBsYXkgZ2FtZSBhZ2FpbnN0IEluZGlhbmEgd2FzIGEgYmFjayBhbmQgZm9ydGggYWZmYWlyLiBJbmRpYW5hIGxlZCBsYXRlIGluIHRoZSBnYW1lLCBidXQgb24gbG9uZyB0dXJuLWZpbGxlZCB1bml2ZXJzZSBwb2ludCwgSWxsaW5vaXMgZ3JvdW5kIG91dCBhIHRvdWdoIHdpbi48L3A+ICAgIFxuICAgICAgICAgICAgPHA+U3VuZGF5IG1vcm5pbmcsIElsbGlub2lzIGNhbWUgb3V0IHZlcnkgaG90IGFuZCBwbGF5ZWQgZXh0cmVtZWx5IHdlbGwgaW4gYSBnb29kIHdpbiBvdmVyIHVwIGFuZCBjb21pbmcgTm9ydGh3ZXN0ZXJuLiBJbiB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgUmVnaW9uYWwgc2VtaS1maW5hbCBhZ2FpbnN0IE1TVSwgSWxsaW5vaXMgY291bGQgbm90IGNvbnRpbnVlIHRoZWlyIGdvb2QgcGxheS4gVGhlIE9saW5lIHN0cnVnZ2xlZCBtaWdodGlseSB3aXRoIGV4ZWN1dGlvbiBlcnJvcnMgZnJvbSB0aGUgeW91bmdlciBwbGF5ZXJzIG9uIHRoZSBsaW5lLiBUaGUgZmlyc3QgaGFsZiBzY29yZSB3YXMgNS04IE1TVS4gRWFybHkgaW4gdGhlIHNlY29uZCBoYWxmLCB0aGlzIHdvcnJ5aW5nIHRyZW5kIGNvbnRpbnVlZCBhbmQgdGhlIHNjb3JlIHdlbnQgdG8gNi0xMCBNU1UuIFdoZW4gdGhpbmdzIHdlcmUgbG9va2luZyBkaXJlLCB0aGUgc29vbiB0byBiZSBncmFkdWF0aW5nIHBsYXllcnMgcmVmdXNlZCB0byBnbyBkb3duIHdpdGhvdXQgYSBmaWdodC4gQmlnIHBsYXlzIGZyb20gUHJlc3RvbiBHb3Vsc29uIGFuZCBUeWxlciBBbmRlcnNvbiBmdWVsZWQgYSBmdXJpb3VzIElsbGlub2lzIGNvbWViYWNrIGhpZ2hsaWdodGVkIGJ5IGEgYmlnIHNreSBmcm9tIEJyaWFuIFJhdGh1bmRlLiBJbGxpbm9pcyBwdWxsZWQgb3V0IGEgc3R1bm5pbmcgMTQtMTEgd2luIG92ZXIgTVNVLiBUaGlzIHNldCB1cCB0aGUgY2xhc3NpYyBHcmVhdCBMYWtlIFJlZ2lvbmFscyBtYXRjaHVwIGJldHdlZW4gSWxsaW5vaXMgYW5kIE1pY2hpZ2FuLiBGb3IgdGhlIGZpcnN0IHRpbWUgc2luY2UgMjAwOCwgdGhpcyBtYXRjaHVwIHdvdWxkIGJlIGZvciB0aGUgUmVnaW9uYWwgdGl0bGUgYW5kIHRoZSBzb2xlIGJpZCB0byBOYXRpb25hbHMuIElsbGlub2lzIG1haW50YWluZWQgYSB2ZXJ5IHNsaW0gbGVhZCB0aHJvdWdob3V0IHRoZSBnYW1lLiBUaGUgT2xpbmUgcGxheWVkIHZlcnkgY2FsbWx5IGV2ZW4gd2l0aCBpbmNyZWFzZWQgcHJlc3N1cmUgZnJvbSBNaWNoaWdhbi4gTGF0ZSBpbiB0aGUgZ2FtZSwgSWxsaW5vaXMgcHVsbGVkIG91dCBhIGNvdXBsZSBicmVha3MgYW5kIGVuZGVkIHRoZSBnYW1lIG9uIGEgZCBhbmQgc3Vic2VxdWVudCBzY29yZSBieSBKb24gTWNLb3kuIElsbGlub2lzIHJldHVybmVkIHRvIE5hdGlvbmFscyBhcyB0aGUgc29sZSByZXByZXNlbnRhdGl2ZSBvZiB0aGUgR3JlYXQgTGFrZXMuIFJ5YW4gU21pdGggd29uIFBsYXllciBvZiB0aGUgUmVnaW9uIGhvbm9ycywgTmVhbCBQaGVscHMsIE5hdGhhbiBHaWJib25zIGVhcm5lZCBGaXJzdCBUZWFtIEFsbC1SZWdpb24gYXdhcmRzLCBCcmFkIEJvbGxpZ2VyIGVhcm5lZCBhIFNlY29uZCBUZWFtIGFuZCBOaWNrIFByb3pvcm92c2t5LCBKb2hubnkgU2FuaWF0IGFuZCBEZXJlayBZYW4gZWFybmVkIEZyZXNobWFuIHRlYW0gYXdhcmRzLjwvcD4gICAgXG4gICAgICAgICAgICA8cD5VbmZvcnR1bmF0ZWx5IGF0IE5hdGlvbmFscywgSWxsaW5vaXMgY291bGQgbm90IGJyZWFrIHRoZSAxN3RoIHBsYWNlIGN1cnNlLiBTb21lIGtleSBwbGF5ZXJzIHdlcmUgdW5hYmxlIHRvIHBsYXkuIElsbGlub2lzIGdhbWVseSB0cmllZCB0byBmaWdodCBvbiBidXQganVzdCBjb3VsZCBub3Qgb3ZlcmNvbWUgdGhlaXIgZGVwbGV0ZWQgcGVyc29ubmVsLiBJbiBhIHVuc3VycHJpc2luZyB0dXJuIG9mIGV2ZW50cywgSWxsaW5vaXMgZmluaXNoZWQgMTd0aCBhdCBOYXRpb25hbHMuPC9wPiAgICBcbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEyLFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTIuanBnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+Rm9yIHRoZSBmaXJzdCB0aW1lIHNpbmNlIDIwMDgsIElsbGlub2lzIHJldHVybmVkIGEgbWFqb3JpdHkgb2YgdGhlIHRlYW0gYW5kIGhhZCBoaWdoIGV4cGVjdGF0aW9ucyBnb2luZyBpbnRvIHRoZSBzZWFzb24uIE1ham9yIHBlcnNvbm5lbCBsb3NzZXMgaW5jbHVkZWQgMi10aW1lIGNhcHRhaW4gQXVzdGluIExpZW4gYW5kIDMteWVhciBPLWxpbmUgc3RhcnRlciBDaHJpcyBIaWRha2EuIFphY2ggRnJhbnR6IGFuZCBSeWFuIFNtaXRoIHJldHVybmVkIGFzIGNhcHRhaW5zIGFuZCB3ZXJlIGpvaW5lZCBieSBLZXZpbiBCcnVucy4gV2l0aCBzdWNoIGEgbGFyZ2UgbnVtYmVyIG9mIHJldHVybmluZyBBLXRlYW1lcnMsIHRyeW91dHMgd2VyZSBhcyBjb21wZXRpdGl2ZSBhcyBldmVyIGFuZCB0aGVyZSB3ZXJlIG1hbnkgcGVvcGxlIGZpZ2h0aW5nIGZvciB0aGUgZmV3IHJlbWFpbmluZyBzcG90cy4gQWZ0ZXIgZm9sbG93aW5nIHRoZSBJbGxpbm9pcyB0cmFkaXRpb24gb2YgbWFraW5nIGZpbmFsIGN1dHMgcmVhbGx5IGxhdGUsIDMgZnJlc2htZW4gaGFkIG1hZGUgdGhlIEEtdGVhbSwgd2hpY2ggaGFkbid0IGhhcHBlbmVkIHNpbmNlIDIwMDkuPC9wPiAgICBcbiAgICAgICAgICAgIDxwPkZvciBzdWNoIGEgdmV0ZXJhbiB0ZWFtLCBmb2N1cyBhbmQgdXJnZW5jeSB3YXMgbGFja2luZyBkdXJpbmcgdGhlIHNlYXNvbi4gVGhlcmUgd2VyZSBtYW55IHRpbWVzIHdoZXJlIHBlb3BsZSB3b3VsZCBiZSBnb2luZyB0aHJvdWdoIHRoZSBtb3Rpb25zIGFuZCBub3QgZ2V0dGluZyB0aGUgbW9zdCBvZiB0aGUgcHJhY3RpY2UuIFVubGlrZSBwYXN0IHllYXJzLCB3aGVuIHRoZSBzZW5pb3IgY2xhc3Mgd291bGQgc2V0IHRoZSB0b25lIGZvciBhbGwgdGhlaXIgeW91bmdlciB0ZWFtbWF0ZXMsIHRoaXMgeWVhciBzYXcgYSByaWZ0IG9wZW4gdXAgYmV0d2VlbiB0aGUgc2VuaW9ycyBhbmQgdGhlIHlvdW5nZXIgbWVtYmVycyBvZiB0aGUgdGVhbS4gVGhpcyByaWZ0IG1hbmlmZXN0ZWQgaXRzZWxmIGluIG1hbnkgd2F5cyB0aHJvdWdob3V0IHRoZSBzZWFzb24sIGJ1dCBpdCBjYW1lIHRvIGEgaGVhZCBhdCBDZW50ZXggd2hlcmUgYSB0ZWFtIG1lZXRpbmcgd2FzIGhlbGQgU2F0dXJkYXkgbmlnaHQgYWZ0ZXIgcG9vbCBwbGF5IGFuZCB0d28ganVuaW9ycyBzcG9rZSB0byBhbGwgdGhlIHNlbmlvcnMgYW5kIHRvbGQgdGhlbSB0byBnZXQgdGhlaXIgYWN0IHRvZ2V0aGVyLjwvcD4gICAgXG4gICAgICAgICAgICA8cD5XaXRoIGhpZ2ggZXhwZWN0YXRpb25zIGdvaW5nIGludG8gdGhlIHNlYXNvbiwgSWxsaW5vaXMgc2NoZWR1bGVkIGEgbW9yZSBjb21wZXRpdGl2ZSB0b3VybmFtZW50IHNjaGVkdWxlIHRoYW4gaW4gMjAxMSBhbmQgd2VudCB0byBFYXN0ZXJucyBhbmQgQ2VudGV4IHR3byB0b3VybmFtZW50cyB3aXRoIHNldmVyYWwgTmF0aW9uYWxzIGNvbnRlbmRlcnMgaW4gYWRkaXRpb24gdG8gdGhlIGVhcmx5IHNlYXNvbiB0b3VybmFtZW50IEZyZWUgU3RhdGUgQ2xhc3NpYy4gV2l0aCBhbGwgdGhlIGRyYW1hIGdvaW5nIG9uIGJlaGluZCBjbG9zZWQgZG9vcnMsIElsbGlub2lzIGhhZCBhbiB1cCBhbmQgZG93biB0b3VybmFtZW50IHBlcmZvcm1hbmNlIHdpdGggc29tZSB1bmNoYXJhY3RlcmlzdGljIGJpZyBsb3NzZXMuIEF0IEZyZWUgU3RhdGUsIElsbGlub2lzIHN0cnVnZ2xlZCB0byBwbGF5IGluIHRoZSB3aW5kIGFnYWluc3QgSW93YSBhbmQgbG9zdCB0byB0aGVtIHR3aWNlLCBvbmNlIG9uIFNhdHVyZGF5IGFuZCBhZ2FpbiBpbiB0aGUgRmluYWwuIEF0IENlbnRleCwgSWxsaW5vaXMgcGxheWVkIElvd2EgYWdhaW4gYW5kIGNhbWUgb3V0IGhvdCBhbmQgdG9vayBhIDMtMCBsZWFkLCBidXQgdGhhdCBxdWlja2x5IGRpc2FwcGVhcmVkIGFuZCBJb3dhIHdvbiBhZ2FpbiBpbiBkb21pbmF0aW5nIGZhc2hpb24uIFRoaXMgYmxlZCBpbnRvIHRoZSBtb3N0IGRpc3Bpcml0aW5nIHBlcmZvcm1hbmNlIGJ5IElsbGlub2lzIGluIG1hbnkgeWVhcnMsIGFzIHRoZXkgcHJvY2VlZGVkIHRvIGJlIGJsYW5rZWQgaW4gdGhlIGZpcnN0IGhhbGYgYnkgVHVmdHMuIEFmdGVyIHBsYXkgZW5kZWQsIHRoZSBhZm9yZW1lbnRpb25lZCB0ZWFtIG1lZXRpbmcgd2FzIGhlbGQuIFN1bmRheSBvZiBDZW50ZXgsIElsbGlub2lzIGNhbWUgb3V0IHJlaW52aWdvcmF0ZWQgYW5kIHBsYXllZCBhIGNsb3NlIGdhbWUgd2l0aCBMdXRoZXIgYnV0IGV2ZW50dWFsbHkgbG9zdCBvbiB1bml2ZXJzZS4gVGhlIGZvbGxvd2luZyB3ZWVrZW5kIGF0IEVhc3Rlcm5zLCBJbGxpbm9pcyBwbGF5ZWQgbXVjaCBtb3JlIGNvbnNpc3RlbnRseSBhbmQgbG9zdCB0d2ljZSwgb25jZSB0byBldmVudHVhbCBjaGFtcGlvbnMgUGl0dHNidXJnaCBhbmQgYWdhaW4gb24gdW5pdmVyc2UgdG8gVHVmdHMuIEJ1b3llZCBieSB0aGVpciBFYXN0ZXJucyByZXN1bHRzLCBJbGxpbm9pcyBsb29rZWQgYWhlYWQgdG8gdGhlIHNlcmllcyBhbmQgYSByZXR1cm4gdG8gTmF0aW9uYWxzLjwvcD4gICAgXG4gICAgICAgICAgICA8cD5UaGUgdGhpcmQgYW5udWFsIGFsdW1uaSBnYW1lIHdhcyBoZWxkLCBhbmQgdGhlIGFsdW1uaSBleHRlbmRlZCB0aGVpciB3aW5uaW5nIHN0cmVhayB0byB0d28gZ2FtZXMgYWZ0ZXIgYSBkaXNtYWwgcGVyZm9ybWFuY2UgYnkgdGhlIGNvbGxlZ2Uga2lkcy4gQWZ0ZXIgdGFraW5nIGhhbGYgOC01LCB0aGUgY29sbGVnZSB0ZWFtIHNlZW1lZCB0byB0aGluayB0aGUgZ2FtZSB3YXMgb3ZlciBhbmQgZGlkIG5vdCB0cnkgYXMgaGFyZCBhcyB0aGUgb2xkZXIsIG1vcmUgb3V0IG9mIHNoYXBlIGFsdW1uaS4gVW5mb3J0dW5hdGVseSwgdGhlIGxlc3NvbnMgZnJvbSB0aGUgYWx1bW5pIGdhbWUgd291bGQgbm90IGJlIHJlbWVtYmVyZWQgbGF0ZXIgaW4gdGhlIHNlYXNvbi48L3A+ICAgIFxuICAgICAgICAgICAgPHA+U2VjdGlvbmFscyBvbmNlIGFnYWluIHdlcmUgaGVsZCBpbiBSYW50b3VsIGFuZCBsaWtlIGV2ZXJ5IG90aGVyIHRvdXJuYW1lbnQgdGhhdCBoYXMgZXZlciBiZWVuIGhlbGQgdGhlcmUsIHRoZSB3ZWF0aGVyIHdhcyB0ZXJyaWJsZS4gU2F0dXJkYXkgd2FzIGNvbGQsIHdpbmR5LCBhbmQgd2V0IGFuZCBJbGxpbm9pcyB0b29rIGNhcmUgb2YgYnVzaW5lc3Mgd2lubmluZyBldmVyeSBnYW1lIGhhbmRpbHkuIFN1bmRheSB3YXMgc3VubnkgYW5kIHZlcnkgd2luZHkgYW5kIGFmdGVyIGdvaW5nIHVwIGJ5IGEgbG90IG9uIE5vcnRod2VzdGVybiwgSWxsaW5vaXMgbG9zdCB0aGVpciBmb2N1cyBhbmQgbGV0IHRoZW0gYmFjayBpbnRvIHRoZSBnYW1lLiBJbGxpbm9pcyBldmVudHVhbGx5IGNsb3NlZCBpdCBvdXQgYW5kIHdvbiBieSBhIGZldyBwb2ludHMuPC9wPiAgICBcbiAgICAgICAgICAgIDxwPkxpa2UgdGhlIHBhc3QgdGhyZWUgeWVhcnMsIElsbGlub2lzIHdhcyBjb3VudGluZyBvbiBiZWluZyBhYmxlIHRvIGZsaXAgdGhlIHN3aXRjaCBhbmQgcGxheSB0aGVpciBiZXN0IHVsdGltYXRlIG9mIHRoZSBzZWFzb24gYXQgUmVnaW9uYWxzLiBXaXRoIHR3byBiaWRzIHRvIE5hdGlvbmFscywgdGhlIGJlc3QgZm9ybWF0IGFuZCBSZWdpb25hbHMgYmVpbmcgaGVsZCBpbiBOYXBlcnZpbGxlLCBjb25maWRlbmNlIHdhcyB2ZXJ5IGhpZ2ggdGhhdCBJbGxpbm9pcyB3b3VsZCBiZSBhYmxlIHRvIGdldCB0aGUgam9iIGRvbmUgYW5kIHF1YWxpZnkgZm9yIE5hdGlvbmFscy4gSXQgd2FzIGEgY29sZCwgd2luZHksIHdldCBkYXkgb24gU2F0dXJkYXkgYnV0IElsbGlub2lzIHdvbiB0aGVpciBmaXJzdCBnYW1lIGNvbWZvcnRhYmx5LiBJbiBhIHNob2NraW5nIHR1cm4gb2YgZXZlbnRzLCBhIGxhY2sgb2YgZm9jdXMgY2F1c2VkIElsbGlub2lzIHRvIGNvbWUgb3V0IGZsYXQgYWdhaW5zdCBFYXN0ZXJuIElsbGlub2lzIGluIHRoZSByZWdpb25hbCBxdWFydGVyZmluYWxzLiBFYXN0ZXJuIElsbGlub2lzIGNhbWUgb3V0IGFuZCBwdW5jaGVkIGluIGZvdXIgYnJlYWtzIGluIGEgcm93LiBJbGxpbm9pcyBmb3VnaHQgYmFjayBhbmQgdGllZCB0aGUgc2NvcmUgYXQgNS01LCBidXQgdGhleSBjb3VsZCBuZXZlciBnZXQgb3ZlciB0aGUgaHVtcCBhbmQgdGFrZSB0aGUgbGVhZC4gRWFzdGVybiBJbGxpbm9pcycgTWljaGFlbCBTY2h3ZW5rIGNhcnJpZWQgdGhlIHRlYW0gdG8gYW4gdXBzZXQgd2l0aCBhIDEzLTEwIHZpY3RvcnkgYW5kIGdhdmUgSWxsaW5vaXMgdGhlaXIgZmlyc3QgbG9zcyBhdCBSZWdpb25hbHMgc2luY2UgMjAwOC48L3A+ICAgIFxuICAgICAgICAgICAgPHA+V2l0aCB0aGVpciBiYWNrcyBhZ2FpbnN0IHRoZSB3YWxsLCBJbGxpbm9pcyByZWdyb3VwZWQgYW5kIHRvb2sgY2FyZSBvZiBidXNpbmVzcyBvbiBTYXR1cmRheSBhbmQgc3RheWVkIGFsaXZlIGluIHRoZSAybmQgcGxhY2UgYnJhY2tldCBmb3IgU3VuZGF5LiBGb3IgdGhlIGZpcnN0IHRpbWUgc2luY2UgMjAwNywgSWxsaW5vaXMgd2FzIG5vdCBpbiB0aGUgUmVnaW9uYWwgRmluYWwgU3VuZGF5IG1vcm5pbmcgYnV0IGluc3RlYWQgaW4gYSBmaWdodCBmb3IgdGhlaXIgc2Vhc29uIGluIHRoZSBiYWNrZG9vciBzZW1pLSBmaW5hbHMuIFRoZXkgZGlzcGF0Y2hlZCBJbmRpYW5hIDE1LTcgYW5kIGhhZCBhIHJlbWF0Y2ggd2l0aCBFYXN0ZXJuIElsbGlub2lzIGluIHRoZSBiYWNrZG9vciBmaW5hbC4gSWxsaW5vaXMgZGlkIG5vdCB0YWtlIHRoZW0gbGlnaHRseSB0aGlzIHRpbWUgYW5kIGNhbWUgb3V0IHdpdGggYSByYXJlbHkgc2VlbiBpbnRlbnNpdHkgYW5kIGJlYXQgRWFzdGVybiAxNS0yLiBIb3dldmVyLCB0aGUgdGVhbSdzIGZvY3VzIGFuZCBleGVjdXRpb24gd2FzIG5vdCB0aGVyZSBhbmQgbXVsdGlwbGUgdHVybm92ZXJzIG9uIGV2ZXJ5IHBvaW50IGN1bG1pbmF0ZWQgaW4gdGhlIGRlc3RydWN0aW9uIG9mIENvYWNoIFdhbGRlbiBOZWxzb24ncyBjbGlwYm9hcmQuIElsbGlub2lzLCBhZnRlciBhbiBhcmR1b3VzIHJvYWQsIGhhZCBmaW5hbGx5IG1hZGUgaXQgdG8gYSBnYW1lIHRvIGdvIHRvIE5hdGlvbmFscyBhZ2FpbnN0IE1pY2hpZ2FuIFN0YXRlLiBJbGxpbm9pcyBzdGFydGVkIHRoZSBnYW1lIG91dCBzdHJvbmcgYW5kIGZpcmVkIHVwIGFuZCBjYW1lIG91dCB3aXRoIHR3byBxdWljayBicmVha3MuIE1TVSBwbGF5ZWQgYSBsb3Qgb2Ygem9uZSBpbiBhbiBlZmZvcnQgdG8gbmVnYXRlIFJ5YW4gU21pdGgncyBodWNrcy4gQnV0IFJ5YW4gZGlkIG5vdCB0YWtlIHRoZSBiYWl0IGFuZCBsZWFkIHRoZSBvZmZlbnNlIHRvIGEgY2xlYW4gbm8gYnJlYWsgZmlyc3QgaGFsZiBhbmQgdGhlIGRlZmVuc2UgZ290IDMgYnJlYWtzIGZvciBhbiA4LTUgaGFsZnRpbWUgbGVhZC4gSWxsaW5vaXMgc21lbGxlZCBhIE5hdGlvbmFscyBiZXJ0aCBhbmQgY2FtZSBvdXQgb2YgaGFsZiB3aXRoIDIgbW9yZSBwb2ludHMgZm9yIGEgY29tbWFuZGluZyAxMC01IGxlYWQuIFRoaXMgd2FzIHdoZW4gTWljaGlnYW4gU3RhdGUgaGVsZCB0aGVpciBncm91bmQgYW5kIGJlZ2FuIGEgdGVuYWNpb3VzIGNvbWViYWNrLiBTdGF5aW5nIHdpdGggdGhlaXIgem9uZSwgTVNVIGJlZ2FuIHRvIGZvcmNlIG1vcmUgYW5kIG1vcmUgdHVybm92ZXJzIGZyb20gSWxsaW5vaXMgYW5kIGJlZ2FuIHRvIGNvbnZlcnQgdGhlbSBmb3IgYnJlYWtzLiBBIDEwLTUgbGVhZCBxdWlja2x5IGJlY2FtZSAxMC04IGFuZCBNU1UgY2xhd2VkIHNsb3dseSBiYWNrIGZyb20gdGhlcmUgdG8gZmluYWxseSB0YWtlIHRoZSBsZWFkIGF0IDEzLTEyLiBBIGxvdCBvZiBjcmVkaXQgaXMgdG8gYmUgZ2l2ZW4gdG8gTVNVIGZvciBuZXZlciBnaXZpbmcgdXAgYW5kIGZpZ2h0aW5nIHRoZWlyIHdheSBiYWNrIHRvIHRoZSBsZWFkLiBCdXQgSWxsaW5vaXMnIGxhY2sgb2YgY29tcG9zdXJlIG9uIG9mZmVuc2UgY291cGxlZCB3aXRoIGEgd2lsbGluZ25lc3MgdG8gdHVybiB0aGUgZGlzYyBvdmVyLCBhcyB3ZWxsIGFzIHRpbWVvdXQgbWlzbWFuYWdlbWVudCBieSBDb2FjaCBXYWxkZW4gTmVsc29uIGRpZCBub3QgaGVscCB0aGUgY2F1c2UuIEV2ZW4gd2l0aCBhbGwgdGhhdCBiZWluZyBzYWlkLCBJbGxpbm9pcyBzY29yZWQgb24gb2ZmZW5zZSB0byBtYWtlIGl0IDEzLSAxMyB1bml2ZXJzZSBwb2ludCB3aXRoIHRoZSB3aW5uZXIgZ29pbmcgdG8gTmF0aW9uYWxzLiBJbGxpbm9pcyBnb3QgdGhlIGRpc2MgdHdpY2Ugb24gdW5pdmVyc2UgYW5kIGJvdGggdGltZXMgdGhyZXcgcGFzc2VzIGludG8gdGhlIGVuZHpvbmUgdGhhdCBoaXQgYSByZWNlaXZlcidzIGhhbmRzLCBidXQgYWxhcyBib3RoIHBhc3NlcyB3ZXJlIGRyb3BwZWQuIEFmdGVyIHRoZSBzZWNvbmQgZHJvcCBpbiB0aGUgZW5kem9uZSBNU1UgcGlja2VkIHVwIHRoZSBkaXNjIGFuZCBpbW1lZGlhdGVseSB0aHJldyBhbiA4MCB5YXJkLCBtb3JlIHRoYW4gZnVsbCBmaWVsZCBodWNrIGZvciB0aGUgZ2FtZSBhbmQgdGhlIE5hdGlvbmFscyBiZXJ0aC48L3A+ICAgIFxuICAgICAgICAgICAgPHA+VGhpcyB3YXMgbm90IHRoZSBlbmRpbmcgdG8gdGhlIDIwMTIgc2Vhc29uIHRoYXQgSWxsaW5vaXMgaW1hZ2luZWQuIEZvciB0aGUgZmlyc3QgdGltZSBzaW5jZSAyMDA3LCBJbGxpbm9pcycgZ3JhZHVhdGluZyBzZW5pb3JzIGRpZCBub3QgZ2V0IHRvIGVuZCB0aGVpciBjYXJlZXJzIGF0IE5hdGlvbmFscy4gV2l0aCBhIGh1Z2UgZ3JhZHVhdGluZyBjbGFzcywgaXQgd2lsbCBiZSB1cCB0byB0aGUgZmV3IHJldHVybmluZyBBLXRlYW1lcnMgdG8gcGljayB1cCB0aGUgcGllY2VzIGFuZCByZXR1cm4gSWxsaW5vaXMgdG8gTmF0aW9uYWxzLjwvcD4gICAgXG4gICAgICAgIGBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMSxcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDExLmpwZycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPlRoZSBwcm9ncmFtIGxvc3Qgc2V2ZXJhbCBwcm9ncmFtIG1haW5zdGF5cyBzdWNoIGFzIDUteWVhciBBLXRlYW1lciBhbmQgMi10aW1lIGNhcHRhaW4gQnJpYW4gUGhlbGFuLCBUb3AgMTAgQ2FsbGFoYW4gZmluaXNoZXIgYW5kIGNhcHRhaW4gV2FsZGVuIE5lbHNvbiwgYW5kIFRlYW0gU3Bpcml0IExlYWRlciBLdXJ0IFpvZWxsaWNrIGFtb25nIG90aGVycy4gVGhpcyByZXF1aXJlZCB0aGUgbGFyZ2UganVuaW9yIGNsYXNzIHRvIHN0ZXAgdXAgYW5kIG1lZXQgdGhlIGNoYWxsZW5nZS4gSnVuaW9ycyBaYWNoYXJ5IEZyYW50eiBhbmQgUnlhbiBTbWl0aCBzdGVwcGVkIHVwIHRvIGJlY29tZSBjYXB0YWlucyBhbG9uZ3NpZGUgcmV0dXJuaW5nIGNhcHRhaW4gQXVzdGluIExpZW4uIFRoZSBjYXB0YWlucyBzdXJ2ZXllZCB0aGUgdHJ5b3V0IHBvb2wgYW5kIHNhdyB0aGF0IGl0IHdhcyBvbmUgb2YgdGhlIG1vc3QgY29tcGV0aXRpdmUgaW4gcmVjZW50IGhpc3RvcnkuIFdhbnRpbmcgdG8gZ2l2ZSBldmVyeW9uZSBhIGZhaXIgbG9vaywgZmluYWwgY3V0cyB3ZXJlbid0IG1hZGUgdW50aWwgdGhlIGVuZCBvZiBKYW51YXJ5LiBBZnRlciB0aGUgc21va2UgY2xlYXJlZCwgdGhlIGZpbmFsIHJvc3RlciBzdG9vZCBhdCAyNyBhbmQgYWZ0ZXIgYSAxIHllYXIgaGlhdHVzIG9mIG5vIGZyZXNobWFuIG1ha2luZyB0aGUgY3V0LCAyIGZyZXNobWFuIGZvdW5kIHRoZW1zZWx2ZXMgb24gdGhlIHRlYW0uPC9wPlxuICAgICAgICAgICAgPHA+RXZlbiB3aXRoIGEgZnVsbCByb3N0ZXIsIElsbGlub2lzIGJhdHRsZWQgdGhlIGluanVyeSBidWcgdGhyb3VnaG91dCB0aGUgc2Vhc29uLiBEbGluZSBoYW5kbGVyIEFkYW0gV3JpZ2h0IHRvcmUgaGlzIGFjbCBhdCBSaXZhbHJ5IFJlaGVhdCBhbmQgb25seSByZXR1cm5lZCBmb3IgYSBmZXcgcG9pbnRzIGF0IE5hdGlvbmFscy4gQ2FwdGFpbiBaYWNoYXJ5IEZyYW50eiBiYXR0bGVkIFBsYW50YXIgRmFzY2lpdGlzIHRoZSB3aG9sZSB5ZWFyLCBtaXNzaW5nIGV2ZXJ5IHRvdXJuYW1lbnQgYmVzaWRlcyBSZWdpb25hbHMgYW5kIE5hdGlvbmFscy4gNXRoIHllYXIgY3V0dGVyIENocmlzIEhpZGFrYSBiYWRseSBzcHJhaW5lZCBoaXMgYW5rbGUgaW4gdGhlIDJuZCBnYW1lIG9mIHRoZSBmaXJzdCB0b3VybmFtZW50IGFuZCBuZXZlciBxdWl0ZSByZWdhaW5lZCBoaXMgb2xkIGZvcm0uIFNlbmlvcnMgU3VsZXltYW4gQWhtYWQgYW5kIEpvbmF0aGFuIEhhdGNoZXIgaGFkIGxlZyBwcm9ibGVtcyBvZiB0aGVpciBvd24gYW5kIHdlcmUgaW4gYW5kIG91dCBvZiB0aGUgbGluZSB1cC4gSnVuaW9yIFJ5YW4gS3VybmlrIGJyb2tlIGhpcyBoYW5kIGFuZCBtaXNzZWQgdGhlIGxhc3QgaGFsZiBvZiB0aGUgc2Vhc29uLiBJbiBhZGRpdGlvbiB0aGVyZSB3ZXJlIG51bWVyb3VzIG90aGVyIGluanVyaWVzIHRoYXQga2VwdCBwZW9wbGUgYXdheSBmcm9tIHRoZSBmaWVsZC48L3A+XG4gICAgICAgICAgICA8cD5Ib3dldmVyIHRoZXJlIHdlcmUgc3RpbGwgdG91cm5hbWVudHMgdG8gYmUgcGxheWVkIGFuZCBnYW1lcyB0byBiZSB3b24uIENvbXBhcmVkIHRvIHBhc3QgeWVhcnMsIElsbGlub2lzIHRyYXZlbGVkIHRvIGxlc3MgY29tcGV0aXRpdmUgdG91cm5hbWVudHMuIFVuZm9ydHVuYXRlbHkgdGhpcyBkaWQgbm90IGxlYWQgdG8gbW9yZSB2aWN0b3JpZXMgYXMgSWxsaW5vaXMgc3RydWdnbGVkIHRvIG1haW50YWluIGZvY3VzIGZvciB3aG9sZSBnYW1lcywgb2Z0ZW4gcGxheWluZyBvbmUgZ29vZCBhbmQgb25lIGJhZCBoYWxmLiBUaGVyZSB3ZXJlIHNvbWUgYmVuZWZpdHMgYXMgc2V2ZXJhbCBwbGF5ZXJzIHdlcmUgYWJsZSB0byBnYWluIG11Y2ggbmVlZGVkIGV4cGVyaWVuY2UgcGxheWluZyBuZXcgYW5kIG1vcmUgY2hhbGxlbmdpbmcgcm9sZXMgdGhhbiB0aGV5IHdlcmUgYWNjdXN0b21lZCB0by4gSWxsaW5vaXMgbWFkZSBzZW1pZmluYWxzIG9mIGJvdGggdGhlIEZyZWVzdGF0ZSBDbGFzc2ljIGFuZCBIdWNrIEZpbm4gYmVmb3JlIGxvc2luZyB0byBDZW50cmFsIFJlZ2lvbiB0ZWFtcyBJb3dhIGFuZCBNaW5uZXNvdGEuIEdvaW5nIGludG8gdGhlIHNlcmllcywgSWxsaW5vaXMgaG9wZWQgdG8gZm9sbG93IHRoZSB0cmVuZHMgb2YgdGhlIHBhc3QgdHdvIElsbGlub2lzIHRlYW1zIGFuZCBwbGF5IHRoZWlyIGJlc3QgdWx0aW1hdGUgZHVyaW5nIHRoZSBzZXJpZXMuPC9wPlxuICAgICAgICAgICAgPHA+U2VjdGlvbmFscyB3YXMgaGVsZCBjbG9zZSBieSBpbiBSYW50b3VsLCBJbGxpbm9pcyBhcyBwZW9wbGUgc3RpbGwgZGlkbid0IGdldCB0aGUgbWVtbyBub3QgdG8gaGF2ZSB0b3VybmFtZW50cyB0aGVyZSBpbiB0aGUgU3ByaW5nLiBTYXR1cmRheSB3YXMgYSB3aW5keSBhbmQgcmFpbnkgZGF5LCBJbGxpbm9pcyB0b29rIGNhcmUgb2YgYnVzaW5lc3MgYW5kIHdvbiBldmVyeSBnYW1lIGJ5IGEgY29tZm9ydGFibGUgbWFyZ2luLiBPbiBTdW5kYXksIGJ1b3llZCBieSB0aGUgcmFyZSBiZWF1dGlmdWwgUmFudG91bCB3ZWF0aGVyLCBJbGxpbm9pcyBiZWF0IE5vcnRod2VzdGVybiBhbmQgRWFzdGVybiBJbGxpbm9pcyB0byByZXBlYXQgYXMgU2VjdGlvbmFsIENoYW1waW9ucy48L3A+XG4gICAgICAgICAgICA8cD5KdXN0IGxpa2UgMjAxMCwgSWxsaW5vaXMgaGFkIHRoZSAzcmQgc2VlZCBnb2luZyBpbnRvIFJlZ2lvbmFscy4gVW5saWtlIHBhc3QgeWVhcnMgb25seSAxIHRlYW0gd291bGQgbWFrZSBpdCB0byBOYXRpb25hbHMsIG1lYW5pbmcgMSBiYWQgaGFsZiBhbmQgdGhlIHNlYXNvbiB3b3VsZCBiZSBvdmVyLiBBbm90aGVyIGNoYW5nZSB3YXMgdGhlIGZvcm1hdCwgd2l0aCB0aGUgZm9ybWF0IGJlaW5nIHBvb2wgcGxheSBpbnN0ZWFkIG9mIGEgc3RyYWlnaHQgYnJhY2tldC4gSW4gYSB2ZXJ5IHdpbmR5IFNhdHVyZGF5LCBJbGxpbm9pcyBndXR0ZWQgb3V0IGEgY2xvc2UgZ2FtZSBhZ2FpbnN0IExveW9sYSwgd2lubmluZyBvbiBkb3VibGUgZ2FtZSBwb2ludC4gQWZ0ZXIgdGhhdCBzY2FyZSB3b2tlIHRoZW0gdXAsIHRoZXkgYmVhdCBXZXN0ZXJuIE1pY2hpZ2FuIGFuZCBOb3RyZSBEYW1lIGhhbmRpbHkuIEV2ZXJ5b25lIG9uIHRoZSB0ZWFtIHdhcyBsb29raW5nIGZvcndhcmQgdG8gZmFjaW5nIE1pY2hpZ2FuIGluIHNlbWlzIGJ1dCBmaXJzdCB0aGV5IHdvdWxkIGhhdmUgdG8gZ2V0IHRocm91Z2ggSW5kaWFuYSBpbiB0aGUgZmlyc3QgZ2FtZSBvZiB0aGUgZGF5IG9uIFN1bmRheS4gTGVkIGJ5IHRoZWlyIHNlbmlvciBsZWFkZXJzIEVkIFd1IGFuZCBUYXlsb3IgS3JhZW1lciwgSW5kaWFuYSBnYXZlIElsbGlub2lzIGFsbCB0aGV5IGNvdWxkIGhhbmRsZSBpbiBhIGNsb3NlIGJhY2sgYW5kIGZvcnRoIGdhbWUgYmVmb3JlIElsbGlub2lzIHB1bGxlZCBpdCBvdXQgd2lubmluZyAxNS0xMy4gVGhpcyBsZWQgdG8gdGhlIHNlbWlmaW5hbCBzaG93ZG93biB3aXRoIE1pY2hpZ2FuIGZvciB0aGUgdGhpcmQgeWVhciBpbiBhIHJvdy4gSG93ZXZlciwgdGhpcyB5ZWFyIHdvdWxkIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBwYXN0IHR3byB5ZWFycyBhcyBJbGxpbm9pcyBjYW1lIG91dCBmaXJpbmcgd2l0aCBhbiBpbnRlbnNpdHkgdGhhdCBNaWNoaWdhbiBlaXRoZXIgY291bGQgbm90IG9yIHdhcyB1bndpbGxpbmcgdG8gbWF0Y2guIEl0IHdhcyBhIHRvdGFsIHRlYW0gZWZmb3J0IGFzIGV2ZXJ5b25lIGNvbnRyaWJ1dGVkIHRvIGEgcmVzb3VuZGluZyAxNS05IHdpbi4gSXQgd2FzIGEgZ3JlYXQgd2luLCBidXQgcGVvcGxlIHdlcmUgdG9vIHNhdGlzZmllZCB3aXRoIHRoYXQgdmljdG9yeSBjb25zaWRlcmluZyB0aGF0IHRoZSBiaWQgdG8gTmF0aW9uYWxzIHdhcyBzdGlsbCB1cCBmb3IgZ3JhYnMuIElsbGlub2lzIHN0aWxsIGhhZCB0byBmYWNlIGEgZGV0ZXJtaW5lZCBvcHBvbmVudCBpbiBNaWNoaWdhbiBTdGF0ZSB3aG8gdW5kb3VidGVkbHkgaGFkIHBsYW5zIGZvciByZXZlbmdlIGZyb20gMjAxMC4gRm9ydHVuYXRlbHkgZm9yIElsbGlub2lzLCBNaWNoaWdhbiBTdGF0ZSBoYWQgc2V2ZXJhbCB1bmZvcmNlZCBlcnJvcnMgaW4gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIGdhbWUgYW5kIElsbGlub2lzIHRvb2sgYWR2YW50YWdlIGdvaW5nIHVwIHNldmVyYWwgYnJlYWtzIGluIHRoZSBmaXJzdCBoYWxmLiBNaWNoaWdhbiBTdGF0ZSB0cmllZCB0byBtb3VudCBhIGNvbWViYWNrIGluIHRoZSBzZWNvbmQgaGFsZiBidXQgdGhlIHNjb3JlIGRpZmZlcmVuY2Ugd2FzIHRvbyBncmVhdC4gSWxsaW5vaXMgd29uIHRoZSByZWdpb24gZm9yIHRoZSAzcmQgeWVhciBpbiBhIHJvdyBhbmQgdG9vayB0aGUgcmVnaW9ucyBvbmx5IGJpZCB0byBOYXRpb25hbHMgd2l0aCBhIDE1LTExIHZpY3RvcnkuIElsbGlub2lzIGhhZCBzZXZlcmFsIHBsYXllcnMgd2hvIHBsYXllZCB3ZWxsIGR1cmluZyBSZWdpb25hbHMgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0byBEYW5lIEpvcmdlbnNlbiwgQnJpYW4gUGllcmNlLCBBdXN0aW4gTGllbiwgWmFjaGFyeSBGcmFudHosIFJ5YW4gU21pdGggYW5kIE5lYWwgUGhlbHBzLiBJbiBhIHN1cnByaXNpbmcgdHVybiBvZiBldmVudHMsIG9ubHkgUnlhbiBTbWl0aCB3YXMgYSBtZW1iZXIgb2YgdGhlIEFsbC1SZWdpb24gdGVhbS48L3A+XG4gICAgICAgICAgICA8cD5Hb2luZyBpbnRvIE5hdGlvbmFscywgSWxsaW5vaXMgcGxhbm5lZCBvbiBicmVha2luZyB0aGUgY3Vyc2Ugb2YgdHdvIHN0cmFpZ2h0IDE3dGggcGxhY2VzLiBJcm9uaWNhbGx5IGVub3VnaCBhbmQgZGVzZXJ2ZWRseSBzbywgSWxsaW5vaXMgaGFkIHRoZSAxN3RoIHNlZWQgZ29pbmcgaW4uIElsbGlub2lzIHdhcyBpbiBhIHBvb2wgd2l0aCBvdmVyYWxsICMxIHNlZWQgUGl0dHNidXJnaCBhbmQgIzEyIHNlZWQgYW5kIGZhbiBmYXZvcml0ZSBDb2xvcmFkbyBDb2xsZWdlLiBJbiB0aGUgZmlyc3QgZ2FtZSBvZiBOYXRpb25hbHMgYWdhaW5zdCBDb2xvcmFkbyBDb2xsZWdlLCBJbGxpbm9pcyBiYXR0bGVkIG5lcnZlcyBhbmQgaGFkIHNldmVyYWwgdW5mb3JjZWQgZXJyb3JzIGluIHRoZSBmaXJzdCBoYWxmLiBIb3dldmVyLCBsZWQgYnkgTmVhbCBQaGVscHMnIHN0ZWxsYXIgZGVmZW5zZSBvbiBDYWxsYWhhbiBjYW5kaWRhdGUgTmlja3kgU3BpdmEgYW5kIERhbmUgSm9yZ2Vuc2VuJ3MgYWVyaWFsIGFiaWxpdHksIElsbGlub2lzIGZvdWdodCBhbmQgY2xhd2VkIGJhY2sgZm9yIGEgZ3JpdHR5IDEzLTExIHZpY3RvcnkuIFRoaXMgd2FzIElsbGlub2lzJyBmaXJzdCBOYXRpb25hbHMgcG9vbCBwbGF5IHZpY3RvcnkgaW4gMiB5ZWFycyBhbmQgaGFkIHRoZW0gcHJpbWVkIHRvIHRha2UgYSBzcG90IGluIHByZXF1YXJ0ZXJzLiBBZnRlciBsb3NpbmcgMTUtMTAgdG8gUGl0dHNidXJnaCBoaWdobGlnaHRlZCBieSBhIGJyZWFrIHdpdGggc2V2ZXJhbCBOYXRpb25hbHMgZmlyc3QgdGltZXJzIGFuZCBib3RoIHJvb2tpZXMsIElsbGlub2lzIG9ubHkgbmVlZGVkIHRvIHdpbiAxIG9mIHRoZWlyIG5leHQgMiBnYW1lcyB0byB0YWtlIGEgc3BvdCBpbiBwcmVxdWFydGVycy4gVW5mb3J0dW5hdGVseSwgdGhlIGlzc3VlcyB0aGF0IGJlZ3VpbGVkIElsbGlub2lzIHRocm91Z2hvdXQgdGhlIHNlYXNvbiBjYW1lIHVwIG9uY2UgYWdhaW4uIFRvIHB1dCBpdCBzaW1wbHksIElsbGlub2lzIGRpZCBub3Qgc2hvdyB1cCBvbiBTYXR1cmRheSBvZiBOYXRpb25hbHMuIElsbGlub2lzIGxvb2tlZCBsaWZlbGVzcyBhbmQgbG9zdCB0byBJb3dhIDE1LTEwLiBFdmVuIHdpdGggdGhhdCBiZWluZyBzYWlkLCBJbGxpbm9pcyBzaW1wbHkgaGFkIHRvIHdpbiBhZ2FpbnN0IFR1ZnRzIHRvIGFkdmFuY2UgdG8gdGhlIGJyYWNrZXQuIFdpdGggdGhlaXIgc2Vhc29uIG9uIHRoZSBsaW5lLCBJbGxpbm9pcyBnYXZlIGEgc2FkLCBkaXNhcHBvaW50aW5nIGVmZm9ydCBib3RoIG9uIHRoZSBmaWVsZCBhbmQgb24gdGhlIHNpZGVsaW5lcy4gVGhlaXIgZWZmb3J0IHdhcyBubyB3aGVyZSBjbG9zZSB0byBnb29kIGVub3VnaCBhbmQgdGhleSBnb3QgcHVuaXNoZWQgZGVzZXJ2ZWRseSwgMTUtNywga25vY2tpbmcgdGhlbSBpbnRvIHRoZSBwbGFjZW1lbnQgYnJhY2tldCBmb3IgdGhlIDNyZCB5ZWFyIGluIGEgcm93LiBJbGxpbm9pcyBsb3N0IHRvIFdoaXRtYW4gMTYtMTQgYWZ0ZXIgbGVhZGluZyBtb3N0IG9mIHRoZSBnYW1lIGFuZCB0aGVuIGluIHRoZSBnYW1lIHRoZXkgaGF2ZSBuZXZlciBsb3N0LCBiZWF0IEZsb3JpZGEgYW5kIHRvb2sgMTd0aCBwbGFjZSBmb3IgdGhlIDNyZCB5ZWFyIGluIGEgcm93LiBIb3dldmVyIHRoZXJlIGlzIGhvcGUgZm9yIHRoZSBmdXR1cmUgd2l0aCAyMCByZXR1cm5pbmcgcGxheWVycyBhbmQgYSB0YWxlbnRlZCBpbmNvbWluZyBjbGFzcywgSWxsaW5vaXMgd2lsbCBsb29rIHRvIGJyZWFrIHRoZSBjdXJzZSBvZiAxN3RoLjwvcD5cbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEwLFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTAuanBnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+SWxsaW5vaXMgaGFkIHRvIGRlYWwgd2l0aCBzZXZlcmFsIGJpZyBsb3NzZXMgZnJvbSB0aGUgeWVhciBiZWZvcmUgYnV0IG5vbmUgYmlnZ2VyIHRoYW4gdGhlIGRlcGFydHVyZSBvZiBsb25ndGltZSBjb2FjaCBNYXR0IFN0dXBjYSB3aG8gY29hY2hlZCBmcm9tIDIwMDQtMjAwOS4gVGhlIGNhcHRhaW5zIEJyaWFuIFBoZWxhbiwgV2FsZGVuIE5lbHNvbiBhbmQgQXVzdGluIExpZW4sIGhhZCB0byBjb21lIHRvIHRlcm1zIHdpdGggdGhlIHJlc3BvbnNpYmlsaXRpZXMgYW5kIGV4dHJhIHdvcmsgdGhhdCBNYXR0IFN0dXBjYSBwcm92aWRlZCwgYW5kIGNhcnJ5IGEgYmlnZ2VyIGxvYWQgdGhlbXNlbHZlcy4gRGVhbGluZyB3aXRoIHRoZSBoZWF2eSBsb3NzZXMgZnJvbSB0aGUgeWVhciBiZWZvcmUsIElsbGlub2lzIGNhbGxlZCB1cCBhIG51bWJlciBvZiBwbGF5ZXJzIGZyb20gdGhlIEItdGVhbSBhbmQgdHdvIGZyb20gdGhlIEMtdGVhbSB3aGljaCB3YXMgYSBwcm9ncmFtIGZpcnN0LiBJbGxpbm9pcyBzcGVudCBtdWNoIG9mIHRoZSBzZWFzb24gYWNjbGltYXRpbmcgdGhlIG5ldyBwbGF5ZXJzIHNvIHRoYXQgdGhleSB3b3VsZCBiZSByZWFkeSBmb3IgTmF0aW9uYWxzIGxldmVsIGNvbXBldGl0aW9uLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZXkgaGFkIHVuZXZlbiByZXN1bHRzIGFuZCBncm93aW5nIHBhaW5zIHRocm91Z2hvdXQgdGhlIHllYXIsIHdpdGggYSBoaWdobGlnaHQgYmVpbmcgbWFraW5nIHRoZSBmaW5hbHMgb2YgTWFyZGlzIEdyYXMgYmVmb3JlIGxvc2luZyB0byBXaXNjb25zaW4gYnkgYSBzdWJzdGFudGlhbCBtYXJnaW4uIEl0IGFsc28gaW5jbHVkZWQgYW5vdGhlciBzaGVsbGFja2luZyBieSBNaWNoaWdhbiBhdCBIdWNrIEZpbm4gYXMgbWFueSBwbGF5ZXJzIGdvdCB0aGVpciBmaXJzdCB0YXN0ZSBvZiB0aGUgcmVnaW9uYWwgcml2YWxyeS4gSWxsaW5vaXMgaGFkIHNldmVyYWwgaW5qdXJpZXMgdGhyb3VnaG91dCB0aGUgeWVhciB3aGljaCBtYWRlIHByYWN0aWNlIGF0dGVuZGFuY2UgYW4gaXNzdWUsIGhvd2V2ZXIgSWxsaW5vaXMgZm91Z2h0IHRocm91Z2ggdGhlbSBhbmQgd2VudCBpbnRvIHRoZSBDb2xsZWdlIFNlcmllcyBtb3N0bHkgaGVhbHRoeS48L3A+XG4gICAgICAgICAgICA8cD5BdCBTZWN0aW9uYWxzIElsbGlub2lzIGhlbGQgdGhlIDEgc2VlZCBnb2luZyBpbiwgYnV0IGxvc3Qgb24gU2F0dXJkYXkgb2YgU2VjdGlvbmFscyBmb3IgdGhlIGZpcnN0IHRpbWUgc2luY2UgdGhlIFJlZ2lvbnMgYW5kIFNlY3Rpb25zIHdlcmUgcmVkcmF3bi4gVGhpcyBnYXZlIHRoZW0gYSAyIHNlZWQgb3V0IG9mIHRoZWlyIHBvb2wgYW5kIGEgZmlyc3Qgcm91bmQgbWF0Y2ggdXAgd2l0aCBOb3RyZSBEYW1lIHRoZSAyIHNlZWQgb3ZlcmFsbCwgd2l0aCBnb29kIHNlZWRpbmcgYXQgUmVnaW9uYWxzIG9uIHRoZSBsaW5lLiBJbGxpbm9pcyB3ZW50IHVwIGJpZyBlYXJseSBidXQgTm90cmUgRGFtZSBtYWRlIGEgZnVyaW91cyBjb21lYmFjayB0byB0aWUgdXAgbGF0ZSBpbiB0aGUgZ2FtZSwgSWxsaW5vaXMgcmVjZWl2ZWQgZ29pbmcgdXB3aW5kIGFuZCB0aHJldyBjYXV0aW9uIGludG8gdGhlIHdpbmQgYnkgdGhyb3dpbmcgc2V2ZXJhbCBjbG9zZSB0aHJvd3MgdGhyb3VnaCBhbmQgYXJvdW5kIHRoZSBOb3RyZSBEYW1lIHpvbmUgYmVmb3JlIHB1bmNoaW5nIGl0IGluIGFuZCB3aW5uaW5nIDE0LTEzLiBJbGxpbm9pcyB0aGVuIHRvb2sgY2FyZSBvZiBidXNpbmVzcyBhbmQgbWFkZSBpdCB0byBmaW5hbHMsIGV4YWN0aW5nIHJldmVuZ2Ugb24gUHVyZHVlIGZvciB0aGUgU2F0dXJkYXkgbG9zcyBhbmQgYmVhdGluZyB0aGVtIDE1LTUgYW5kIHJlY2xhaW1pbmcgdGhlIFNlY3Rpb25hbCB0aXRsZS48L3A+XG4gICAgICAgICAgICA8cD5Hb2luZyBpbnRvIFJlZ2lvbmFscyBJbGxpbm9pcyBoYWQgdGhlIDMgc2VlZCBnb2luZyBpbiBiZWhpbmQgTWljaGlnYW4gU3RhdGUgYW5kIE1pY2hpZ2FuLiBJbGxpbm9pcyBiZWF0IGJvdGggRGF5dG9uIGFuZCBQdXJkdWUgaGFuZGlseSBhbmQgYWR2YW5jZWQgdG8gc2VtaWZpbmFscyBiZWZvcmUgZmluZGluZyBvdXQgdGhhdCBSZWdpb25hbHMgd291bGQgYmUgcG9zdHBvbmVkIGZvciBhIHdlZWsuIEhhdmluZyBhIHdlZWsgdG8gcHJlcGFyZSBhbmQgdG8gaGVhbCwgSWxsaW5vaXMgZmFjZWQgTWljaGlnYW4gYXQgUmVnaW9uYWxzIGFzIGlzIHRoZSBub3JtLiBJbiBhIGhlYXZ5IHdpbmQgZ2FtZSwgd2hpY2ggc2F3IHNldmVyYWwgbGVhZCBjaGFuZ2VzLCBidXQgZmV3IGJyZWFrcywgYW5kIGxvdHMgb2YgZ3JlYXQgcGxheXMgZnJvbSBib3RoIHRlYW1zLCBJbGxpbm9pcyB3YXMgYWJsZSB0byBzY29yZSBvbiBhIGd1dC13cmVuY2hpbmcgdW5pdmVyc2UgcG9pbnQgYW5kIHdvbiB0aGUgZ2FtZSA5LTguPC9wPlxuICAgICAgICAgICAgPHA+VGhpcyBzZW50IElsbGlub2lzIHRvIGl0cyAzcmQgc3RyYWlnaHQgUmVnaW9uYWwgZmluYWwgd2l0aCBhIGNoYW5jZSB0byByZXBlYXQgYXMgUmVnaW9uYWwgY2hhbXBpb25zIGZvciB0aGUgZmlyc3QgdGltZSBpbiB0aGUgcHJvZ3JhbXMgaGlzdG9yeS4gSWxsaW5vaXMgZmFjZWQgTWljaGlnYW4gU3RhdGUgd2l0aCB0aGUgUmVnaW9uYWwgdGl0bGUgb24gdGhlIGxpbmUgYW5kIHByZXZhaWxlZCBpbiBhIGNsb3NlIGdhbWUgd2l0aCBJbGxpbm9pcyBiZWluZyBhYmxlIHRvIHB1bGwgYXdheSBpbiB0aGUgZW5kLCAxNS0xMC4gSWxsaW5vaXMgcmVwZWF0ZWQgYXMgUmVnaW9uYWwgY2hhbXBpb25zIGZvciB0aGUgZmlyc3QgdGltZSBhbmQgaGFkIEJyaWFuIFBoZWxhbiBhbmQgV2FsZGVuIE5lbHNvbiB3aW4gZmlyc3QgdGVhbSBBbGwtUmVnaW9uIGhvbm9ycyBhbmQgaGFkIFJ5YW4gU21pdGggd2luIDJuZCB0ZWFtIEFsbC1SZWdpb24sIGJlY29taW5nIHRoZSBmaXJzdCBzb3Bob21vcmUgaW4gdGhlIHByb2dyYW1zIGhpc3RvcnkgdG8gd2luIGEgcmVnaW9uYWwgYXdhcmQuIElsbGlub2lzIHdhcyBzZWVkZWQgMTR0aCBnb2luZyBpbnRvIE5hdGlvbmFscy4gVGhleSBsb3N0IHRvIEhhcnZhcmQgaGFuZGlseSBidXQgd2FzIHN0aWxsIGluIGNvbnRlbnRpb24gZm9yIGEgcHJlcXVhcnRlcnMgYmVydGggaWYgdGhleSB3ZXJlIGFibGUgdG8gYmVhdCBib3RoIFVOQ1cgYW5kIElvd2EuIEhvd2V2ZXIsIGluIGdhbWVzIHBvc3NpYmx5IHNob3dpbmcgYSBsYWNrIG9mIGV4cGVyaWVuY2Ugb3IgdGhlIGJ1cmRlbiBvZiBjYXB0YWluaW5nIGFuZCBjb2FjaGluZyBwcm92aW5nIHRvbyBncmVhdCwgSWxsaW5vaXMgbG9zdCBsYXRlIGxlYWRzIGluIGJvdGggZ2FtZXMgYW5kIGxvc3QgdG8gVU5DVyAxNC0xMiBhbmQgdG8gSW93YSAxNi0xNC4gSWxsaW5vaXMgdGhlbiBwbGF5ZWQgQ2FybGV0b24gaW4gYSBtdWNoIGNsb3NlciB0aGFuIGV4cGVjdGVkIDE1LTEyIGxvc3MgYW5kIGxvc3QgdG8gV2lzY29uc2luLiBCZWF0aW5nIEthbnNhcyBpbiB0aGUgbGFzdCBnYW1lIG9mIHRoZSB0b3VybmFtZW50IGdhdmUgSWxsaW5vaXMgaXRzIG9ubHkgd2luIGF0IE5hdGlvbmFscyBhbmQgc2VudCB0aGVtIGhvbWUgd2l0aCBhbm90aGVyIDE3dGggcGxhY2UgZmluaXNoLiBJbGxpbm9pcyBkaWQgbm90IGdyYWR1YXRlIGFzIG1hbnkgcGxheWVycyBhcyBpbiB5ZWFycyBwYXN0LCB3aGljaCBtYWtlcyBJbGxpbm9pcyBpbiBhIHByaW1lIHBvc2l0aW9uIHRvIGNvbnRpbnVlIGl0cyBOYXRpb25hbHMgcXVhbGlmeWluZyBzdHJlYWsuPC9wPlxuICAgICAgICBgXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDksXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAwOS5qcGcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD4yMDA5IHNhdyB0aGUgZGVwYXJ0dXJlcyBvZiBtYW55IGZpeHR1cmVzIG9mIHRoZSBJbGxpbm9pcyBwcm9ncmFtIHN1Y2ggYXMgSm9lbCBLb2VobmVtYW4sIFBhdCBTdGVwaGVucywgSmFrZSBTZWdpbCBhbmQgRGF2aWQgQWJyYW0uIEluIHRoZWlyIHBsYWNlIGl0IHdhcyB1cCB0byB0aGUgY2xhc3Mgb2YgMjAwNSB0byBzdGVwIHVwIGFuZCBsZWFkIHRoZSBwcm9ncmFtLiBJdCB3YXMgdGhlIGZpcnN0IHRpbWUgaW4gc2V2ZXJhbCB5ZWFycyB0aGF0IHRoZXJlIHdlcmUgMyBjYXB0YWlucyB2YWNhbmNpZXMuIFRoZXkgd2VyZSBmaWxsZWQgYnkgRGVuaXMgQWduaWVsLCBCcmlhbiBQaGVsYW4gYW5kIENoYXJsaWUgTydCcmllbi4gTGlrZSBpbiAyMDA2IHdoZW4gdGhlIHRlYW0gbG9zdCBzZXZlcmFsIGltcGFjdCBwbGF5ZXJzLCB0aGUgdGVhbSB3YXMgYWJsZSB0byByZWNydWl0IGEgdmVyeSBkZWVwIGNsYXNzIHRoYXQgcml2YWxzIGFuZCBtYXkgc3VycGFzcyB0aGUgZnJlc2htYW4gY2xhc3Mgb2YgMjAwNi4gVGhpcyBpbmZsdXggb2YgZnJlc2htYW4gbGVkIHRvIHRoZSAybmQgeWVhciBvZiB0aGUgQy0gdGVhbXMgZXhpc3RlbmNlIGluIHRoZSBwcm9ncmFtcyBoaXN0b3J5LjwvcD4gICAgXG4gICAgICAgICAgICA8cD5UaGUgcmVndWxhciBzZWFzb24gZm9yIElsbGlub2lzIHdhcyB2ZXJ5IHJvdWdoLCB3aXRoIHRoZSB0ZWFtIHRyeWluZyB0byBmaW5kIHBlb3BsZSB3aG8gd291bGQgYmUgYWJsZSB0byBmaWxsIHRoZSBiaWcgaG9sZXMgbGVmdCBieSB0aGUgZGVwYXJ0ZWQgcGxheWVycy4gVGhpcyBsZWQgdG8gc2V2ZXJhbCBiaWcgbG9zc2VzIHRocm91Z2hvdXQgdGhlIHllYXIgYW5kIHBvb3IgdG91cm5hbWVudCBmaW5pc2hlcywgY3VsbWluYXRpbmcgaW4gYSAxMy0yIGJlYXRkb3duIGJ5IHJlZ2lvbmFsIHJpdmFsIE1pY2hpZ2FuIGF0IEh1Y2sgRmlubi4gR29pbmcgaW50byB0aGUgcG9zdHNlYXNvbi90aGUgY29sbGVnZSBzZXJpZXMsIElsbGlub2lzIGhhZCBhIGxvdCBvZiB1bmNlcnRhaW50eS4gQXQgU2VjdGlvbmFscywgSWxsaW5vaXMgdG9vayBjYXJlIG9mIGJ1c2luZXNzIG9uIFNhdHVyZGF5IGFuZCBiZWF0IGEgdG91Z2ggTm9ydGggUGFyayB0ZWFtIGluIHNlbWlmaW5hbHMgYW5kIG1hZGUgRmluYWxzIGFnYWluc3QgTm90cmUgRGFtZS4gSW4gYSByYWlueSwgY29sZCBmaW5hbCwgSWxsaW5vaXMgbG9va2VkIGxpa2UgdGhleSBkaWQgdGhyb3VnaG91dCB0aGUgc2Vhc29uIGFuZCBsb3N0IDE1LTEwLiBUaGlzIGdhdmUgSWxsaW5vaXMgYSA0IHNlZWQgZ29pbmcgaW50byBSZWdpb25hbHMgYW5kIGEgZGVmaW5pdGUgbG9uZ3Nob3QgZm9yIG9uZSBvZiB0aGUgdHdvIE5hdGlvbmFscyBiaWRzLjwvcD5cbiAgICAgICAgICAgIDxwPklsbGlub2lzIGZhY2VkIHRvdWdoZXIgdGhhbiBleHBlY3RlZCBnYW1lcyBhZ2FpbnN0IEtlbnlvbiBhbmQgTm9ydGggUGFyayBiZWZvcmUgbWVldGluZyBNaWNoaWdhbiBpbiBSZWdpb25hbCBzZW1pZmluYWxzLiBJbGxpbm9pcyBjYW1lIHRvZ2V0aGVyIGluIGEgd2F5IHRoYXQgaGFkIG5vdCBiZWVuIHNlZW4gYWxsIHNlYXNvbiwgYW5kIHB1dCBmb3J0aCB0aGVpciBiZXN0IGVmZm9ydCBvZiB0aGUgc2Vhc29uIGFuZCBiZWF0IE1pY2hpZ2FuIGluIGEgdGVuc2UgaGFyZCBmb3VnaHQgZ2FtZSAxMi05LiBUaGlzIHB1dCBJbGxpbm9pcyBpbiBpdHMgc2Vjb25kIHN0cmFpZ2h0IFJlZ2lvbmFsIGZpbmFsIGFnYWluc3QgT2hpbyBTdGF0ZS4gVGhlIHByZXZpb3VzIGRheSdzIG1vbWVudHVtIGNhcnJpZWQgb3ZlciBhcyBJbGxpbm9pcyBiZWF0IE9oaW8gU3RhdGUgaGFuZGlseSAxNS0xMSwgdGFraW5nIGhvbWUgaXRzIGZpcnN0IFJlZ2lvbmFsIGNoYW1waW9uc2hpcCBzaW5jZSAyMDAyLjwvcD5cbiAgICAgICAgICAgIDxwPklsbGlub2lzIHBsYWNlZCBEZW5pcyBBZ25pZWwsIEJyaWFuIFBoZWxhbiwgUGF2YW4gU2FyZ3VydSwgYW5kIFdhbGRlbiBOZWxzb24gb24gdGhlIEdyZWF0IExha2VzIDJuZCBUZWFtIEFsbC1SZWdpb24sIENvYWNoIE1hdHQgU3R1cGNhIHdvbiB0aGUgaW5hdWd1cmFsIENvYWNoIG9mIHRoZSBSZWdpb24gYXdhcmQsIGFuZCBSeWFuIFNtaXRoIHdvbiBGcmVzaG1hbiBvZiB0aGUgeWVhci4gV2lubmluZyB0aGUgUmVnaW9uIGdhdmUgSWxsaW5vaXMgYW4gOCBzZWVkIGdvaW5nIGludG8gTmF0aW9uYWxzLCBob3dldmVyIHdoYXRldmVyIG1hZ2ljIElsbGlub2lzIGhhZCBhdCBSZWdpb25hbHMgd2FzIGxvc3QgYXQgTmF0aW9uYWxzLCBhcyBJbGxpbm9pcyBsb3N0IHNldmVyYWwgZ2FtZXMgYnkgYmlnIG1hcmdpbnMgZXhjZXB0IGZvciBvbmUgY2xvc2UgcG9vbCBwbGF5IGdhbWUgYWdhaW5zdCBUdWZ0cyBhbmQgdGhlIG9ubHkgd2luIGFnYWluc3QgQ2FsLiBUaGV5IGRpZCBzbyBpbiBnb29kIHNwaXJpdCwgd2lubmluZyB0aGUgMjAwOSBOYXRpb25hbHMgU3Bpcml0IEF3YXJkIGFuZCBkdWJiZWQgWnViYWlyOiBUaGUgbW9zdCBzcGlyaXRlZCBtYW4gaW4gdWx0aW1hdGUuIEFsdGhvdWdoLCB0aGlzIHBlcmZvcm1hbmNlIGdhdmUgSWxsaW5vaXMgYSBkaXNhcHBvaW50aW5nIDE3dGggcGxhY2UgZmluaXNoIGF0IE5hdGlvbmFscyBhbmQgd2l0aCBzZXZlcmFsIHBsYXllcnMgZ3JhZHVhdGluZyBpbmNsdWRpbmcgY2FwdGFpbiBEZW5pcyBBZ25pZWwsIHRoZSBwcm9zcGVjdCBvZiBhbm90aGVyIHJlYnVpbGRpbmcgeWVhciBsb29tZWQgbGFyZ2UuPC9wPlxuICAgICAgICBgXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDgsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAwOC5qcGcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5Vc2luZyB0aGUgbG9zcyBhdCBSZWdpb25hbHMgdGhlIHByZXZpb3VzIHllYXIgYXMgbW90aXZhdGlvbiBhbmQgZGV0ZXJtaW5lZCB0byBtYWtlIE5hdGlvbmFscyBpbiBjYXB0YWlucyBKb2VsIEtvZWhuZW1hbiwgUGF0IFN0ZXBoYW5zIGFuZCBEYXZpZCBBYnJhbXMsIGZpbmFsIHllYXIuIE1hbnkgcGxheWVycyBvbiB0aGUgdGVhbSBzcGVudCB0aGVpciBzdW1tZXIgYW5kIGZhbGwsIGdvaW5nIHRvIHRvdXJuYW1lbnRzIHRvZ2V0aGVyIGluIGFuIGVmZm9ydCB0byBnZXQgYmV0dGVyLiBJbGxpbm9pcyBhbHNvIGdvdCBhIGtleSB0cmFuc2ZlciBzdHVkZW50IERlbmlzIEFnbmllbCwgd2hvIGNyZWF0ZWQgdGhlIHRlYW0gYXQgTG95b2xhIFVuaXZlcnNpdHkgaW4gQ2hpY2Fnby4gVGhpcyB3YXMgYSB2ZXJ5IHZldGVyYW4gdGVhbSB1bmRlciBjb2FjaCBNYXR0IFN0dXBjYSB0aGF0IHdhcyBwb2lzZWQgdG8gbWFrZSBhIHJ1biBpbnRvIE5hdGlvbmFscy48L3A+ICAgIFxuICAgICAgICAgICAgPHA+VGhyb3VnaG91dCB0aGUgc2Vhc29uLCBJbGxpbm9pcyBoYWQgYSBjaGFuY2UgdG8gd2luIGV2ZXJ5IGdhbWUgdGhhdCB0aGV5IHBsYXllZC4gVGhlIGJpZ2dlc3QgbWFyZ2luIG9mIHZpY3RvcnkgaW4gSWxsaW5vaXMnIGxvc3NlcyBoZWFkaW5nIGludG8gUmVnaW9uYWxzIHdhcyAzIHBvaW50cy4gSWxsaW5vaXMgc3VmZmVyZWQgc29tZSBrZXkgaW5qdXJpZXMgYmVmb3JlIFNlY3Rpb25hbHMgYnV0IG1hbmFnZWQgdG8gcGVyc2V2ZXJlIGFuZCBob2xkIG9mIE5vcnRoIFBhcmsgaW4gYW4gZXhjaXRpbmcgMTctMTYgU2VjdGlvbmFsIEZpbmFsLiBMaWtlIHRoZSBwcmV2aW91cyB5ZWFyIElsbGlub2lzIGhhZCBhIDIgc2VlZCBnb2luZyBpbnRvIFJlZ2lvbmFscy4gVGhleSB0b29rIGNhcmUgb2YgYnVzaW5lc3Mgb24gU2F0dXJkYXkgd2lubmluZyBhbGwgMyBnYW1lcyBhbmQgc2VjdXJpbmcgYSBzcG90IGluIHRoZSBSZWdpb25hbCBmaW5hbHMuIEluIG1hbnkgcGVvcGxlJ3MgZmlyc3QgUmVnaW9uYWwgZmluYWwsIElsbGlub2lzIHBsYXllZCB0ZW50YXRpdmVseSBhbmQgbG9zdCAxNS0xMSB0byBNaWNoaWdhbiBwdXR0aW5nIHRoZW0gaW4gdGhlIDJuZCBwbGFjZSBnYW1lIGFnYWluc3QgT2hpbyBTdGF0ZS4gSW4gYSByZXZlcnNhbCBvZiB0aGUgcHJldmlvdXMgeWVhcnMgZ2FtZSBhdCBSZWdpb25hbHMsIElsbGlub2lzIHN0b3JtZWQgb3V0IHRvIGEgYmlnIGxlYWQgYW5kIG1haW50YWluZWQgaXQgdGhyb3VnaG91dCBhbmQgcHVuY2hlZCB0aGVpciBmaXJzdCB0aWNrZXQgdG8gTmF0aW9uYWxzIGluIDMgeWVhcnMuPC9wPiAgICBcbiAgICAgICAgICAgIDxwPlBhdCBTdGVwaGVucyBhbmQgSm9lbCBLb2VobmVtYW4gYm90aCB3b24gYWxsLXJlZ2lvbiBob25vcnMuIE5hdGlvbmFscyB0aGF0IHllYXIgd2FzIGluIEJvdWxkZXIsIENvbG9yYWRvIGFuZCBJbGxpbm9pcyB3ZW50IGludG8gaXQgaG9sZGluZyBhbiA4IHNlZWQgYW5kIGluIGEgcG9vbCB3aXRoIEZsb3JpZGEsIE5vcnRoIFRleGFzIGFuZCBEZWxhd2FyZS4gSWxsaW5vaXMgYmVhdCBEZWxhd2FyZSB0byBjbGluY2ggYSBzcG90IGluIHByZXF1YXJ0ZXJzLCBhbmQgbG9zdCB0byBGbG9yaWRhIGFuZCBOb3J0aCBUZXhhcy4gSW4gcHJlcXVhcnRlcnMgSWxsaW5vaXMgd2FzIG1hdGNoZWQgdXAgYWdhaW5zdCBNaWNoaWdhbiwgd2hvIHRoZXkgaGFkIGxvc3QgdG8gYXQgUmVnaW9uYWxzIGFuZCBoYWQgbm90IGJlYXRlbiBzaW5jZSAyMDA0LiBJbiBhIGhhcmQgZm91Z2h0IGdhbWUgbGVkIGJ5IHRoZSBncmFkdWF0aW5nIHBsYXllcnMsIElsbGlub2lzIHByZXZhaWxlZCAxNS0xMSBzZW5kaW5nIHRoZW0gaW50byBxdWFydGVycyBhZ2FpbnN0IHRoZSBob21ldG93biB0ZWFtIENvbG9yYWRvLiBJbiBhbiBleGNpdGluZyBnYW1lIHRoYXQgc2F3IHNldmVyYWwgYmlnIHBsYXlzLCBJbGxpbm9pcyBsb3N0IDE1LTEyIHRvIENvbG9yYWRvIGFuZCBlbmRlZCB0aGVpciBzZWFzb24gaGF2aW5nIHRoZW0gdGllZCBmb3IgNXRoIHdoaWNoIGlzIHRoZSBoaWdoZXN0IGZpbmlzaCBpbiB0aGUgcHJvZ3JhbXMgaGlzdG9yeS4gMjAwOCBzYXcgdGhlIGRlcGFydHVyZSBvZiBtYW55IG1haW5zdGF5cyBmb3IgSWxsaW5vaXMgYW5kIHRoZSBmb2xsb3dpbmcgeWVhcnMgd291bGQgc2hvdyBob3cgd2VsbCB0aGUgcmVjcnVpdGluZyBlZmZvcnRzIG9mIDIwMDUgcGFpZCBvZmYuPC9wPiAgICAgIFxuICAgICAgICBgXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDcsXG4gICAgICAgIGltYWdlUGF0aDogJycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPkNvbWluZyBvZmYgb2Ygb25lIHRoZSB3b3JzdCB5ZWFycyBpbiByZWNlbnQgaGlzdG9yeSwgSWxsaW5vaXMgc3RhcnRlZCB0byBwdXQgdGhlIHBpZWNlcyBpbiBwbGFjZSB0byBtYWtlIGEgcnVuIGF0IGEgTmF0aW9uYWxzIGJlcnRoLiBUaGUgbGVhZGVyc2hpcCB3aGljaCBhZGRlZCBKYWtlIFNlZ2lsIGFzIGEgY2FwdGFpbiwgam9pbmluZyBKb2VsIEtvZWhuZW1hbiBhbmQgQnJpYW4gS29yYmVzbWV5ZXIgYW5kIE1hdHQgU3R1cGNhIGFzIGNvYWNoLCBjb250aW51ZWQgdG8gZm9jdXMgb24gcmVjcnVpdGluZywgcmVzdWx0aW5nIGluIGFuIGFub3RoZXIgYmlnIGluZmx1eCBvZiBmcmVzaG1hbi4gUmVzdWx0aW5nIGluIHRoZSBjcmVhdGlvbiBvZiB0aGUgZmlyc3QgQy10ZWFtIGluIHRoZSBwcm9ncmFtcyBoaXN0b3J5LiBIb3dldmVyLCB1bmxpa2UgdGhlIHByZXZpb3VzIHllYXIsIG1hbnkgb2YgdGhlbSBzdG9wcGVkIHBsYXlpbmcgd2l0aGluIGEgeWVhci48L3A+ICAgIFxuICAgICAgICAgICAgPHA+SW4gb3JkZXIgdG8gZ2VhciB1cCB0byBtYWtlIGEgcnVuIGFuZCB0byBmYWNlIHN0aWZmZXIgY29tcGV0aXRpb24sIElsbGlub2lzIGRlc2lnbmVkIGEgbXVjaCBoYXJkZXIgdG91cm5hbWVudCBzY2hlZHVsZSB0cmF2ZWxsaW5nIHRvIHRvdXJuYW1lbnRzIGluIExhcyBWZWdhcyBhbmQgQXVzdGluLCBpbiBhZGRpdGlvbiB0byBvbmVzIHRoZXkgaGFkIHByZXZpb3VzbHkgZ29uZSB0byBpbiBCYXRvbiBSb3VnZSBhbmQgQXRsYW50YS4gVGhpcyBiZW5lZml0ZWQgdGhlIHRlYW0sIGFzIHRoZXkgd2VyZSBhYmxlIHRvIG1hdGNoIHVwIGFuZCBzZWUgd2hlcmUgdGhleSBzdG9vZCBpbiByZWxhdGlvbiB0byBib3RoIE5hdGlvbmFscyBmaW5hbGlzdHMuIEFzIGEgcmVzdWx0LCB0aGUgdGVhbSB3YXMgYWJsZSB0byBzZWUgdGhhdCB0aGV5IHdlcmUgbW9yZSB0aGFuIHByZXBhcmVkIHRvIHRha2UgYSBOYXRpb25hbHMgYmVydGggb3V0IG9mIFJlZ2lvbmFscy48L3A+ICAgIFxuICAgICAgICAgICAgPHA+SWxsaW5vaXMgc3RlYW1yb2xsZWQgdGhyb3VnaCBTZWN0aW9uYWxzIGFuZCByZWNsYWltZWQgdGhlIFNlY3Rpb25hbHMgY3Jvd24gYW5kIGhhZCBhIDItc2VlZCBnb2luZyBpbnRvIFJlZ2lvbmFscy4gUmVnaW9uYWxzIHdhcyBoZWxkIGluIFJhbnRvdWwsIElsbGlub2lzIGFuZCB3YXMgaG9zdGVkIGJ5IElsbGlub2lzLiBJbGxpbm9pcyB0b29rIGNhcmUgb2YgYnVzaW5lc3MgZWFybHksIGJlYXRpbmcgRGF5dG9uIGFuZCBOb3RyZSBEYW1lIGhhbmRpbHkgYmVmb3JlIHNxdWFyaW5nIG9mZiBhZ2FpbnN0IEluZGlhbmEgaW4gUmVnaW9uYWwgc2VtaWZpbmFscy4gSW4gYSB2ZXJ5IGhlYXZ5IHVwd2luZCBkb3dud2luZCBnYW1lIHRoYXQgc2F3IHZlcnkgZmV3IGJyZWFrcywgSWxsaW5vaXMgcmVjZWl2ZWQgZ29pbmcgZG93bndpbmQgb24gdW5pdmVyc2UgcG9pbnQgYnV0IHdhcyB1bmFibGUgdG8gcHVuY2ggaXQgaW4gYW5kIGxvc3Qgb24gYSBjb3VwbGUgZmxvYXR5IHVwd2luZCBodWNrcy4gT3V0IG9mIHRoZSBydW5uaW5nIGZvciBmaXJzdCwgSWxsaW5vaXMgd2FzIG5vdyBpbiB0aGUgYmFja2Rvb3IgYnJhY2tldCBoYXZpbmcgdG8gd2luIGV2ZXJ5IGdhbWUgaW4gb3JkZXIgdG8gYWR2YW5jZSB0byBOYXRpb25hbHMuIFRoZXkgYmVhdCBOb3J0aHdlc3Rlcm4gYW5kIGZhY2VkIE9oaW8gU3RhdGUsIHRoZSAjMSBzZWVkIGdvaW5nIGludG8gdGhlIHRvdXJuYW1lbnQgd2hvIGhhZCBhbHNvIGxvc3QgaW4gc2VtaXMgdG8gTWljaGlnYW4uIFBlcmhhcHMgc2hvd2luZyBhIGxpdHRsZSBiaXQgb2YgaW5leHBlcmllbmNlIGluIGEgcHJlc3N1cmUgZmlsbGVkIGdhbWUsIElsbGlub2lzIHdlbnQgZG93biBiaWcgZWFybHksIGdvaW5nIGRvd24gNS0wLCBob3dldmVyLCB0aGV5IG1vdW50ZWQgYSBmdXJpb3VzIGNvbWViYWNrIGFuZCBjYW1lIGNsb3NlIHRvIG5lZ2F0aW5nIHRoZSBlYXJseSBkZWZpY2l0LCBidXQgZXZlbnR1YWxseSBzdWNjdW1iZWQgMTUtMTIgYW5kIGVuZGluZyB0aGVpciBzZWFzb24gd2l0aG91dCBhIE5hdGlvbmFscyBiZXJ0aCBmb3IgdGhlIDNyZCB5ZWFyIGluIGEgcm93LiBJbGxpbm9pcyBmaW5pc2hlZCA0dGggYXQgUmVnaW9uYWxzLjwvcD4gICAgXG4gICAgICAgICAgICA8cD5CcmlhbiBLb3JiZXNtZXllciBhbmQgSm9lbCBLb2VobmVtYW4gYm90aCByZWNlaXZlZCBhbGwtcmVnaW9uIGhvbm9ycy4gSG93ZXZlciB1bmxpa2UgdGhlIHByZXZpb3VzIHllYXIsIHRoZXJlIHdlcmUgc2V2ZXJhbCBncmFkdWF0aW5nIHBsYXllcnMgbW9zdCBub3RhYmx5IEJyaWFuIEtvcmJlc21leWVyLCB3aG8gaGFkIGNhcHRhaW5lZCB0aGUgdGVhbSB0aGUgcHJldmlvdXMgMiB5ZWFycyBhbmQgd2FzIGEgbWFqb3IgcGxheWVyIG9uIG9mZmVuc2UuIEZpbmRpbmcgcGxheWVycyB0byBzdGVwIGludG8gdGhlIGhvbGVzIGxlZnQgYnkgdGhlIGdyYWR1YXRpbmcgcGxheWVycyB3YXMgYSBtYWpvciBxdWVzdGlvbiBnb2luZyBpbnRvIHRoZSBuZXh0IHllYXIuPC9wPiAgICBcbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA2LFxuICAgICAgICBpbWFnZVBhdGg6ICcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5BZnRlciBjb21pbmcgc28gY2xvc2UgdG8gYSBOYXRpb25hbHMgYmVydGggdGhlIHllYXIgYmVmb3JlLCAyMDA2IHdhcyBhIHJlYnVpbGRpbmcgeWVhciBmb3IgSWxsaW5vaXMuIEFmdGVyIGxvc2luZyBzZXZlcmFsIHN0YXJ0aW5nIHBsYXllcnMsIHRoZSBjYXB0YWlucywgQnJpYW4gS29yYmVzbWV5ZXIgYW5kIEpvZWwgS29laG5lbWFuIGFuZCBjb2FjaCBNYXR0IFN0dXBjYSwgZGVjaWRlZCB0byBmb2N1cyB0aGVpciBlbmVyZ2llcyBvbiByZWNydWl0aW5nIGFuZCByZXBsZW5pc2hpbmcgdGhlIHByb2dyYW0uIFRoaXMgbGVkIHRvIG9uZSBvZiB0aGUgZGVlcGVzdCBmcmVzaG1hbiBjbGFzc2VzIGluIHRoZSBwcm9ncmFtcyBoaXN0b3J5IGxhcmdlbHkgZHVlIHRvIHRoZSBlZmZvcnRzIG9mIEJyaWFuIEtvcmJlc21leWVyLiBJbiBvcmRlciB0byBmYWNpbGl0YXRlIHRoZSByZWJ1aWxkaW5nIHByb2Nlc3MsIHRoZSBsZWFkZXJzaGlwIGRlY2lkZWQgdG8gZ28gd2l0aCBhIHZlcnkgc21hbGwgQS10ZWFtIHJvc3RlciBvZiBsZXNzIHRoYW4gMjAgZ3V5cywgc28gdGhhdCBldmVyeW9uZSB3b3VsZCBiZSBhYmxlIHRvIHBsYXkgYm90aCBvbiB0aGUgQS10ZWFtIGFuZCBvbiB0aGUgQi10ZWFtLiBUaGUgQi10ZWFtIHdpdGggdGhlIHNlcnZpY2VzIG9mIGNvYWNoIE5pY2sgTWNEdWZmZWUgd2FzIGFibGUgdG8gbnVydHVyZSB0aGUgcGxheWVycyBhbmQgaGF2ZSB0aGVtIHJlYWR5IHRvIHRha2UgdGhlIG5leHQgc3RlcCBvbnRvIHRoZSBBLXRlYW0uIEl0IHdhcyBhIHNlYXNvbiB3aXRoIHZlcnkgZmV3IGJyaWdodCBzcG90cywgYXMgSWxsaW5vaXMgZGlkIG5vdCBtYWtlIHRoZSBTZWN0aW9uYWwgZmluYWwgZm9yIG9uZSBvZiB0aGUgZmV3IHRpbWVzIGluIG1vZGVybiBoaXN0b3J5LCBmaW5pc2hpbmcgNHRoIGF0IFNlY3Rpb25hbHMsIGFuZCBkaWQgbm90IGV2ZW4gbWFrZSBTdW5kYXkgb2YgUmVnaW9uYWxzLCBmaW5pc2hpbmcgdGllZCBmb3IgN3RoIGFmdGVyIGxvc2luZyBpbiBxdWFydGVyZmluYWxzIGFuZCBnZXR0aW5nIGVsaW1pbmF0ZWQgaW4gdGhlIGJhY2tkb29yIGJyYWNrZXQuIEhvd2V2ZXIsIHRoZXJlIHdlcmUgZW5jb3VyYWdpbmcgc2lnbnMgZm9yIGZ1dHVyZSB5ZWFycyB0byBjb21lLCBCcmlhbiBQaGVsYW4gd29uIGZyZXNobWFuIG9mIHRoZSB5ZWFyIGZvciB0aGUgR3JlYXQgTGFrZXMgUmVnaW9uIGFuZCB0aGVyZSB3ZXJlIHNldmVyYWwgdGFsZW50ZWQgcGxheWVycyB3YWl0aW5nIGluIHRoZSB3aW5ncywgcmVhZHkgdG8gbWFrZSB0aGVpciBtYXJrIG9uIHRoZSBwcm9ncmFtIGFuZCB0aGUgc2FtZSBjb3JlIG9mIHBsYXllcnMgcmV0dXJuaW5nLjwvcD4gICAgXG4gICAgICAgIGBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNSxcbiAgICAgICAgaW1hZ2VQYXRoOiAnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+SWxsaW5vaXMgYWR2YW5jZWQgdG8gdGhlIGZpbmFscyBhdCBSZWdpb25hbHMgYW5kIGxvc3QgdG8gTWljaGlnYW4gb24gZG91YmxlIGdhbWUgcG9pbnQsIGFuZCBoYWQgdG8gaW1tZWRpYXRlbHkgcGxheSBNaWNoaWdhbiBTdGF0ZSBmb3Igc2Vjb25kIHBsYWNlIGFuZCB0aGUgY2hhbmNlIHRvIHJldHVybiB0byBuYXRpb25hbHMuIENvbWluZyBvdXQgZmxhdCBhZnRlciB0aGUgbG9zcyB0byBNaWNoaWdhbiBJbGxpbm9pcyB3ZW50IGRvd24gMy0wLiBCYXR0bGVkIGJhY2sgdG8gZG91YmxlIGdhbWUgcG9pbnQgYnV0IGFnYWluIGxvc3QgYW5kIHdlcmUgZWxpbWluYXRlZC48L3A+XG4gICAgICAgIGBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNCxcbiAgICAgICAgaW1hZ2VQYXRoOiAnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+SWxsaW5vaXMgZmluaXNoZWQgc2Vjb25kIGF0IFJlZ2lvbmFscyBhbmQgYWR2YW5jZWQgdG8gTmF0aW9uYWxzIGluIFNlYXR0bGUsIFdhc2hpbmd0b24uIElsbGlub2lzIGxvc3QgYSBjbG9zZSBnYW1lIHRvIE5vcnRoIENhcm9saW5hIFN0YXRlIGluIFByZXF1YXJ0ZXJzIGFuZCBmaW5pc2hlZCA5dGguPC9wPlxuICAgICAgICBgXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDMsXG4gICAgICAgIGltYWdlUGF0aDogJycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPklsbGlub2lzIHN0YXJ0ZWQgYmVpbmcgaW52aXRlZCB0byB0aGUgbWFqb3IgdG91cm5hbWVudHMsIGluY2x1ZGluZyBpdHMgZmlyc3QgaW52aXRlIHRvIEVhc3Rlcm5zLiBUaGlzIGhlbHBlZCBwcmVwYXJlIHRoZSB0ZWFtIGZvciB0aGUgc2Vhc29uLiBTZWVkZWQgZmlyc3QgYXQgUmVnaW9uYWxzLCBJbGxpbm9pcyBsb3N0IGluIHRoZSBmaW5hbHMgdG8gT2hpbyBTdGF0ZSBhbmQgYWR2YW5jZWQgdG8gTmF0aW9uYWxzIGluIEF1c3RpbiwgVFguIEFmdGVyIGJlYXRpbmcgTWljaGlnYW4gYW5kIEdlb3JnaWEgZmFpcmx5IGhhbmRpbHkgaW4gdGhlIGZpcnN0IHR3byBnYW1lcywgSWxsaW5vaXMgYmVhdCBOb3J0aCBDYXJvbGluYSBTdGF0ZSAxNy0xNSB0byB3aW4gdGhlIHBvb2wuIEluIHF1YXJ0ZXJzIElsbGlub2lzIG1hdGNoZWQgdXAgd2l0aCBDb2xvcmFkby5UaGV5IHdlcmUgMyBmZWV0IGF3YXkgZnJvbSBiZWluZyB1cCAxNC0xMywgcHVsbGluZyBkb3dud2luZCwgYnV0IHZpY3RvcnkgZWx1ZGVkIHRoZW0sIGFuZCBlbmRlZCB1cCBmaW5pc2hpbmcgdGllZCBmb3IgNXRoLjwvcD5cbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDAyLFxuICAgICAgICBpbWFnZVBhdGg6ICcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5UaGUgcHJvZ3JhbSBtYWRlIGEgYmlnIGp1bXAgZm9yd2FyZCB1bmRlciB0aGUgY29hY2hpbmcgb2YgSm9lIEZlcnJhcmkuIFRoZSB0ZWFtIGFkdmFuY2VkIHRvIHRoZSBSZWdpb25hbCBGaW5hbCBmb3IgdGhlIGZpcnN0IHRpbWUgZXZlciwgdGhlIEZpbmFsIHdhcyBhZ2FpbnN0IE1pY2hpZ2FuLiBUaGVyZSB3YXMgYSBjb25zaXN0ZW50IHdpbmQgb2YgMjUtMzUgbXBoIHdpdGggZ3VzdHMgb2Ygb3ZlciA0MC4gRm9yIGEgbG90IG9mIHRoZSBnYW1lIGl0IHdhcyB1cHdpbmQvZG93bndpbmQgd2l0aCB0aGUgaHVjayBhbmQgem9uZSBzdHJhdGVneSBiZWluZyBlbXBsb3llZC4gVGhlbiBlYXJseSBpbiB0aGUgc2Vjb25kIGhhbGYgd2UgZ290IGEgYmlnIGJyZWFrIG9mZiBhbmQgd2VyZSBhYmxlIHRvIHdvcmsgdGhlIGRpc2MgdXAgdGhlIGJhY2toYW5kIHNpZGVsaW5lIGFsbCB0aGUgd2F5IHRvIHRoZSBlbmR6b25lIGZvciBhIHNjb3JlIHRvIHRha2UgdGhlIGxlYWQuIEZyb20gdGhlcmUgd2UgbWFpbnRhaW5lZCBvdXIgbGVhZCB1cCB0byAxMy0xMi4gTWljaGlnYW4gd29ya2VkIHRoZSBkaXNjIHVwd2luZCBhbmQgY2FsbGVkIGEgdGltZW91dCA1IHlhcmRzIG91dCBvZiB0aGUgZW5kem9uZSBvbiB0aGUgZm9yZWhhbmQgc2lkZS4gT3V0IG9mIHRoZSB0aW1lb3V0IHRoZXkgaGFkIGEgbWFuIGJyZWFrIG9wZW4gb24gdGhlIGZvcmNlIHNpZGUuIEFsdmluIFdhbmcgd2FzIGFibGUgdG8gcnVuIHBhc3QgZm9yIHRoZSBnYW1lIHNhdmluZyBkLiBXZSB3ZXJlIGFibGUgdG8gc2NvcmUgdGhhdCBwb2ludCBhbmQgdGhlIG5leHQgZG93bndpbmRlciBpbiB0aGUgYmFjayBjb3JuZXIgb2YgdGhlIGVuZHpvbmUgdG8gYWR2YW5jZSB0byBvdXIgZmlyc3QgTmF0aW9uYWxzLiBJbGxpbm9pcycgZmlyc3QgTmF0aW9uYWxzIHRvdXJuYW1lbnQgd2FzIGluIFNwb2thbmUsIFdBLiBXZSBsb3N0IG1hbnkgY2xvc2UgZ2FtZXMgZWFybHkgdG8gQ29sb3JhZG8gYW5kIENhcmxldG9uLiBXZSBiZWF0IENvbG9yYWRvIGxhdGVyIGluIHRoZSB0b3VybmFtZW50IGFuZCBmaW5pc2hlZCA5dGguPC9wPlxuICAgICAgICBgXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDEsXG4gICAgICAgIGltYWdlUGF0aDogJycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPkJpbGwgRmlubiBhbmQgTmljayBNY0R1ZmZlZSBqb2luZWQgdGhlIHRlYW0gdGhpcyB5ZWFyLCBhbmQgdGhlIHRlYW0gd2FzIHRoZSBzdHJvbmdlc3QgaXQgaGFkIGV2ZXIgYmVlbiB3aXRoIHRoZXNlIHR3byBvdXRzdGFuZGluZyByb29raWVzLiBNYW55IG9mIHRoZSBvbGRlciByZXR1cm5lcnMgbm93IGhhZCAzLTQgeWVhcnMgb2YgY29tcGV0aXRpdmUgdWx0aW1hdGUgdW5kZXIgdGhlaXIgYmVsdHMsIGFuZCB0aGUgdGVhbSB3YXMgb24gdGhlIHZlcmdlIG9mIGJyZWFraW5nIHRocm91Z2guIEEgU2VjdGlvbmFsIGZpbmFsIHdpbiBvdmVyIEluZGlhbmEgc2V0IHVwIElsbGlub2lzIGFzIHRoZSAzcmQgc2VlZCBhdCBSZWdpb25hbHMgYmVoaW5kIE1pY2hpZ2FuIGFuZCBPU1UgKHJlZ2lvbmFsIGhvc3RzKS4gQWZ0ZXIgYmVhdGluZyBhIHRvdWdoIE5EIHRlYW0gaW4gcXVhcnRlcmZpbmFscywgSWxsaW5vaXMgZmFjZWQgTWljaGlnYW4gaW4gdGhlIHNlbWlmaW5hbHMuIERlc3BpdGUgYmVpbmcgdXAgYnkgYSBmZXcgZ29hbHMgYXQgaGFsZi10aW1lLCBNaWNoaWdhbidzIE5hdGlvbmFscyBleHBlcmllbmNlIHNob3dlZCBhbmQgdGhleSBlbmRlZCB1cCB3aW5uaW5nIGEgY2xvc2VseSBmb3VnaHQgZ2FtZS4gU3VuZGF5IG1vcm5pbmcsIElsbGlub2lzIGxvc3QgdG8gT2JlcmxpbiwgbWFraW5nIGl0IHRocmVlIHN0cmFpZ2h0IHllYXJzIG9mIHNlbWlmaW5hbCBsb3NzZXMgYXQgUmVnaW9uYWxzLjwvcD5cbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDAwLFxuICAgICAgICBpbWFnZVBhdGg6ICcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5JbGxpbm9pcyBjaGFuZ2VkIGl0cyBuYW1lIHRvIEZJU1QgYW5kIGhhZCBhbm90aGVyIGdvb2QgcmVjcnVpdGluZyBjbGFzcyB3aXRoIHRoZSBsaWtlcyBvZiBHcmVnIFNldmVyaW4sIENocmlzIEhhZ2VuLCBOZWxzIE92ZXJnYWFyZC1Db29rLCBLeWxlIEVlcnRtb2VkLCBCcmlhbiBGaWZhcmVrLCBhbmQgRGF2ZSBEcmFlZ2VyLiBJbGxpbm9pcyB3ZW50IHRvIHRoZSBTdGFuZm9yZCBJbnZpdGUgZm9yIHRoZSBmaXJzdCB0aW1lLiBSZWdpb25hbHMgd2FzIGF0IFB1cmR1ZSBVbml2ZXJzaXR5IHRoYXQgeWVhciwgYW5kIElsbGlub2lzIGxvc3QgdG8gRGF5dG9uIGluIHNlbWlmaW5hbHMsIGJlYXQgT2JlcmxpbiBTdW5kYXkgbW9ybmluZywgYW5kIHRoZW4gbG9zdCBhbiBlbGltaW5hdGlvbiBnYW1lIHRvIE5vdHJlIERhbWUuPC9wPlxuICAgICAgICBgXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDE5OTksXG4gICAgICAgIGltYWdlUGF0aDogJycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPjE5OTkgc2F3IGFub3RoZXIgc3VyZ2UgaW4gdGhlIHRlYW0ncyBkZXZlbG9wbWVudC4gTW9yZSByZWNydWl0cyBsaWtlIEFsdmluIFdhbmcsIEpvaG4gS29sdHNlLCBhbmQgS2V2aW4gUGF0dGVyc29uIGpvaW5lZCB0aGUgdGVhbS4gVGhlIENvbGxlZ2UgUmVnaW9ucyB3ZXJlIHJlZHJhd24gd2hpY2ggbWVhbnQgdGhhdCBJbGxpbm9pcyBoYWQgYSByZWFsIG9wcG9ydHVuaXR5IHRvIHF1YWxpZnkgZm9yIG5hdGlvbmFscyBpbiB0aGUgbmV3bHkgZm9ybWVkIEdyZWF0IExha2VzIFJlZ2lvbi4gSXQgd2FzIGEgZ3JlYXQgeWVhciBmb3IgdGhlIHRlYW0sIHdoaWNoIHJhY2tlZCB1cCBtYW55IHdpbnMsIGluY2x1ZGluZyB3aW5zIGF0IEZyb3plbiBPdmVyIGluIEJsb29taW5ndG9uLCBJTiBhbmQgdGhlIGZpcnN0IFNlY3Rpb25hbCBDaGFtcGlvbnNoaXAgZm9yIHRoZSB0ZWFtLiBDb21pbmcgaW50byBSZWdpb25hbHMsIElsbGlub2lzIHdhcyBzZWVkZWQgc2Vjb25kIGFuZCBob3N0ZWQgdGhlIHRvdXJuYW1lbnQuIFRoZSB0ZWFtIGxvc3QgYSBoZWFydGJyZWFrZXIgaW4gc2VtaWZpbmFscyB0byBPYmVybGluIENvbGxlZ2UsIGFuZCB0aGVuIGxvc3QgYW4gZWxpbWluYXRpb24gZ2FtZSBvbiBTdW5kYXkgbW9ybmluZyB0byBOb3RyZSBEYW1lLjwvcD5cbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAxOTk4LFxuICAgICAgICBpbWFnZVBhdGg6ICcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5XYXMgYSB0cmFuc2Zvcm1hdGlvbmFsIHllYXIgZm9yIHRoZSBwcm9ncmFtLCBhcyBhIGdyZWF0IGNsYXNzIG9mIHJvb2tpZXMgam9pbmVkIElsbGlub2lzLiBKYXJyZXR0IEJpYWxlaywgWGlhIFhpLCBBbmR5IFppbGwsIEt5bGUgUm9tYmVyZywgYW5kIEphY29iIERlZSB3ZXJlIGFtb25nIHRoZSBuZXcgcGxheWVycyB3aG8gaGVscGVkIHB1c2ggdGhlIHRlYW0gdG8gdG93YXJkcyBiZWNvbWluZyBhIG1vcmUgbGVnaXRpbWF0ZSBwcm9ncmFtLiBUaGUgdGVhbSBjaGFuZ2VkIHRoZWlyIG5hbWUgdG8gJ01lbiBGcm9tIE1hcnMnLCBnb3QgdW5pZm9ybXMsIGRlc2lnbmVkIG5ldyBkaXNjcywgYW5kIGFjdHVhbGx5IHN0YXJ0ZWQgcHJhY3RpY2luZyBhIHJlYWwgb2ZmZW5zaXZlIHNjaGVtZSBhbmQgc3BlbnQgbW9yZSB0aW1lIHdvcmtpbmcgb3V0IG9mZiB0aGUgZmllbGQuIElsbGlub2lzIHNldCB0aGUgZ29hbCBvZiBxdWFsaWZ5aW5nIGZvciBSZWdpb25hbHMsIGFuZCBhdCB0aGF0IHRpbWUgdGhlIENlbnRyYWwgUmVnaW9uIGluY2x1ZGVkIGV2ZXJ5IHN0YXRlIGZyb20gTWlubmVzb3RhIHRvIElsbGlub2lzIHRvIENvbG9yYWRvLiBBIDR0aCBwbGFjZSBmaW5pc2ggYXQgc2VjdGlvbmFscyBwcm9wZWxsZWQgdGhlbSB0byB0aGVpciBmaXJzdCBSZWdpb25hbHMgYmlydGggaW4gbWFueSB5ZWFycy4gQXQgUmVnaW9uYWxzIGluIE1pY2hpZ2FuLCBJbGxpbm9pcyBwbGF5ZWQgR3Jpbm5lbGwgYW5kIENvbG9yYWRvIFN0YXRlIHBvb2wgcGxheSwgYnV0IHdlcmUgZWxpbWluYXRlZCBmcm9tIGNvbXBldGl0aW9uIG9uIFNhdHVyZGF5LjwvcD5cbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAxOTk3LFxuICAgICAgICBpbWFnZVBhdGg6ICcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5Ub20gQ29mZmluIGFrYSBJcm9uIE1hbiwgYW4gb2xkZXIgcGxheWVyIGRlc2VydmVzIGNyZWRpdCBmb3Igb3JnYW5pemluZyB0aGUgcHJvZ3JhbSBhbmQgcmVjcnVpdGluZyBlZmZvcnRzLiBIZSBtb3ZlZCB0byBDaGFtcGFpZ24gaW4gdGhlIGZhbGwgb2YgMTk5NiBhbmQgcmVhbGx5IGhlbHBlZCBsZWFkIHRoZSBwcm9ncmFtIGluIHRoZSByaWdodCBkaXJlY3Rpb24gYWxvbmcgd2l0aCBwbGF5ZXJzIGxpa2UgSm9lIEZlcnJhcmkgYW5kIFJ5YW4gRmVocmVuYmFjaGVyIGFuZCBvdGhlcnMuIEluIHRoZSBmYWxsIG9mIDE5OTYsIHRoZSB0ZWFtIHdhcyBtb3N0bHkgZmlsbGVkIHdpdGggZ3JhZHVhdGUgc3R1ZGVudHMgYW5kIG9sZGVyIHBsYXllcnMsIGFuZCBoYWQgYSAnc2VyaW91cycgcGljay11cCB2aWJlIHdoZXJlIHByYWN0aWNlcyB3ZXJlIG1vc3RseSBzY3JpbW1hZ2VzIHdpdGggc29tZSBvY2Nhc2lvbmFsIGRyaWxscy4gVW5kZXIgQ2FwdGFpbiBUZWQgV2lucm93LCAnQmlnIFJlZCBVbHRpbWF0ZScgc3RydWdnbGVkIHRvIHdpbiBtYW55IGdhbWVzLCBidXQgdHJhdmVsZWQgdG8gdG91cm5hbWVudHMgaW4gQmF0b24gUm91Z2UsIExBLCBDYXJib25kYWxlLCBJTCwgTWFkaXNvbiwgV0ksIGFtb25nc3QgYSBmZXcgb3RoZXJzLiBLZXkgcGxheWVycyBpbmNsdWRlZCBKb2huIENvbm91ciwgTGVvIFdhbmcsIEpvbiBSYXNtdXNzZW4sIGFuZCBEYXZpZCBGaXNrZS4gSm9lIEZlcnJhcmkgYW5kIE1hdHQgVGF5bG9yIHdlcmUgdGhlIG9ubHkgZnJlc2htZW4sIHdobyBzaG93ZWQgdXAgY29uc2lzdGVudGx5LCBhbmQgdGhlIHllYXIgZW5kZWQgd2l0aCBhIGxvdyBmaW5pc2ggYXQgU2VjdGlvbmFscyBhbmQgSWxsaW5vaXMgZGlkIG5vdCBxdWFsaWZ5IGZvciBSZWdpb25hbHMgdGhhdCB5ZWFyLiBCUlUgLSB0aGUgb3JpZ2luIG9mIHRoaXMgbmFtZSBjb21lcyBmcm9tIHRoZSBwcmFjdGljZSBvbiB0aGUgdGVhbSB3aGVyZSBpZiB5b3UgZ290IGhhbmRibG9ja2VkIHlvdSBoYWQgdG8gY2h1ZyBhIGJvdHRsZSBvZiBCaWcgUmVkIFNvZGEsIHdoaWNoIGhhZCBzb21lIHNpZ25pZmljYW5jZS48L3A+XG4gICAgICAgIGBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMTk5NixcbiAgICAgICAgaW1hZ2VQYXRoOiAnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+SWxsaW5vaXMgYWdhaW4gaG9zdGVkIFNlY3Rpb25hbHMgYW5kIHF1YWxpZmllZCBmb3IgUmVnaW9uYWxzLCBmaW5pc2hpbmcgM3JkIGJlaGluZCBOb3RyZSBEYW1lIGFuZCBJbmRpYW5hLiBPdXIgdGVhbSBieSB0aGlzIHBvaW50IHdhcyBtb3JlIHRoYW4gaGFsZiB1bmRlcmdyYWR1YXRlczsgdGhlcmUgd2VyZSBhdCBtb3N0IDE0IGF0IFJlZ2lvbmFscy4gVGhlIHRlYW0gd2FzIHJ1biBhdCB0aGlzIHRpbWUgYnkgVGVkIFdpbnJvdy4gVGVkIGFuZCBHYXJ5IExlZG9ubmUgd2VyZSBiYXNpY2FsbHkgdGhlIGVudGlyZSB0ZWFtLiBCaWxsIEJyYW5zb24gd2FzIHN0aWxsIHBsYXlpbmcsIEpvaG4gQ29ubm91ciB3YXMgaW4gaGlzIGZpcnN0IHllYXIsIExlbyBXYW5nIHdhcyBpbiBoaXMgZmlyc3QgeWVhciBhbFNvcGhvbW9yZSBHYXJ5IExlZG9ubmUgaGFkIHRvIGNvbnZpbmNlIHBsYXllcnMgdG8gYXR0ZW5kIFJlZ2lvbmFscyBpbiBXZXN0IExhZmF5ZXR0ZS4gSWxsaW5vaXMgd2VudCAwLTMgaW4gcG9vbCBwbGF5IGxvc2luZyByZWxhdGl2ZWx5IGNsb3NlIGdhbWVzIHRvIENvbG9yYWRvIGFuZCBPYmVybGluLjwvcD5cbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAxOTk1LFxuICAgICAgICBpbWFnZVBhdGg6ICcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5BZnRlciBsb3NpbmcgMiBvZiBvdXIgdG9wIGdyYWQgc3R1ZGVudHMgSWxsaW5vaXMgbG9zdCBpbiB0aGUgZ2FtZSB0byBnbyB0byBSZWdpb25hbHMgdG8gQmFsbCBTdGF0ZS48L3A+XG4gICAgICAgIGBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMTk5NCxcbiAgICAgICAgaW1hZ2VQYXRoOiAnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+SW4gRmVicnVhcnkgb2YgMTk5NCwgSWxsaW5vaXMgaGFkIHdpbnRlciBwcmFjdGljZXMgaW4gdGhlIEFybW9yeSBhbmQgdGhlIEJ1YmJsZS4gVGhlIFVuaXZlcnNpdHkgd291bGQgZ2l2ZSB1cyAxLjUgaG91cnMgYSB3ZWVrIFN1bmRheSBuaWdodCAxMDozMCB0byBNaWRuaWdodCwgd2Ugc3BsaXQgdXNlIHdpdGggdGhlIHdvbWVuJ3MgdGVhbS4gVGhlIG1ha2V1cCBvZiB0aGUgdGVhbSB3YXMgbXVjaCBkaWZmZXJlbnQsIHRoZXJlIHdlcmUgaGFkIDE3IHBsYXllcnMgYXQgU2VjdGlvbmFscyA0IHdlcmUgdW5kZXJncmFkcy4gQWxtb3N0IGFsbCBncmFkIHN0dWRlbnRzIGFuZCBtb3N0IHdlcmUgaW4gdGhlaXIgbGF0ZSAyMCdzLiBUaGVyZSB3YXMgbGl0dGxlIHRvIG5vIHJlY3J1aXRpbmcgZWZmb3J0LiBQcmFjdGljZSBnZW5lcmFsbHkgY29uc2lzdGVkIG9mIHNvbWUgYmFkIGRyaWxscywgYnV0IHRoZXkgd2VyZSBkcmlsbHMgZGVzaWduZWQgdG8gbGVhcm4gaG93IHRvIHRocm93IGluIG1vc3QgY2FzZXMsIHRoZW4gd2Ugc2NyaW1tYWdlZC4gT3VyIGxldmVsIG9mIGF0aGxldGljaXNtIHdhcyBhd2Z1bCBjb21wYXJlZCB0byB0b2RheSdzIGdhbWUsIGJ1dCBvdXIgb2xkZXIgdGVhbSB3YXMgcHJldHR5IHN0cm9uZyB0aHJvd2luZywgYXQgbGVhc3QgZm9yIGEgY29sbGVnZSB0ZWFtIGF0IHRoYXQgdGltZS4gV2luZCB3YXMgb3VyIGZyaWVuZCBhcyBpdCBhbGxvd2VkIHVzIHRvIHJ1biBhIHpvbmUuIEluIGFueSBjYXNlIHRoZSB0ZWFtIHdhcyBmYWlybHkgc29saWQuIFRvbnkgQ3VydGlzLCBNaWtlIFBlcmN5LCBhbmQgQmlsbCBCcmFuc29uIHdlcmUgc29tZSBvZiB0aGUgc3Ryb25nIGdyYWQgc3R1ZGVudCB0aHJvd2Vycy4gTWlrZSBGcml0eiBhbiBvbGQgdW5kZXJncmFkIGF0IDIzLCBUZWQgV2lucm93IGFuZCBHYXJ5IExlZG9ubmUgYm90aCBzb3Bob21vcmVzIHdlcmUgdGhlIGNvbnRyaWJ1dGluZyB1bmRlcmdyYWRzLiBUaGUgdGVhbSBob3N0ZWQgU2VjdGlvbmFscyBhbmQgdG9vayAybmQgdG8gUHVyZHVlLCBvdXIgYmlnIHdpbiB3YXMgYmVhdGluZyBJbmRpYW5hIHdobyBoYWQgYmVlbiB0aGUgc3RyZW5ndGggb2YgdGhlIFNlY3Rpb24uIFJlZ2lvbmFscyB3YXMgaW4gR3Jpbm5lbGwsIElvd2EuIEl0IHdhcyB0aGUgZmlyc3QgeWVhciB0aGV5IGhhZCBtb3ZlZCBDb2xvcmFkbyBpbnRvIG91ciBSZWdpb24gYXMgdGhleSBoYWQgbG9iYmllZCBmb3IgYW4gZWFzaWVyIFJlZ2lvbi4gQXQgUmVnaW9uYWxzIElsbGlub2lzIHdlbnQgMy0xIGluIHBvb2wgcGxheSwgbG9zaW5nIHRvIFB1cmR1ZSwgYmVhdGluZyBDb2xvcmFkbywgTWFjYWxlc3RlciwgYW5kIEdyaW5uZWxsLiBJbiBwcmUtcXVhcnRlcnMgd2UgYmVhdCBEYXl0b24gbWFraW5nIHRoZSB0b3AgOCBkb3VibGUgZWxpbWluYXRpb24gZm9yIDMgc3BvdHMuIExvc3QgdG8gQ2FybGV0b24gYW5kIE9iZXJsaW4gYW5kIHRoYXQgd2FzIGl0LjwvcD5cbiAgICAgICAgYFxuICAgIH1cbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvZGF0YS9oaXN0b3J5LXllYXIuZGF0YS50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+VGVhbSBIaXN0b3J5PC9oMT5cXG48ZGl2IGNsYXNzPVxcXCJ1aSBzZWNvbmRhcnkgcG9pbnRpbmcgbWVudVxcXCI+XFxuICAgIDxkaXYgIzE5OTRkcm9wZG93biBjbGFzcz1cXFwidWkgZHJvcGRvd24gaXRlbVxcXCI+XFxuICAgICAgICAxOTk0LTE5OTk8aSBjbGFzcz1cXFwiZHJvcGRvd24gaWNvblxcXCI+PC9pPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVudVxcXCI+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8xOTk0XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4xOTk0PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8xOTk1XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4xOTk1PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8xOTk2XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4xOTk2PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8xOTk3XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4xOTk3PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8xOTk4XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4xOTk4PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8xOTk5XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4xOTk5PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgIzIwMDBkcm9wZG93biBjbGFzcz1cXFwidWkgZHJvcGRvd24gaXRlbVxcXCI+XFxuICAgICAgICAyMDAwLTIwMDk8aSBjbGFzcz1cXFwiZHJvcGRvd24gaWNvblxcXCI+PC9pPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVudVxcXCI+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDAxXFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDAxPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDAyXFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDAyPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDAzXFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDAzPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDA0XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDA0PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDA1XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDA1PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDA2XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDA2PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDA3XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDA3PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDA4XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDA4PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDA5XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDA5PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgIzIwMTBkcm9wZG93biBjbGFzcz1cXFwidWkgZHJvcGRvd24gaXRlbVxcXCI+XFxuICAgICAgICAyMDEwLTIwMTc8aSBjbGFzcz1cXFwiZHJvcGRvd24gaWNvblxcXCI+PC9pPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVudVxcXCI+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDEwXFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDEwPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDExXFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDExPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDEyXFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDEyPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDEzXFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDEzPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDE0XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDE0PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDE1XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDE1PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDE2XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDE2PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDE3XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj4yMDE3PC9kaXY+XFxuXFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuPGgyIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPnt7eWVhcn19PC9oMj5cXG48bmctY29udGFpbmVyICpuZ0Zvcj1cXFwibGV0IGhpc3RvcnlZZWFyIG9mIGhpc3RvcnlEYXRhXFxcIj5cXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cXFwiaGlzdG9yeVllYXIueWVhciA9PT0geWVhclxcXCI+XFxuICAgICAgICA8aW1nICpuZ0lmPVxcXCJoaXN0b3J5WWVhci5pbWFnZVBhdGhcXFwiIHNyYz1cXFwie3toaXN0b3J5WWVhci5pbWFnZVBhdGh9fVxcXCIvPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic3VtbWFyeVxcXCIgW2lubmVySFRNTF09XFxcImhpc3RvcnlZZWFyLnN1bW1hcnlNYXJrdXBcXFwiPjwvZGl2PlxcbiAgICA8L25nLWNvbnRhaW5lcj5cXG48L25nLWNvbnRhaW5lcj5cXG48IS0tT25seSBzaG93IHRoZSBwcmV2aW91cyBhbmQgbmV4dCBidXR0b24gaWYgdGhleSBhcmUgd2l0aGluIHRoZSBib3VuZHMgb2Ygb3VyIGhpc3Rvcnkgc3VtbWFyaWVzLS0+XFxuPGEgKm5nSWY9XFxcInllYXIgPiAxOTk0XFxcIiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS97e3llYXIgLSAxfX1cXFwiPjxpIGNsYXNzPVxcXCJhbmdsZSBkb3VibGUgbGVmdCBpY29uXFxcIj48L2k+PC9hPlxcbjxhICpuZ0lmPVxcXCJ5ZWFyIDwgMjAxN1xcXCIgcm91dGVyTGluaz1cXFwiL2hpc3Rvcnkve3t5ZWFyICsgMX19XFxcIj48aSBjbGFzcz1cXFwiYW5nbGUgZG91YmxlIHJpZ2h0IGljb25cXFwiPjwvaT48L2E+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hpc3RvcnkvdGVhbS1oaXN0b3J5L3RlYW0taGlzdG9yeS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi90ZWFtLWhpc3RvcnkuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hpc3RvcnkvdGVhbS1oaXN0b3J5L3RlYW0taGlzdG9yeS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImltZ3t3aWR0aDo3NSU7Ym9yZGVyOjFweCBzb2xpZCAjMDAwMDRkO21hcmdpbi1ib3R0b206MTVweDtib3JkZXItcmFkaXVzOi4yODU3MTQyOWVtfWl7Zm9udC1zaXplOjJlbX1pLnJpZ2h0e2Zsb2F0OnJpZ2h0fWkubGVmdHtmbG9hdDpsZWZ0fS5zdW1tYXJ5e3RleHQtYWxpZ246bGVmdDttYXJnaW4tYm90dG9tOjIwcHh9LnVpLmRyb3Bkb3duLml0ZW17d2lkdGg6MTIxcHg7aGVpZ2h0OjQwcHh9LnVpLmRyb3Bkb3duLml0ZW0gLmFjdGl2ZSwudWkuZHJvcGRvd24uaXRlbTpmb2N1c3tib3JkZXI6MH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vcG9zdGNzcy1sb2FkZXIvbGliIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFXQVJEU19EQVRBIH0gZnJvbSAnLi9kYXRhL2F3YXJkcy5kYXRhJztcbmltcG9ydCB7IEF3YXJkIH0gZnJvbSAnLi9tb2RlbC9hd2FyZC5tb2RlbCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXdhcmRzJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9hd2FyZHMuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2F3YXJkcy5jb21wb25lbnQubGVzcycpXVxufSlcbmV4cG9ydCBjbGFzcyBBd2FyZHNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIC8vIEF3YXJkcyBkYXRhIHRvIGluamVjdCBpbnRvIG91ciB0ZW1wbGF0ZVxuICAgIHByaXZhdGUgYXdhcmREYXRhOiBBd2FyZFtdID0gQVdBUkRTX0RBVEE7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvYXdhcmRzLmNvbXBvbmVudC50cyIsImltcG9ydCB7IEF3YXJkIH0gZnJvbSAnLi4vbW9kZWwvYXdhcmQubW9kZWwnO1xuXG5leHBvcnQgY29uc3QgQVdBUkRTX0RBVEE6IEF3YXJkW10gPSBbXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE5LFxuICAgICAgICBuYW1lOiAnSm9leSBLZW5uZWR5JyxcbiAgICAgICAgYXdhcmQ6ICdBbGwtRnJlc2htYW4nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTgsXG4gICAgICAgIG5hbWU6ICdCZW4gU2Fib3VyaW4nLFxuICAgICAgICBhd2FyZDogJzJuZCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE4LFxuICAgICAgICBuYW1lOiAnUmVpZCBNYXJ0aW4nLFxuICAgICAgICBhd2FyZDogJ0FsbC1GcmVzaG1hbidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxOCxcbiAgICAgICAgbmFtZTogJ0FudGhvbnkgUnV6em8nLFxuICAgICAgICBhd2FyZDogJ0FsbC1GcmVzaG1hbidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNyxcbiAgICAgICAgbmFtZTogJ0RyYWtlIEhpbGwnLFxuICAgICAgICBhd2FyZDogJ0FsbC1GcmVzaG1hbidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNixcbiAgICAgICAgbmFtZTogJ05pY2sgUHJvem9yb3Zza3knLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE2LFxuICAgICAgICBuYW1lOiAnSm9obm55IFNhbmlhdCcsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIG5hbWU6ICdQcmF5YWcgUGF0ZWwnLFxuICAgICAgICBhd2FyZDogJzJuZCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE2LFxuICAgICAgICBuYW1lOiAnQmVuIFNhYm91cmluJyxcbiAgICAgICAgYXdhcmQ6ICdBbGwtRnJlc2htYW4vRk9UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNixcbiAgICAgICAgbmFtZTogJ0phY29iIEN1dGhiZXJ0JyxcbiAgICAgICAgYXdhcmQ6ICdBbGwtRnJlc2htYW4nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTUsXG4gICAgICAgIG5hbWU6ICdNYXR0IFN0dXBjYScsXG4gICAgICAgIGF3YXJkOiAnQ09UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNSxcbiAgICAgICAgbmFtZTogJ05pY2sgUHJvem9yb3Zza3knLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE1LFxuICAgICAgICBuYW1lOiAnTWF0dCBXZXN0JyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNSxcbiAgICAgICAgbmFtZTogJ0tldmluIExpbicsXG4gICAgICAgIGF3YXJkOiAnQWxsLUZyZXNobWFuL0ZPVFknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTQsXG4gICAgICAgIG5hbWU6ICdOZWFsIFBoZWxwcycsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTQsXG4gICAgICAgIG5hbWU6ICdOaWNrIFByb3pvcm92c2t5JyxcbiAgICAgICAgYXdhcmQ6ICcybmQgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgbmFtZTogJ05hdGhhbiBHaWJib25zJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgbmFtZTogJ05lYWwgUGhlbHBzJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgbmFtZTogJ1J5YW4gU21pdGgnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtL1BPVFknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTMsXG4gICAgICAgIG5hbWU6ICdCcmFkIEJvbGxpbmdlcicsXG4gICAgICAgIGF3YXJkOiAnMm5kIFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTMsXG4gICAgICAgIG5hbWU6ICdOaWNrIFByb3pvcm92c2t5JyxcbiAgICAgICAgYXdhcmQ6ICdBbGwgRnJlc2htYW4nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTMsXG4gICAgICAgIG5hbWU6ICdKb2hubnkgU2FuaWF0JyxcbiAgICAgICAgYXdhcmQ6ICdBbGwgRnJlc2htYW4nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTMsXG4gICAgICAgIG5hbWU6ICdEZXJlayBZYW4nLFxuICAgICAgICBhd2FyZDogJ0FsbCBGcmVzaG1hbidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMixcbiAgICAgICAgbmFtZTogJ1J5YW4gU21pdGgnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEyLFxuICAgICAgICBuYW1lOiAnRGFuZSBKb3JnZW5zZW4nLFxuICAgICAgICBhd2FyZDogJzJuZCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDExLFxuICAgICAgICBuYW1lOiAnUnlhbiBTbWl0aCcsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTAsXG4gICAgICAgIG5hbWU6ICdXYWxkZW4gTmVsc29uJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMCxcbiAgICAgICAgbmFtZTogJ0JyaWFuIFBoZWxhbicsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTAsXG4gICAgICAgIG5hbWU6ICdSeWFuIFNtaXRoJyxcbiAgICAgICAgYXdhcmQ6ICcybmQgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwOSxcbiAgICAgICAgbmFtZTogJ01hdHQgU3R1cGNhJyxcbiAgICAgICAgYXdhcmQ6ICdDT1RZJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA5LFxuICAgICAgICBuYW1lOiAnRGVuaXMgQWduaWVsJyxcbiAgICAgICAgYXdhcmQ6ICcybmQgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwOSxcbiAgICAgICAgbmFtZTogJ1dhbGRlbiBOZWxzb24nLFxuICAgICAgICBhd2FyZDogJzJuZCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA5LFxuICAgICAgICBuYW1lOiAnUGF2YW4gU2FyZ3VydScsXG4gICAgICAgIGF3YXJkOiAnMm5kIFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDksXG4gICAgICAgIG5hbWU6ICdSeWFuIFNtaXRoJyxcbiAgICAgICAgYXdhcmQ6ICdGT1RZJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA4LFxuICAgICAgICBuYW1lOiAnSm9lbCBLb2VobmVtYW4nLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA4LFxuICAgICAgICBuYW1lOiAnUGF0IFN0ZXBoZW5zJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNyxcbiAgICAgICAgbmFtZTogJ0pvZWwgS29laG5lbWFuJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNyxcbiAgICAgICAgbmFtZTogJ0JyaWFuIEtvcmJlc21leWVyJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNixcbiAgICAgICAgbmFtZTogJ0JyaWFuIFBoZWxhbicsXG4gICAgICAgIGF3YXJkOiAnRk9UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNSxcbiAgICAgICAgbmFtZTogJ05pY2sgTWNEdWZmZWUnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA1LFxuICAgICAgICBuYW1lOiAnTWlrZSBDbGFyaycsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDUsXG4gICAgICAgIG5hbWU6ICdEYXZpZCBBYnJhbScsXG4gICAgICAgIGF3YXJkOiAnRk9UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNCxcbiAgICAgICAgbmFtZTogJ01hdHQgV2Vsc2gnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA0LFxuICAgICAgICBuYW1lOiAnTmljayBNY0R1ZmZlZScsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDQsXG4gICAgICAgIG5hbWU6ICdQYXQgU3RlcGhlbnMnLFxuICAgICAgICBhd2FyZDogJ0ZPVFknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDMsXG4gICAgICAgIG5hbWU6ICdOYXRlIEJvc3NjaGVyJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwMixcbiAgICAgICAgbmFtZTogJ1hpIFhpYScsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDIsXG4gICAgICAgIG5hbWU6ICdEYW5lIE9sc2VuJyxcbiAgICAgICAgYXdhcmQ6ICdGT1RZJ1xuICAgIH1cbl07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvZGF0YS9hd2FyZHMuZGF0YS50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+QXdhcmRzPC9oMT5cXG48dGFibGUgY2xhc3M9XFxcInVpIGNlbGxlZCB0YWJsZVxcXCI+XFxuICAgIDx0aGVhZD5cXG4gICAgICAgIDx0cj5cXG4gICAgICAgICAgICA8dGg+WWVhcjwvdGg+XFxuICAgICAgICAgICAgPHRoPk5hbWU8L3RoPlxcbiAgICAgICAgICAgIDx0aD5Bd2FyZDwvdGg+XFxuICAgICAgICA8L3RyPlxcbiAgICA8L3RoZWFkPlxcbiAgICA8dGJvZHk+XFxuICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgYXdhcmQgb2YgYXdhcmREYXRhXFxcIj5cXG4gICAgICAgICAgICA8dGQ+e3thd2FyZC55ZWFyfX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e2F3YXJkLm5hbWV9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7YXdhcmQuYXdhcmR9fTwvdGQ+XFxuICAgICAgICA8L3RyPlxcbiAgICA8L3Rib2R5PlxcbjwvdGFibGU+XFxuPHA+KkFsbC1GcmVzaG1hbiB0ZWFtIGFkZGVkIGluIDIwMTMsIEZPVFkgKEZyZXNobWFuIG9mIHRoZSBZZWFyKSBnaXZlbiB0byB0aGUgQWxsLUZyZXNobWFuIG1lbWJlciB3aXRoIHRoZSBtb3N0IDFzdCBwbGFjZSB2b3RlczwvcD5cXG48cD4qUGxheWVyIG9mIHRoZSB5ZWFyIGF3YXJkIGFkZGVkIGluIDIwMTMsIFBPVFkgKFBsYXllciBvZiB0aGUgWWVhcikgZ2l2ZW4gdG8gdGhlIEFsbC1SZWdpb24gbWVtYmVyIHdpdGggdGhlIG1vc3QgMXN0IHBsYWNlIHZvdGVzPC9wPlxcbjxwPipDT1RZIChDb2FjaCBvZiB0aGUgWWVhcikgYWRkZWQgaW4gMjAwOTwvcD5cXG48cD4qMm5kLVRlYW0gQWxsIFJlZ2lvbiBhZGRlZCBpbiAyMDA5PC9wPlxcbjxwPipBd2FyZHMgZmlyc3QgZ2l2ZW4gb3V0IGluIDIwMDI8L3A+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9hd2FyZHMuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcInB7dGV4dC1hbGlnbjpsZWZ0O3RleHQtaW5kZW50OjB9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyL2xpYiEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSRVNVTFRTX0RBVEEgfSBmcm9tICcuL2RhdGEvcmVzdWx0cy5kYXRhJztcbmltcG9ydCB7IFJlc3VsdCB9IGZyb20gJy4vbW9kZWwvcmVzdWx0Lm1vZGVsJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdyZXN1bHRzJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9yZXN1bHRzLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9yZXN1bHRzLmNvbXBvbmVudC5sZXNzJyldXG59KVxuZXhwb3J0IGNsYXNzIFJlc3VsdHNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIC8vIFJlc3VsdHMgZGF0YSB0byBpbmplY3QgaW50byBvdXIgdGVtcGxhdGVcbiAgICBwcml2YXRlIHJlc3VsdERhdGE6IFJlc3VsdFtdID0gUkVTVUxUU19EQVRBO1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvcmVzdWx0cy9yZXN1bHRzLmNvbXBvbmVudC50cyIsImltcG9ydCB7IFJlc3VsdCB9IGZyb20gJy4uL21vZGVsL3Jlc3VsdC5tb2RlbCc7XG5cbmV4cG9ydCBjb25zdCBSRVNVTFRTX0RBVEE6IFJlc3VsdFtdID0gW1xuICAgIHtcbiAgICAgICAgeWVhcjogMjAxOSxcbiAgICAgICAgc2VjdGlvbmFsczogJ1QtMm5kJyxcbiAgICAgICAgcmVnaW9uYWxzOiAnM3JkJyxcbiAgICAgICAgbmF0aW9uYWxzOiAnLScsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cHM6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy90ZWFtcy9ldmVudHMvRXZlbnR0ZWFtLz9UZWFtSWQ9d1pveWl3dkNnMVZoVUlXTmkxV0RhQlhzUjZrZE9CRW1USjZpeW5tdmxiYyUzZCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxOCxcbiAgICAgICAgc2VjdGlvbmFsczogJzJuZCcsXG4gICAgICAgIHJlZ2lvbmFsczogJ1QtNXRoJyxcbiAgICAgICAgbmF0aW9uYWxzOiAnLScsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cHM6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy90ZWFtcy9ldmVudHMvRXZlbnR0ZWFtLz9UZWFtSWQ9OEtkTVV5R2llVFRFJTJmNUkzb0dUYW1HR1dYNlNRMm1WSEhyV3RweSUyZmRKa2slM2QnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTcsXG4gICAgICAgIHNlY3Rpb25hbHM6ICcybmQnLFxuICAgICAgICByZWdpb25hbHM6ICc2dGgnLFxuICAgICAgICBuYXRpb25hbHM6ICctJyxcbiAgICAgICAgdGVhbVBhZ2VMYWJlbDogJ1VTQVUnLFxuICAgICAgICB0ZWFtUGFnZUxpbms6ICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL3RlYW1zLz9FdmVudFRlYW1JZD1USVV4WHJaNHBETmhOaTRNM1FBMUolMmI5RDhrQWROc3M4Tnk0SnlVVXVaaGclM2QnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIHNlY3Rpb25hbHM6ICczcmQnLFxuICAgICAgICByZWdpb25hbHM6ICczcmQnLFxuICAgICAgICBuYXRpb25hbHM6ICctJyxcbiAgICAgICAgdGVhbVBhZ2VMYWJlbDogJ1VTQVUnLFxuICAgICAgICB0ZWFtUGFnZUxpbms6ICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvdGVhbXMvZXZlbnRzL0V2ZW50dGVhbS8/VGVhbUlkPW5RenNDTzBmS2JVVUVGWmZLSiUyZk9Vb3RkJTJmMVBNNndvMzVIUGFYSkVNVUM4JTNkJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE1LFxuICAgICAgICBzZWN0aW9uYWxzOiAnMm5kJyxcbiAgICAgICAgcmVnaW9uYWxzOiAnMXN0JyxcbiAgICAgICAgbmF0aW9uYWxzOiAnMTN0aCcsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL3RlYW1zL2V2ZW50cy9FdmVudHRlYW0vP1RlYW1JZD1UJTJiVjZEMlh5TFRsa0xBJTJmWDJXcGFpUEduWXk2UzNEbiUyZm1jYmxmbzA4RE5vJTNkJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE0LFxuICAgICAgICBzZWN0aW9uYWxzOiAnMXN0JyxcbiAgICAgICAgcmVnaW9uYWxzOiAnNXRoJyxcbiAgICAgICAgbmF0aW9uYWxzOiAnLScsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL3RlYW1zL2V2ZW50cy9FdmVudHRlYW0vP1RlYW1JZD0xejhocnlnR1lhRHdKcWs4RiUyZm1QNGxPazlCRDMlMmZJJTJiS1czM0lIbzhxRjlFJTNkJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEzLFxuICAgICAgICBzZWN0aW9uYWxzOiAnMXN0JyxcbiAgICAgICAgcmVnaW9uYWxzOiAnMXN0JyxcbiAgICAgICAgbmF0aW9uYWxzOiAnMTd0aCcsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzLyNjb2xsZWdlLW9wZW4vdGVhbS8xNzk0J1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEyLFxuICAgICAgICBzZWN0aW9uYWxzOiAnMXN0JyxcbiAgICAgICAgcmVnaW9uYWxzOiAnM3JkJyxcbiAgICAgICAgbmF0aW9uYWxzOiAnLScsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzMjAxMi8jY29sbGVnZS1vcGVuL3RlYW0vMTc5NCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMSxcbiAgICAgICAgc2VjdGlvbmFsczogJzFzdCcsXG4gICAgICAgIHJlZ2lvbmFsczogJzFzdCcsXG4gICAgICAgIG5hdGlvbmFsczogJzE3dGgnLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3JlczIwMTEvI2NvbGxlZ2Utb3Blbi90ZWFtLzE3OTQnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTAsXG4gICAgICAgIHNlY3Rpb25hbHM6ICcxc3QnLFxuICAgICAgICByZWdpb25hbHM6ICcxc3QnLFxuICAgICAgICBuYXRpb25hbHM6ICcxN3RoJyxcbiAgICAgICAgdGVhbVBhZ2VMYWJlbDogJ1VTQVUnLFxuICAgICAgICB0ZWFtUGFnZUxpbms6ICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMyMDEwLyNjb2xsZWdlLW9wZW4vdGVhbS8xNzk0J1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA5LFxuICAgICAgICBzZWN0aW9uYWxzOiAnMm5kJyxcbiAgICAgICAgcmVnaW9uYWxzOiAnMXN0JyxcbiAgICAgICAgbmF0aW9uYWxzOiAnMTN0aCcsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3VsdGltYXRlLnNjb3JlcmVwb3J0Lm5ldC8yMDA5L3Njb3Jlcy5jZ2k/ZGl2PTE4JnBhZ2U9MyZ0ZWFtPTE3OTQnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDgsXG4gICAgICAgIHNlY3Rpb25hbHM6ICcxc3QnLFxuICAgICAgICByZWdpb25hbHM6ICcybmQnLFxuICAgICAgICBuYXRpb25hbHM6ICc1dGgnLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly91bHRpbWF0ZS5zY29yZXJlcG9ydC5uZXQvMjAwOC9zY29yZXMuY2dpP2Rpdj0xOCZwYWdlPTMmdGVhbT0xNzk0J1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA3LFxuICAgICAgICBzZWN0aW9uYWxzOiAnMnN0JyxcbiAgICAgICAgcmVnaW9uYWxzOiAnNHRoJyxcbiAgICAgICAgbmF0aW9uYWxzOiAnLScsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3VsdGltYXRlLnNjb3JlcmVwb3J0Lm5ldC8yMDA3L3Njb3Jlcy5jZ2k/ZGl2PTE4JnBhZ2U9MyZ0ZWFtPTE3OTQnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDYsXG4gICAgICAgIHNlY3Rpb25hbHM6ICczcmQnLFxuICAgICAgICByZWdpb25hbHM6ICc3dGgnLFxuICAgICAgICBuYXRpb25hbHM6ICctJyxcbiAgICAgICAgdGVhbVBhZ2VMYWJlbDogJ1VTQVUnLFxuICAgICAgICB0ZWFtUGFnZUxpbms6ICdodHRwOi8vdWx0aW1hdGUuc2NvcmVyZXBvcnQubmV0LzIwMDYvc2NvcmVzLmNnaT9kaXY9MTgmcGFnZT0zJnRlYW09MTc5NCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNSxcbiAgICAgICAgc2VjdGlvbmFsczogJzJzdCcsXG4gICAgICAgIHJlZ2lvbmFsczogJzNyZCcsXG4gICAgICAgIG5hdGlvbmFsczogJy0nLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly91bHRpbWF0ZS5zY29yZXJlcG9ydC5uZXQvMjAwNS9zY29yZXMuY2dpP2Rpdj0xOCZwYWdlPTMmdGVhbT0xNzk0J1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA0LFxuICAgICAgICBzZWN0aW9uYWxzOiAnMXN0JyxcbiAgICAgICAgcmVnaW9uYWxzOiAnMm5kJyxcbiAgICAgICAgbmF0aW9uYWxzOiAnMTd0aCcsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3VsdGltYXRlLnNjb3JlcmVwb3J0Lm5ldC8yMDA0L3Njb3Jlcy5jZ2k/ZGl2PTE4JnBhZ2U9MyZ0ZWFtPTE3OTQnXG4gICAgfVxuXTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9oaXN0b3J5L3Jlc3VsdHMvZGF0YS9yZXN1bHRzLmRhdGEudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGgxIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPlJlc3VsdHM8L2gxPlxcbjx0YWJsZSBjbGFzcz1cXFwidWkgY2VsbGVkIHRhYmxlXFxcIj5cXG4gICAgPHRoZWFkPlxcbiAgICA8dHI+XFxuICAgICAgICA8dGg+WWVhcjwvdGg+XFxuICAgICAgICA8dGg+U2VjdGlvbmFsczwvdGg+XFxuICAgICAgICA8dGg+UmVnaW9uYWxzPC90aD5cXG4gICAgICAgIDx0aD5OYXRpb25hbHM8L3RoPlxcbiAgICAgICAgPHRoPlRlYW0gUGFnZTwvdGg+XFxuICAgIDwvdHI+XFxuICAgIDwvdGhlYWQ+XFxuICAgIDx0Ym9keT5cXG4gICAgPHRyICpuZ0Zvcj1cXFwibGV0IHJlc3VsdCBvZiByZXN1bHREYXRhXFxcIj5cXG4gICAgICAgIDx0ZD57e3Jlc3VsdC55ZWFyfX08L3RkPlxcbiAgICAgICAgPHRkPnt7cmVzdWx0LnNlY3Rpb25hbHN9fTwvdGQ+XFxuICAgICAgICA8dGQ+e3tyZXN1bHQucmVnaW9uYWxzfX08L3RkPlxcbiAgICAgICAgPHRkPnt7cmVzdWx0Lm5hdGlvbmFsc319PC90ZD5cXG4gICAgICAgIDx0ZD48YSBjbGFzcz1cXFwidXNhdS1saW5rXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgaHJlZj1cXFwie3tyZXN1bHQudGVhbVBhZ2VMaW5rfX1cXFwiPnt7cmVzdWx0LnRlYW1QYWdlTGFiZWx9fTwvYT48L3RkPlxcbiAgICA8L3RyPlxcbiAgICA8L3Rib2R5PlxcbjwvdGFibGU+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hpc3RvcnkvcmVzdWx0cy9yZXN1bHRzLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL3Jlc3VsdHMuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hpc3RvcnkvcmVzdWx0cy9yZXN1bHRzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyL2xpYiEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvcmVzdWx0cy9yZXN1bHRzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IFJvdXRlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbmltcG9ydCB7IFRlYW1IaXN0b3J5Q29tcG9uZW50IH0gZnJvbSAnLi90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBBd2FyZHNDb21wb25lbnQgfSBmcm9tICcuL2F3YXJkcy9hd2FyZHMuY29tcG9uZW50JztcbmltcG9ydCB7IFJlc3VsdHNDb21wb25lbnQgfSBmcm9tICcuL3Jlc3VsdHMvcmVzdWx0cy5jb21wb25lbnQnO1xuaW1wb3J0IHsgUk9VVEVTIH0gZnJvbSAnLi4vYXBwLnJvdXRlcyc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW0Jyb3dzZXJNb2R1bGUsIFJvdXRlck1vZHVsZS5mb3JSb290KFJPVVRFUyldLFxuICAgIGRlY2xhcmF0aW9uczogW1RlYW1IaXN0b3J5Q29tcG9uZW50LCBBd2FyZHNDb21wb25lbnQsIFJlc3VsdHNDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIEhpc3RvcnlNb2R1bGUge31cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9oaXN0b3J5L2hpc3RvcnkubW9kdWxlLnRzIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbmltcG9ydCB7IE1lbnVEZXNrdG9wQ29tcG9uZW50IH0gZnJvbSAnLi9tZW51LWRlc2t0b3AvbWVudS1kZXNrdG9wLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNZW51TW9iaWxlQ29tcG9uZW50IH0gZnJvbSAnLi9tZW51LW1vYmlsZS9tZW51LW1vYmlsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgTGVmdFNpZGViYXJDb21wb25lbnQgfSBmcm9tICcuL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50JztcbmltcG9ydCB7IFJpZ2h0U2lkZWJhckNvbXBvbmVudCB9IGZyb20gJy4vcmlnaHQtc2lkZWJhci9yaWdodC1zaWRlYmFyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQYWdlRnJhbWVDb21wb25lbnQgfSBmcm9tICcuL3BhZ2UtZnJhbWUuY29tcG9uZW50JztcblxuaW1wb3J0IHsgUk9VVEVTIH0gZnJvbSAnLi4vYXBwLnJvdXRlcyc7XG5pbXBvcnQgeyBGb290ZXJDb21wb25lbnQgfSBmcm9tICcuL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbUm91dGVyTW9kdWxlLmZvclJvb3QoUk9VVEVTKV0sXG4gICAgZGVjbGFyYXRpb25zOiBbUGFnZUZyYW1lQ29tcG9uZW50LCBNZW51RGVza3RvcENvbXBvbmVudCwgTWVudU1vYmlsZUNvbXBvbmVudCwgTGVmdFNpZGViYXJDb21wb25lbnQsIFJpZ2h0U2lkZWJhckNvbXBvbmVudCwgRm9vdGVyQ29tcG9uZW50XSxcbiAgICBleHBvcnRzOiBbUGFnZUZyYW1lQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlRnJhbWVNb2R1bGUge31cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUubW9kdWxlLnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdtZW51LWRlc2t0b3AnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL21lbnUtZGVza3RvcC5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vbWVudS1kZXNrdG9wLmNvbXBvbmVudC5sZXNzJyldXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVEZXNrdG9wQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gICAgLy8gTWVudSBkcm9wZG93bnNcbiAgICBAVmlld0NoaWxkKCd0ZWFtRHJvcGRvd24nKVxuICAgIHByaXZhdGUgdGVhbURyb3Bkb3duOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ2hpc3RvcnlEcm9wZG93bicpXG4gICAgcHJpdmF0ZSBoaXN0b3J5RHJvcGRvd246IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIG91ciBtb2JpbGUgbWVudSBkcm9wZG93bi5cbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgICQodGhpcy50ZWFtRHJvcGRvd24ubmF0aXZlRWxlbWVudCkuZHJvcGRvd24oe30pO1xuICAgICAgICAkKHRoaXMuaGlzdG9yeURyb3Bkb3duLm5hdGl2ZUVsZW1lbnQpLmRyb3Bkb3duKHt9KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9tZW51LWRlc2t0b3AvbWVudS1kZXNrdG9wLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8IS0tSGVhZGVyLS0+XFxuPGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL2hvbWVcXFwiPjxpbWcgY2xhc3M9XFxcImNyZXN0XFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbWVudS9jcmVzdC5wbmdcIikgKyBcIlxcXCIvPjwvYT5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL2hvbWVcXFwiPjxoMSBjbGFzcz1cXFwiaGVhZGVyLXRleHRcXFwiPklsbGlub2lzIFVsdGltYXRlPC9oMT48L2E+XFxuPC9kaXY+XFxuPCEtLU1lbnUtLT5cXG48ZGl2IGNsYXNzPVxcXCJ1aSBwb2ludGluZyBzdGFja2FibGUgbWVudVxcXCI+XFxuICAgIDxhIHJvdXRlckxpbms9XFxcIi9ob21lXFxcIiAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtIGFjdGl2ZVxcXCI+PGkgY2xhc3M9XFxcImhvbWUgaWNvblxcXCI+PC9pPkhvbWU8L2E+XFxuICAgIDxhIHJvdXRlckxpbms9XFxcIi9hYm91dFxcXCIgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiaW5mbyBpY29uXFxcIj48L2k+QWJvdXQgVXM8L2E+XFxuICAgIDxhIHJvdXRlckxpbms9XFxcIi9wcm9zcGVjdHNcXFwiICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiY2hpbGQgaWNvblxcXCI+PC9pPlByb3NwZWN0aXZlIFBsYXllcnM8L2E+XFxuICAgIDxkaXYgI3RlYW1Ecm9wZG93biBjbGFzcz1cXFwidWkgZHJvcGRvd24gaXRlbVxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwidXNlciBpY29uXFxcIj48L2k+VGVhbTxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9wcmFjdGljZVxcXCIgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcInNvY2NlciBpY29uXFxcIj48L2k+UHJhY3RpY2U8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi90b3VybmFtZW50cy8yMDE5XFxcIiAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImNhbGVuZGFyIGljb25cXFwiPjwvaT5Ub3VybmFtZW50czwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgcm91dGVyTGluaz1cXFwiL3Jvc3Rlci8yMDE5XFxcIiAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwib3JkZXJlZCBsaXN0IGljb25cXFwiPjwvaT5Sb3N0ZXI8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9hYnNlbnRcXFwiICAgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcInJlbW92ZSBpY29uXFxcIj48L2k+QWJzZW50IEZvcm08L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiAjaGlzdG9yeURyb3Bkb3duIGNsYXNzPVxcXCJ1aSBkcm9wZG93biBpdGVtXFxcIj5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJmYXN0IGJhY2t3YXJkIGljb25cXFwiPjwvaT5IaXN0b3J5PGkgY2xhc3M9XFxcImRyb3Bkb3duIGljb25cXFwiPjwvaT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lbnVcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgcm91dGVyTGluaz1cXFwiL2hpc3RvcnkvMjAxN1xcXCIgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcInVuZG8gaWNvblxcXCI+PC9pPlRlYW0gSGlzdG9yeTwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgcm91dGVyTGluaz1cXFwiL2F3YXJkc1xcXCIgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcInRyb3BoeSBpY29uXFxcIj48L2k+QXdhcmRzPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvcmVzdWx0c1xcXCIgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiYXJjaGl2ZSBpY29uXFxcIj48L2k+UGFzdCBSZXN1bHRzPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxhIGhyZWY9XFxcImh0dHA6Ly93d3cuaWxsaW5pdWx0aS5ibG9nc3BvdC5jb20vXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJjb21tZW50IGljb25cXFwiPjwvaT5CbG9nPC9hPlxcbiAgICA8YSByb3V0ZXJMaW5rPVxcXCIvY29udGFjdFxcXCIgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcIm1haWwgaWNvblxcXCI+PC9pPkNvbnRhY3QgVXM8L2E+XFxuPC9kaXY+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1kZXNrdG9wL21lbnUtZGVza3RvcC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9jcmVzdC5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL21lbnUvY3Jlc3QucG5nXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL21lbnUtZGVza3RvcC5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9tZW51LWRlc2t0b3AvbWVudS1kZXNrdG9wLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmhlYWRlcnt3aWR0aDoxMDAlO2JhY2tncm91bmQtaW1hZ2U6dXJsKFwiICsgcmVxdWlyZShcIi4uLy4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbWVudS9oZWFkZXItYmFja2dyb3VuZC5qcGdcIikgKyBcIik7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5oZWFkZXIgLmhlYWRlci10ZXh0e2ZvbnQtc2l6ZTo3MnB4O2ZvbnQtZmFtaWx5Ok9zd2FsZCxzYW5zLXNlcmlmO2NvbG9yOiNmZjYyMjY7dGV4dC10cmFuc2Zvcm06dXBwZXJjYXNlO3BhZGRpbmc6MjVweDttYXJnaW46MDtsZXR0ZXItc3BhY2luZzoycHg7dGV4dC1zaGFkb3c6LTFweCAtMXB4IDAgI2ZmZiwxcHggLTFweCAwICNmZmYsLTFweCAxcHggMCAjZmZmLDFweCAxcHggMCAjZmZmfS5oZWFkZXIgLmNyZXN0e21heC1oZWlnaHQ6ODBweDttYXgtd2lkdGg6NTBweH0udWkubWVudXttYXJnaW4tdG9wOjA7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW4tYm90dG9tOjIwcHh9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyL2xpYiEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1kZXNrdG9wL21lbnUtZGVza3RvcC5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9oZWFkZXItYmFja2dyb3VuZC5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL21lbnUvaGVhZGVyLWJhY2tncm91bmQuanBnXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdtZW51LW1vYmlsZScsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vbWVudS1tb2JpbGUuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL21lbnUtbW9iaWxlLmNvbXBvbmVudC5sZXNzJyldXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVNb2JpbGVDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgICAvLyBNZW51IGRyb3Bkb3duc1xuICAgIEBWaWV3Q2hpbGQoJ3RlYW1Ecm9wZG93bicpXG4gICAgcHJpdmF0ZSB0ZWFtRHJvcGRvd246IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgnaGlzdG9yeURyb3Bkb3duJylcbiAgICBwcml2YXRlIGhpc3RvcnlEcm9wZG93bjogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCdtb2JpbGVEcm9wZG93bicpXG4gICAgcHJpdmF0ZSBtb2JpbGVEcm9wZG93bjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgb3VyIG1vYmlsZSBtZW51IGRyb3Bkb3duLlxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gJCh0aGlzLnRlYW1Ecm9wZG93bi5uYXRpdmVFbGVtZW50KS5kcm9wZG93bih7fSk7XG4gICAgICAgIC8vICQodGhpcy5oaXN0b3J5RHJvcGRvd24ubmF0aXZlRWxlbWVudCkuZHJvcGRvd24oe30pO1xuICAgICAgICAkKHRoaXMubW9iaWxlRHJvcGRvd24ubmF0aXZlRWxlbWVudCkuZHJvcGRvd24oe30pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtbW9iaWxlL21lbnUtbW9iaWxlLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8IS0tSGVhZGVyL01lbnUtLT5cXG48ZGl2IGNsYXNzPVxcXCJoZWFkZXJcXFwiPlxcbiAgICA8ZGl2ICNtb2JpbGVEcm9wZG93biBjbGFzcz1cXFwidWkgaW5saW5lIGRyb3Bkb3duXFxcIj5cXG4gICAgICAgIDxoMSBjbGFzcz1cXFwiaGVhZGVyLXRleHRcXFwiPklsbGlub2lzIFVsdGltYXRlPC9oMT5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvaG9tZVxcXCIgICAgICAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiaG9tZSBpY29uXFxcIj48L2k+SG9tZTwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvYWJvdXRcXFwiICAgICAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiaW5mbyBpY29uXFxcIj48L2k+QWJvdXQgVXM8L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL3Byb3NwZWN0c1xcXCIgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImNoaWxkIGljb25cXFwiPjwvaT5Qcm9zcGVjdGl2ZSBQbGF5ZXJzPC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9wcmFjdGljZVxcXCIgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJzb2NjZXIgaWNvblxcXCI+PC9pPlByYWN0aWNlPC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi90b3VybmFtZW50cy8yMDE5XFxcIiAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJjYWxlbmRhciBpY29uXFxcIj48L2k+VG91cm5hbWVudHM8L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL3Jvc3Rlci8yMDE5XFxcIiAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcIm9yZGVyZWQgbGlzdCBpY29uXFxcIj48L2k+Um9zdGVyPC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9hYnNlbnRcXFwiICAgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJyZW1vdmUgaWNvblxcXCI+PC9pPkFic2VudCBGb3JtPC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTdcXFwiICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJ1bmRvIGljb25cXFwiPjwvaT5UZWFtIEhpc3Rvcnk8L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL2F3YXJkc1xcXCIgICAgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcInRyb3BoeSBpY29uXFxcIj48L2k+QXdhcmRzPC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9yZXN1bHRzXFxcIiAgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJhcmNoaXZlIGljb25cXFwiPjwvaT5QYXN0IFJlc3VsdHM8L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL2Jsb2dcXFwiICAgICAgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImNvbW1lbnQgaWNvblxcXCI+PC9pPkJsb2c8L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL2NvbnRhY3RcXFwiICAgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcIm1haWwgaWNvblxcXCI+PC9pPkNvbnRhY3QgVXM8L2E+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuaGVhZGVye3dpZHRoOjEwMCU7YmFja2dyb3VuZC1pbWFnZTp1cmwoXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9tZW51L2hlYWRlci1iYWNrZ3JvdW5kLmpwZ1wiKSArIFwiKTtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luLWJvdHRvbToyMHB4fS5oZWFkZXIgLnVpLmRyb3Bkb3due3RleHQtYWxpZ246Y2VudGVyfS5oZWFkZXIgLmhlYWRlci10ZXh0e2ZvbnQtc2l6ZTo3MnB4O2ZvbnQtZmFtaWx5Ok9zd2FsZCxzYW5zLXNlcmlmO2NvbG9yOiNmZjYyMjY7dGV4dC10cmFuc2Zvcm06dXBwZXJjYXNlO3BhZGRpbmc6MTBweDttYXJnaW46MDtsZXR0ZXItc3BhY2luZzoycHg7dGV4dC1zaGFkb3c6LTFweCAtMXB4IDAgI2ZmZiwxcHggLTFweCAwICNmZmYsLTFweCAxcHggMCAjZmZmLDFweCAxcHggMCAjZmZmfS5oZWFkZXIgLmRyb3Bkb3duLmljb257Zm9udC1zaXplOjIwcHg7Y29sb3I6I2ZmZn0uaGVhZGVyIC5tZW51e3dpZHRoOjEwMCV9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyL2xpYiEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdsZWZ0LXNpZGViYXInLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2xlZnQtc2lkZWJhci5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzJyldXG59KVxuZXhwb3J0IGNsYXNzIExlZnRTaWRlYmFyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVUd2l0dGVyV2lkZ2V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHdpdHRlciBzY3JpcHQgZm9yIGluaXRpYWxpemluZyBvdXIgVHdpdHRlciBUaW1lbGluZSB3aWRnZXRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplVHdpdHRlcldpZGdldCgpOiB2b2lkIHtcbiAgICAgICAgIShmdW5jdGlvbihkLCBzLCBpZCkge1xuICAgICAgICAgICAgbGV0IGpzOiBhbnksXG4gICAgICAgICAgICAgICAgZmpzID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZShzKVswXSxcbiAgICAgICAgICAgICAgICBwID0gJ2h0dHBzJztcbiAgICAgICAgICAgIGlmICghZC5nZXRFbGVtZW50QnlJZChpZCkpIHtcbiAgICAgICAgICAgICAgICBqcyA9IGQuY3JlYXRlRWxlbWVudChzKTtcbiAgICAgICAgICAgICAgICBqcy5pZCA9IGlkO1xuICAgICAgICAgICAgICAgIGpzLnNyYyA9IHAgKyAnOi8vcGxhdGZvcm0udHdpdHRlci5jb20vd2lkZ2V0cy5qcyc7XG4gICAgICAgICAgICAgICAgZmpzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGpzLCBmanMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShkb2N1bWVudCwgJ3NjcmlwdCcsICd0d2l0dGVyLXdqcycpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInVpIHNlZ21lbnQgdHdpdHRlci1zaWRlYmFyXFxcIj5cXG4gICAgPGEgY2xhc3M9XFxcInR3aXR0ZXItdGltZWxpbmVcXFwiIGhlaWdodD1cXFwiNTAwcHhcXFwiIGhyZWY9XFxcImh0dHBzOi8vdHdpdHRlci5jb20vaWxsaW5pbWVuc3VsdGlcXFwiIGRhdGEtd2lkZ2V0LWlkPVxcXCI2MDU0MTQ4MzYzNjk4ODMxMzZcXFwiPlR3ZWV0cyBieSBASWxsaW5pVWx0aTwvYT5cXG48L2Rpdj5cXG5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL2xlZnQtc2lkZWJhci5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnR3aXR0ZXItc2lkZWJhcntwYWRkaW5nOjA7bWF4LXdpZHRoOjIwMHB4O21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyL2xpYiEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL2xlZnQtc2lkZWJhci5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncmlnaHQtc2lkZWJhcicsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vcmlnaHQtc2lkZWJhci5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vcmlnaHQtc2lkZWJhci5jb21wb25lbnQubGVzcycpXVxufSlcbmV4cG9ydCBjbGFzcyBSaWdodFNpZGViYXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIG5nT25Jbml0KCk6IHZvaWQge31cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPCEtLVBheXBhbCBTaWRlYmFyLS0+XFxuPGRpdiBjbGFzcz1cXFwidWkgc2VnbWVudCBwYXlwYWwtc2lkZWJhclxcXCI+XFxuICAgIDxoMiBjbGFzcz1cXFwidWkgaGVhZGVyXFxcIj5IZWxwIE91dCBJbGxpbm9pcyBVbHRpbWF0ZSE8L2gyPlxcblxcbiAgICA8cD5JbGxpbm9pcyBVbHRpbWF0ZSBpcyBtb3N0bHkgc3R1ZGVudC1mdW5kZWQsIGhlbHAgdXMgb3V0IGJ5IGRvbmF0aW5nITwvcD5cXG4gICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cucGF5cGFsLm1lL2lsbGlub2lzVWx0aW1hdGVcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgIDxpbWcgY2xhc3M9XFxcInBheXBhbC1kb25hdGUgaHZyLWdyb3dcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvcGF5cGFsLWRvbmF0ZS5wbmdcIikgKyBcIlxcXCIvPlxcbiAgICA8L2E+XFxuPC9kaXY+XFxuPCEtLVNvY2lhbCBNZWRpYSBJY29ucy0tPlxcbjxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZhY2Vib29rLmNvbS9JbGxpbm9pc1VsdGltYXRlXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+XFxuICAgIDxpbWcgY2xhc3M9XFxcInNvY2lhbC1tZWRpYS1idXR0b24gaHZyLXNpbmtcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvZmFjZWJvb2stYnV0dG9uLnBuZ1wiKSArIFwiXFxcIi8+XFxuPC9hPlxcbjxhIGhyZWY9XFxcImh0dHBzOi8vdHdpdHRlci5jb20vaWxsaW5pdWx0aVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICA8aW1nIGNsYXNzPVxcXCJzb2NpYWwtbWVkaWEtYnV0dG9uIGh2ci1zaW5rXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL3R3aXR0ZXItYnV0dG9uLnBuZ1wiKSArIFwiXFxcIi8+XFxuPC9hPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9wYXlwYWwtZG9uYXRlLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL3BheXBhbC1kb25hdGUucG5nXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXNzZXRzL2ZhY2Vib29rLWJ1dHRvbi5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9mYWNlYm9vay1idXR0b24ucG5nXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXNzZXRzL3R3aXR0ZXItYnV0dG9uLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL3R3aXR0ZXItYnV0dG9uLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9yaWdodC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5wYXlwYWwtc2lkZWJhcnttYXgtd2lkdGg6MjAwcHg7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0b30ucGF5cGFsLXNpZGViYXIgcHt0ZXh0LWluZGVudDowO21hcmdpbi1ib3R0b206MDtwYWRkaW5nLXRvcDoxNXB4O3BhZGRpbmctYm90dG9tOjE1cHh9LnBheXBhbC1kb25hdGV7d2lkdGg6MTAwcHh9LnVpLmhlYWRlcnttYXJnaW4tYm90dG9tOjB9LnNvY2lhbC1tZWRpYS1idXR0b257d2lkdGg6NDAlO21heC13aWR0aDo3MHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjozcHg7Ym94LXNoYWRvdzowIDFweCAycHggMCByZ2JhKDM0LDM2LDM4LC4xNSk7Ym9yZGVyLXJhZGl1czouMjg1NzE0MjllbX1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vcG9zdGNzcy1sb2FkZXIvbGliIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9yaWdodC1zaWRlYmFyL3JpZ2h0LXNpZGViYXIuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3BhZ2UtZnJhbWUnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUZyYW1lQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBuZ09uSW5pdCgpOiB2b2lkIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9wYWdlLWZyYW1lLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8IS0tSGVhZGVyLS0+XFxuPG1lbnUtZGVza3RvcCBjbGFzcz1cXFwibWVudS1kZXNrdG9wXFxcIj48L21lbnUtZGVza3RvcD5cXG48bWVudS1tb2JpbGUgY2xhc3M9XFxcIm1lbnUtbW9iaWxlXFxcIj48L21lbnUtbW9iaWxlPlxcblxcbjwhLS1Db250ZW50LS0+XFxuPGRpdiBjbGFzcz1cXFwibWFpbi1jb250YWluZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsZWZ0LXNpZGViYXJcXFwiPlxcbiAgICAgICAgPGxlZnQtc2lkZWJhcj48L2xlZnQtc2lkZWJhcj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1haW4tY29udGVudFxcXCI+XFxuICAgICAgICA8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyaWdodC1zaWRlYmFyXFxcIj5cXG4gICAgICAgIDxyaWdodC1zaWRlYmFyPjwvcmlnaHQtc2lkZWJhcj5cXG4gICAgPC9kaXY+XFxuICAgIDxmb290ZXI+PC9mb290ZXI+XFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9wYWdlLWZyYW1lLmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubGVmdC1zaWRlYmFyLC5tZW51LWRlc2t0b3AsLnJpZ2h0LXNpZGViYXJ7ZGlzcGxheTpub25lfS5tYWluLWNvbnRhaW5lcnttYXJnaW4tYm90dG9tOjUwcHh9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo3NjhweCl7Lm1haW4tY29udGFpbmVye2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4fS5tZW51LW1vYmlsZXtkaXNwbGF5Om5vbmV9LmxlZnQtc2lkZWJhciwubWVudS1kZXNrdG9wLC5yaWdodC1zaWRlYmFye2Rpc3BsYXk6YmxvY2t9Lm1haW4tY29udGVudHtwYWRkaW5nOjAgMTBweDt3aWR0aDoxMDAlfS5sZWZ0LXNpZGViYXJ7bWFyZ2luLWxlZnQ6MTBweDstbXMtZmxleDowIDAgMjAwcHg7ZmxleDowIDAgMjAwcHh9LnJpZ2h0LXNpZGViYXJ7bWFyZ2luLXJpZ2h0OjEwcHg7bWFyZ2luLWxlZnQ6YXV0bzstbXMtZmxleDowIDAgMTUwcHg7ZmxleDowIDAgMTUwcHh9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6MTAyNHB4KXsubWFpbi1jb250ZW50e3BhZGRpbmc6MCAzMHB4fS5sZWZ0LXNpZGViYXJ7bWFyZ2luLWxlZnQ6NTBweH0ucmlnaHQtc2lkZWJhcnttYXJnaW4tcmlnaHQ6NTBweDstbXMtZmxleDowIDAgMjAwcHg7ZmxleDowIDAgMjAwcHh9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6MTI4MHB4KXsubWFpbi1jb250ZW50e3BhZGRpbmc6MCA1MHB4fS5sZWZ0LXNpZGViYXJ7bWFyZ2luLWxlZnQ6ODBweH0ucmlnaHQtc2lkZWJhcnttYXJnaW4tcmlnaHQ6ODBweH19XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyL2xpYiEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2Zvb3RlcicsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZm9vdGVyLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9mb290ZXIuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5leHBvcnQgY2xhc3MgRm9vdGVyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge31cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInVpIG1lbnVcXFwiPlxcbiAgICA8cD5Gb3Igc3VwcG9ydCBvciB0byByZXBvcnQgd2Vic2l0ZSBpc3N1ZXMsIGVtYWlsIHRoZSBhZG1pbiBhdCB3Y2pwaG9lbml4QGdtYWlsLmNvbSBvciB0aGUgY3JlYXRvciBhdCBuaWNrLnByb3pvcm92c2t5QGdtYWlsLmNvbTwvcD5cXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9mb290ZXIvZm9vdGVyLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL2Zvb3Rlci5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9mb290ZXIvZm9vdGVyLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnVpLm1lbnV7cG9zaXRpb246Zml4ZWQ7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn1we21hcmdpbjowIGF1dG87Zm9udC1zaXplOjEwcHh9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo3NjhweCl7cHtmb250LXNpemU6MTJweH19XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyL2xpYiEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvZm9vdGVyL2Zvb3Rlci5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=
