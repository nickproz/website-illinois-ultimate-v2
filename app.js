webpackJsonp([0],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	var platform_browser_dynamic_1 = __webpack_require__(5);
	var core_1 = __webpack_require__(7);
	var app_module_1 = __webpack_require__(27);
	/*
	 Our application code
	*/
	// Turns off assertions and other checks within the framework if we are in production
	if (process.env.ENV === 'prod') {
	    core_1.enableProdMode();
	}
	// Bootstrap
	platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var common_1 = __webpack_require__(26);
	var platform_browser_1 = __webpack_require__(25);
	var http_1 = __webpack_require__(28);
	var forms_1 = __webpack_require__(29);
	var home_component_1 = __webpack_require__(33);
	var about_component_1 = __webpack_require__(39);
	var prospective_players_component_1 = __webpack_require__(43);
	var contact_component_1 = __webpack_require__(48);
	var app_component_1 = __webpack_require__(52);
	var team_module_1 = __webpack_require__(60);
	var history_module_1 = __webpack_require__(150);
	var page_frame_module_1 = __webpack_require__(151);
	var AppModule = (function () {
	    function AppModule() {
	    }
	    return AppModule;
	}());
	AppModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            platform_browser_1.BrowserModule,
	            http_1.HttpModule,
	            forms_1.FormsModule,
	            // AgmCoreModule.forRoot({
	            //     apiKey: 'AIzaSyBRIXAk5xdvn3ezypsSe55f8dZhcHheAZ8'
	            // }),
	            page_frame_module_1.PageFrameModule,
	            team_module_1.TeamModule,
	            history_module_1.HistoryModule
	        ],
	        declarations: [
	            app_component_1.AppComponent,
	            home_component_1.HomeComponent,
	            about_component_1.AboutComponent,
	            prospective_players_component_1.ProspectivePlayersComponent,
	            contact_component_1.ContactComponent
	        ],
	        // Use hash strategy so page refreshes on Github pages route correctly
	        providers: [{ provide: common_1.LocationStrategy, useClass: common_1.HashLocationStrategy }],
	        bootstrap: [app_component_1.AppComponent]
	    }),
	    __metadata("design:paramtypes", [])
	], AppModule);
	exports.AppModule = AppModule;


/***/ }),
/* 28 */,
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v2.2.4
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(7), __webpack_require__(30), __webpack_require__(8), __webpack_require__(9), __webpack_require__(31)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/operator/toPromise', 'rxjs/Subject', 'rxjs/Observable', 'rxjs/observable/fromPromise'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.forms = global.ng.forms || {}),global.ng.core,global.Rx.Observable.prototype,global.Rx,global.Rx,global.Rx.Observable));
	}(this, function (exports,_angular_core,rxjs_operator_toPromise,rxjs_Subject,rxjs_Observable,rxjs_observable_fromPromise) { 'use strict';
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Base class for control directives.
	     *
	     * Only used internally in the forms module.
	     *
	     * @stable
	     */
	    var AbstractControlDirective = (function () {
	        function AbstractControlDirective() {
	        }
	        Object.defineProperty(AbstractControlDirective.prototype, "control", {
	            get: function () { throw new Error('unimplemented'); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "value", {
	            get: function () { return this.control ? this.control.value : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "valid", {
	            get: function () { return this.control ? this.control.valid : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "invalid", {
	            get: function () { return this.control ? this.control.invalid : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "pending", {
	            get: function () { return this.control ? this.control.pending : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "errors", {
	            get: function () { return this.control ? this.control.errors : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
	            get: function () { return this.control ? this.control.pristine : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
	            get: function () { return this.control ? this.control.dirty : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "touched", {
	            get: function () { return this.control ? this.control.touched : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
	            get: function () { return this.control ? this.control.untouched : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "disabled", {
	            get: function () { return this.control ? this.control.disabled : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "enabled", {
	            get: function () { return this.control ? this.control.enabled : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "statusChanges", {
	            get: function () { return this.control ? this.control.statusChanges : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "valueChanges", {
	            get: function () { return this.control ? this.control.valueChanges : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "path", {
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        AbstractControlDirective.prototype.reset = function (value) {
	            if (value === void 0) { value = undefined; }
	            if (this.control)
	                this.control.reset(value);
	        };
	        AbstractControlDirective.prototype.hasError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return this.control ? this.control.hasError(errorCode, path) : false;
	        };
	        AbstractControlDirective.prototype.getError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return this.control ? this.control.getError(errorCode, path) : null;
	        };
	        return AbstractControlDirective;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * A directive that contains multiple {@link NgControl}s.
	     *
	     * Only used by the forms module.
	     *
	     * @stable
	     */
	    var ControlContainer = (function (_super) {
	        __extends$1(ControlContainer, _super);
	        function ControlContainer() {
	            _super.apply(this, arguments);
	        }
	        Object.defineProperty(ControlContainer.prototype, "formDirective", {
	            /**
	             * Get the form to which this container belongs.
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ControlContainer.prototype, "path", {
	            /**
	             * Get the path to this container.
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        return ControlContainer;
	    }(AbstractControlDirective));
	
	    function isPresent(obj) {
	        return obj != null;
	    }
	    function isBlank(obj) {
	        return obj == null;
	    }
	    // JS has NaN !== NaN
	    function looseIdentical(a, b) {
	        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	    }
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    function isPrimitive(obj) {
	        return !isJsObject(obj);
	    }
	
	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        StringMapWrapper.merge = function (m1, m2) {
	            var m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        StringMapWrapper.equals = function (m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var i = 0; i < k1.length; i++) {
	                var key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        ListWrapper.removeAll = function (list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                if (index > -1) {
	                    list.splice(index, 1);
	                }
	            }
	        };
	        ListWrapper.remove = function (list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        ListWrapper.flatten = function (list) {
	            return list.reduce(function (flat, item) {
	                var flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;
	                return flat.concat(flatItem);
	            }, []);
	        };
	        return ListWrapper;
	    }());
	
	    var isPromise = _angular_core.__core_private__.isPromise;
	
	    function isEmptyInputValue(value) {
	        return value == null || typeof value === 'string' && value.length === 0;
	    }
	    /**
	     * Providers for validators to be used for {@link FormControl}s in a form.
	     *
	     * Provide this using `multi: true` to add validators.
	     *
	     * ### Example
	     *
	     * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
	     * @stable
	     */
	    var NG_VALIDATORS = new _angular_core.OpaqueToken('NgValidators');
	    /**
	     * Providers for asynchronous validators to be used for {@link FormControl}s
	     * in a form.
	     *
	     * Provide this using `multi: true` to add validators.
	     *
	     * See {@link NG_VALIDATORS} for more details.
	     *
	     * @stable
	     */
	    var NG_ASYNC_VALIDATORS = new _angular_core.OpaqueToken('NgAsyncValidators');
	    /**
	     * Provides a set of validators used by form controls.
	     *
	     * A validator is a function that processes a {@link FormControl} or collection of
	     * controls and returns a map of errors. A null map means that validation has passed.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * var loginControl = new FormControl("", Validators.required)
	     * ```
	     *
	     * @stable
	     */
	    var Validators = (function () {
	        function Validators() {
	        }
	        /**
	         * Validator that requires controls to have a non-empty value.
	         */
	        Validators.required = function (control) {
	            return isEmptyInputValue(control.value) ? { 'required': true } : null;
	        };
	        /**
	         * Validator that requires controls to have a value of a minimum length.
	         */
	        Validators.minLength = function (minLength) {
	            return function (control) {
	                if (isEmptyInputValue(control.value)) {
	                    return null; // don't validate empty values to allow optional controls
	                }
	                var length = typeof control.value === 'string' ? control.value.length : 0;
	                return length < minLength ?
	                    { 'minlength': { 'requiredLength': minLength, 'actualLength': length } } :
	                    null;
	            };
	        };
	        /**
	         * Validator that requires controls to have a value of a maximum length.
	         */
	        Validators.maxLength = function (maxLength) {
	            return function (control) {
	                var length = typeof control.value === 'string' ? control.value.length : 0;
	                return length > maxLength ?
	                    { 'maxlength': { 'requiredLength': maxLength, 'actualLength': length } } :
	                    null;
	            };
	        };
	        /**
	         * Validator that requires a control to match a regex to its value.
	         */
	        Validators.pattern = function (pattern) {
	            if (!pattern)
	                return Validators.nullValidator;
	            var regex;
	            var regexStr;
	            if (typeof pattern === 'string') {
	                regexStr = "^" + pattern + "$";
	                regex = new RegExp(regexStr);
	            }
	            else {
	                regexStr = pattern.toString();
	                regex = pattern;
	            }
	            return function (control) {
	                if (isEmptyInputValue(control.value)) {
	                    return null; // don't validate empty values to allow optional controls
	                }
	                var value = control.value;
	                return regex.test(value) ? null :
	                    { 'pattern': { 'requiredPattern': regexStr, 'actualValue': value } };
	            };
	        };
	        /**
	         * No-op validator.
	         */
	        Validators.nullValidator = function (c) { return null; };
	        /**
	         * Compose multiple validators into a single function that returns the union
	         * of the individual error maps.
	         */
	        Validators.compose = function (validators) {
	            if (!validators)
	                return null;
	            var presentValidators = validators.filter(isPresent);
	            if (presentValidators.length == 0)
	                return null;
	            return function (control) {
	                return _mergeErrors(_executeValidators(control, presentValidators));
	            };
	        };
	        Validators.composeAsync = function (validators) {
	            if (!validators)
	                return null;
	            var presentValidators = validators.filter(isPresent);
	            if (presentValidators.length == 0)
	                return null;
	            return function (control) {
	                var promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
	                return Promise.all(promises).then(_mergeErrors);
	            };
	        };
	        return Validators;
	    }());
	    function _convertToPromise(obj) {
	        return isPromise(obj) ? obj : rxjs_operator_toPromise.toPromise.call(obj);
	    }
	    function _executeValidators(control, validators) {
	        return validators.map(function (v) { return v(control); });
	    }
	    function _executeAsyncValidators(control, validators) {
	        return validators.map(function (v) { return v(control); });
	    }
	    function _mergeErrors(arrayOfErrors) {
	        var res = arrayOfErrors.reduce(function (res, errors) {
	            return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
	        }, {});
	        return Object.keys(res).length === 0 ? null : res;
	    }
	
	    /**
	     * Used to provide a {@link ControlValueAccessor} for form controls.
	     *
	     * See {@link DefaultValueAccessor} for how to implement one.
	     * @stable
	     */
	    var NG_VALUE_ACCESSOR = new _angular_core.OpaqueToken('NgValueAccessor');
	
	    var CHECKBOX_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return CheckboxControlValueAccessor; }),
	        multi: true,
	    };
	    /**
	     * The accessor for writing a value and listening to changes on a checkbox input element.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="checkbox" name="rememberLogin" ngModel>
	     *  ```
	     *
	     *  @stable
	     */
	    var CheckboxControlValueAccessor = (function () {
	        function CheckboxControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        CheckboxControlValueAccessor.prototype.writeValue = function (value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
	        };
	        CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	        CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        CheckboxControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        CheckboxControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',
	                        host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
	                        providers: [CHECKBOX_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        CheckboxControlValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return CheckboxControlValueAccessor;
	    }());
	
	    var DEFAULT_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return DefaultValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The default accessor for writing a value and listening to changes that is used by the
	     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="text" name="searchQuery" ngModel>
	     *  ```
	     *
	     *  @stable
	     */
	    var DefaultValueAccessor = (function () {
	        function DefaultValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        DefaultValueAccessor.prototype.writeValue = function (value) {
	            var normalizedValue = value == null ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        };
	        DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	        DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        DefaultValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        DefaultValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
	                        // TODO: vsavkin replace the above selector with the one below it once
	                        // https://github.com/angular/angular/issues/3011 is implemented
	                        // selector: '[ngControl],[ngModel],[ngFormControl]',
	                        host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                        providers: [DEFAULT_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        DefaultValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return DefaultValueAccessor;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    function normalizeValidator(validator) {
	        if (validator.validate) {
	            return function (c) { return validator.validate(c); };
	        }
	        else {
	            return validator;
	        }
	    }
	    function normalizeAsyncValidator(validator) {
	        if (validator.validate) {
	            return function (c) { return validator.validate(c); };
	        }
	        else {
	            return validator;
	        }
	    }
	
	    var NUMBER_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return NumberValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The accessor for writing a number value and listening to changes that is used by the
	     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="number" [(ngModel)]="age">
	     *  ```
	     */
	    var NumberValueAccessor = (function () {
	        function NumberValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        NumberValueAccessor.prototype.writeValue = function (value) {
	            // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
	            var normalizedValue = value == null ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        };
	        NumberValueAccessor.prototype.registerOnChange = function (fn) {
	            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };
	        };
	        NumberValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        NumberValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        NumberValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',
	                        host: {
	                            '(change)': 'onChange($event.target.value)',
	                            '(input)': 'onChange($event.target.value)',
	                            '(blur)': 'onTouched()'
	                        },
	                        providers: [NUMBER_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        NumberValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return NumberValueAccessor;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    function unimplemented() {
	        throw new Error('unimplemented');
	    }
	    /**
	     * A base class that all control directive extend.
	     * It binds a {@link FormControl} object to a DOM element.
	     *
	     * Used internally by Angular forms.
	     *
	     * @stable
	     */
	    var NgControl = (function (_super) {
	        __extends$2(NgControl, _super);
	        function NgControl() {
	            _super.apply(this, arguments);
	            /** @internal */
	            this._parent = null;
	            this.name = null;
	            this.valueAccessor = null;
	            /** @internal */
	            this._rawValidators = [];
	            /** @internal */
	            this._rawAsyncValidators = [];
	        }
	        Object.defineProperty(NgControl.prototype, "validator", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgControl.prototype, "asyncValidator", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        return NgControl;
	    }(AbstractControlDirective));
	
	    var RADIO_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return RadioControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * Internal class used by Angular to uncheck radio buttons with the matching name.
	     */
	    var RadioControlRegistry = (function () {
	        function RadioControlRegistry() {
	            this._accessors = [];
	        }
	        RadioControlRegistry.prototype.add = function (control, accessor) {
	            this._accessors.push([control, accessor]);
	        };
	        RadioControlRegistry.prototype.remove = function (accessor) {
	            for (var i = this._accessors.length - 1; i >= 0; --i) {
	                if (this._accessors[i][1] === accessor) {
	                    this._accessors.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        RadioControlRegistry.prototype.select = function (accessor) {
	            var _this = this;
	            this._accessors.forEach(function (c) {
	                if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {
	                    c[1].fireUncheck(accessor.value);
	                }
	            });
	        };
	        RadioControlRegistry.prototype._isSameGroup = function (controlPair, accessor) {
	            if (!controlPair[0].control)
	                return false;
	            return controlPair[0]._parent === accessor._control._parent &&
	                controlPair[1].name === accessor.name;
	        };
	        RadioControlRegistry.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        RadioControlRegistry.ctorParameters = [];
	        return RadioControlRegistry;
	    }());
	    /**
	     * @whatItDoes  Writes radio control values and listens to radio control changes.
	     *
	     * Used by {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName}
	     * to keep the view synced with the {@link FormControl} model.
	     *
	     * @howToUse
	     *
	     * If you have imported the {@link FormsModule} or the {@link ReactiveFormsModule}, this
	     * value accessor will be active on any radio control that has a form directive. You do
	     * **not** need to add a special selector to activate it.
	     *
	     * ### How to use radio buttons with form directives
	     *
	     * To use radio buttons in a template-driven form, you'll want to ensure that radio buttons
	     * in the same group have the same `name` attribute.  Radio buttons with different `name`
	     * attributes do not affect each other.
	     *
	     * {@example forms/ts/radioButtons/radio_button_example.ts region='TemplateDriven'}
	     *
	     * When using radio buttons in a reactive form, radio buttons in the same group should have the
	     * same `formControlName`. You can also add a `name` attribute, but it's optional.
	     *
	     * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}
	     *
	     *  * **npm package**: `@angular/forms`
	     *
	     *  @stable
	     */
	    var RadioControlValueAccessor = (function () {
	        function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this._registry = _registry;
	            this._injector = _injector;
	            this.onChange = function () { };
	            this.onTouched = function () { };
	        }
	        RadioControlValueAccessor.prototype.ngOnInit = function () {
	            this._control = this._injector.get(NgControl);
	            this._checkName();
	            this._registry.add(this._control, this);
	        };
	        RadioControlValueAccessor.prototype.ngOnDestroy = function () { this._registry.remove(this); };
	        RadioControlValueAccessor.prototype.writeValue = function (value) {
	            this._state = value === this.value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', this._state);
	        };
	        RadioControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this._fn = fn;
	            this.onChange = function () {
	                fn(_this.value);
	                _this._registry.select(_this);
	            };
	        };
	        RadioControlValueAccessor.prototype.fireUncheck = function (value) { this.writeValue(value); };
	        RadioControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        RadioControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        RadioControlValueAccessor.prototype._checkName = function () {
	            if (this.name && this.formControlName && this.name !== this.formControlName) {
	                this._throwNameError();
	            }
	            if (!this.name && this.formControlName)
	                this.name = this.formControlName;
	        };
	        RadioControlValueAccessor.prototype._throwNameError = function () {
	            throw new Error("\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type=\"radio\" formControlName=\"food\" name=\"food\">\n    ");
	        };
	        RadioControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',
	                        host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
	                        providers: [RADIO_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        RadioControlValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	            { type: RadioControlRegistry, },
	            { type: _angular_core.Injector, },
	        ];
	        RadioControlValueAccessor.propDecorators = {
	            'name': [{ type: _angular_core.Input },],
	            'formControlName': [{ type: _angular_core.Input },],
	            'value': [{ type: _angular_core.Input },],
	        };
	        return RadioControlValueAccessor;
	    }());
	
	    var RANGE_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return RangeValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The accessor for writing a range value and listening to changes that is used by the
	     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="range" [(ngModel)]="age" >
	     *  ```
	     */
	    var RangeValueAccessor = (function () {
	        function RangeValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        RangeValueAccessor.prototype.writeValue = function (value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', parseFloat(value));
	        };
	        RangeValueAccessor.prototype.registerOnChange = function (fn) {
	            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };
	        };
	        RangeValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        RangeValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        RangeValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',
	                        host: {
	                            '(change)': 'onChange($event.target.value)',
	                            '(input)': 'onChange($event.target.value)',
	                            '(blur)': 'onTouched()'
	                        },
	                        providers: [RANGE_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        RangeValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return RangeValueAccessor;
	    }());
	
	    var SELECT_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return SelectControlValueAccessor; }),
	        multi: true
	    };
	    function _buildValueString(id, value) {
	        if (id == null)
	            return "" + value;
	        if (!isPrimitive(value))
	            value = 'Object';
	        return (id + ": " + value).slice(0, 50);
	    }
	    function _extractId(valueString) {
	        return valueString.split(':')[0];
	    }
	    /**
	     * @whatItDoes Writes values and listens to changes on a select element.
	     *
	     * Used by {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName}
	     * to keep the view synced with the {@link FormControl} model.
	     *
	     * @howToUse
	     *
	     * If you have imported the {@link FormsModule} or the {@link ReactiveFormsModule}, this
	     * value accessor will be active on any select control that has a form directive. You do
	     * **not** need to add a special selector to activate it.
	     *
	     * ### How to use select controls with form directives
	     *
	     * To use a select in a template-driven form, simply add an `ngModel` and a `name`
	     * attribute to the main `<select>` tag.
	     *
	     * If your option values are simple strings, you can bind to the normal `value` property
	     * on the option.  If your option values happen to be objects (and you'd like to save the
	     * selection in your form as an object), use `ngValue` instead:
	     *
	     * {@example forms/ts/selectControl/select_control_example.ts region='Component'}
	     *
	     * In reactive forms, you'll also want to add your form directive (`formControlName` or
	     * `formControl`) on the main `<select>` tag. Like in the former example, you have the
	     * choice of binding to the  `value` or `ngValue` property on the select's options.
	     *
	     * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}
	     *
	     * Note: We listen to the 'change' event because 'input' events aren't fired
	     * for selects in Firefox and IE:
	     * https://bugzilla.mozilla.org/show_bug.cgi?id=1024350
	     * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4660045/
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * @stable
	     */
	    var SelectControlValueAccessor = (function () {
	        function SelectControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            /** @internal */
	            this._optionMap = new Map();
	            /** @internal */
	            this._idCounter = 0;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        SelectControlValueAccessor.prototype.writeValue = function (value) {
	            this.value = value;
	            var valueString = _buildValueString(this._getOptionId(value), value);
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
	        };
	        SelectControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this.onChange = function (valueString) {
	                _this.value = valueString;
	                fn(_this._getOptionValue(valueString));
	            };
	        };
	        SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        SelectControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /** @internal */
	        SelectControlValueAccessor.prototype._registerOption = function () { return (this._idCounter++).toString(); };
	        /** @internal */
	        SelectControlValueAccessor.prototype._getOptionId = function (value) {
	            for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
	                var id = _a[_i];
	                if (looseIdentical(this._optionMap.get(id), value))
	                    return id;
	            }
	            return null;
	        };
	        /** @internal */
	        SelectControlValueAccessor.prototype._getOptionValue = function (valueString) {
	            var id = _extractId(valueString);
	            return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
	        };
	        SelectControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',
	                        host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                        providers: [SELECT_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        SelectControlValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return SelectControlValueAccessor;
	    }());
	    /**
	     * @whatItDoes Marks `<option>` as dynamic, so Angular can be notified when options change.
	     *
	     * @howToUse
	     *
	     * See docs for {@link SelectControlValueAccessor} for usage examples.
	     *
	     * @stable
	     */
	    var NgSelectOption = (function () {
	        function NgSelectOption(_element, _renderer, _select) {
	            this._element = _element;
	            this._renderer = _renderer;
	            this._select = _select;
	            if (this._select)
	                this.id = this._select._registerOption();
	        }
	        Object.defineProperty(NgSelectOption.prototype, "ngValue", {
	            set: function (value) {
	                if (this._select == null)
	                    return;
	                this._select._optionMap.set(this.id, value);
	                this._setElementValue(_buildValueString(this.id, value));
	                this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgSelectOption.prototype, "value", {
	            set: function (value) {
	                this._setElementValue(value);
	                if (this._select)
	                    this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        NgSelectOption.prototype._setElementValue = function (value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        };
	        NgSelectOption.prototype.ngOnDestroy = function () {
	            if (this._select) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        };
	        NgSelectOption.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'option' },] },
	        ];
	        /** @nocollapse */
	        NgSelectOption.ctorParameters = [
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: SelectControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	        ];
	        NgSelectOption.propDecorators = {
	            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],
	            'value': [{ type: _angular_core.Input, args: ['value',] },],
	        };
	        return NgSelectOption;
	    }());
	
	    var SELECT_MULTIPLE_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return SelectMultipleControlValueAccessor; }),
	        multi: true
	    };
	    function _buildValueString$1(id, value) {
	        if (id == null)
	            return "" + value;
	        if (typeof value === 'string')
	            value = "'" + value + "'";
	        if (!isPrimitive(value))
	            value = 'Object';
	        return (id + ": " + value).slice(0, 50);
	    }
	    function _extractId$1(valueString) {
	        return valueString.split(':')[0];
	    }
	    /**
	     * The accessor for writing a value and listening to changes on a select element.
	     *
	     * @stable
	     */
	    var SelectMultipleControlValueAccessor = (function () {
	        function SelectMultipleControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            /** @internal */
	            this._optionMap = new Map();
	            /** @internal */
	            this._idCounter = 0;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        SelectMultipleControlValueAccessor.prototype.writeValue = function (value) {
	            var _this = this;
	            this.value = value;
	            if (value == null)
	                return;
	            var values = value;
	            // convert values to ids
	            var ids = values.map(function (v) { return _this._getOptionId(v); });
	            this._optionMap.forEach(function (opt, o) { opt._setSelected(ids.indexOf(o.toString()) > -1); });
	        };
	        SelectMultipleControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this.onChange = function (_) {
	                var selected = [];
	                if (_.hasOwnProperty('selectedOptions')) {
	                    var options = _.selectedOptions;
	                    for (var i = 0; i < options.length; i++) {
	                        var opt = options.item(i);
	                        var val = _this._getOptionValue(opt.value);
	                        selected.push(val);
	                    }
	                }
	                else {
	                    var options = _.options;
	                    for (var i = 0; i < options.length; i++) {
	                        var opt = options.item(i);
	                        if (opt.selected) {
	                            var val = _this._getOptionValue(opt.value);
	                            selected.push(val);
	                        }
	                    }
	                }
	                fn(selected);
	            };
	        };
	        SelectMultipleControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        SelectMultipleControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /** @internal */
	        SelectMultipleControlValueAccessor.prototype._registerOption = function (value) {
	            var id = (this._idCounter++).toString();
	            this._optionMap.set(id, value);
	            return id;
	        };
	        /** @internal */
	        SelectMultipleControlValueAccessor.prototype._getOptionId = function (value) {
	            for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
	                var id = _a[_i];
	                if (looseIdentical(this._optionMap.get(id)._value, value))
	                    return id;
	            }
	            return null;
	        };
	        /** @internal */
	        SelectMultipleControlValueAccessor.prototype._getOptionValue = function (valueString) {
	            var id = _extractId$1(valueString);
	            return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
	        };
	        SelectMultipleControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
	                        host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },
	                        providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        SelectMultipleControlValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return SelectMultipleControlValueAccessor;
	    }());
	    /**
	     * Marks `<option>` as dynamic, so Angular can be notified when options change.
	     *
	     * ### Example
	     *
	     * ```
	     * <select multiple name="city" ngModel>
	     *   <option *ngFor="let c of cities" [value]="c"></option>
	     * </select>
	     * ```
	     */
	    var NgSelectMultipleOption = (function () {
	        function NgSelectMultipleOption(_element, _renderer, _select) {
	            this._element = _element;
	            this._renderer = _renderer;
	            this._select = _select;
	            if (this._select) {
	                this.id = this._select._registerOption(this);
	            }
	        }
	        Object.defineProperty(NgSelectMultipleOption.prototype, "ngValue", {
	            set: function (value) {
	                if (this._select == null)
	                    return;
	                this._value = value;
	                this._setElementValue(_buildValueString$1(this.id, value));
	                this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgSelectMultipleOption.prototype, "value", {
	            set: function (value) {
	                if (this._select) {
	                    this._value = value;
	                    this._setElementValue(_buildValueString$1(this.id, value));
	                    this._select.writeValue(this._select.value);
	                }
	                else {
	                    this._setElementValue(value);
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        NgSelectMultipleOption.prototype._setElementValue = function (value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        };
	        /** @internal */
	        NgSelectMultipleOption.prototype._setSelected = function (selected) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);
	        };
	        NgSelectMultipleOption.prototype.ngOnDestroy = function () {
	            if (this._select) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        };
	        NgSelectMultipleOption.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'option' },] },
	        ];
	        /** @nocollapse */
	        NgSelectMultipleOption.ctorParameters = [
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: SelectMultipleControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	        ];
	        NgSelectMultipleOption.propDecorators = {
	            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],
	            'value': [{ type: _angular_core.Input, args: ['value',] },],
	        };
	        return NgSelectMultipleOption;
	    }());
	
	    function controlPath(name, parent) {
	        return parent.path.concat([name]);
	    }
	    function setUpControl(control, dir) {
	        if (!control)
	            _throwError(dir, 'Cannot find control with');
	        if (!dir.valueAccessor)
	            _throwError(dir, 'No value accessor for form control with');
	        control.validator = Validators.compose([control.validator, dir.validator]);
	        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	        dir.valueAccessor.writeValue(control.value);
	        // view -> model
	        dir.valueAccessor.registerOnChange(function (newValue) {
	            dir.viewToModelUpdate(newValue);
	            control.markAsDirty();
	            control.setValue(newValue, { emitModelToViewChange: false });
	        });
	        // touched
	        dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });
	        control.registerOnChange(function (newValue, emitModelEvent) {
	            // control -> view
	            dir.valueAccessor.writeValue(newValue);
	            // control -> ngModel
	            if (emitModelEvent)
	                dir.viewToModelUpdate(newValue);
	        });
	        if (dir.valueAccessor.setDisabledState) {
	            control.registerOnDisabledChange(function (isDisabled) { dir.valueAccessor.setDisabledState(isDisabled); });
	        }
	        // re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4
	        dir._rawValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange)
	                validator.registerOnValidatorChange(function () { return control.updateValueAndValidity(); });
	        });
	        dir._rawAsyncValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange)
	                validator.registerOnValidatorChange(function () { return control.updateValueAndValidity(); });
	        });
	    }
	    function cleanUpControl(control, dir) {
	        dir.valueAccessor.registerOnChange(function () { return _noControlError(dir); });
	        dir.valueAccessor.registerOnTouched(function () { return _noControlError(dir); });
	        dir._rawValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange) {
	                validator.registerOnValidatorChange(null);
	            }
	        });
	        dir._rawAsyncValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange) {
	                validator.registerOnValidatorChange(null);
	            }
	        });
	        if (control)
	            control._clearChangeFns();
	    }
	    function setUpFormContainer(control, dir) {
	        if (isBlank(control))
	            _throwError(dir, 'Cannot find control with');
	        control.validator = Validators.compose([control.validator, dir.validator]);
	        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	    }
	    function _noControlError(dir) {
	        return _throwError(dir, 'There is no FormControl instance attached to form control element with');
	    }
	    function _throwError(dir, message) {
	        var messageEnd;
	        if (dir.path.length > 1) {
	            messageEnd = "path: '" + dir.path.join(' -> ') + "'";
	        }
	        else if (dir.path[0]) {
	            messageEnd = "name: '" + dir.path + "'";
	        }
	        else {
	            messageEnd = 'unspecified name attribute';
	        }
	        throw new Error(message + " " + messageEnd);
	    }
	    function composeValidators(validators) {
	        return isPresent(validators) ? Validators.compose(validators.map(normalizeValidator)) : null;
	    }
	    function composeAsyncValidators(validators) {
	        return isPresent(validators) ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) :
	            null;
	    }
	    function isPropertyUpdated(changes, viewModel) {
	        if (!changes.hasOwnProperty('model'))
	            return false;
	        var change = changes['model'];
	        if (change.isFirstChange())
	            return true;
	        return !looseIdentical(viewModel, change.currentValue);
	    }
	    var BUILTIN_ACCESSORS = [
	        CheckboxControlValueAccessor,
	        RangeValueAccessor,
	        NumberValueAccessor,
	        SelectControlValueAccessor,
	        SelectMultipleControlValueAccessor,
	        RadioControlValueAccessor,
	    ];
	    function isBuiltInAccessor(valueAccessor) {
	        return BUILTIN_ACCESSORS.some(function (a) { return valueAccessor.constructor === a; });
	    }
	    // TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
	    function selectValueAccessor(dir, valueAccessors) {
	        if (!valueAccessors)
	            return null;
	        var defaultAccessor;
	        var builtinAccessor;
	        var customAccessor;
	        valueAccessors.forEach(function (v) {
	            if (v.constructor === DefaultValueAccessor) {
	                defaultAccessor = v;
	            }
	            else if (isBuiltInAccessor(v)) {
	                if (builtinAccessor)
	                    _throwError(dir, 'More than one built-in value accessor matches form control with');
	                builtinAccessor = v;
	            }
	            else {
	                if (customAccessor)
	                    _throwError(dir, 'More than one custom value accessor matches form control with');
	                customAccessor = v;
	            }
	        });
	        if (customAccessor)
	            return customAccessor;
	        if (builtinAccessor)
	            return builtinAccessor;
	        if (defaultAccessor)
	            return defaultAccessor;
	        _throwError(dir, 'No valid value accessor for form control with');
	        return null;
	    }
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * This is a base class for code shared between {@link NgModelGroup} and {@link FormGroupName}.
	     *
	     * @stable
	     */
	    var AbstractFormGroupDirective = (function (_super) {
	        __extends(AbstractFormGroupDirective, _super);
	        function AbstractFormGroupDirective() {
	            _super.apply(this, arguments);
	        }
	        AbstractFormGroupDirective.prototype.ngOnInit = function () {
	            this._checkParentType();
	            this.formDirective.addFormGroup(this);
	        };
	        AbstractFormGroupDirective.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeFormGroup(this);
	            }
	        };
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "control", {
	            /**
	             * Get the {@link FormGroup} backing this binding.
	             */
	            get: function () { return this.formDirective.getFormGroup(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "path", {
	            /**
	             * Get the path to this control group.
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "formDirective", {
	            /**
	             * Get the {@link Form} to which this group belongs.
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "validator", {
	            get: function () { return composeValidators(this._validators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "asyncValidator", {
	            get: function () { return composeAsyncValidators(this._asyncValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        AbstractFormGroupDirective.prototype._checkParentType = function () { };
	        return AbstractFormGroupDirective;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var AbstractControlStatus = (function () {
	        function AbstractControlStatus(cd) {
	            this._cd = cd;
	        }
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassUntouched", {
	            get: function () { return this._cd.control ? this._cd.control.untouched : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassTouched", {
	            get: function () { return this._cd.control ? this._cd.control.touched : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassPristine", {
	            get: function () { return this._cd.control ? this._cd.control.pristine : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassDirty", {
	            get: function () { return this._cd.control ? this._cd.control.dirty : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassValid", {
	            get: function () { return this._cd.control ? this._cd.control.valid : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassInvalid", {
	            get: function () { return this._cd.control ? this._cd.control.invalid : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassPending", {
	            get: function () { return this._cd.control ? this._cd.control.pending : false; },
	            enumerable: true,
	            configurable: true
	        });
	        return AbstractControlStatus;
	    }());
	    var ngControlStatusHost = {
	        '[class.ng-untouched]': 'ngClassUntouched',
	        '[class.ng-touched]': 'ngClassTouched',
	        '[class.ng-pristine]': 'ngClassPristine',
	        '[class.ng-dirty]': 'ngClassDirty',
	        '[class.ng-valid]': 'ngClassValid',
	        '[class.ng-invalid]': 'ngClassInvalid',
	        '[class.ng-pending]': 'ngClassPending',
	    };
	    /**
	     * Directive automatically applied to Angular form controls that sets CSS classes
	     * based on control status (valid/invalid/dirty/etc).
	     *
	     * @stable
	     */
	    var NgControlStatus = (function (_super) {
	        __extends$3(NgControlStatus, _super);
	        function NgControlStatus(cd) {
	            _super.call(this, cd);
	        }
	        NgControlStatus.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost },] },
	        ];
	        /** @nocollapse */
	        NgControlStatus.ctorParameters = [
	            { type: NgControl, decorators: [{ type: _angular_core.Self },] },
	        ];
	        return NgControlStatus;
	    }(AbstractControlStatus));
	    /**
	     * Directive automatically applied to Angular form groups that sets CSS classes
	     * based on control status (valid/invalid/dirty/etc).
	     *
	     * @stable
	     */
	    var NgControlStatusGroup = (function (_super) {
	        __extends$3(NgControlStatusGroup, _super);
	        function NgControlStatusGroup(cd) {
	            _super.call(this, cd);
	        }
	        NgControlStatusGroup.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',
	                        host: ngControlStatusHost
	                    },] },
	        ];
	        /** @nocollapse */
	        NgControlStatusGroup.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Self },] },
	        ];
	        return NgControlStatusGroup;
	    }(AbstractControlStatus));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Use by directives and components to emit custom Events.
	     *
	     * ### Examples
	     *
	     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	     * title gets clicked:
	     *
	     * ```
	     * @Component({
	     *   selector: 'zippy',
	     *   template: `
	     *   <div class="zippy">
	     *     <div (click)="toggle()">Toggle</div>
	     *     <div [hidden]="!visible">
	     *       <ng-content></ng-content>
	     *     </div>
	     *  </div>`})
	     * export class Zippy {
	     *   visible: boolean = true;
	     *   @Output() open: EventEmitter<any> = new EventEmitter();
	     *   @Output() close: EventEmitter<any> = new EventEmitter();
	     *
	     *   toggle() {
	     *     this.visible = !this.visible;
	     *     if (this.visible) {
	     *       this.open.emit(null);
	     *     } else {
	     *       this.close.emit(null);
	     *     }
	     *   }
	     * }
	     * ```
	     *
	     * The events payload can be accessed by the parameter `$event` on the components output event
	     * handler:
	     *
	     * ```
	     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	     * ```
	     *
	     * Uses Rx.Observable but provides an adapter to make it work as specified here:
	     * https://github.com/jhusain/observable-spec
	     *
	     * Once a reference implementation of the spec is available, switch to it.
	     * @stable
	     */
	    var EventEmitter = (function (_super) {
	        __extends$5(EventEmitter, _super);
	        /**
	         * Creates an instance of [EventEmitter], which depending on [isAsync],
	         * delivers events synchronously or asynchronously.
	         */
	        function EventEmitter(isAsync) {
	            if (isAsync === void 0) { isAsync = false; }
	            _super.call(this);
	            this.__isAsync = isAsync;
	        }
	        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	            var schedulerFn;
	            var errorFn = function (err) { return null; };
	            var completeFn = function () { return null; };
	            if (generatorOrNext && typeof generatorOrNext === 'object') {
	                schedulerFn = this.__isAsync ? function (value) {
	                    setTimeout(function () { return generatorOrNext.next(value); });
	                } : function (value) { generatorOrNext.next(value); };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                        function (err) { generatorOrNext.error(err); };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                        function () { generatorOrNext.complete(); };
	                }
	            }
	            else {
	                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
	                    function (value) { generatorOrNext(value); };
	                if (error) {
	                    errorFn =
	                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	                }
	                if (complete) {
	                    completeFn =
	                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	                }
	            }
	            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	        };
	        return EventEmitter;
	    }(rxjs_Subject.Subject));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.
	     */
	    var VALID = 'VALID';
	    /**
	     * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.
	     */
	    var INVALID = 'INVALID';
	    /**
	     * Indicates that a FormControl is pending, i.e. that async validation is occurring and
	     * errors are not yet available for the input value.
	     */
	    var PENDING = 'PENDING';
	    /**
	     * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor
	     * calculations of validity or value.
	     */
	    var DISABLED = 'DISABLED';
	    function _find(control, path, delimiter) {
	        if (path == null)
	            return null;
	        if (!(path instanceof Array)) {
	            path = path.split(delimiter);
	        }
	        if (path instanceof Array && (path.length === 0))
	            return null;
	        return path.reduce(function (v, name) {
	            if (v instanceof FormGroup) {
	                return v.controls[name] || null;
	            }
	            if (v instanceof FormArray) {
	                return v.at(name) || null;
	            }
	            return null;
	        }, control);
	    }
	    function toObservable(r) {
	        return isPromise(r) ? rxjs_observable_fromPromise.fromPromise(r) : r;
	    }
	    function coerceToValidator(validator) {
	        return Array.isArray(validator) ? composeValidators(validator) : validator;
	    }
	    function coerceToAsyncValidator(asyncValidator) {
	        return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator;
	    }
	    /**
	     * @whatItDoes This is the base class for {@link FormControl}, {@link FormGroup}, and
	     * {@link FormArray}.
	     *
	     * It provides some of the shared behavior that all controls and groups of controls have, like
	     * running validators, calculating status, and resetting state. It also defines the properties
	     * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
	     * instantiated directly.
	     *
	     * @stable
	     */
	    var AbstractControl = (function () {
	        function AbstractControl(validator, asyncValidator) {
	            this.validator = validator;
	            this.asyncValidator = asyncValidator;
	            /** @internal */
	            this._onCollectionChange = function () { };
	            this._pristine = true;
	            this._touched = false;
	            /** @internal */
	            this._onDisabledChange = [];
	        }
	        Object.defineProperty(AbstractControl.prototype, "value", {
	            /**
	             * The value of the control.
	             */
	            get: function () { return this._value; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "parent", {
	            /**
	             * The parent control.
	             */
	            get: function () { return this._parent; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "status", {
	            /**
	             * The validation status of the control. There are four possible
	             * validation statuses:
	             *
	             * * **VALID**:  control has passed all validation checks
	             * * **INVALID**: control has failed at least one validation check
	             * * **PENDING**: control is in the midst of conducting a validation check
	             * * **DISABLED**: control is exempt from validation checks
	             *
	             * These statuses are mutually exclusive, so a control cannot be
	             * both valid AND invalid or invalid AND disabled.
	             */
	            get: function () { return this._status; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "valid", {
	            /**
	             * A control is `valid` when its `status === VALID`.
	             *
	             * In order to have this status, the control must have passed all its
	             * validation checks.
	             */
	            get: function () { return this._status === VALID; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "invalid", {
	            /**
	             * A control is `invalid` when its `status === INVALID`.
	             *
	             * In order to have this status, the control must have failed
	             * at least one of its validation checks.
	             */
	            get: function () { return this._status === INVALID; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "pending", {
	            /**
	             * A control is `pending` when its `status === PENDING`.
	             *
	             * In order to have this status, the control must be in the
	             * middle of conducting a validation check.
	             */
	            get: function () { return this._status == PENDING; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "disabled", {
	            /**
	             * A control is `disabled` when its `status === DISABLED`.
	             *
	             * Disabled controls are exempt from validation checks and
	             * are not included in the aggregate value of their ancestor
	             * controls.
	             */
	            get: function () { return this._status === DISABLED; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "enabled", {
	            /**
	             * A control is `enabled` as long as its `status !== DISABLED`.
	             *
	             * In other words, it has a status of `VALID`, `INVALID`, or
	             * `PENDING`.
	             */
	            get: function () { return this._status !== DISABLED; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "errors", {
	            /**
	             * Returns any errors generated by failing validation. If there
	             * are no errors, it will return null.
	             */
	            get: function () { return this._errors; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "pristine", {
	            /**
	             * A control is `pristine` if the user has not yet changed
	             * the value in the UI.
	             *
	             * Note that programmatic changes to a control's value will
	             * *not* mark it dirty.
	             */
	            get: function () { return this._pristine; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "dirty", {
	            /**
	             * A control is `dirty` if the user has changed the value
	             * in the UI.
	             *
	             * Note that programmatic changes to a control's value will
	             * *not* mark it dirty.
	             */
	            get: function () { return !this.pristine; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "touched", {
	            /**
	            * A control is marked `touched` once the user has triggered
	            * a `blur` event on it.
	            */
	            get: function () { return this._touched; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "untouched", {
	            /**
	             * A control is `untouched` if the user has not yet triggered
	             * a `blur` event on it.
	             */
	            get: function () { return !this._touched; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "valueChanges", {
	            /**
	             * Emits an event every time the value of the control changes, in
	             * the UI or programmatically.
	             */
	            get: function () { return this._valueChanges; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "statusChanges", {
	            /**
	             * Emits an event every time the validation status of the control
	             * is re-calculated.
	             */
	            get: function () { return this._statusChanges; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Sets the synchronous validators that are active on this control.  Calling
	         * this will overwrite any existing sync validators.
	         */
	        AbstractControl.prototype.setValidators = function (newValidator) {
	            this.validator = coerceToValidator(newValidator);
	        };
	        /**
	         * Sets the async validators that are active on this control. Calling this
	         * will overwrite any existing async validators.
	         */
	        AbstractControl.prototype.setAsyncValidators = function (newValidator) {
	            this.asyncValidator = coerceToAsyncValidator(newValidator);
	        };
	        /**
	         * Empties out the sync validator list.
	         */
	        AbstractControl.prototype.clearValidators = function () { this.validator = null; };
	        /**
	         * Empties out the async validator list.
	         */
	        AbstractControl.prototype.clearAsyncValidators = function () { this.asyncValidator = null; };
	        /**
	         * Marks the control as `touched`.
	         *
	         * This will also mark all direct ancestors as `touched` to maintain
	         * the model.
	         */
	        AbstractControl.prototype.markAsTouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = true;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `untouched`.
	         *
	         * If the control has any children, it will also mark all children as `untouched`
	         * to maintain the model, and re-calculate the `touched` status of all parent
	         * controls.
	         */
	        AbstractControl.prototype.markAsUntouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = false;
	            this._forEachChild(function (control) { control.markAsUntouched({ onlySelf: true }); });
	            if (this._parent && !onlySelf) {
	                this._parent._updateTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `dirty`.
	         *
	         * This will also mark all direct ancestors as `dirty` to maintain
	         * the model.
	         */
	        AbstractControl.prototype.markAsDirty = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = false;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsDirty({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `pristine`.
	         *
	         * If the control has any children, it will also mark all children as `pristine`
	         * to maintain the model, and re-calculate the `pristine` status of all parent
	         * controls.
	         */
	        AbstractControl.prototype.markAsPristine = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = true;
	            this._forEachChild(function (control) { control.markAsPristine({ onlySelf: true }); });
	            if (this._parent && !onlySelf) {
	                this._parent._updatePristine({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `pending`.
	         */
	        AbstractControl.prototype.markAsPending = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._status = PENDING;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsPending({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Disables the control. This means the control will be exempt from validation checks and
	         * excluded from the aggregate value of any parent. Its status is `DISABLED`.
	         *
	         * If the control has children, all children will be disabled to maintain the model.
	         */
	        AbstractControl.prototype.disable = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._status = DISABLED;
	            this._errors = null;
	            this._forEachChild(function (control) { control.disable({ onlySelf: true }); });
	            this._updateValue();
	            if (emitEvent !== false) {
	                this._valueChanges.emit(this._value);
	                this._statusChanges.emit(this._status);
	            }
	            this._updateAncestors(onlySelf);
	            this._onDisabledChange.forEach(function (changeFn) { return changeFn(true); });
	        };
	        /**
	         * Enables the control. This means the control will be included in validation checks and
	         * the aggregate value of its parent. Its status is re-calculated based on its value and
	         * its validators.
	         *
	         * If the control has children, all children will be enabled.
	         */
	        AbstractControl.prototype.enable = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._status = VALID;
	            this._forEachChild(function (control) { control.enable({ onlySelf: true }); });
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
	            this._updateAncestors(onlySelf);
	            this._onDisabledChange.forEach(function (changeFn) { return changeFn(false); });
	        };
	        AbstractControl.prototype._updateAncestors = function (onlySelf) {
	            if (this._parent && !onlySelf) {
	                this._parent.updateValueAndValidity();
	                this._parent._updatePristine();
	                this._parent._updateTouched();
	            }
	        };
	        AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
	        /**
	         * Re-calculates the value and validation status of the control.
	         *
	         * By default, it will also update the value and validity of its ancestors.
	         */
	        AbstractControl.prototype.updateValueAndValidity = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._setInitialStatus();
	            this._updateValue();
	            if (this.enabled) {
	                this._errors = this._runValidator();
	                this._status = this._calculateStatus();
	                if (this._status === VALID || this._status === PENDING) {
	                    this._runAsyncValidator(emitEvent);
	                }
	            }
	            if (emitEvent !== false) {
	                this._valueChanges.emit(this._value);
	                this._statusChanges.emit(this._status);
	            }
	            if (this._parent && !onlySelf) {
	                this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            }
	        };
	        /** @internal */
	        AbstractControl.prototype._updateTreeValidity = function (_a) {
	            var emitEvent = (_a === void 0 ? { emitEvent: true } : _a).emitEvent;
	            this._forEachChild(function (ctrl) { return ctrl._updateTreeValidity({ emitEvent: emitEvent }); });
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
	        };
	        AbstractControl.prototype._setInitialStatus = function () { this._status = this._allControlsDisabled() ? DISABLED : VALID; };
	        AbstractControl.prototype._runValidator = function () {
	            return this.validator ? this.validator(this) : null;
	        };
	        AbstractControl.prototype._runAsyncValidator = function (emitEvent) {
	            var _this = this;
	            if (this.asyncValidator) {
	                this._status = PENDING;
	                this._cancelExistingSubscription();
	                var obs = toObservable(this.asyncValidator(this));
	                this._asyncValidationSubscription =
	                    obs.subscribe({ next: function (res) { return _this.setErrors(res, { emitEvent: emitEvent }); } });
	            }
	        };
	        AbstractControl.prototype._cancelExistingSubscription = function () {
	            if (this._asyncValidationSubscription) {
	                this._asyncValidationSubscription.unsubscribe();
	            }
	        };
	        /**
	         * Sets errors on a form control.
	         *
	         * This is used when validations are run manually by the user, rather than automatically.
	         *
	         * Calling `setErrors` will also update the validity of the parent control.
	         *
	         * ### Example
	         *
	         * ```
	         * const login = new FormControl("someLogin");
	         * login.setErrors({
	         *   "notUnique": true
	         * });
	         *
	         * expect(login.valid).toEqual(false);
	         * expect(login.errors).toEqual({"notUnique": true});
	         *
	         * login.setValue("someOtherLogin");
	         *
	         * expect(login.valid).toEqual(true);
	         * ```
	         */
	        AbstractControl.prototype.setErrors = function (errors, _a) {
	            var emitEvent = (_a === void 0 ? {} : _a).emitEvent;
	            this._errors = errors;
	            this._updateControlsErrors(emitEvent !== false);
	        };
	        /**
	         * Retrieves a child control given the control's name or path.
	         *
	         * Paths can be passed in as an array or a string delimited by a dot.
	         *
	         * To get a control nested within a `person` sub-group:
	         *
	         * * `this.form.get('person.name');`
	         *
	         * -OR-
	         *
	         * * `this.form.get(['person', 'name']);`
	         */
	        AbstractControl.prototype.get = function (path) { return _find(this, path, '.'); };
	        /**
	         * Returns true if the control with the given path has the error specified. Otherwise
	         * returns null or undefined.
	         *
	         * If no path is given, it checks for the error on the present control.
	         */
	        AbstractControl.prototype.getError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            var control = path ? this.get(path) : this;
	            return control && control._errors ? control._errors[errorCode] : null;
	        };
	        /**
	         * Returns true if the control with the given path has the error specified. Otherwise
	         * returns false.
	         *
	         * If no path is given, it checks for the error on the present control.
	         */
	        AbstractControl.prototype.hasError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return !!this.getError(errorCode, path);
	        };
	        Object.defineProperty(AbstractControl.prototype, "root", {
	            /**
	             * Retrieves the top-level ancestor of this control.
	             */
	            get: function () {
	                var x = this;
	                while (x._parent) {
	                    x = x._parent;
	                }
	                return x;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        AbstractControl.prototype._updateControlsErrors = function (emitEvent) {
	            this._status = this._calculateStatus();
	            if (emitEvent) {
	                this._statusChanges.emit(this._status);
	            }
	            if (this._parent) {
	                this._parent._updateControlsErrors(emitEvent);
	            }
	        };
	        /** @internal */
	        AbstractControl.prototype._initObservables = function () {
	            this._valueChanges = new EventEmitter();
	            this._statusChanges = new EventEmitter();
	        };
	        AbstractControl.prototype._calculateStatus = function () {
	            if (this._allControlsDisabled())
	                return DISABLED;
	            if (this._errors)
	                return INVALID;
	            if (this._anyControlsHaveStatus(PENDING))
	                return PENDING;
	            if (this._anyControlsHaveStatus(INVALID))
	                return INVALID;
	            return VALID;
	        };
	        /** @internal */
	        AbstractControl.prototype._anyControlsHaveStatus = function (status) {
	            return this._anyControls(function (control) { return control.status === status; });
	        };
	        /** @internal */
	        AbstractControl.prototype._anyControlsDirty = function () {
	            return this._anyControls(function (control) { return control.dirty; });
	        };
	        /** @internal */
	        AbstractControl.prototype._anyControlsTouched = function () {
	            return this._anyControls(function (control) { return control.touched; });
	        };
	        /** @internal */
	        AbstractControl.prototype._updatePristine = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = !this._anyControlsDirty();
	            if (this._parent && !onlySelf) {
	                this._parent._updatePristine({ onlySelf: onlySelf });
	            }
	        };
	        /** @internal */
	        AbstractControl.prototype._updateTouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = this._anyControlsTouched();
	            if (this._parent && !onlySelf) {
	                this._parent._updateTouched({ onlySelf: onlySelf });
	            }
	        };
	        /** @internal */
	        AbstractControl.prototype._isBoxedValue = function (formState) {
	            return typeof formState === 'object' && formState !== null &&
	                Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
	        };
	        /** @internal */
	        AbstractControl.prototype._registerOnCollectionChange = function (fn) { this._onCollectionChange = fn; };
	        return AbstractControl;
	    }());
	    /**
	     * @whatItDoes Tracks the value and validation status of an individual form control.
	     *
	     * It is one of the three fundamental building blocks of Angular forms, along with
	     * {@link FormGroup} and {@link FormArray}.
	     *
	     * @howToUse
	     *
	     * When instantiating a {@link FormControl}, you can pass in an initial value as the
	     * first argument. Example:
	     *
	     * ```ts
	     * const ctrl = new FormControl('some value');
	     * console.log(ctrl.value);     // 'some value'
	     *```
	     *
	     * You can also initialize the control with a form state object on instantiation,
	     * which includes both the value and whether or not the control is disabled.
	     * You can't use the value key without the disabled key; both are required
	     * to use this way of initialization.
	     *
	     * ```ts
	     * const ctrl = new FormControl({value: 'n/a', disabled: true});
	     * console.log(ctrl.value);     // 'n/a'
	     * console.log(ctrl.status);   // 'DISABLED'
	     * ```
	     *
	     * To include a sync validator (or an array of sync validators) with the control,
	     * pass it in as the second argument. Async validators are also supported, but
	     * have to be passed in separately as the third arg.
	     *
	     * ```ts
	     * const ctrl = new FormControl('', Validators.required);
	     * console.log(ctrl.value);     // ''
	     * console.log(ctrl.status);   // 'INVALID'
	     * ```
	     *
	     * See its superclass, {@link AbstractControl}, for more properties and methods.
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * @stable
	     */
	    var FormControl = (function (_super) {
	        __extends$6(FormControl, _super);
	        function FormControl(formState, validator, asyncValidator) {
	            if (formState === void 0) { formState = null; }
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator));
	            /** @internal */
	            this._onChange = [];
	            this._applyFormState(formState);
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	            this._initObservables();
	        }
	        /**
	         * Set the value of the form control to `value`.
	         *
	         * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`
	         * and not its parent component. This defaults to false.
	         *
	         * If `emitEvent` is `true`, this
	         * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults
	         * to true (as it falls through to `updateValueAndValidity`).
	         *
	         * If `emitModelToViewChange` is `true`, the view will be notified about the new value
	         * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
	         * specified.
	         *
	         * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the
	         * model.  This is the default behavior if `emitViewToModelChange` is not specified.
	         */
	        FormControl.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange, emitViewToModelChange = _b.emitViewToModelChange;
	            this._value = value;
	            if (this._onChange.length && emitModelToViewChange !== false) {
	                this._onChange.forEach(function (changeFn) { return changeFn(_this._value, emitViewToModelChange !== false); });
	            }
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Patches the value of a control.
	         *
	         * This function is functionally the same as {@link FormControl.setValue} at this level.
	         * It exists for symmetry with {@link FormGroup.patchValue} on `FormGroups` and `FormArrays`,
	         * where it does behave differently.
	         */
	        FormControl.prototype.patchValue = function (value, options) {
	            if (options === void 0) { options = {}; }
	            this.setValue(value, options);
	        };
	        /**
	         * Resets the form control. This means by default:
	         *
	         * * it is marked as `pristine`
	         * * it is marked as `untouched`
	         * * value is set to null
	         *
	         * You can also reset to a specific form state by passing through a standalone
	         * value or a form state object that contains both a value and a disabled state
	         * (these are the only two properties that cannot be calculated).
	         *
	         * Ex:
	         *
	         * ```ts
	         * this.control.reset('Nancy');
	         *
	         * console.log(this.control.value);  // 'Nancy'
	         * ```
	         *
	         * OR
	         *
	         * ```
	         * this.control.reset({value: 'Nancy', disabled: true});
	         *
	         * console.log(this.control.value);  // 'Nancy'
	         * console.log(this.control.status);  // 'DISABLED'
	         * ```
	         */
	        FormControl.prototype.reset = function (formState, _a) {
	            if (formState === void 0) { formState = null; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._applyFormState(formState);
	            this.markAsPristine({ onlySelf: onlySelf });
	            this.markAsUntouched({ onlySelf: onlySelf });
	            this.setValue(this._value, { onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * @internal
	         */
	        FormControl.prototype._updateValue = function () { };
	        /**
	         * @internal
	         */
	        FormControl.prototype._anyControls = function (condition) { return false; };
	        /**
	         * @internal
	         */
	        FormControl.prototype._allControlsDisabled = function () { return this.disabled; };
	        /**
	         * Register a listener for change events.
	         */
	        FormControl.prototype.registerOnChange = function (fn) { this._onChange.push(fn); };
	        /**
	         * @internal
	         */
	        FormControl.prototype._clearChangeFns = function () {
	            this._onChange = [];
	            this._onDisabledChange = [];
	            this._onCollectionChange = function () { };
	        };
	        /**
	         * Register a listener for disabled events.
	         */
	        FormControl.prototype.registerOnDisabledChange = function (fn) {
	            this._onDisabledChange.push(fn);
	        };
	        /**
	         * @internal
	         */
	        FormControl.prototype._forEachChild = function (cb) { };
	        FormControl.prototype._applyFormState = function (formState) {
	            if (this._isBoxedValue(formState)) {
	                this._value = formState.value;
	                formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :
	                    this.enable({ onlySelf: true, emitEvent: false });
	            }
	            else {
	                this._value = formState;
	            }
	        };
	        return FormControl;
	    }(AbstractControl));
	    /**
	     * @whatItDoes Tracks the value and validity state of a group of {@link FormControl}
	     * instances.
	     *
	     * A `FormGroup` aggregates the values of each child {@link FormControl} into one object,
	     * with each control name as the key.  It calculates its status by reducing the statuses
	     * of its children. For example, if one of the controls in a group is invalid, the entire
	     * group becomes invalid.
	     *
	     * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,
	     * along with {@link FormControl} and {@link FormArray}.
	     *
	     * @howToUse
	     *
	     * When instantiating a {@link FormGroup}, pass in a collection of child controls as the first
	     * argument. The key for each child will be the name under which it is registered.
	     *
	     * ### Example
	     *
	     * ```
	     * const form = new FormGroup({
	     *   first: new FormControl('Nancy', Validators.minLength(2)),
	     *   last: new FormControl('Drew'),
	     * });
	     *
	     * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
	     * console.log(form.status);  // 'VALID'
	     * ```
	     *
	     * You can also include group-level validators as the second arg, or group-level async
	     * validators as the third arg. These come in handy when you want to perform validation
	     * that considers the value of more than one child control.
	     *
	     * ### Example
	     *
	     * ```
	     * const form = new FormGroup({
	     *   password: new FormControl('', Validators.minLength(2)),
	     *   passwordConfirm: new FormControl('', Validators.minLength(2)),
	     * }, passwordMatchValidator);
	     *
	     *
	     * function passwordMatchValidator(g: FormGroup) {
	     *    return g.get('password').value === g.get('passwordConfirm').value
	     *       ? null : {'mismatch': true};
	     * }
	     * ```
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * @stable
	     */
	    var FormGroup = (function (_super) {
	        __extends$6(FormGroup, _super);
	        function FormGroup(controls, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, validator, asyncValidator);
	            this.controls = controls;
	            this._initObservables();
	            this._setUpControls();
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        /**
	         * Registers a control with the group's list of controls.
	         *
	         * This method does not update value or validity of the control, so for
	         * most cases you'll want to use {@link FormGroup.addControl} instead.
	         */
	        FormGroup.prototype.registerControl = function (name, control) {
	            if (this.controls[name])
	                return this.controls[name];
	            this.controls[name] = control;
	            control.setParent(this);
	            control._registerOnCollectionChange(this._onCollectionChange);
	            return control;
	        };
	        /**
	         * Add a control to this group.
	         */
	        FormGroup.prototype.addControl = function (name, control) {
	            this.registerControl(name, control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Remove a control from this group.
	         */
	        FormGroup.prototype.removeControl = function (name) {
	            if (this.controls[name])
	                this.controls[name]._registerOnCollectionChange(function () { });
	            delete (this.controls[name]);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Replace an existing control.
	         */
	        FormGroup.prototype.setControl = function (name, control) {
	            if (this.controls[name])
	                this.controls[name]._registerOnCollectionChange(function () { });
	            delete (this.controls[name]);
	            if (control)
	                this.registerControl(name, control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Check whether there is an enabled control with the given name in the group.
	         *
	         * It will return false for disabled controls. If you'd like to check for
	         * existence in the group only, use {@link AbstractControl.get} instead.
	         */
	        FormGroup.prototype.contains = function (controlName) {
	            return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
	        };
	        /**
	         *  Sets the value of the {@link FormGroup}. It accepts an object that matches
	         *  the structure of the group, with control names as keys.
	         *
	         * This method performs strict checks, so it will throw an error if you try
	         * to set the value of a control that doesn't exist or if you exclude the
	         * value of a control.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const form = new FormGroup({
	         *     first: new FormControl(),
	         *     last: new FormControl()
	         *  });
	         *  console.log(form.value);   // {first: null, last: null}
	         *
	         *  form.setValue({first: 'Nancy', last: 'Drew'});
	         *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
	         *
	         *  ```
	         */
	        FormGroup.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._checkAllValuesPresent(value);
	            Object.keys(value).forEach(function (name) {
	                _this._throwIfControlMissing(name);
	                _this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         *  Patches the value of the {@link FormGroup}. It accepts an object with control
	         *  names as keys, and will do its best to match the values to the correct controls
	         *  in the group.
	         *
	         *  It accepts both super-sets and sub-sets of the group without throwing an error.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const form = new FormGroup({
	         *     first: new FormControl(),
	         *     last: new FormControl()
	         *  });
	         *  console.log(form.value);   // {first: null, last: null}
	         *
	         *  form.patchValue({first: 'Nancy'});
	         *  console.log(form.value);   // {first: 'Nancy', last: null}
	         *
	         *  ```
	         */
	        FormGroup.prototype.patchValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            Object.keys(value).forEach(function (name) {
	                if (_this.controls[name]) {
	                    _this.controls[name].patchValue(value[name], { onlySelf: true, emitEvent: emitEvent });
	                }
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Resets the {@link FormGroup}. This means by default:
	         *
	         * * The group and all descendants are marked `pristine`
	         * * The group and all descendants are marked `untouched`
	         * * The value of all descendants will be null or null maps
	         *
	         * You can also reset to a specific form state by passing in a map of states
	         * that matches the structure of your form, with control names as keys. The state
	         * can be a standalone value or a form state object with both a value and a disabled
	         * status.
	         *
	         * ### Example
	         *
	         * ```ts
	         * this.form.reset({first: 'name', last: 'last name'});
	         *
	         * console.log(this.form.value);  // {first: 'name', last: 'last name'}
	         * ```
	         *
	         * - OR -
	         *
	         * ```
	         * this.form.reset({
	         *   first: {value: 'name', disabled: true},
	         *   last: 'last'
	         * });
	         *
	         * console.log(this.form.value);  // {first: 'name', last: 'last name'}
	         * console.log(this.form.get('first').status);  // 'DISABLED'
	         * ```
	         */
	        FormGroup.prototype.reset = function (value, _a) {
	            if (value === void 0) { value = {}; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._forEachChild(function (control, name) {
	                control.reset(value[name], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            this._updatePristine({ onlySelf: onlySelf });
	            this._updateTouched({ onlySelf: onlySelf });
	        };
	        /**
	         * The aggregate value of the {@link FormGroup}, including any disabled controls.
	         *
	         * If you'd like to include all values regardless of disabled status, use this method.
	         * Otherwise, the `value` property is the best way to get the value of the group.
	         */
	        FormGroup.prototype.getRawValue = function () {
	            return this._reduceChildren({}, function (acc, control, name) {
	                acc[name] = control.value;
	                return acc;
	            });
	        };
	        /** @internal */
	        FormGroup.prototype._throwIfControlMissing = function (name) {
	            if (!Object.keys(this.controls).length) {
	                throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
	            }
	            if (!this.controls[name]) {
	                throw new Error("Cannot find form control with name: " + name + ".");
	            }
	        };
	        /** @internal */
	        FormGroup.prototype._forEachChild = function (cb) {
	            var _this = this;
	            Object.keys(this.controls).forEach(function (k) { return cb(_this.controls[k], k); });
	        };
	        /** @internal */
	        FormGroup.prototype._setUpControls = function () {
	            var _this = this;
	            this._forEachChild(function (control) {
	                control.setParent(_this);
	                control._registerOnCollectionChange(_this._onCollectionChange);
	            });
	        };
	        /** @internal */
	        FormGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
	        /** @internal */
	        FormGroup.prototype._anyControls = function (condition) {
	            var _this = this;
	            var res = false;
	            this._forEachChild(function (control, name) {
	                res = res || (_this.contains(name) && condition(control));
	            });
	            return res;
	        };
	        /** @internal */
	        FormGroup.prototype._reduceValue = function () {
	            var _this = this;
	            return this._reduceChildren({}, function (acc, control, name) {
	                if (control.enabled || _this.disabled) {
	                    acc[name] = control.value;
	                }
	                return acc;
	            });
	        };
	        /** @internal */
	        FormGroup.prototype._reduceChildren = function (initValue, fn) {
	            var res = initValue;
	            this._forEachChild(function (control, name) { res = fn(res, control, name); });
	            return res;
	        };
	        /** @internal */
	        FormGroup.prototype._allControlsDisabled = function () {
	            for (var _i = 0, _a = Object.keys(this.controls); _i < _a.length; _i++) {
	                var controlName = _a[_i];
	                if (this.controls[controlName].enabled) {
	                    return false;
	                }
	            }
	            return Object.keys(this.controls).length > 0 || this.disabled;
	        };
	        /** @internal */
	        FormGroup.prototype._checkAllValuesPresent = function (value) {
	            this._forEachChild(function (control, name) {
	                if (value[name] === undefined) {
	                    throw new Error("Must supply a value for form control with name: '" + name + "'.");
	                }
	            });
	        };
	        return FormGroup;
	    }(AbstractControl));
	    /**
	     * @whatItDoes Tracks the value and validity state of an array of {@link FormControl}
	     * instances.
	     *
	     * A `FormArray` aggregates the values of each child {@link FormControl} into an array.
	     * It calculates its status by reducing the statuses of its children. For example, if one of
	     * the controls in a `FormArray` is invalid, the entire array becomes invalid.
	     *
	     * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,
	     * along with {@link FormControl} and {@link FormGroup}.
	     *
	     * @howToUse
	     *
	     * When instantiating a {@link FormArray}, pass in an array of child controls as the first
	     * argument.
	     *
	     * ### Example
	     *
	     * ```
	     * const arr = new FormArray([
	     *   new FormControl('Nancy', Validators.minLength(2)),
	     *   new FormControl('Drew'),
	     * ]);
	     *
	     * console.log(arr.value);   // ['Nancy', 'Drew']
	     * console.log(arr.status);  // 'VALID'
	     * ```
	     *
	     * You can also include array-level validators as the second arg, or array-level async
	     * validators as the third arg. These come in handy when you want to perform validation
	     * that considers the value of more than one child control.
	     *
	     * ### Adding or removing controls
	     *
	     * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
	     * in `FormArray` itself. These methods ensure the controls are properly tracked in the
	     * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
	     * the `FormArray` directly, as that will result in strange and unexpected behavior such
	     * as broken change detection.
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * @stable
	     */
	    var FormArray = (function (_super) {
	        __extends$6(FormArray, _super);
	        function FormArray(controls, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, validator, asyncValidator);
	            this.controls = controls;
	            this._initObservables();
	            this._setUpControls();
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        /**
	         * Get the {@link AbstractControl} at the given `index` in the array.
	         */
	        FormArray.prototype.at = function (index) { return this.controls[index]; };
	        /**
	         * Insert a new {@link AbstractControl} at the end of the array.
	         */
	        FormArray.prototype.push = function (control) {
	            this.controls.push(control);
	            this._registerControl(control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Insert a new {@link AbstractControl} at the given `index` in the array.
	         */
	        FormArray.prototype.insert = function (index, control) {
	            this.controls.splice(index, 0, control);
	            this._registerControl(control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Remove the control at the given `index` in the array.
	         */
	        FormArray.prototype.removeAt = function (index) {
	            if (this.controls[index])
	                this.controls[index]._registerOnCollectionChange(function () { });
	            this.controls.splice(index, 1);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Replace an existing control.
	         */
	        FormArray.prototype.setControl = function (index, control) {
	            if (this.controls[index])
	                this.controls[index]._registerOnCollectionChange(function () { });
	            this.controls.splice(index, 1);
	            if (control) {
	                this.controls.splice(index, 0, control);
	                this._registerControl(control);
	            }
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        Object.defineProperty(FormArray.prototype, "length", {
	            /**
	             * Length of the control array.
	             */
	            get: function () { return this.controls.length; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         *  Sets the value of the {@link FormArray}. It accepts an array that matches
	         *  the structure of the control.
	         *
	         * This method performs strict checks, so it will throw an error if you try
	         * to set the value of a control that doesn't exist or if you exclude the
	         * value of a control.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const arr = new FormArray([
	         *     new FormControl(),
	         *     new FormControl()
	         *  ]);
	         *  console.log(arr.value);   // [null, null]
	         *
	         *  arr.setValue(['Nancy', 'Drew']);
	         *  console.log(arr.value);   // ['Nancy', 'Drew']
	         *  ```
	         */
	        FormArray.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._checkAllValuesPresent(value);
	            value.forEach(function (newValue, index) {
	                _this._throwIfControlMissing(index);
	                _this.at(index).setValue(newValue, { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         *  Patches the value of the {@link FormArray}. It accepts an array that matches the
	         *  structure of the control, and will do its best to match the values to the correct
	         *  controls in the group.
	         *
	         *  It accepts both super-sets and sub-sets of the array without throwing an error.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const arr = new FormArray([
	         *     new FormControl(),
	         *     new FormControl()
	         *  ]);
	         *  console.log(arr.value);   // [null, null]
	         *
	         *  arr.patchValue(['Nancy']);
	         *  console.log(arr.value);   // ['Nancy', null]
	         *  ```
	         */
	        FormArray.prototype.patchValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            value.forEach(function (newValue, index) {
	                if (_this.at(index)) {
	                    _this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: emitEvent });
	                }
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Resets the {@link FormArray}. This means by default:
	         *
	         * * The array and all descendants are marked `pristine`
	         * * The array and all descendants are marked `untouched`
	         * * The value of all descendants will be null or null maps
	         *
	         * You can also reset to a specific form state by passing in an array of states
	         * that matches the structure of the control. The state can be a standalone value
	         * or a form state object with both a value and a disabled status.
	         *
	         * ### Example
	         *
	         * ```ts
	         * this.arr.reset(['name', 'last name']);
	         *
	         * console.log(this.arr.value);  // ['name', 'last name']
	         * ```
	         *
	         * - OR -
	         *
	         * ```
	         * this.arr.reset([
	         *   {value: 'name', disabled: true},
	         *   'last'
	         * ]);
	         *
	         * console.log(this.arr.value);  // ['name', 'last name']
	         * console.log(this.arr.get(0).status);  // 'DISABLED'
	         * ```
	         */
	        FormArray.prototype.reset = function (value, _a) {
	            if (value === void 0) { value = []; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._forEachChild(function (control, index) {
	                control.reset(value[index], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            this._updatePristine({ onlySelf: onlySelf });
	            this._updateTouched({ onlySelf: onlySelf });
	        };
	        /**
	         * The aggregate value of the array, including any disabled controls.
	         *
	         * If you'd like to include all values regardless of disabled status, use this method.
	         * Otherwise, the `value` property is the best way to get the value of the array.
	         */
	        FormArray.prototype.getRawValue = function () { return this.controls.map(function (control) { return control.value; }); };
	        /** @internal */
	        FormArray.prototype._throwIfControlMissing = function (index) {
	            if (!this.controls.length) {
	                throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
	            }
	            if (!this.at(index)) {
	                throw new Error("Cannot find form control at index " + index);
	            }
	        };
	        /** @internal */
	        FormArray.prototype._forEachChild = function (cb) {
	            this.controls.forEach(function (control, index) { cb(control, index); });
	        };
	        /** @internal */
	        FormArray.prototype._updateValue = function () {
	            var _this = this;
	            this._value = this.controls.filter(function (control) { return control.enabled || _this.disabled; })
	                .map(function (control) { return control.value; });
	        };
	        /** @internal */
	        FormArray.prototype._anyControls = function (condition) {
	            return this.controls.some(function (control) { return control.enabled && condition(control); });
	        };
	        /** @internal */
	        FormArray.prototype._setUpControls = function () {
	            var _this = this;
	            this._forEachChild(function (control) { return _this._registerControl(control); });
	        };
	        /** @internal */
	        FormArray.prototype._checkAllValuesPresent = function (value) {
	            this._forEachChild(function (control, i) {
	                if (value[i] === undefined) {
	                    throw new Error("Must supply a value for form control at index: " + i + ".");
	                }
	            });
	        };
	        /** @internal */
	        FormArray.prototype._allControlsDisabled = function () {
	            for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {
	                var control = _a[_i];
	                if (control.enabled)
	                    return false;
	            }
	            return this.controls.length > 0 || this.disabled;
	        };
	        FormArray.prototype._registerControl = function (control) {
	            control.setParent(this);
	            control._registerOnCollectionChange(this._onCollectionChange);
	        };
	        return FormArray;
	    }(AbstractControl));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var formDirectiveProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return NgForm; })
	    };
	    var resolvedPromise = Promise.resolve(null);
	    /**
	     * @whatItDoes Creates a top-level {@link FormGroup} instance and binds it to a form
	     * to track aggregate form value and validation status.
	     *
	     * @howToUse
	     *
	     * As soon as you import the `FormsModule`, this directive becomes active by default on
	     * all `<form>` tags.  You don't need to add a special selector.
	     *
	     * You can export the directive into a local template variable using `ngForm` as the key
	     * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
	     * {@link FormGroup} instance are duplicated on the directive itself, so a reference to it
	     * will give you access to the aggregate value and validity status of the form, as well as
	     * user interaction properties like `dirty` and `touched`.
	     *
	     * To register child controls with the form, you'll want to use {@link NgModel} with a
	     * `name` attribute.  You can also use {@link NgModelGroup} if you'd like to create
	     * sub-groups within the form.
	     *
	     * You can listen to the directive's `ngSubmit` event to be notified when the user has
	     * triggered a form submission. The `ngSubmit` event will be emitted with the original form
	     * submission event.
	     *
	     * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * * **NgModule**: `FormsModule`
	     *
	     *  @stable
	     */
	    var NgForm = (function (_super) {
	        __extends$4(NgForm, _super);
	        function NgForm(validators, asyncValidators) {
	            _super.call(this);
	            this._submitted = false;
	            this.ngSubmit = new EventEmitter();
	            this.form =
	                new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
	        }
	        Object.defineProperty(NgForm.prototype, "submitted", {
	            get: function () { return this._submitted; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "formDirective", {
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "control", {
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "path", {
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "controls", {
	            get: function () { return this.form.controls; },
	            enumerable: true,
	            configurable: true
	        });
	        NgForm.prototype.addControl = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var container = _this._findContainer(dir.path);
	                dir._control = container.registerControl(dir.name, dir.control);
	                setUpControl(dir.control, dir);
	                dir.control.updateValueAndValidity({ emitEvent: false });
	            });
	        };
	        NgForm.prototype.getControl = function (dir) { return this.form.get(dir.path); };
	        NgForm.prototype.removeControl = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var container = _this._findContainer(dir.path);
	                if (container) {
	                    container.removeControl(dir.name);
	                }
	            });
	        };
	        NgForm.prototype.addFormGroup = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var container = _this._findContainer(dir.path);
	                var group = new FormGroup({});
	                setUpFormContainer(group, dir);
	                container.registerControl(dir.name, group);
	                group.updateValueAndValidity({ emitEvent: false });
	            });
	        };
	        NgForm.prototype.removeFormGroup = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var container = _this._findContainer(dir.path);
	                if (container) {
	                    container.removeControl(dir.name);
	                }
	            });
	        };
	        NgForm.prototype.getFormGroup = function (dir) { return this.form.get(dir.path); };
	        NgForm.prototype.updateModel = function (dir, value) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var ctrl = _this.form.get(dir.path);
	                ctrl.setValue(value);
	            });
	        };
	        NgForm.prototype.setValue = function (value) { this.control.setValue(value); };
	        NgForm.prototype.onSubmit = function ($event) {
	            this._submitted = true;
	            this.ngSubmit.emit($event);
	            return false;
	        };
	        NgForm.prototype.onReset = function () { this.resetForm(); };
	        NgForm.prototype.resetForm = function (value) {
	            if (value === void 0) { value = undefined; }
	            this.form.reset(value);
	            this._submitted = false;
	        };
	        /** @internal */
	        NgForm.prototype._findContainer = function (path) {
	            path.pop();
	            return path.length ? this.form.get(path) : this.form;
	        };
	        NgForm.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',
	                        providers: [formDirectiveProvider],
	                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
	                        outputs: ['ngSubmit'],
	                        exportAs: 'ngForm'
	                    },] },
	        ];
	        /** @nocollapse */
	        NgForm.ctorParameters = [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ];
	        return NgForm;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var Examples = {
	        formControlName: "\n    <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });",
	        formGroupName: "\n    <div [formGroup]=\"myGroup\">\n       <div formGroupName=\"person\">\n          <input formControlName=\"firstName\">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });",
	        formArrayName: "\n    <div [formGroup]=\"myGroup\">\n      <div formArrayName=\"cities\">\n        <div *ngFor=\"let city of cityArray.controls; let i=index\">\n          <input [formControlName]=\"i\">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl('SF')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });",
	        ngModelGroup: "\n    <form>\n       <div ngModelGroup=\"person\">\n          <input [(ngModel)]=\"person.name\" name=\"firstName\">\n       </div>\n    </form>",
	        ngModelWithFormGroup: "\n    <div [formGroup]=\"myGroup\">\n       <input formControlName=\"firstName\">\n       <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n    </div>\n  "
	    };
	
	    var TemplateDrivenErrors = (function () {
	        function TemplateDrivenErrors() {
	        }
	        TemplateDrivenErrors.modelParentException = function () {
	            throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup's partner directive \"formControlName\" instead.  Example:\n\n      " + Examples.formControlName + "\n\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n      Example:\n\n      " + Examples.ngModelWithFormGroup);
	        };
	        TemplateDrivenErrors.formGroupNameException = function () {
	            throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      " + Examples.formGroupName + "\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      " + Examples.ngModelGroup);
	        };
	        TemplateDrivenErrors.missingNameException = function () {
	            throw new Error("If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as 'standalone' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]=\"person.firstName\" name=\"first\">\n      Example 2: <input [(ngModel)]=\"person.firstName\" [ngModelOptions]=\"{standalone: true}\">");
	        };
	        TemplateDrivenErrors.modelGroupParentException = function () {
	            throw new Error("\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      " + Examples.formGroupName + "\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      " + Examples.ngModelGroup);
	        };
	        return TemplateDrivenErrors;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var modelGroupProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return NgModelGroup; })
	    };
	    /**
	     * @whatItDoes Creates and binds a {@link FormGroup} instance to a DOM element.
	     *
	     * @howToUse
	     *
	     * This directive can only be used as a child of {@link NgForm} (or in other words,
	     * within `<form>` tags).
	     *
	     * Use this directive if you'd like to create a sub-group within a form. This can
	     * come in handy if you want to validate a sub-group of your form separately from
	     * the rest of your form, or if some values in your domain model make more sense to
	     * consume together in a nested object.
	     *
	     * Pass in the name you'd like this sub-group to have and it will become the key
	     * for the sub-group in the form's full value. You can also export the directive into
	     * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
	     *
	     * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * * **NgModule**: `FormsModule`
	     *
	     * @stable
	     */
	    var NgModelGroup = (function (_super) {
	        __extends$8(NgModelGroup, _super);
	        function NgModelGroup(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /** @internal */
	        NgModelGroup.prototype._checkParentType = function () {
	            if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
	                TemplateDrivenErrors.modelGroupParentException();
	            }
	        };
	        NgModelGroup.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' },] },
	        ];
	        /** @nocollapse */
	        NgModelGroup.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ];
	        NgModelGroup.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['ngModelGroup',] },],
	        };
	        return NgModelGroup;
	    }(AbstractFormGroupDirective));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var formControlBinding = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return NgModel; })
	    };
	    /**
	     * `ngModel` forces an additional change detection run when its inputs change:
	     * E.g.:
	     * ```
	     * <div>{{myModel.valid}}</div>
	     * <input [(ngModel)]="myValue" #myModel="ngModel">
	     * ```
	     * I.e. `ngModel` can export itself on the element and then be used in the template.
	     * Normally, this would result in expressions before the `input` that use the exported directive
	     * to have and old value as they have been
	     * dirty checked before. As this is a very common case for `ngModel`, we added this second change
	     * detection run.
	     *
	     * Notes:
	     * - this is just one extra run no matter how many `ngModel` have been changed.
	     * - this is a general problem when using `exportAs` for directives!
	     */
	    var resolvedPromise$1 = Promise.resolve(null);
	    /**
	     * @whatItDoes Creates a {@link FormControl} instance from a domain model and binds it
	     * to a form control element.
	     *
	     * The {@link FormControl} instance will track the value, user interaction, and
	     * validation status of the control and keep the view synced with the model. If used
	     * within a parent form, the directive will also register itself with the form as a child
	     * control.
	     *
	     * @howToUse
	     *
	     * This directive can be used by itself or as part of a larger form. All you need is the
	     * `ngModel` selector to activate it.
	     *
	     * It accepts a domain model as an optional {@link @Input}. If you have a one-way binding
	     * to `ngModel` with `[]` syntax, changing the value of the domain model in the component
	     * class will set the value in the view. If you have a two-way binding with `[()]` syntax
	     * (also known as 'banana-box syntax'), the value in the UI will always be synced back to
	     * the domain model in your class as well.
	     *
	     * If you wish to inspect the properties of the associated {@link FormControl} (like
	     * validity state), you can also export the directive into a local template variable using
	     * `ngModel` as the key (ex: `#myVar="ngModel"`). You can then access the control using the
	     * directive's `control` property, but most properties you'll need (like `valid` and `dirty`)
	     * will fall through to the control anyway, so you can access them directly. You can see a
	     * full list of properties directly available in {@link AbstractControlDirective}.
	     *
	     * The following is an example of a simple standalone control using `ngModel`:
	     *
	     * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
	     *
	     * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
	     * so that the control can be registered with the parent form under that name.
	     *
	     * It's worth noting that in the context of a parent form, you often can skip one-way or
	     * two-way binding because the parent form will sync the value for you. You can access
	     * its properties by exporting it into a local template variable using `ngForm` (ex:
	     * `#f="ngForm"`). Then you can pass it where it needs to go on submit.
	     *
	     * If you do need to populate initial values into your form, using a one-way binding for
	     * `ngModel` tends to be sufficient as long as you use the exported form's value rather
	     * than the domain model's value on submit.
	     *
	     * Take a look at an example of using `ngModel` within a form:
	     *
	     * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
	     *
	     * To see `ngModel` examples with different form control types, see:
	     *
	     * * Radio buttons: {@link RadioControlValueAccessor}
	     * * Selects: {@link SelectControlValueAccessor}
	     *
	     * **npm package**: `@angular/forms`
	     *
	     * **NgModule**: `FormsModule`
	     *
	     *  @stable
	     */
	    var NgModel = (function (_super) {
	        __extends$7(NgModel, _super);
	        function NgModel(parent, validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            /** @internal */
	            this._control = new FormControl();
	            /** @internal */
	            this._registered = false;
	            this.update = new EventEmitter();
	            this._parent = parent;
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        NgModel.prototype.ngOnChanges = function (changes) {
	            this._checkForErrors();
	            if (!this._registered)
	                this._setUpControl();
	            if ('isDisabled' in changes) {
	                this._updateDisabled(changes);
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this._updateValue(this.model);
	                this.viewModel = this.model;
	            }
	        };
	        NgModel.prototype.ngOnDestroy = function () { this.formDirective && this.formDirective.removeControl(this); };
	        Object.defineProperty(NgModel.prototype, "control", {
	            get: function () { return this._control; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "path", {
	            get: function () {
	                return this._parent ? controlPath(this.name, this._parent) : [this.name];
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "formDirective", {
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "validator", {
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "asyncValidator", {
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        NgModel.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        NgModel.prototype._setUpControl = function () {
	            this._isStandalone() ? this._setUpStandalone() :
	                this.formDirective.addControl(this);
	            this._registered = true;
	        };
	        NgModel.prototype._isStandalone = function () {
	            return !this._parent || (this.options && this.options.standalone);
	        };
	        NgModel.prototype._setUpStandalone = function () {
	            setUpControl(this._control, this);
	            this._control.updateValueAndValidity({ emitEvent: false });
	        };
	        NgModel.prototype._checkForErrors = function () {
	            if (!this._isStandalone()) {
	                this._checkParentType();
	            }
	            this._checkName();
	        };
	        NgModel.prototype._checkParentType = function () {
	            if (!(this._parent instanceof NgModelGroup) &&
	                this._parent instanceof AbstractFormGroupDirective) {
	                TemplateDrivenErrors.formGroupNameException();
	            }
	            else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
	                TemplateDrivenErrors.modelParentException();
	            }
	        };
	        NgModel.prototype._checkName = function () {
	            if (this.options && this.options.name)
	                this.name = this.options.name;
	            if (!this._isStandalone() && !this.name) {
	                TemplateDrivenErrors.missingNameException();
	            }
	        };
	        NgModel.prototype._updateValue = function (value) {
	            var _this = this;
	            resolvedPromise$1.then(function () { _this.control.setValue(value, { emitViewToModelChange: false }); });
	        };
	        NgModel.prototype._updateDisabled = function (changes) {
	            var _this = this;
	            var disabledValue = changes['isDisabled'].currentValue;
	            var isDisabled = disabledValue === '' || (disabledValue && disabledValue !== 'false');
	            resolvedPromise$1.then(function () {
	                if (isDisabled && !_this.control.disabled) {
	                    _this.control.disable();
	                }
	                else if (!isDisabled && _this.control.disabled) {
	                    _this.control.enable();
	                }
	            });
	        };
	        NgModel.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[ngModel]:not([formControlName]):not([formControl])',
	                        providers: [formControlBinding],
	                        exportAs: 'ngModel'
	                    },] },
	        ];
	        /** @nocollapse */
	        NgModel.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ];
	        NgModel.propDecorators = {
	            'name': [{ type: _angular_core.Input },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'options': [{ type: _angular_core.Input, args: ['ngModelOptions',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	        };
	        return NgModel;
	    }(NgControl));
	
	    var ReactiveErrors = (function () {
	        function ReactiveErrors() {
	        }
	        ReactiveErrors.controlParentException = function () {
	            throw new Error("formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + Examples.formControlName);
	        };
	        ReactiveErrors.ngModelGroupException = function () {
	            throw new Error("formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        " + Examples.formGroupName + "\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        " + Examples.ngModelGroup);
	        };
	        ReactiveErrors.missingFormException = function () {
	            throw new Error("formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       " + Examples.formControlName);
	        };
	        ReactiveErrors.groupParentException = function () {
	            throw new Error("formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + Examples.formGroupName);
	        };
	        ReactiveErrors.arrayParentException = function () {
	            throw new Error("formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        " + Examples.formArrayName);
	        };
	        ReactiveErrors.disabledAttrWarning = function () {
	            console.warn("\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    ");
	        };
	        return ReactiveErrors;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$9 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var formControlBinding$1 = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return FormControlDirective; })
	    };
	    /**
	     * @whatItDoes Syncs a standalone {@link FormControl} instance to a form control element.
	     *
	     * In other words, this directive ensures that any values written to the {@link FormControl}
	     * instance programmatically will be written to the DOM element (model -> view). Conversely,
	     * any values written to the DOM element through user input will be reflected in the
	     * {@link FormControl} instance (view -> model).
	     *
	     * @howToUse
	     *
	     * Use this directive if you'd like to create and manage a {@link FormControl} instance directly.
	     * Simply create a {@link FormControl}, save it to your component class, and pass it into the
	     * {@link FormControlDirective}.
	     *
	     * This directive is designed to be used as a standalone control.  Unlike {@link FormControlName},
	     * it does not require that your {@link FormControl} instance be part of any parent
	     * {@link FormGroup}, and it won't be registered to any {@link FormGroupDirective} that
	     * exists above it.
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {@link FormControl} instance. See a full list of available properties in
	     * {@link AbstractControl}.
	     *
	     * **Set the value**: You can pass in an initial value when instantiating the {@link FormControl},
	     * or you can set it programmatically later using {@link AbstractControl.setValue} or
	     * {@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the control, you can
	     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to
	     * {@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     *  @stable
	     */
	    var FormControlDirective = (function (_super) {
	        __extends$9(FormControlDirective, _super);
	        function FormControlDirective(validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            this.update = new EventEmitter();
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        Object.defineProperty(FormControlDirective.prototype, "isDisabled", {
	            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
	            enumerable: true,
	            configurable: true
	        });
	        FormControlDirective.prototype.ngOnChanges = function (changes) {
	            if (this._isControlChanged(changes)) {
	                setUpControl(this.form, this);
	                if (this.control.disabled && this.valueAccessor.setDisabledState) {
	                    this.valueAccessor.setDisabledState(true);
	                }
	                this.form.updateValueAndValidity({ emitEvent: false });
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.form.setValue(this.model);
	                this.viewModel = this.model;
	            }
	        };
	        Object.defineProperty(FormControlDirective.prototype, "path", {
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "validator", {
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "asyncValidator", {
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "control", {
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        FormControlDirective.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        FormControlDirective.prototype._isControlChanged = function (changes) {
	            return changes.hasOwnProperty('form');
	        };
	        FormControlDirective.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControl]', providers: [formControlBinding$1], exportAs: 'ngForm' },] },
	        ];
	        /** @nocollapse */
	        FormControlDirective.ctorParameters = [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ];
	        FormControlDirective.propDecorators = {
	            'form': [{ type: _angular_core.Input, args: ['formControl',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	        };
	        return FormControlDirective;
	    }(NgControl));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$11 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var formDirectiveProvider$1 = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormGroupDirective; })
	    };
	    /**
	     * @whatItDoes Binds an existing {@link FormGroup} to a DOM element.
	     *
	     * @howToUse
	     *
	     * This directive accepts an existing {@link FormGroup} instance. It will then use this
	     * {@link FormGroup} instance to match any child {@link FormControl}, {@link FormGroup},
	     * and {@link FormArray} instances to child {@link FormControlName}, {@link FormGroupName},
	     * and {@link FormArrayName} directives.
	     *
	     * **Set value**: You can set the form's initial value when instantiating the
	     * {@link FormGroup}, or you can set it programmatically later using the {@link FormGroup}'s
	     * {@link AbstractControl.setValue} or {@link AbstractControl.patchValue} methods.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the form, you can subscribe
	     * to the {@link FormGroup}'s {@link AbstractControl.valueChanges} event.  You can also listen to
	     * its {@link AbstractControl.statusChanges} event to be notified when the validation status is
	     * re-calculated.
	     *
	     * Furthermore, you can listen to the directive's `ngSubmit` event to be notified when the user has
	     * triggered a form submission. The `ngSubmit` event will be emitted with the original form
	     * submission event.
	     *
	     * ### Example
	     *
	     * In this example, we create form controls for first name and last name.
	     *
	     * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
	     *
	     * **npm package**: `@angular/forms`
	     *
	     * **NgModule**: {@link ReactiveFormsModule}
	     *
	     *  @stable
	     */
	    var FormGroupDirective = (function (_super) {
	        __extends$11(FormGroupDirective, _super);
	        function FormGroupDirective(_validators, _asyncValidators) {
	            _super.call(this);
	            this._validators = _validators;
	            this._asyncValidators = _asyncValidators;
	            this._submitted = false;
	            this.directives = [];
	            this.form = null;
	            this.ngSubmit = new EventEmitter();
	        }
	        FormGroupDirective.prototype.ngOnChanges = function (changes) {
	            this._checkFormPresent();
	            if (changes.hasOwnProperty('form')) {
	                this._updateValidators();
	                this._updateDomValue();
	                this._updateRegistrations();
	            }
	        };
	        Object.defineProperty(FormGroupDirective.prototype, "submitted", {
	            get: function () { return this._submitted; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "formDirective", {
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "control", {
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "path", {
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        FormGroupDirective.prototype.addControl = function (dir) {
	            var ctrl = this.form.get(dir.path);
	            setUpControl(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	            this.directives.push(dir);
	            return ctrl;
	        };
	        FormGroupDirective.prototype.getControl = function (dir) { return this.form.get(dir.path); };
	        FormGroupDirective.prototype.removeControl = function (dir) { ListWrapper.remove(this.directives, dir); };
	        FormGroupDirective.prototype.addFormGroup = function (dir) {
	            var ctrl = this.form.get(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        };
	        FormGroupDirective.prototype.removeFormGroup = function (dir) { };
	        FormGroupDirective.prototype.getFormGroup = function (dir) { return this.form.get(dir.path); };
	        FormGroupDirective.prototype.addFormArray = function (dir) {
	            var ctrl = this.form.get(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        };
	        FormGroupDirective.prototype.removeFormArray = function (dir) { };
	        FormGroupDirective.prototype.getFormArray = function (dir) { return this.form.get(dir.path); };
	        FormGroupDirective.prototype.updateModel = function (dir, value) {
	            var ctrl = this.form.get(dir.path);
	            ctrl.setValue(value);
	        };
	        FormGroupDirective.prototype.onSubmit = function ($event) {
	            this._submitted = true;
	            this.ngSubmit.emit($event);
	            return false;
	        };
	        FormGroupDirective.prototype.onReset = function () { this.resetForm(); };
	        FormGroupDirective.prototype.resetForm = function (value) {
	            if (value === void 0) { value = undefined; }
	            this.form.reset(value);
	            this._submitted = false;
	        };
	        /** @internal */
	        FormGroupDirective.prototype._updateDomValue = function () {
	            var _this = this;
	            this.directives.forEach(function (dir) {
	                var newCtrl = _this.form.get(dir.path);
	                if (dir._control !== newCtrl) {
	                    cleanUpControl(dir._control, dir);
	                    if (newCtrl)
	                        setUpControl(newCtrl, dir);
	                    dir._control = newCtrl;
	                }
	            });
	            this.form._updateTreeValidity({ emitEvent: false });
	        };
	        FormGroupDirective.prototype._updateRegistrations = function () {
	            var _this = this;
	            this.form._registerOnCollectionChange(function () { return _this._updateDomValue(); });
	            if (this._oldForm)
	                this._oldForm._registerOnCollectionChange(function () { });
	            this._oldForm = this.form;
	        };
	        FormGroupDirective.prototype._updateValidators = function () {
	            var sync = composeValidators(this._validators);
	            this.form.validator = Validators.compose([this.form.validator, sync]);
	            var async = composeAsyncValidators(this._asyncValidators);
	            this.form.asyncValidator = Validators.composeAsync([this.form.asyncValidator, async]);
	        };
	        FormGroupDirective.prototype._checkFormPresent = function () {
	            if (!this.form) {
	                ReactiveErrors.missingFormException();
	            }
	        };
	        FormGroupDirective.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[formGroup]',
	                        providers: [formDirectiveProvider$1],
	                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
	                        exportAs: 'ngForm'
	                    },] },
	        ];
	        /** @nocollapse */
	        FormGroupDirective.ctorParameters = [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ];
	        FormGroupDirective.propDecorators = {
	            'form': [{ type: _angular_core.Input, args: ['formGroup',] },],
	            'ngSubmit': [{ type: _angular_core.Output },],
	        };
	        return FormGroupDirective;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$12 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var formGroupNameProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormGroupName; })
	    };
	    /**
	     * @whatItDoes Syncs a nested {@link FormGroup} to a DOM element.
	     *
	     * @howToUse
	     *
	     * This directive can only be used with a parent {@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the nested {@link FormGroup} you want to link, and
	     * will look for a {@link FormGroup} registered with that name in the parent
	     * {@link FormGroup} instance you passed into {@link FormGroupDirective}.
	     *
	     * Nested form groups can come in handy when you want to validate a sub-group of a
	     * form separately from the rest or when you'd like to group the values of certain
	     * controls into their own nested object.
	     *
	     * **Access the group**: You can access the associated {@link FormGroup} using the
	     * {@link AbstractControl.get} method. Ex: `this.form.get('name')`.
	     *
	     * You can also access individual controls within the group using dot syntax.
	     * Ex: `this.form.get('name.first')`
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {@link FormGroup}. See a full list of available properties in {@link AbstractControl}.
	     *
	     * **Set the value**: You can set an initial value for each child control when instantiating
	     * the {@link FormGroup}, or you can set it programmatically later using
	     * {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the group, you can
	     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to
	     * {@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     * @stable
	     */
	    var FormGroupName = (function (_super) {
	        __extends$12(FormGroupName, _super);
	        function FormGroupName(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /** @internal */
	        FormGroupName.prototype._checkParentType = function () {
	            if (_hasInvalidParent(this._parent)) {
	                ReactiveErrors.groupParentException();
	            }
	        };
	        FormGroupName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] },] },
	        ];
	        /** @nocollapse */
	        FormGroupName.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ];
	        FormGroupName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formGroupName',] },],
	        };
	        return FormGroupName;
	    }(AbstractFormGroupDirective));
	    var formArrayNameProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormArrayName; })
	    };
	    /**
	     * @whatItDoes Syncs a nested {@link FormArray} to a DOM element.
	     *
	     * @howToUse
	     *
	     * This directive is designed to be used with a parent {@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the nested {@link FormArray} you want to link, and
	     * will look for a {@link FormArray} registered with that name in the parent
	     * {@link FormGroup} instance you passed into {@link FormGroupDirective}.
	     *
	     * Nested form arrays can come in handy when you have a group of form controls but
	     * you're not sure how many there will be. Form arrays allow you to create new
	     * form controls dynamically.
	     *
	     * **Access the array**: You can access the associated {@link FormArray} using the
	     * {@link AbstractControl.get} method on the parent {@link FormGroup}.
	     * Ex: `this.form.get('cities')`.
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {@link FormArray}. See a full list of available properties in {@link AbstractControl}.
	     *
	     * **Set the value**: You can set an initial value for each child control when instantiating
	     * the {@link FormArray}, or you can set the value programmatically later using the
	     * {@link FormArray}'s {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}
	     * methods.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the array, you can
	     * subscribe to the {@link FormArray}'s {@link AbstractControl.valueChanges} event.  You can also
	     * listen to its {@link AbstractControl.statusChanges} event to be notified when the validation
	     * status is re-calculated.
	     *
	     * **Add new controls**: You can add new controls to the {@link FormArray} dynamically by
	     * calling its {@link FormArray.push} method.
	     *  Ex: `this.form.get('cities').push(new FormControl());`
	     *
	     * ### Example
	     *
	     * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     * @stable
	     */
	    var FormArrayName = (function (_super) {
	        __extends$12(FormArrayName, _super);
	        function FormArrayName(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        FormArrayName.prototype.ngOnInit = function () {
	            this._checkParentType();
	            this.formDirective.addFormArray(this);
	        };
	        FormArrayName.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeFormArray(this);
	            }
	        };
	        Object.defineProperty(FormArrayName.prototype, "control", {
	            get: function () { return this.formDirective.getFormArray(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "formDirective", {
	            get: function () {
	                return this._parent ? this._parent.formDirective : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "path", {
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "validator", {
	            get: function () { return composeValidators(this._validators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "asyncValidator", {
	            get: function () { return composeAsyncValidators(this._asyncValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        FormArrayName.prototype._checkParentType = function () {
	            if (_hasInvalidParent(this._parent)) {
	                ReactiveErrors.arrayParentException();
	            }
	        };
	        FormArrayName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] },] },
	        ];
	        /** @nocollapse */
	        FormArrayName.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ];
	        FormArrayName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formArrayName',] },],
	        };
	        return FormArrayName;
	    }(ControlContainer));
	    function _hasInvalidParent(parent) {
	        return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&
	            !(parent instanceof FormArrayName);
	    }
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$10 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var controlNameBinding = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return FormControlName; })
	    };
	    /**
	     * @whatItDoes  Syncs a {@link FormControl} in an existing {@link FormGroup} to a form control
	     * element by name.
	     *
	     * In other words, this directive ensures that any values written to the {@link FormControl}
	     * instance programmatically will be written to the DOM element (model -> view). Conversely,
	     * any values written to the DOM element through user input will be reflected in the
	     * {@link FormControl} instance (view -> model).
	     *
	     * @howToUse
	     *
	     * This directive is designed to be used with a parent {@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the {@link FormControl} instance you want to
	     * link, and will look for a {@link FormControl} registered with that name in the
	     * closest {@link FormGroup} or {@link FormArray} above it.
	     *
	     * **Access the control**: You can access the {@link FormControl} associated with
	     * this directive by using the {@link AbstractControl.get} method.
	     * Ex: `this.form.get('first');`
	     *
	     * **Get value**: the `value` property is always synced and available on the {@link FormControl}.
	     * See a full list of available properties in {@link AbstractControl}.
	     *
	     *  **Set value**: You can set an initial value for the control when instantiating the
	     *  {@link FormControl}, or you can set it programmatically later using
	     *  {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the control, you can
	     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to
	     * {@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * In this example, we create form controls for first name and last name.
	     *
	     * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
	     *
	     * To see `formControlName` examples with different form control types, see:
	     *
	     * * Radio buttons: {@link RadioControlValueAccessor}
	     * * Selects: {@link SelectControlValueAccessor}
	     *
	     * **npm package**: `@angular/forms`
	     *
	     * **NgModule**: {@link ReactiveFormsModule}
	     *
	     *  @stable
	     */
	    var FormControlName = (function (_super) {
	        __extends$10(FormControlName, _super);
	        function FormControlName(parent, validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            this._added = false;
	            this.update = new EventEmitter();
	            this._parent = parent;
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        Object.defineProperty(FormControlName.prototype, "isDisabled", {
	            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
	            enumerable: true,
	            configurable: true
	        });
	        FormControlName.prototype.ngOnChanges = function (changes) {
	            if (!this._added)
	                this._setUpControl();
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.viewModel = this.model;
	                this.formDirective.updateModel(this, this.model);
	            }
	        };
	        FormControlName.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeControl(this);
	            }
	        };
	        FormControlName.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        Object.defineProperty(FormControlName.prototype, "path", {
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "formDirective", {
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "validator", {
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "asyncValidator", {
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "control", {
	            get: function () { return this._control; },
	            enumerable: true,
	            configurable: true
	        });
	        FormControlName.prototype._checkParentType = function () {
	            if (!(this._parent instanceof FormGroupName) &&
	                this._parent instanceof AbstractFormGroupDirective) {
	                ReactiveErrors.ngModelGroupException();
	            }
	            else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) &&
	                !(this._parent instanceof FormArrayName)) {
	                ReactiveErrors.controlParentException();
	            }
	        };
	        FormControlName.prototype._setUpControl = function () {
	            this._checkParentType();
	            this._control = this.formDirective.addControl(this);
	            if (this.control.disabled && this.valueAccessor.setDisabledState) {
	                this.valueAccessor.setDisabledState(true);
	            }
	            this._added = true;
	        };
	        FormControlName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControlName]', providers: [controlNameBinding] },] },
	        ];
	        /** @nocollapse */
	        FormControlName.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ];
	        FormControlName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formControlName',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	        };
	        return FormControlName;
	    }(NgControl));
	
	    var REQUIRED_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return RequiredValidator; }),
	        multi: true
	    };
	    /**
	     * A Directive that adds the `required` validator to any controls marked with the
	     * `required` attribute, via the {@link NG_VALIDATORS} binding.
	     *
	     * ### Example
	     *
	     * ```
	     * <input name="fullName" ngModel required>
	     * ```
	     *
	     * @stable
	     */
	    var RequiredValidator = (function () {
	        function RequiredValidator() {
	        }
	        Object.defineProperty(RequiredValidator.prototype, "required", {
	            get: function () { return this._required; },
	            set: function (value) {
	                this._required = value != null && value !== false && "" + value !== 'false';
	                if (this._onChange)
	                    this._onChange();
	            },
	            enumerable: true,
	            configurable: true
	        });
	        RequiredValidator.prototype.validate = function (c) {
	            return this.required ? Validators.required(c) : null;
	        };
	        RequiredValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        RequiredValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[required][formControlName],[required][formControl],[required][ngModel]',
	                        providers: [REQUIRED_VALIDATOR],
	                        host: { '[attr.required]': 'required ? "" : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        RequiredValidator.ctorParameters = [];
	        RequiredValidator.propDecorators = {
	            'required': [{ type: _angular_core.Input },],
	        };
	        return RequiredValidator;
	    }());
	    /**
	     * Provider which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.
	     *
	     * ## Example:
	     *
	     * {@example common/forms/ts/validators/validators.ts region='min'}
	     */
	    var MIN_LENGTH_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return MinLengthValidator; }),
	        multi: true
	    };
	    /**
	     * A directive which installs the {@link MinLengthValidator} for any `formControlName`,
	     * `formControl`, or control with `ngModel` that also has a `minlength` attribute.
	     *
	     * @stable
	     */
	    var MinLengthValidator = (function () {
	        function MinLengthValidator() {
	        }
	        MinLengthValidator.prototype.ngOnChanges = function (changes) {
	            if ('minlength' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        MinLengthValidator.prototype.validate = function (c) {
	            return this.minlength == null ? null : this._validator(c);
	        };
	        MinLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        MinLengthValidator.prototype._createValidator = function () {
	            this._validator = Validators.minLength(parseInt(this.minlength, 10));
	        };
	        MinLengthValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
	                        providers: [MIN_LENGTH_VALIDATOR],
	                        host: { '[attr.minlength]': 'minlength ? minlength : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        MinLengthValidator.ctorParameters = [];
	        MinLengthValidator.propDecorators = {
	            'minlength': [{ type: _angular_core.Input },],
	        };
	        return MinLengthValidator;
	    }());
	    /**
	     * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.
	     *
	     * ## Example:
	     *
	     * {@example common/forms/ts/validators/validators.ts region='max'}
	     */
	    var MAX_LENGTH_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return MaxLengthValidator; }),
	        multi: true
	    };
	    /**
	     * A directive which installs the {@link MaxLengthValidator} for any `formControlName,
	     * `formControl`,
	     * or control with `ngModel` that also has a `maxlength` attribute.
	     *
	     * @stable
	     */
	    var MaxLengthValidator = (function () {
	        function MaxLengthValidator() {
	        }
	        MaxLengthValidator.prototype.ngOnChanges = function (changes) {
	            if ('maxlength' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        MaxLengthValidator.prototype.validate = function (c) {
	            return this.maxlength != null ? this._validator(c) : null;
	        };
	        MaxLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        MaxLengthValidator.prototype._createValidator = function () {
	            this._validator = Validators.maxLength(parseInt(this.maxlength, 10));
	        };
	        MaxLengthValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
	                        providers: [MAX_LENGTH_VALIDATOR],
	                        host: { '[attr.maxlength]': 'maxlength ? maxlength : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        MaxLengthValidator.ctorParameters = [];
	        MaxLengthValidator.propDecorators = {
	            'maxlength': [{ type: _angular_core.Input },],
	        };
	        return MaxLengthValidator;
	    }());
	    var PATTERN_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return PatternValidator; }),
	        multi: true
	    };
	    /**
	     * A Directive that adds the `pattern` validator to any controls marked with the
	     * `pattern` attribute, via the {@link NG_VALIDATORS} binding. Uses attribute value
	     * as the regex to validate Control value against.  Follows pattern attribute
	     * semantics; i.e. regex must match entire Control value.
	     *
	     * ### Example
	     *
	     * ```
	     * <input [name]="fullName" pattern="[a-zA-Z ]*" ngModel>
	     * ```
	     * @stable
	     */
	    var PatternValidator = (function () {
	        function PatternValidator() {
	        }
	        PatternValidator.prototype.ngOnChanges = function (changes) {
	            if ('pattern' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        PatternValidator.prototype.validate = function (c) { return this._validator(c); };
	        PatternValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        PatternValidator.prototype._createValidator = function () { this._validator = Validators.pattern(this.pattern); };
	        PatternValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
	                        providers: [PATTERN_VALIDATOR],
	                        host: { '[attr.pattern]': 'pattern ? pattern : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        PatternValidator.ctorParameters = [];
	        PatternValidator.propDecorators = {
	            'pattern': [{ type: _angular_core.Input },],
	        };
	        return PatternValidator;
	    }());
	
	    /**
	     * @whatItDoes Creates an {@link AbstractControl} from a user-specified configuration.
	     *
	     * It is essentially syntactic sugar that shortens the `new FormGroup()`,
	     * `new FormControl()`, and `new FormArray()` boilerplate that can build up in larger
	     * forms.
	     *
	     * @howToUse
	     *
	     * To use, inject `FormBuilder` into your component class. You can then call its methods
	     * directly.
	     *
	     * {@example forms/ts/formBuilder/form_builder_example.ts region='Component'}
	     *
	     *  * **npm package**: `@angular/forms`
	     *
	     *  * **NgModule**: {@link ReactiveFormsModule}
	     *
	     * @stable
	     */
	    var FormBuilder = (function () {
	        function FormBuilder() {
	        }
	        /**
	         * Construct a new {@link FormGroup} with the given map of configuration.
	         * Valid keys for the `extra` parameter map are `validator` and `asyncValidator`.
	         *
	         * See the {@link FormGroup} constructor for more details.
	         */
	        FormBuilder.prototype.group = function (controlsConfig, extra) {
	            if (extra === void 0) { extra = null; }
	            var controls = this._reduceControls(controlsConfig);
	            var validator = isPresent(extra) ? extra['validator'] : null;
	            var asyncValidator = isPresent(extra) ? extra['asyncValidator'] : null;
	            return new FormGroup(controls, validator, asyncValidator);
	        };
	        /**
	         * Construct a new {@link FormControl} with the given `formState`,`validator`, and
	         * `asyncValidator`.
	         *
	         * `formState` can either be a standalone value for the form control or an object
	         * that contains both a value and a disabled status.
	         *
	         */
	        FormBuilder.prototype.control = function (formState, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            return new FormControl(formState, validator, asyncValidator);
	        };
	        /**
	         * Construct a {@link FormArray} from the given `controlsConfig` array of
	         * configuration, with the given optional `validator` and `asyncValidator`.
	         */
	        FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {
	            var _this = this;
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            var controls = controlsConfig.map(function (c) { return _this._createControl(c); });
	            return new FormArray(controls, validator, asyncValidator);
	        };
	        /** @internal */
	        FormBuilder.prototype._reduceControls = function (controlsConfig) {
	            var _this = this;
	            var controls = {};
	            Object.keys(controlsConfig).forEach(function (controlName) {
	                controls[controlName] = _this._createControl(controlsConfig[controlName]);
	            });
	            return controls;
	        };
	        /** @internal */
	        FormBuilder.prototype._createControl = function (controlConfig) {
	            if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup ||
	                controlConfig instanceof FormArray) {
	                return controlConfig;
	            }
	            else if (Array.isArray(controlConfig)) {
	                var value = controlConfig[0];
	                var validator = controlConfig.length > 1 ? controlConfig[1] : null;
	                var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
	                return this.control(value, validator, asyncValidator);
	            }
	            else {
	                return this.control(controlConfig);
	            }
	        };
	        FormBuilder.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        FormBuilder.ctorParameters = [];
	        return FormBuilder;
	    }());
	
	    var SHARED_FORM_DIRECTIVES = [
	        NgSelectOption, NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor,
	        RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor,
	        SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus,
	        NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator
	    ];
	    var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
	    var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
	    /**
	     * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
	     */
	    var InternalFormsSharedModule = (function () {
	        function InternalFormsSharedModule() {
	        }
	        InternalFormsSharedModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: SHARED_FORM_DIRECTIVES,
	                        exports: SHARED_FORM_DIRECTIVES,
	                    },] },
	        ];
	        /** @nocollapse */
	        InternalFormsSharedModule.ctorParameters = [];
	        return InternalFormsSharedModule;
	    }());
	
	    /**
	     * The ng module for forms.
	     * @stable
	     */
	    var FormsModule = (function () {
	        function FormsModule() {
	        }
	        FormsModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: TEMPLATE_DRIVEN_DIRECTIVES,
	                        providers: [RadioControlRegistry],
	                        exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
	                    },] },
	        ];
	        /** @nocollapse */
	        FormsModule.ctorParameters = [];
	        return FormsModule;
	    }());
	    /**
	     * The ng module for reactive forms.
	     * @stable
	     */
	    var ReactiveFormsModule = (function () {
	        function ReactiveFormsModule() {
	        }
	        ReactiveFormsModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: [REACTIVE_DRIVEN_DIRECTIVES],
	                        providers: [FormBuilder, RadioControlRegistry],
	                        exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
	                    },] },
	        ];
	        /** @nocollapse */
	        ReactiveFormsModule.ctorParameters = [];
	        return ReactiveFormsModule;
	    }());
	
	    exports.AbstractControlDirective = AbstractControlDirective;
	    exports.AbstractFormGroupDirective = AbstractFormGroupDirective;
	    exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;
	    exports.ControlContainer = ControlContainer;
	    exports.NG_VALUE_ACCESSOR = NG_VALUE_ACCESSOR;
	    exports.DefaultValueAccessor = DefaultValueAccessor;
	    exports.NgControl = NgControl;
	    exports.NgControlStatus = NgControlStatus;
	    exports.NgControlStatusGroup = NgControlStatusGroup;
	    exports.NgForm = NgForm;
	    exports.NgModel = NgModel;
	    exports.NgModelGroup = NgModelGroup;
	    exports.RadioControlValueAccessor = RadioControlValueAccessor;
	    exports.FormControlDirective = FormControlDirective;
	    exports.FormControlName = FormControlName;
	    exports.FormGroupDirective = FormGroupDirective;
	    exports.FormArrayName = FormArrayName;
	    exports.FormGroupName = FormGroupName;
	    exports.NgSelectOption = NgSelectOption;
	    exports.SelectControlValueAccessor = SelectControlValueAccessor;
	    exports.SelectMultipleControlValueAccessor = SelectMultipleControlValueAccessor;
	    exports.MaxLengthValidator = MaxLengthValidator;
	    exports.MinLengthValidator = MinLengthValidator;
	    exports.PatternValidator = PatternValidator;
	    exports.RequiredValidator = RequiredValidator;
	    exports.FormBuilder = FormBuilder;
	    exports.AbstractControl = AbstractControl;
	    exports.FormArray = FormArray;
	    exports.FormControl = FormControl;
	    exports.FormGroup = FormGroup;
	    exports.NG_ASYNC_VALIDATORS = NG_ASYNC_VALIDATORS;
	    exports.NG_VALIDATORS = NG_VALIDATORS;
	    exports.Validators = Validators;
	    exports.FormsModule = FormsModule;
	    exports.ReactiveFormsModule = ReactiveFormsModule;
	
	}));

/***/ }),
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var HomeComponent = (function () {
	    function HomeComponent() {
	    }
	    HomeComponent.prototype.ngOnInit = function () {
	        console.log('Home Component!');
	    };
	    return HomeComponent;
	}());
	HomeComponent = __decorate([
	    core_1.Component({
	        selector: 'home',
	        template: __webpack_require__(34),
	        styles: [__webpack_require__(36)],
	        encapsulation: core_1.ViewEncapsulation.None,
	    }),
	    __metadata("design:paramtypes", [])
	], HomeComponent);
	exports.HomeComponent = HomeComponent;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = "<img class=\"home-image\" src=\"" + __webpack_require__(35) + "\"/>";

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/home.jpg";

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(37);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".home-image {\n  width: 100%;\n  box-shadow: 0px 1px 2px 0 rgba(34, 36, 38, 0.15);\n  border: 1px solid #00004D;\n}\n", ""]);
	
	// exports


/***/ }),
/* 38 */,
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var AboutComponent = (function () {
	    function AboutComponent() {
	    }
	    AboutComponent.prototype.ngOnInit = function () {
	        console.log('About Component!');
	    };
	    return AboutComponent;
	}());
	AboutComponent = __decorate([
	    core_1.Component({
	        selector: 'about',
	        template: __webpack_require__(40),
	        styles: [__webpack_require__(41)]
	    }),
	    __metadata("design:paramtypes", [])
	], AboutComponent);
	exports.AboutComponent = AboutComponent;


/***/ }),
/* 40 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">About Us</h1>\n<p>Illinois Ultimate is one of the premier ultimate programs in the Midwest and frequently ranks in the National top 25. We strive to contend with the best programs in the country and have qualified to compete at Nationals 7 of the last 10 years. We are a program that prides itself on developing players who come to Illinois with no experience playing competitive ultimate. We teach all levels of ultimate, from the basics of throwing a forehand all the way to throwing bombs in the worst of weather.</p>\n<h2 class=\"ui header\">Mission Statement</h2>\n<p>We want to compete at the highest level possible in college ultimate while remaining respectful to our opponents.  We want to develop all our of players to become the best they can be at ultimate, as well as players who exemplify the true meaning of sportsmanship, which is pivotal to the progress of ultimate frisbee in its current state.</p>\n<h2 class=\"ui header\">Team Structure/Affiliation with University</h2>\n<p>Our team is a Registered Student Organization (RSO) at the University of Illinois and we are classified as a club sport. We receive some funding from the University that helps pay for our travel costs and hotels while we are at tournaments.</p>\n<p>We are a member of the USAU  College Series and compete in a series of tournaments that  culminate in the College Championships held every year during Memorial Day weekend. Most, if not all, state schools have established ultimate teams and many smaller schools have teams as well.  We compete in the Illinois conference which is as you can guess, the schools in the state of Illinois. The next largest division is the Great Lakes Region, which includes the states of Illinois, Indiana, Michigan, and Kentucky. The final step is the aforementioned National Championships.</p>\n<p>Our program is split up into two teams, A and B. Our A team is a group of individuals who are very dedicated to the team and who put in a large amount of time for practices as well as training outside of practices. Our B team is more oriented towards the development of younger or inexperienced players. B team provides a much more relaxed atmosphere but still remains competitive with all other B teams in the region, and even beats some smaller schools' A teams.</p>\n<p>A team has tryouts each year. This year's tryouts will consist of four fall tournaments. There will be a round of cuts made after the second tournament. The tryout roster will then be narrowed down to one team before the final tournament of the fall, via cuts on a rolling basis. Players may be moved between the A and B team rosters as necessary.</p>";

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(42);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "p {\n  text-align: left;\n}\n", ""]);
	
	// exports


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var google_spreadsheet_service_1 = __webpack_require__(44);
	var ProspectivePlayersComponent = (function () {
	    // Constructor with our http service injected
	    function ProspectivePlayersComponent(spreadsheetService) {
	        this.spreadsheetService = spreadsheetService;
	        // API url for our personal server
	        this.googleSheetsApiUrl = 'https://nick-proz-google-sheet-api.herokuapp.com/sheets/11ijrHoysiIwsFfEggbSNM9Y8VvzU65jeuhQ3vkV5FGw/sheetIndex/2/rows/';
	        // API url for our backup server (sheetsu API)
	        // private googleSheetsBackupApiUrl = 'https://sheetsu.com/apis/v1.0/7a030ae60b7d';
	        this.googleSheetsBackupApiUrl = '';
	        // Error messages
	        this.validationErrors = 'Please do not leave any required fields blank.';
	        this.submissionError = 'Could not submit the form  due to a server error. Please try again soon or contact the web admins.';
	        // Contact input
	        this.contact = 'Yes';
	        // Boolean indicating if our form is in the process of submitting (to show our loading icon)
	        this.formIsSubmitting = false;
	        // Boolean indicating if our form was successfully submitted (to show our success message)
	        this.submitSuccess = false;
	    }
	    ProspectivePlayersComponent.prototype.ngOnInit = function () { };
	    ProspectivePlayersComponent.prototype.handleSubmit = function (event) {
	        event.preventDefault();
	        this.submitSuccess = false;
	        if (!this.formIsValid()) {
	            this.formErrors = this.validationErrors;
	        }
	        else {
	            this.formIsSubmitting = true;
	            this.formErrors = null;
	            var date = new Date();
	            var data = {
	                "Timestamp": date.toLocaleString(),
	                "First Name": this.firstName,
	                "Last Name": this.lastName,
	                "Email Address": this.emailAddress,
	                "Hometown": this.hometown,
	                "Highschool": this.highschool,
	                "Major": this.major,
	                "Experience": this.experience,
	                "Other Clubs": this.otherClubs,
	                "Contact Me": this.contact
	            };
	            this.submitAbsentForm(data);
	        }
	    };
	    /**
	     * Submits our form to the spreadsheet by calling our service method.
	     * On success, we show our confirmation modal and reset our rsvp modal.
	     * On failure, we hide our submitting dialog and show our submission error to the user.
	     *
	     * @param data - data to submit to our spreadsheet
	     */
	    ProspectivePlayersComponent.prototype.submitAbsentForm = function (data) {
	        var _this = this;
	        this.spreadsheetService.postRowToSpreadsheet(this.googleSheetsApiUrl, this.googleSheetsBackupApiUrl, data)
	            .then(function () {
	            _this.resetForm();
	            _this.submitSuccess = true;
	        })
	            .catch(function () {
	            _this.formIsSubmitting = false;
	            _this.formErrors = _this.submissionError;
	        });
	    };
	    /**
	     * Clears our input fields, errors, and resets our form is submitting flag.
	     */
	    ProspectivePlayersComponent.prototype.resetForm = function () {
	        this.firstName = null;
	        this.lastName = null;
	        this.emailAddress = null;
	        this.hometown = null;
	        this.highschool = null;
	        this.major = null;
	        this.experience = null;
	        this.otherClubs = null;
	        this.formErrors = null;
	        this.formIsSubmitting = false;
	    };
	    /**
	     * Front-end validation for our form.
	     * Our form is valid only if all fields are populated.
	     *
	     * @returns {boolean} - true if the form is valid, false otherwise
	     */
	    ProspectivePlayersComponent.prototype.formIsValid = function () {
	        return this.firstName != null && this.firstName != ''
	            && this.lastName != null && this.lastName != ''
	            && this.emailAddress != null && this.emailAddress != ''
	            && this.hometown != null && this.hometown != ''
	            && this.highschool != null && this.highschool != ''
	            && this.major != null && this.major != ''
	            && this.experience != null && this.experience != ''
	            && this.otherClubs != null && this.otherClubs != ''
	            && this.contact != null && this.contact != '';
	    };
	    return ProspectivePlayersComponent;
	}());
	ProspectivePlayersComponent = __decorate([
	    core_1.Component({
	        selector: 'prospective-players',
	        template: __webpack_require__(45),
	        styles: [__webpack_require__(46)]
	    }),
	    __metadata("design:paramtypes", [typeof (_a = typeof google_spreadsheet_service_1.SpreadsheetService !== "undefined" && google_spreadsheet_service_1.SpreadsheetService) === "function" && _a || Object])
	], ProspectivePlayersComponent);
	exports.ProspectivePlayersComponent = ProspectivePlayersComponent;
	var _a;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var http_1 = __webpack_require__(28);
	/**
	 * Service to interact with our Google spreadsheet.
	 */
	var SpreadsheetService = (function () {
	    // Constructor with our http service injected
	    function SpreadsheetService(http) {
	        this.http = http;
	        // HTTP headers
	        this.headers = new http_1.Headers({ 'Content-Type': 'application/json' });
	    }
	    /**
	     * Attempts to post the data passed in to our spreadsheet.
	     * Rejects the promise if there is an error.
	     *
	     * @param apiUrl - url of the google sheets API
	     * @param backupApiUrl - url of hte google sheets backup API
	     * @param data - data to add to our spreadsheet
	     * @returns {Promise<JSON>} - Promise holding the successfully posted object, or a rejected promise with an error
	     */
	    SpreadsheetService.prototype.postRowToSpreadsheet = function (apiUrl, backupApiUrl, data) {
	        var _this = this;
	        return this.http
	            .post(apiUrl, data, { headers: this.headers })
	            .toPromise()
	            .then(function (response) { return response.json(); })
	            .catch(function () { return _this.postRowToSpreadsheetBackup(backupApiUrl, data); });
	    };
	    /**
	     * Attempts to post the data passed in to our backup spreadsheet.
	     * This is a backup post in case our personal server fails.
	     * Rejects the promise if there is an error.
	     *
	     * @param backupApiUrl - url of hte google sheets backup API
	     * @param data - data to add to our spreadsheet
	     * @returns {Promise<JSON>} - Promise holding the successfully posted object, or a rejected promise with an error
	     */
	    SpreadsheetService.prototype.postRowToSpreadsheetBackup = function (backupApiUrl, data) {
	        return this.http
	            .post(backupApiUrl, data, { headers: this.headers })
	            .toPromise()
	            .then(function (response) { return response.json(); })
	            .catch(SpreadsheetService.handleError);
	    };
	    /**
	     * Handles all rsvp service errors (after our backup call) when interfacing
	     * with the google spreadsheet api. We log the error and reject the promise.
	     *
	     * @param error - Error to log and reject
	     * @returns {Promise<any>} - A rejected promise
	     */
	    SpreadsheetService.handleError = function (error) {
	        console.error('An error occurred when attempting to send data to our spreadsheet: ', error);
	        return Promise.reject(error);
	    };
	    return SpreadsheetService;
	}());
	SpreadsheetService = __decorate([
	    core_1.Injectable(),
	    __metadata("design:paramtypes", [typeof (_a = typeof http_1.Http !== "undefined" && http_1.Http) === "function" && _a || Object])
	], SpreadsheetService);
	exports.SpreadsheetService = SpreadsheetService;
	var _a;


/***/ }),
/* 45 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Prospective Players</h1>\n<p>Illinois Ultimate has had a long history since its inception in the early 1990s and now consistently competes with best competition around the country. Illinois has qualified for national championships 6 out of the last 9 years behind our dedication, determination, and distinguished character on and off the field. Illinois alumni have gone on to play for nationals caliber club teams such as Chicago Machine, Minneapolis Drag 'n Thrust, Cincinnati Steamboat, Atlanta Chain Lightning, and San Francisco Blackbird. Alumni have played on professional AUDL teams such as the Chicago Wildfire, Minnesota Windchill, Cincinnati Revolution, and the San Jose Spiders. They have also created and captained club teams including Chicago Machine, Black Market Ultimate, and Beachfront Ultimate, and have gone on to coach college ultimate at the University of Illinois, the University of Chicago, Northwestern University, and the University of Kentucky. It's safe to say that once you play ultimate at Illinois you are opened up to a world of opportunity through our alumni network, who are more than willing to assist you on your journey though ultimate during and beyond your college years.</p>\n<p>While you are at Illinois you will enjoy a number of experiences. This ranges from team socials to study groups and from practices in Irwin Fieldhouse to playing games on the shores of San Diego. Your teammates won't only be your best friends, they will be family. You will learn the various ways ultimate is played, how to expand your throwing arsenal, how to improve your athleticism, and how to take your game to the next level. A majority of our team didn't play organized ultimate before coming to college, and are now some of the best players in the Great Lakes region (see our All-Regions honors page).</p>\n<p>We encourage prospective players to fill out our interest form and to reach out to the captains especially if you will be on campus. We are more than happy to meet up and discuss what Illinois can do for you, and to see what you can do to be ready for Illinois once you get on campus. Our contact information is below. Thank you for taking the time to visit our website, and we hope to hear from you soon.</p>\n\n<form class=\"ui form\">\n        <div class=\"two fields\">\n            <div class=\"field\">\n                <label>First Name <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"firstName\" type=\"text\" name=\"first-name\" placeholder=\"First Name\">\n            </div>\n            <div class=\"field\">\n                <label>Last Name <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"lastName\" type=\"text\" name=\"last-name\" placeholder=\"Last Name\">\n            </div>\n        </div>\n        <div class=\"two fields\">\n            <div class=\"field\">\n                <label>Email Address <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"emailAddress\" type=\"text\" name=\"email-address\" placeholder=\"Email Address\">\n            </div>\n            <div class=\"field\">\n                <label>What is your Hometown? <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"hometown\" type=\"text\" name=\"home-town\" placeholder=\"Hometown\">\n            </div>\n        </div>\n        <div class=\"two fields\">\n            <div class=\"field\">\n                <label>What high school did you attend? <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"highschool\" type=\"text\" name=\"highschool\" placeholder=\"Highschool\">\n            </div>\n            <div class=\"field\">\n                <label>What major are you planning on going into? <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"major\" type=\"text\" name=\"major\" placeholder=\"Major\">\n            </div>\n        </div>\n        <div class=\"field\">\n            <label>How long have you played ultimate/what kind of experience do you have? <span class=\"required\">*</span></label>\n            <textarea [(ngModel)]=\"experience\" name=\"experience\" rows=\"2\"></textarea>\n        </div>\n        <div class=\"field\">\n            <label>What other clubs/organizations are you planning on joining when you arrive on campus? <span class=\"required\">*</span></label>\n            <textarea [(ngModel)]=\"otherClubs\" name=\"other-clubs\" rows=\"2\"></textarea>\n        </div>\n        <div class=\"inline fields\">\n            <label>Would you be alright with a captain or coach reaching out to you? <span class=\"required\">*</span></label>\n            <div class=\"field\">\n                <div class=\"ui radio checkbox\">\n                    <input id=\"contact-yes\" [(ngModel)]=\"contact\" type=\"radio\" name=\"contact\" value=\"Yes\" checked=\"checked\" tabindex=\"0\" class=\"hidden\">\n                    <label for=\"contact-yes\">Yes</label>\n                </div>\n            </div>\n            <div class=\"field\">\n                <div class=\"ui radio checkbox\">\n                    <input id=\"contact-no\" [(ngModel)]=\"contact\" type=\"radio\" name=\"contact\" value=\"No\" tabindex=\"0\" class=\"hidden\">\n                    <label for=\"contact-no\">No</label>\n                </div>\n            </div>\n        </div>\n    <button (click)=\"handleSubmit($event)\" class=\"ui button\" type=\"submit\">Submit</button>\n    <div class=\"ui error message\" *ngIf=\"formErrors\">\n        <p>{{formErrors}}</p>\n    </div>\n    <div class=\"ui success message\" *ngIf=\"submitSuccess\">\n        <div class=\"header\">Form Submitted</div>\n        <p>The form was successfully submitted! Thanks for taking the time to fill it out.</p>\n    </div>\n    <div *ngIf=\"formIsSubmitting\" class=\"ui active inverted dimmer\"><div class=\"ui text loader\">Submitting</div></div>\n</form>";

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(47);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "p,\nlabel {\n  text-align: left;\n}\n.ui.form {\n  margin: 20px auto;\n}\n.ui.form .ui.error.message,\n.ui.form .ui.success.message {\n  display: block;\n}\n.ui.form .ui.error.message p,\n.ui.form .ui.success.message p {\n  text-align: center;\n}\n", ""]);
	
	// exports


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var ContactComponent = (function () {
	    function ContactComponent() {
	    }
	    ContactComponent.prototype.ngOnInit = function () {
	        console.log('Contact Component!');
	    };
	    return ContactComponent;
	}());
	ContactComponent = __decorate([
	    core_1.Component({
	        selector: 'contact',
	        template: __webpack_require__(49),
	        styles: [__webpack_require__(50)]
	    }),
	    __metadata("design:paramtypes", [])
	], ContactComponent);
	exports.ContactComponent = ContactComponent;


/***/ }),
/* 49 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Contact Us</h1>\n<p>For any questions regarding practice or club details, feel free to contact any of the current captains:</p>\n\n<p class=\"captain\">Chris Buchta -- cbuchta2@gmail.com</p>\n<p class=\"captain\">Ben Foster -- ben.foster234@gmail.com</p>\n<p class=\"captain\">Jacob Komenda -- jacob.komenda@gmail.com</p>";

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(51);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".captain {\n  margin-bottom: 0;\n}\n", ""]);
	
	// exports


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	__webpack_require__(53);
	var AppComponent = (function () {
	    function AppComponent() {
	    }
	    AppComponent.prototype.ngOnInit = function () { };
	    return AppComponent;
	}());
	AppComponent = __decorate([
	    core_1.Component({
	        selector: 'app',
	        template: __webpack_require__(57),
	        styles: [__webpack_require__(58)]
	    }),
	    __metadata("design:paramtypes", [])
	], AppComponent);
	exports.AppComponent = AppComponent;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(54);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(56)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/css-loader/index.js!./styles.css", function() {
				var newContent = require("!!../../../node_modules/css-loader/index.js!./styles.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "/* General Elements */\nbody {\n    background-image: url(" + __webpack_require__(55) + ");\n    font-family: 'Quattrocento', serif;\n    text-align: center;\n    overflow-y: scroll;\n}\np {\n    text-indent: 25px;\n    padding: 5px;\n}\na {\n    color: #ff6226;\n}\na:hover {\n    color: #00004D;\n}\ninput {\n    font-family: 'Quattrocento', serif !important;\n}\n\ninput:focus {\n     border-color: #ff6226 !important;\n}\n\n/* Headers */\n.ui.header {\n    font-family: 'Oswald', sans-serif;\n    color: #00004D;\n    letter-spacing: 1px;\n    /*text-transform: uppercase;*/\n}\n\n/* Tables */\n.ui.table tr, .ui.table td {\n    text-align: center;\n    border-top: 0;\n}\n\n/* Secondary Menus */\n.ui.secondary.pointing.menu {\n    justify-content: center;\n}\n.ui.secondary.pointing.menu .item.active {\n    border-color: #00004D;\n}\n\n/* Random */\n.button {\n    background-color: #ff6226 !important;\n    color: white !important;\n}\n.required {\n    color: #ff6226;\n}", ""]);
	
	// exports


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/background.jpg";

/***/ }),
/* 56 */,
/* 57 */
/***/ (function(module, exports) {

	module.exports = "<main class=\"main-container\">\n    <page-frame></page-frame>\n</main>\n";

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(59);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".main-container {\n  height: 100%;\n}\n", ""]);
	
	// exports


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var core_2 = __webpack_require__(61);
	var platform_browser_1 = __webpack_require__(25);
	var forms_1 = __webpack_require__(29);
	var practice_component_1 = __webpack_require__(84);
	var tournaments_component_1 = __webpack_require__(89);
	var roster_component_1 = __webpack_require__(124);
	var absent_component_1 = __webpack_require__(129);
	var router_1 = __webpack_require__(90);
	var app_routes_1 = __webpack_require__(134);
	var google_spreadsheet_service_1 = __webpack_require__(44);
	var TeamModule = (function () {
	    function TeamModule() {
	    }
	    return TeamModule;
	}());
	TeamModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            platform_browser_1.BrowserModule,
	            forms_1.FormsModule,
	            core_2.AgmCoreModule.forRoot({
	                apiKey: 'AIzaSyBRIXAk5xdvn3ezypsSe55f8dZhcHheAZ8'
	            }),
	            router_1.RouterModule.forRoot(app_routes_1.ROUTES)
	        ],
	        declarations: [
	            practice_component_1.PracticeComponent,
	            tournaments_component_1.TournamentsComponent,
	            roster_component_1.RosterComponent,
	            absent_component_1.AbsentComponent
	        ],
	        providers: [google_spreadsheet_service_1.SpreadsheetService]
	    }),
	    __metadata("design:paramtypes", [])
	], TeamModule);
	exports.TeamModule = TeamModule;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	// main modules
	__export(__webpack_require__(62));
	__export(__webpack_require__(79));
	// Google Maps types
	// core module
	// we explicitly export the module here to prevent this Ionic 2 bug:
	// http://stevemichelotti.com/integrate-angular-2-google-maps-into-ionic-2/
	var core_module_1 = __webpack_require__(83);
	exports.AgmCoreModule = core_module_1.AgmCoreModule;
	//# sourceMappingURL=index.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var google_map_1 = __webpack_require__(63);
	exports.SebmGoogleMap = google_map_1.SebmGoogleMap;
	var google_map_circle_1 = __webpack_require__(72);
	exports.SebmGoogleMapCircle = google_map_circle_1.SebmGoogleMapCircle;
	var google_map_info_window_1 = __webpack_require__(73);
	exports.SebmGoogleMapInfoWindow = google_map_info_window_1.SebmGoogleMapInfoWindow;
	var google_map_kml_layer_1 = __webpack_require__(74);
	exports.SebmGoogleMapKmlLayer = google_map_kml_layer_1.SebmGoogleMapKmlLayer;
	var google_map_marker_1 = __webpack_require__(75);
	exports.SebmGoogleMapMarker = google_map_marker_1.SebmGoogleMapMarker;
	var google_map_polygon_1 = __webpack_require__(76);
	exports.SebmGoogleMapPolygon = google_map_polygon_1.SebmGoogleMapPolygon;
	var google_map_polyline_1 = __webpack_require__(77);
	exports.SebmGoogleMapPolyline = google_map_polyline_1.SebmGoogleMapPolyline;
	var google_map_polyline_point_1 = __webpack_require__(78);
	exports.SebmGoogleMapPolylinePoint = google_map_polyline_point_1.SebmGoogleMapPolylinePoint;
	//# sourceMappingURL=directives.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var circle_manager_1 = __webpack_require__(66);
	var info_window_manager_1 = __webpack_require__(67);
	var marker_manager_1 = __webpack_require__(68);
	var polygon_manager_1 = __webpack_require__(69);
	var polyline_manager_1 = __webpack_require__(70);
	var kml_layer_manager_1 = __webpack_require__(71);
	/**
	 * SebMGoogleMap renders a Google Map.
	 * **Important note**: To be able see a map in the browser, you have to define a height for the CSS
	 * class `sebm-google-map-container`.
	 *
	 * ### Example
	 * ```typescript
	 * import { Component } from '@angular/core';
	 * import { SebmGoogleMap } from 'angular2-google-maps/core';
	 *
	 * @Component({
	 *  selector: 'my-map-cmp',
	 *  directives: [SebmGoogleMap],
	 *  styles: [`
	 *    .sebm-google-map-container {
	 *      height: 300px;
	 *    }
	 * `],
	 *  template: `
	 *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
	 *    </sebm-google-map>
	 *  `
	 * })
	 * ```
	 */
	var SebmGoogleMap = (function () {
	    function SebmGoogleMap(_elem, _mapsWrapper) {
	        this._elem = _elem;
	        this._mapsWrapper = _mapsWrapper;
	        /**
	         * The longitude that defines the center of the map.
	         */
	        this.longitude = 0;
	        /**
	         * The latitude that defines the center of the map.
	         */
	        this.latitude = 0;
	        /**
	         * The zoom level of the map. The default zoom level is 8.
	         */
	        this.zoom = 8;
	        /**
	         * Enables/disables if map is draggable.
	         */
	        this.draggable = true;
	        /**
	         * Enables/disables zoom and center on double click. Enabled by default.
	         */
	        this.disableDoubleClickZoom = false;
	        /**
	         * Enables/disables all default UI of the Google map. Please note: When the map is created, this
	         * value cannot get updated.
	         */
	        this.disableDefaultUI = false;
	        /**
	         * If false, disables scrollwheel zooming on the map. The scrollwheel is enabled by default.
	         */
	        this.scrollwheel = true;
	        /**
	         * If false, prevents the map from being controlled by the keyboard. Keyboard shortcuts are
	         * enabled by default.
	         */
	        this.keyboardShortcuts = true;
	        /**
	         * The enabled/disabled state of the Zoom control.
	         */
	        this.zoomControl = true;
	        /**
	         * Styles to apply to each of the default map types. Note that for Satellite/Hybrid and Terrain
	         * modes, these styles will only apply to labels and geometry.
	         */
	        this.styles = [];
	        /**
	         * When true and the latitude and/or longitude values changes, the Google Maps panTo method is
	         * used to
	         * center the map. See: https://developers.google.com/maps/documentation/javascript/reference#Map
	         */
	        this.usePanning = false;
	        /**
	         * The initial enabled/disabled state of the Street View Pegman control.
	         * This control is part of the default UI, and should be set to false when displaying a map type
	         * on which the Street View road overlay should not appear (e.g. a non-Earth map type).
	         */
	        this.streetViewControl = true;
	        /**
	         * Sets the viewport to contain the given bounds.
	         */
	        this.fitBounds = null;
	        /**
	         * The initial enabled/disabled state of the Scale control. This is disabled by default.
	         */
	        this.scaleControl = false;
	        /**
	         * The initial enabled/disabled state of the Map type control.
	         */
	        this.mapTypeControl = false;
	        this._observableSubscriptions = [];
	        /**
	         * This event emitter gets emitted when the user clicks on the map (but not when they click on a
	         * marker or infoWindow).
	         */
	        this.mapClick = new core_1.EventEmitter();
	        /**
	         * This event emitter gets emitted when the user right-clicks on the map (but not when they click
	         * on a marker or infoWindow).
	         */
	        this.mapRightClick = new core_1.EventEmitter();
	        /**
	         * This event emitter gets emitted when the user double-clicks on the map (but not when they click
	         * on a marker or infoWindow).
	         */
	        this.mapDblClick = new core_1.EventEmitter();
	        /**
	         * This event emitter is fired when the map center changes.
	         */
	        this.centerChange = new core_1.EventEmitter();
	        /**
	         * This event is fired when the viewport bounds have changed.
	         */
	        this.boundsChange = new core_1.EventEmitter();
	        /**
	         * This event is fired when the map becomes idle after panning or zooming.
	         */
	        this.idle = new core_1.EventEmitter();
	        /**
	         * This event is fired when the zoom level has changed.
	         */
	        this.zoomChange = new core_1.EventEmitter();
	    }
	    /** @internal */
	    SebmGoogleMap.prototype.ngOnInit = function () {
	        // todo: this should be solved with a new component and a viewChild decorator
	        var container = this._elem.nativeElement.querySelector('.sebm-google-map-container-inner');
	        this._initMapInstance(container);
	    };
	    SebmGoogleMap.prototype._initMapInstance = function (el) {
	        this._mapsWrapper.createMap(el, {
	            center: { lat: this.latitude || 0, lng: this.longitude || 0 },
	            zoom: this.zoom,
	            minZoom: this.minZoom,
	            maxZoom: this.maxZoom,
	            disableDefaultUI: this.disableDefaultUI,
	            backgroundColor: this.backgroundColor,
	            draggable: this.draggable,
	            draggableCursor: this.draggableCursor,
	            draggingCursor: this.draggingCursor,
	            keyboardShortcuts: this.keyboardShortcuts,
	            zoomControl: this.zoomControl,
	            styles: this.styles,
	            streetViewControl: this.streetViewControl,
	            scaleControl: this.scaleControl,
	            mapTypeControl: this.mapTypeControl
	        });
	        // register event listeners
	        this._handleMapCenterChange();
	        this._handleMapZoomChange();
	        this._handleMapMouseEvents();
	        this._handleBoundsChange();
	        this._handleIdleEvent();
	    };
	    /** @internal */
	    SebmGoogleMap.prototype.ngOnDestroy = function () {
	        // unsubscribe all registered observable subscriptions
	        this._observableSubscriptions.forEach(function (s) { return s.unsubscribe(); });
	    };
	    /* @internal */
	    SebmGoogleMap.prototype.ngOnChanges = function (changes) {
	        this._updateMapOptionsChanges(changes);
	        this._updatePosition(changes);
	    };
	    SebmGoogleMap.prototype._updateMapOptionsChanges = function (changes) {
	        var options = {};
	        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMap._mapOptionsAttributes.indexOf(k) !== -1; });
	        optionKeys.forEach(function (k) { options[k] = changes[k].currentValue; });
	        this._mapsWrapper.setMapOptions(options);
	    };
	    /**
	     * Triggers a resize event on the google map instance.
	     * Returns a promise that gets resolved after the event was triggered.
	     */
	    SebmGoogleMap.prototype.triggerResize = function () {
	        var _this = this;
	        // Note: When we would trigger the resize event and show the map in the same turn (which is a
	        // common case for triggering a resize event), then the resize event would not
	        // work (to show the map), so we trigger the event in a timeout.
	        return new Promise(function (resolve) {
	            setTimeout(function () { return _this._mapsWrapper.triggerMapEvent('resize').then(function () { return resolve(); }); });
	        });
	    };
	    SebmGoogleMap.prototype._updatePosition = function (changes) {
	        if (changes['latitude'] == null && changes['longitude'] == null &&
	            changes['fitBounds'] == null) {
	            // no position update needed
	            return;
	        }
	        // we prefer fitBounds in changes
	        if (changes['fitBounds'] && this.fitBounds != null) {
	            this._fitBounds();
	            return;
	        }
	        if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {
	            return;
	        }
	        var newCenter = {
	            lat: this.latitude,
	            lng: this.longitude,
	        };
	        if (this.usePanning) {
	            this._mapsWrapper.panTo(newCenter);
	        }
	        else {
	            this._mapsWrapper.setCenter(newCenter);
	        }
	    };
	    SebmGoogleMap.prototype._fitBounds = function () {
	        if (this.usePanning) {
	            this._mapsWrapper.panToBounds(this.fitBounds);
	            return;
	        }
	        this._mapsWrapper.fitBounds(this.fitBounds);
	    };
	    SebmGoogleMap.prototype._handleMapCenterChange = function () {
	        var _this = this;
	        var s = this._mapsWrapper.subscribeToMapEvent('center_changed').subscribe(function () {
	            _this._mapsWrapper.getCenter().then(function (center) {
	                _this.latitude = center.lat();
	                _this.longitude = center.lng();
	                _this.centerChange.emit({ lat: _this.latitude, lng: _this.longitude });
	            });
	        });
	        this._observableSubscriptions.push(s);
	    };
	    SebmGoogleMap.prototype._handleBoundsChange = function () {
	        var _this = this;
	        var s = this._mapsWrapper.subscribeToMapEvent('bounds_changed').subscribe(function () {
	            _this._mapsWrapper.getBounds().then(function (bounds) { _this.boundsChange.emit(bounds); });
	        });
	        this._observableSubscriptions.push(s);
	    };
	    SebmGoogleMap.prototype._handleMapZoomChange = function () {
	        var _this = this;
	        var s = this._mapsWrapper.subscribeToMapEvent('zoom_changed').subscribe(function () {
	            _this._mapsWrapper.getZoom().then(function (z) {
	                _this.zoom = z;
	                _this.zoomChange.emit(z);
	            });
	        });
	        this._observableSubscriptions.push(s);
	    };
	    SebmGoogleMap.prototype._handleIdleEvent = function () {
	        var _this = this;
	        var s = this._mapsWrapper.subscribeToMapEvent('idle').subscribe(function () { _this.idle.emit(void 0); });
	        this._observableSubscriptions.push(s);
	    };
	    SebmGoogleMap.prototype._handleMapMouseEvents = function () {
	        var _this = this;
	        var events = [
	            { name: 'click', emitter: this.mapClick },
	            { name: 'rightclick', emitter: this.mapRightClick },
	        ];
	        events.forEach(function (e) {
	            var s = _this._mapsWrapper.subscribeToMapEvent(e.name).subscribe(function (event) {
	                var value = { coords: { lat: event.latLng.lat(), lng: event.latLng.lng() } };
	                e.emitter.emit(value);
	            });
	            _this._observableSubscriptions.push(s);
	        });
	    };
	    /**
	     * Map option attributes that can change over time
	     */
	    SebmGoogleMap._mapOptionsAttributes = [
	        'disableDoubleClickZoom', 'scrollwheel', 'draggable', 'draggableCursor', 'draggingCursor',
	        'keyboardShortcuts', 'zoomControl', 'styles', 'streetViewControl', 'zoom', 'mapTypeControl',
	        'minZoom', 'maxZoom'
	    ];
	    SebmGoogleMap.decorators = [
	        { type: core_1.Component, args: [{
	                    selector: 'sebm-google-map',
	                    providers: [
	                        google_maps_api_wrapper_1.GoogleMapsAPIWrapper, marker_manager_1.MarkerManager, info_window_manager_1.InfoWindowManager, circle_manager_1.CircleManager, polyline_manager_1.PolylineManager,
	                        polygon_manager_1.PolygonManager, kml_layer_manager_1.KmlLayerManager
	                    ],
	                    inputs: [
	                        'longitude', 'latitude', 'zoom', 'minZoom', 'maxZoom', 'draggable: mapDraggable',
	                        'disableDoubleClickZoom', 'disableDefaultUI', 'scrollwheel', 'backgroundColor', 'draggableCursor',
	                        'draggingCursor', 'keyboardShortcuts', 'zoomControl', 'styles', 'usePanning', 'streetViewControl',
	                        'fitBounds', 'scaleControl', 'mapTypeControl'
	                    ],
	                    outputs: [
	                        'mapClick', 'mapRightClick', 'mapDblClick', 'centerChange', 'idle', 'boundsChange', 'zoomChange'
	                    ],
	                    host: { '[class.sebm-google-map-container]': 'true' },
	                    styles: ["\n    .sebm-google-map-container-inner {\n      width: inherit;\n      height: inherit;\n    }\n    .sebm-google-map-content {\n      display:none;\n    }\n  "],
	                    template: "\n    <div class='sebm-google-map-container-inner'></div>\n    <div class='sebm-google-map-content'>\n      <ng-content></ng-content>\n    </div>\n  "
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMap.ctorParameters = function () { return [
	        { type: core_1.ElementRef, },
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	    ]; };
	    return SebmGoogleMap;
	}());
	exports.SebmGoogleMap = SebmGoogleMap;
	//# sourceMappingURL=google-map.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var maps_api_loader_1 = __webpack_require__(65);
	/**
	 * Wrapper class that handles the communication with the Google Maps Javascript
	 * API v3
	 */
	var GoogleMapsAPIWrapper = (function () {
	    function GoogleMapsAPIWrapper(_loader, _zone) {
	        var _this = this;
	        this._loader = _loader;
	        this._zone = _zone;
	        this._map =
	            new Promise(function (resolve) { _this._mapResolver = resolve; });
	    }
	    GoogleMapsAPIWrapper.prototype.createMap = function (el, mapOptions) {
	        var _this = this;
	        return this._loader.load().then(function () {
	            var map = new google.maps.Map(el, mapOptions);
	            _this._mapResolver(map);
	            return;
	        });
	    };
	    GoogleMapsAPIWrapper.prototype.setMapOptions = function (options) {
	        this._map.then(function (m) { m.setOptions(options); });
	    };
	    /**
	     * Creates a google map marker with the map context
	     */
	    GoogleMapsAPIWrapper.prototype.createMarker = function (options) {
	        if (options === void 0) { options = {}; }
	        return this._map.then(function (map) {
	            options.map = map;
	            return new google.maps.Marker(options);
	        });
	    };
	    GoogleMapsAPIWrapper.prototype.createInfoWindow = function (options) {
	        return this._map.then(function () { return new google.maps.InfoWindow(options); });
	    };
	    /**
	     * Creates a google.map.Circle for the current map.
	     */
	    GoogleMapsAPIWrapper.prototype.createCircle = function (options) {
	        return this._map.then(function (map) {
	            options.map = map;
	            return new google.maps.Circle(options);
	        });
	    };
	    GoogleMapsAPIWrapper.prototype.createPolyline = function (options) {
	        return this.getNativeMap().then(function (map) {
	            var line = new google.maps.Polyline(options);
	            line.setMap(map);
	            return line;
	        });
	    };
	    GoogleMapsAPIWrapper.prototype.createPolygon = function (options) {
	        return this.getNativeMap().then(function (map) {
	            var polygon = new google.maps.Polygon(options);
	            polygon.setMap(map);
	            return polygon;
	        });
	    };
	    /**
	     * Determines if given coordinates are insite a Polygon path.
	     */
	    GoogleMapsAPIWrapper.prototype.containsLocation = function (latLng, polygon) {
	        return google.maps.geometry.poly.containsLocation(latLng, polygon);
	    };
	    GoogleMapsAPIWrapper.prototype.subscribeToMapEvent = function (eventName) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._map.then(function (m) {
	                m.addListener(eventName, function (arg) { _this._zone.run(function () { return observer.next(arg); }); });
	            });
	        });
	    };
	    GoogleMapsAPIWrapper.prototype.setCenter = function (latLng) {
	        return this._map.then(function (map) { return map.setCenter(latLng); });
	    };
	    GoogleMapsAPIWrapper.prototype.getZoom = function () { return this._map.then(function (map) { return map.getZoom(); }); };
	    GoogleMapsAPIWrapper.prototype.getBounds = function () {
	        return this._map.then(function (map) { return map.getBounds(); });
	    };
	    GoogleMapsAPIWrapper.prototype.setZoom = function (zoom) {
	        return this._map.then(function (map) { return map.setZoom(zoom); });
	    };
	    GoogleMapsAPIWrapper.prototype.getCenter = function () {
	        return this._map.then(function (map) { return map.getCenter(); });
	    };
	    GoogleMapsAPIWrapper.prototype.panTo = function (latLng) {
	        return this._map.then(function (map) { return map.panTo(latLng); });
	    };
	    GoogleMapsAPIWrapper.prototype.fitBounds = function (latLng) {
	        return this._map.then(function (map) { return map.fitBounds(latLng); });
	    };
	    GoogleMapsAPIWrapper.prototype.panToBounds = function (latLng) {
	        return this._map.then(function (map) { return map.panToBounds(latLng); });
	    };
	    /**
	     * Returns the native Google Maps Map instance. Be careful when using this instance directly.
	     */
	    GoogleMapsAPIWrapper.prototype.getNativeMap = function () { return this._map; };
	    /**
	     * Triggers the given event name on the map instance.
	     */
	    GoogleMapsAPIWrapper.prototype.triggerMapEvent = function (eventName) {
	        return this._map.then(function (m) { return google.maps.event.trigger(m, eventName); });
	    };
	    GoogleMapsAPIWrapper.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    GoogleMapsAPIWrapper.ctorParameters = function () { return [
	        { type: maps_api_loader_1.MapsAPILoader, },
	        { type: core_1.NgZone, },
	    ]; };
	    return GoogleMapsAPIWrapper;
	}());
	exports.GoogleMapsAPIWrapper = GoogleMapsAPIWrapper;
	//# sourceMappingURL=google-maps-api-wrapper.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var MapsAPILoader = (function () {
	    function MapsAPILoader() {
	    }
	    MapsAPILoader.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    MapsAPILoader.ctorParameters = function () { return []; };
	    return MapsAPILoader;
	}());
	exports.MapsAPILoader = MapsAPILoader;
	//# sourceMappingURL=maps-api-loader.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var CircleManager = (function () {
	    function CircleManager(_apiWrapper, _zone) {
	        this._apiWrapper = _apiWrapper;
	        this._zone = _zone;
	        this._circles = new Map();
	    }
	    CircleManager.prototype.addCircle = function (circle) {
	        this._circles.set(circle, this._apiWrapper.createCircle({
	            center: { lat: circle.latitude, lng: circle.longitude },
	            clickable: circle.clickable,
	            draggable: circle.draggable,
	            editable: circle.editable,
	            fillColor: circle.fillColor,
	            fillOpacity: circle.fillOpacity,
	            radius: circle.radius,
	            strokeColor: circle.strokeColor,
	            strokeOpacity: circle.strokeOpacity,
	            strokePosition: circle.strokePosition,
	            strokeWeight: circle.strokeWeight,
	            visible: circle.visible,
	            zIndex: circle.zIndex
	        }));
	    };
	    ;
	    /**
	     * Removes the given circle from the map.
	     */
	    CircleManager.prototype.removeCircle = function (circle) {
	        var _this = this;
	        return this._circles.get(circle).then(function (c) {
	            c.setMap(null);
	            _this._circles.delete(circle);
	        });
	    };
	    CircleManager.prototype.setOptions = function (circle, options) {
	        return this._circles.get(circle).then(function (c) { return c.setOptions(options); });
	    };
	    ;
	    CircleManager.prototype.getBounds = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.getBounds(); });
	    };
	    ;
	    CircleManager.prototype.getCenter = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.getCenter(); });
	    };
	    ;
	    CircleManager.prototype.getRadius = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.getRadius(); });
	    };
	    CircleManager.prototype.setCenter = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.setCenter({ lat: circle.latitude, lng: circle.longitude }); });
	    };
	    ;
	    CircleManager.prototype.setEditable = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.setEditable(circle.editable); });
	    };
	    ;
	    CircleManager.prototype.setDraggable = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.setDraggable(circle.draggable); });
	    };
	    ;
	    CircleManager.prototype.setVisible = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.setVisible(circle.visible); });
	    };
	    ;
	    CircleManager.prototype.setRadius = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.setRadius(circle.radius); });
	    };
	    ;
	    CircleManager.prototype.createEventObservable = function (eventName, circle) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            var listener = null;
	            _this._circles.get(circle).then(function (c) {
	                listener = c.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	            return function () {
	                if (listener !== null) {
	                    listener.remove();
	                }
	            };
	        });
	    };
	    CircleManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    CircleManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	    ]; };
	    return CircleManager;
	}());
	exports.CircleManager = CircleManager;
	//# sourceMappingURL=circle-manager.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(9);
	var core_1 = __webpack_require__(7);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var marker_manager_1 = __webpack_require__(68);
	var InfoWindowManager = (function () {
	    function InfoWindowManager(_mapsWrapper, _zone, _markerManager) {
	        this._mapsWrapper = _mapsWrapper;
	        this._zone = _zone;
	        this._markerManager = _markerManager;
	        this._infoWindows = new Map();
	    }
	    InfoWindowManager.prototype.deleteInfoWindow = function (infoWindow) {
	        var _this = this;
	        var iWindow = this._infoWindows.get(infoWindow);
	        if (iWindow == null) {
	            // info window already deleted
	            return Promise.resolve();
	        }
	        return iWindow.then(function (i) {
	            return _this._zone.run(function () {
	                i.close();
	                _this._infoWindows.delete(infoWindow);
	            });
	        });
	    };
	    InfoWindowManager.prototype.setPosition = function (infoWindow) {
	        return this._infoWindows.get(infoWindow).then(function (i) { return i.setPosition({
	            lat: infoWindow.latitude,
	            lng: infoWindow.longitude
	        }); });
	    };
	    InfoWindowManager.prototype.setZIndex = function (infoWindow) {
	        return this._infoWindows.get(infoWindow)
	            .then(function (i) { return i.setZIndex(infoWindow.zIndex); });
	    };
	    InfoWindowManager.prototype.open = function (infoWindow) {
	        var _this = this;
	        return this._infoWindows.get(infoWindow).then(function (w) {
	            if (infoWindow.hostMarker != null) {
	                return _this._markerManager.getNativeMarker(infoWindow.hostMarker).then(function (marker) {
	                    return _this._mapsWrapper.getNativeMap().then(function (map) { return w.open(map, marker); });
	                });
	            }
	            return _this._mapsWrapper.getNativeMap().then(function (map) { return w.open(map); });
	        });
	    };
	    InfoWindowManager.prototype.close = function (infoWindow) {
	        return this._infoWindows.get(infoWindow).then(function (w) { return w.close(); });
	    };
	    InfoWindowManager.prototype.setOptions = function (infoWindow, options) {
	        return this._infoWindows.get(infoWindow).then(function (i) { return i.setOptions(options); });
	    };
	    InfoWindowManager.prototype.addInfoWindow = function (infoWindow) {
	        var options = {
	            content: infoWindow.content,
	            maxWidth: infoWindow.maxWidth,
	            zIndex: infoWindow.zIndex,
	        };
	        if (typeof infoWindow.latitude === 'number' && typeof infoWindow.longitude === 'number') {
	            options.position = { lat: infoWindow.latitude, lng: infoWindow.longitude };
	        }
	        var infoWindowPromise = this._mapsWrapper.createInfoWindow(options);
	        this._infoWindows.set(infoWindow, infoWindowPromise);
	    };
	    /**
	     * Creates a Google Maps event listener for the given InfoWindow as an Observable
	     */
	    InfoWindowManager.prototype.createEventObservable = function (eventName, infoWindow) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._infoWindows.get(infoWindow).then(function (i) {
	                i.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	        });
	    };
	    InfoWindowManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    InfoWindowManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	        { type: marker_manager_1.MarkerManager, },
	    ]; };
	    return InfoWindowManager;
	}());
	exports.InfoWindowManager = InfoWindowManager;
	//# sourceMappingURL=info-window-manager.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var MarkerManager = (function () {
	    function MarkerManager(_mapsWrapper, _zone) {
	        this._mapsWrapper = _mapsWrapper;
	        this._zone = _zone;
	        this._markers = new Map();
	    }
	    MarkerManager.prototype.deleteMarker = function (marker) {
	        var _this = this;
	        var m = this._markers.get(marker);
	        if (m == null) {
	            // marker already deleted
	            return Promise.resolve();
	        }
	        return m.then(function (m) {
	            return _this._zone.run(function () {
	                m.setMap(null);
	                _this._markers.delete(marker);
	            });
	        });
	    };
	    MarkerManager.prototype.updateMarkerPosition = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setPosition({ lat: marker.latitude, lng: marker.longitude }); });
	    };
	    MarkerManager.prototype.updateTitle = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setTitle(marker.title); });
	    };
	    MarkerManager.prototype.updateLabel = function (marker) {
	        return this._markers.get(marker).then(function (m) { m.setLabel(marker.label); });
	    };
	    MarkerManager.prototype.updateDraggable = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setDraggable(marker.draggable); });
	    };
	    MarkerManager.prototype.updateIcon = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setIcon(marker.iconUrl); });
	    };
	    MarkerManager.prototype.updateOpacity = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setOpacity(marker.opacity); });
	    };
	    MarkerManager.prototype.updateVisible = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setVisible(marker.visible); });
	    };
	    MarkerManager.prototype.updateZIndex = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setZIndex(marker.zIndex); });
	    };
	    MarkerManager.prototype.addMarker = function (marker) {
	        var markerPromise = this._mapsWrapper.createMarker({
	            position: { lat: marker.latitude, lng: marker.longitude },
	            label: marker.label,
	            draggable: marker.draggable,
	            icon: marker.iconUrl,
	            opacity: marker.opacity,
	            visible: marker.visible,
	            zIndex: marker.zIndex,
	            title: marker.title
	        });
	        this._markers.set(marker, markerPromise);
	    };
	    MarkerManager.prototype.getNativeMarker = function (marker) {
	        return this._markers.get(marker);
	    };
	    MarkerManager.prototype.createEventObservable = function (eventName, marker) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._markers.get(marker).then(function (m) {
	                m.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	        });
	    };
	    MarkerManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    MarkerManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	    ]; };
	    return MarkerManager;
	}());
	exports.MarkerManager = MarkerManager;
	//# sourceMappingURL=marker-manager.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var PolygonManager = (function () {
	    function PolygonManager(_mapsWrapper, _zone) {
	        this._mapsWrapper = _mapsWrapper;
	        this._zone = _zone;
	        this._polygons = new Map();
	    }
	    PolygonManager.prototype.addPolygon = function (path) {
	        var polygonPromise = this._mapsWrapper.createPolygon({
	            clickable: path.clickable,
	            draggable: path.draggable,
	            editable: path.editable,
	            fillColor: path.fillColor,
	            fillOpacity: path.fillOpacity,
	            geodesic: path.geodesic,
	            paths: path.paths,
	            strokeColor: path.strokeColor,
	            strokeOpacity: path.strokeOpacity,
	            strokeWeight: path.strokeWeight,
	            visible: path.visible,
	            zIndex: path.zIndex,
	        });
	        this._polygons.set(path, polygonPromise);
	    };
	    PolygonManager.prototype.updatePolygon = function (polygon) {
	        var _this = this;
	        var m = this._polygons.get(polygon);
	        if (m == null) {
	            return Promise.resolve();
	        }
	        return m.then(function (l) { return _this._zone.run(function () { l.setPaths(polygon.paths); }); });
	    };
	    PolygonManager.prototype.setPolygonOptions = function (path, options) {
	        return this._polygons.get(path).then(function (l) { l.setOptions(options); });
	    };
	    PolygonManager.prototype.deletePolygon = function (paths) {
	        var _this = this;
	        var m = this._polygons.get(paths);
	        if (m == null) {
	            return Promise.resolve();
	        }
	        return m.then(function (l) {
	            return _this._zone.run(function () {
	                l.setMap(null);
	                _this._polygons.delete(paths);
	            });
	        });
	    };
	    PolygonManager.prototype.createEventObservable = function (eventName, path) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._polygons.get(path).then(function (l) {
	                l.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	        });
	    };
	    PolygonManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    PolygonManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	    ]; };
	    return PolygonManager;
	}());
	exports.PolygonManager = PolygonManager;
	//# sourceMappingURL=polygon-manager.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var PolylineManager = (function () {
	    function PolylineManager(_mapsWrapper, _zone) {
	        this._mapsWrapper = _mapsWrapper;
	        this._zone = _zone;
	        this._polylines = new Map();
	    }
	    PolylineManager._convertPoints = function (line) {
	        var path = line._getPoints().map(function (point) {
	            return { lat: point.latitude, lng: point.longitude };
	        });
	        return path;
	    };
	    PolylineManager.prototype.addPolyline = function (line) {
	        var path = PolylineManager._convertPoints(line);
	        var polylinePromise = this._mapsWrapper.createPolyline({
	            clickable: line.clickable,
	            draggable: line.draggable,
	            editable: line.editable,
	            geodesic: line.geodesic,
	            strokeColor: line.strokeColor,
	            strokeOpacity: line.strokeOpacity,
	            strokeWeight: line.strokeWeight,
	            visible: line.visible,
	            zIndex: line.zIndex,
	            path: path
	        });
	        this._polylines.set(line, polylinePromise);
	    };
	    PolylineManager.prototype.updatePolylinePoints = function (line) {
	        var _this = this;
	        var path = PolylineManager._convertPoints(line);
	        var m = this._polylines.get(line);
	        if (m == null) {
	            return Promise.resolve();
	        }
	        return m.then(function (l) { return _this._zone.run(function () { l.setPath(path); }); });
	    };
	    PolylineManager.prototype.setPolylineOptions = function (line, options) {
	        return this._polylines.get(line).then(function (l) { l.setOptions(options); });
	    };
	    PolylineManager.prototype.deletePolyline = function (line) {
	        var _this = this;
	        var m = this._polylines.get(line);
	        if (m == null) {
	            return Promise.resolve();
	        }
	        return m.then(function (l) {
	            return _this._zone.run(function () {
	                l.setMap(null);
	                _this._polylines.delete(line);
	            });
	        });
	    };
	    PolylineManager.prototype.createEventObservable = function (eventName, line) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._polylines.get(line).then(function (l) {
	                l.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	        });
	    };
	    PolylineManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    PolylineManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	    ]; };
	    return PolylineManager;
	}());
	exports.PolylineManager = PolylineManager;
	//# sourceMappingURL=polyline-manager.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	/**
	 * Manages all KML Layers for a Google Map instance.
	 */
	var KmlLayerManager = (function () {
	    function KmlLayerManager(_wrapper, _zone) {
	        this._wrapper = _wrapper;
	        this._zone = _zone;
	        this._layers = new Map();
	    }
	    /**
	     * Adds a new KML Layer to the map.
	     */
	    KmlLayerManager.prototype.addKmlLayer = function (layer) {
	        var newLayer = this._wrapper.getNativeMap().then(function (m) {
	            return new google.maps.KmlLayer({
	                clickable: layer.clickable,
	                map: m,
	                preserveViewport: layer.preserveViewport,
	                screenOverlays: layer.screenOverlays,
	                suppressInfoWindows: layer.suppressInfoWindows,
	                url: layer.url,
	                zIndex: layer.zIndex
	            });
	        });
	        this._layers.set(layer, newLayer);
	    };
	    KmlLayerManager.prototype.setOptions = function (layer, options) {
	        this._layers.get(layer).then(function (l) { return l.setOptions(options); });
	    };
	    KmlLayerManager.prototype.deleteKmlLayer = function (layer) {
	        var _this = this;
	        this._layers.get(layer).then(function (l) {
	            l.setMap(null);
	            _this._layers.delete(layer);
	        });
	    };
	    /**
	     * Creates a Google Maps event listener for the given KmlLayer as an Observable
	     */
	    KmlLayerManager.prototype.createEventObservable = function (eventName, layer) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._layers.get(layer).then(function (m) {
	                m.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	        });
	    };
	    KmlLayerManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    KmlLayerManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	    ]; };
	    return KmlLayerManager;
	}());
	exports.KmlLayerManager = KmlLayerManager;
	//# sourceMappingURL=kml-layer-manager.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var circle_manager_1 = __webpack_require__(66);
	var SebmGoogleMapCircle = (function () {
	    function SebmGoogleMapCircle(_manager) {
	        this._manager = _manager;
	        /**
	         * Indicates whether this Circle handles mouse events. Defaults to true.
	         */
	        this.clickable = true;
	        /**
	         * If set to true, the user can drag this circle over the map. Defaults to false.
	         */
	        this.draggable = false;
	        /**
	         * If set to true, the user can edit this circle by dragging the control points shown at
	         * the center and around the circumference of the circle. Defaults to false.
	         */
	        this.editable = false;
	        /**
	         * The radius in meters on the Earth's surface.
	         */
	        this.radius = 0;
	        /**
	         * The stroke position. Defaults to CENTER.
	         * This property is not supported on Internet Explorer 8 and earlier.
	         */
	        this.strokePosition = 'CENTER';
	        /**
	         * The stroke width in pixels.
	         */
	        this.strokeWeight = 0;
	        /**
	         * Whether this circle is visible on the map. Defaults to true.
	         */
	        this.visible = true;
	        /**
	         * This event is fired when the circle's center is changed.
	         */
	        this.centerChange = new core_1.EventEmitter();
	        /**
	         * This event emitter gets emitted when the user clicks on the circle.
	         */
	        this.circleClick = new core_1.EventEmitter();
	        /**
	         * This event emitter gets emitted when the user clicks on the circle.
	         */
	        this.circleDblClick = new core_1.EventEmitter();
	        /**
	         * This event is repeatedly fired while the user drags the circle.
	         */
	        this.drag = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user stops dragging the circle.
	         */
	        this.dragEnd = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user starts dragging the circle.
	         */
	        this.dragStart = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousedown event is fired on the circle.
	         */
	        this.mouseDown = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousemove event is fired on the circle.
	         */
	        this.mouseMove = new core_1.EventEmitter();
	        /**
	         * This event is fired on circle mouseout.
	         */
	        this.mouseOut = new core_1.EventEmitter();
	        /**
	         * This event is fired on circle mouseover.
	         */
	        this.mouseOver = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mouseup event is fired on the circle.
	         */
	        this.mouseUp = new core_1.EventEmitter();
	        /**
	         * This event is fired when the circle's radius is changed.
	         */
	        this.radiusChange = new core_1.EventEmitter();
	        /**
	         * This event is fired when the circle is right-clicked on.
	         */
	        this.rightClick = new core_1.EventEmitter();
	        this._circleAddedToManager = false;
	        this._eventSubscriptions = [];
	    }
	    /** @internal */
	    SebmGoogleMapCircle.prototype.ngOnInit = function () {
	        this._manager.addCircle(this);
	        this._circleAddedToManager = true;
	        this._registerEventListeners();
	    };
	    /** @internal */
	    SebmGoogleMapCircle.prototype.ngOnChanges = function (changes) {
	        if (!this._circleAddedToManager) {
	            return;
	        }
	        if (changes['latitude'] || changes['longitude']) {
	            this._manager.setCenter(this);
	        }
	        if (changes['editable']) {
	            this._manager.setEditable(this);
	        }
	        if (changes['draggable']) {
	            this._manager.setDraggable(this);
	        }
	        if (changes['visible']) {
	            this._manager.setVisible(this);
	        }
	        if (changes['radius']) {
	            this._manager.setRadius(this);
	        }
	        this._updateCircleOptionsChanges(changes);
	    };
	    SebmGoogleMapCircle.prototype._updateCircleOptionsChanges = function (changes) {
	        var options = {};
	        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMapCircle._mapOptions.indexOf(k) !== -1; });
	        optionKeys.forEach(function (k) { options[k] = changes[k].currentValue; });
	        if (optionKeys.length > 0) {
	            this._manager.setOptions(this, options);
	        }
	    };
	    SebmGoogleMapCircle.prototype._registerEventListeners = function () {
	        var _this = this;
	        var events = new Map();
	        events.set('center_changed', this.centerChange);
	        events.set('click', this.circleClick);
	        events.set('dblclick', this.circleDblClick);
	        events.set('drag', this.drag);
	        events.set('dragend', this.dragEnd);
	        events.set('dragStart', this.dragStart);
	        events.set('mousedown', this.mouseDown);
	        events.set('mousemove', this.mouseMove);
	        events.set('mouseout', this.mouseOut);
	        events.set('mouseover', this.mouseOver);
	        events.set('mouseup', this.mouseUp);
	        events.set('radius_changed', this.radiusChange);
	        events.set('rightclick', this.rightClick);
	        events.forEach(function (eventEmitter, eventName) {
	            _this._eventSubscriptions.push(_this._manager.createEventObservable(eventName, _this).subscribe(function (value) {
	                switch (eventName) {
	                    case 'radius_changed':
	                        _this._manager.getRadius(_this).then(function (radius) { return eventEmitter.emit(radius); });
	                        break;
	                    case 'center_changed':
	                        _this._manager.getCenter(_this).then(function (center) {
	                            return eventEmitter.emit({ lat: center.lat(), lng: center.lng() });
	                        });
	                        break;
	                    default:
	                        eventEmitter.emit({ coords: { lat: value.latLng.lat(), lng: value.latLng.lng() } });
	                }
	            }));
	        });
	    };
	    /** @internal */
	    SebmGoogleMapCircle.prototype.ngOnDestroy = function () {
	        this._eventSubscriptions.forEach(function (s) { s.unsubscribe(); });
	        this._eventSubscriptions = null;
	        this._manager.removeCircle(this);
	    };
	    /**
	     * Gets the LatLngBounds of this Circle.
	     */
	    SebmGoogleMapCircle.prototype.getBounds = function () { return this._manager.getBounds(this); };
	    SebmGoogleMapCircle.prototype.getCenter = function () { return this._manager.getCenter(this); };
	    SebmGoogleMapCircle._mapOptions = [
	        'fillColor', 'fillOpacity', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight',
	        'visible', 'zIndex'
	    ];
	    SebmGoogleMapCircle.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'sebm-google-map-circle',
	                    inputs: [
	                        'latitude', 'longitude', 'clickable', 'draggable: circleDraggable', 'editable', 'fillColor',
	                        'fillOpacity', 'radius', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight',
	                        'visible', 'zIndex'
	                    ],
	                    outputs: [
	                        'centerChange', 'circleClick', 'circleDblClick', 'drag', 'dragEnd', 'dragStart', 'mouseDown',
	                        'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'radiusChange', 'rightClick'
	                    ]
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapCircle.ctorParameters = function () { return [
	        { type: circle_manager_1.CircleManager, },
	    ]; };
	    return SebmGoogleMapCircle;
	}());
	exports.SebmGoogleMapCircle = SebmGoogleMapCircle;
	//# sourceMappingURL=google-map-circle.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var info_window_manager_1 = __webpack_require__(67);
	var infoWindowId = 0;
	/**
	 * SebmGoogleMapInfoWindow renders a info window inside a {@link SebmGoogleMapMarker} or standalone.
	 *
	 * ### Example
	 * ```typescript
	 * import { Component } from 'angular2/core';
	 * import { SebmGoogleMap, SebmGoogleMapMarker, SebmGoogleMapInfoWindow } from
	 * 'angular2-google-maps/core';
	 *
	 * @Component({
	 *  selector: 'my-map-cmp',
	 *  directives: [SebmGoogleMap, SebmGoogleMapMarker, SebmGoogleMapInfoWindow],
	 *  styles: [`
	 *    .sebm-google-map-container {
	 *      height: 300px;
	 *    }
	 * `],
	 *  template: `
	 *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
	 *      <sebm-google-map-marker [latitude]="lat" [longitude]="lng" [label]="'M'">
	 *        <sebm-google-map-info-window [disableAutoPan]="true">
	 *          Hi, this is the content of the <strong>info window</strong>
	 *        </sebm-google-map-info-window>
	 *      </sebm-google-map-marker>
	 *    </sebm-google-map>
	 *  `
	 * })
	 * ```
	 */
	var SebmGoogleMapInfoWindow = (function () {
	    function SebmGoogleMapInfoWindow(_infoWindowManager, _el) {
	        this._infoWindowManager = _infoWindowManager;
	        this._el = _el;
	        /**
	         * Sets the open state for the InfoWindow. You can also call the open() and close() methods.
	         */
	        this.isOpen = false;
	        /**
	         * Emits an event when the info window is closed.
	         */
	        this.infoWindowClose = new core_1.EventEmitter();
	        this._infoWindowAddedToManager = false;
	        this._id = (infoWindowId++).toString();
	    }
	    SebmGoogleMapInfoWindow.prototype.ngOnInit = function () {
	        this.content = this._el.nativeElement.querySelector('.sebm-google-map-info-window-content');
	        this._infoWindowManager.addInfoWindow(this);
	        this._infoWindowAddedToManager = true;
	        this._updateOpenState();
	        this._registerEventListeners();
	    };
	    /** @internal */
	    SebmGoogleMapInfoWindow.prototype.ngOnChanges = function (changes) {
	        if (!this._infoWindowAddedToManager) {
	            return;
	        }
	        if ((changes['latitude'] || changes['longitude']) && typeof this.latitude === 'number' &&
	            typeof this.longitude === 'number') {
	            this._infoWindowManager.setPosition(this);
	        }
	        if (changes['zIndex']) {
	            this._infoWindowManager.setZIndex(this);
	        }
	        if (changes['isOpen']) {
	            this._updateOpenState();
	        }
	        this._setInfoWindowOptions(changes);
	    };
	    SebmGoogleMapInfoWindow.prototype._registerEventListeners = function () {
	        var _this = this;
	        this._infoWindowManager.createEventObservable('closeclick', this).subscribe(function () {
	            _this.isOpen = false;
	            _this.infoWindowClose.emit();
	        });
	    };
	    SebmGoogleMapInfoWindow.prototype._updateOpenState = function () {
	        this.isOpen ? this.open() : this.close();
	    };
	    SebmGoogleMapInfoWindow.prototype._setInfoWindowOptions = function (changes) {
	        var options = {};
	        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMapInfoWindow._infoWindowOptionsInputs.indexOf(k) !== -1; });
	        optionKeys.forEach(function (k) { options[k] = changes[k].currentValue; });
	        this._infoWindowManager.setOptions(this, options);
	    };
	    /**
	     * Opens the info window.
	     */
	    SebmGoogleMapInfoWindow.prototype.open = function () { return this._infoWindowManager.open(this); };
	    /**
	     * Closes the info window.
	     */
	    SebmGoogleMapInfoWindow.prototype.close = function () {
	        var _this = this;
	        return this._infoWindowManager.close(this).then(function () { _this.infoWindowClose.emit(); });
	    };
	    /** @internal */
	    SebmGoogleMapInfoWindow.prototype.id = function () { return this._id; };
	    /** @internal */
	    SebmGoogleMapInfoWindow.prototype.toString = function () { return 'SebmGoogleMapInfoWindow-' + this._id.toString(); };
	    /** @internal */
	    SebmGoogleMapInfoWindow.prototype.ngOnDestroy = function () { this._infoWindowManager.deleteInfoWindow(this); };
	    SebmGoogleMapInfoWindow._infoWindowOptionsInputs = ['disableAutoPan', 'maxWidth'];
	    SebmGoogleMapInfoWindow.decorators = [
	        { type: core_1.Component, args: [{
	                    selector: 'sebm-google-map-info-window',
	                    inputs: ['latitude', 'longitude', 'disableAutoPan', 'isOpen', 'zIndex', 'maxWidth'],
	                    outputs: ['infoWindowClose'],
	                    template: "<div class='sebm-google-map-info-window-content'>\n      <ng-content></ng-content>\n    </div>\n  "
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapInfoWindow.ctorParameters = function () { return [
	        { type: info_window_manager_1.InfoWindowManager, },
	        { type: core_1.ElementRef, },
	    ]; };
	    return SebmGoogleMapInfoWindow;
	}());
	exports.SebmGoogleMapInfoWindow = SebmGoogleMapInfoWindow;
	//# sourceMappingURL=google-map-info-window.js.map

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var kml_layer_manager_1 = __webpack_require__(71);
	var layerId = 0;
	var SebmGoogleMapKmlLayer = (function () {
	    function SebmGoogleMapKmlLayer(_manager) {
	        this._manager = _manager;
	        this._addedToManager = false;
	        this._id = (layerId++).toString();
	        this._subscriptions = [];
	        /**
	         * If true, the layer receives mouse events. Default value is true.
	         */
	        this.clickable = true;
	        /**
	         * By default, the input map is centered and zoomed to the bounding box of the contents of the
	         * layer.
	         * If this option is set to true, the viewport is left unchanged, unless the map's center and zoom
	         * were never set.
	         */
	        this.preserveViewport = false;
	        /**
	         * Whether to render the screen overlays. Default true.
	         */
	        this.screenOverlays = true;
	        /**
	         * Suppress the rendering of info windows when layer features are clicked.
	         */
	        this.suppressInfoWindows = false;
	        /**
	         * The URL of the KML document to display.
	         */
	        this.url = null;
	        /**
	         * The z-index of the layer.
	         */
	        this.zIndex = null;
	        /**
	         * This event is fired when a feature in the layer is clicked.
	         */
	        this.layerClick = new core_1.EventEmitter();
	        /**
	         * This event is fired when the KML layers default viewport has changed.
	         */
	        this.defaultViewportChange = new core_1.EventEmitter();
	        /**
	         * This event is fired when the KML layer has finished loading.
	         * At this point it is safe to read the status property to determine if the layer loaded
	         * successfully.
	         */
	        this.statusChange = new core_1.EventEmitter();
	    }
	    SebmGoogleMapKmlLayer.prototype.ngOnInit = function () {
	        if (this._addedToManager) {
	            return;
	        }
	        this._manager.addKmlLayer(this);
	        this._addedToManager = true;
	        this._addEventListeners();
	    };
	    SebmGoogleMapKmlLayer.prototype.ngOnChanges = function (changes) {
	        if (!this._addedToManager) {
	            return;
	        }
	        this._updatePolygonOptions(changes);
	    };
	    SebmGoogleMapKmlLayer.prototype._updatePolygonOptions = function (changes) {
	        var options = Object.keys(changes)
	            .filter(function (k) { return SebmGoogleMapKmlLayer._kmlLayerOptions.indexOf(k) !== -1; })
	            .reduce(function (obj, k) {
	            obj[k] = changes[k].currentValue;
	            return obj;
	        }, {});
	        if (Object.keys(options).length > 0) {
	            this._manager.setOptions(this, options);
	        }
	    };
	    SebmGoogleMapKmlLayer.prototype._addEventListeners = function () {
	        var _this = this;
	        var listeners = [
	            { name: 'click', handler: function (ev) { return _this.layerClick.emit(ev); } },
	            { name: 'defaultviewport_changed', handler: function () { return _this.defaultViewportChange.emit(); } },
	            { name: 'status_changed', handler: function () { return _this.statusChange.emit(); } },
	        ];
	        listeners.forEach(function (obj) {
	            var os = _this._manager.createEventObservable(obj.name, _this).subscribe(obj.handler);
	            _this._subscriptions.push(os);
	        });
	    };
	    /** @internal */
	    SebmGoogleMapKmlLayer.prototype.id = function () { return this._id; };
	    /** @internal */
	    SebmGoogleMapKmlLayer.prototype.toString = function () { return "SebmGoogleMapKmlLayer-" + this._id.toString(); };
	    /** @internal */
	    SebmGoogleMapKmlLayer.prototype.ngOnDestroy = function () {
	        this._manager.deleteKmlLayer(this);
	        // unsubscribe all registered observable subscriptions
	        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });
	    };
	    SebmGoogleMapKmlLayer._kmlLayerOptions = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'];
	    SebmGoogleMapKmlLayer.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'sebm-google-map-kml-layer',
	                    inputs: ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'],
	                    outputs: ['layerClick', 'defaultViewportChange', 'statusChange']
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapKmlLayer.ctorParameters = function () { return [
	        { type: kml_layer_manager_1.KmlLayerManager, },
	    ]; };
	    return SebmGoogleMapKmlLayer;
	}());
	exports.SebmGoogleMapKmlLayer = SebmGoogleMapKmlLayer;
	//# sourceMappingURL=google-map-kml-layer.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var marker_manager_1 = __webpack_require__(68);
	var google_map_info_window_1 = __webpack_require__(73);
	var markerId = 0;
	/**
	 * SebmGoogleMapMarker renders a map marker inside a {@link SebmGoogleMap}.
	 *
	 * ### Example
	 * ```typescript
	 * import { Component } from 'angular2/core';
	 * import { SebmGoogleMap, SebmGoogleMapMarker } from 'angular2-google-maps/core';
	 *
	 * @Component({
	 *  selector: 'my-map-cmp',
	 *  directives: [SebmGoogleMap, SebmGoogleMapMarker],
	 *  styles: [`
	 *    .sebm-google-map-container {
	 *      height: 300px;
	 *    }
	 * `],
	 *  template: `
	 *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
	 *      <sebm-google-map-marker [latitude]="lat" [longitude]="lng" [label]="'M'">
	 *      </sebm-google-map-marker>
	 *    </sebm-google-map>
	 *  `
	 * })
	 * ```
	 */
	var SebmGoogleMapMarker = (function () {
	    function SebmGoogleMapMarker(_markerManager) {
	        this._markerManager = _markerManager;
	        /**
	         * If true, the marker can be dragged. Default value is false.
	         */
	        this.draggable = false;
	        /**
	         * If true, the marker is visible
	         */
	        this.visible = true;
	        /**
	         * Whether to automatically open the child info window when the marker is clicked.
	         */
	        this.openInfoWindow = true;
	        /**
	         * The marker's opacity between 0.0 and 1.0.
	         */
	        this.opacity = 1;
	        /**
	         * All markers are displayed on the map in order of their zIndex, with higher values displaying in
	         * front of markers with lower values. By default, markers are displayed according to their
	         * vertical position on screen, with lower markers appearing in front of markers further up the
	         * screen.
	         */
	        this.zIndex = 1;
	        /**
	         * This event emitter gets emitted when the user clicks on the marker.
	         */
	        this.markerClick = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user stops dragging the marker.
	         */
	        this.dragEnd = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user mouses over the marker.
	         */
	        this.mouseOver = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user mouses outside the marker.
	         */
	        this.mouseOut = new core_1.EventEmitter();
	        this._markerAddedToManger = false;
	        this._observableSubscriptions = [];
	        this._id = (markerId++).toString();
	    }
	    /* @internal */
	    SebmGoogleMapMarker.prototype.ngAfterContentInit = function () {
	        if (this.infoWindow != null) {
	            this.infoWindow.hostMarker = this;
	        }
	    };
	    /** @internal */
	    SebmGoogleMapMarker.prototype.ngOnChanges = function (changes) {
	        if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {
	            return;
	        }
	        if (!this._markerAddedToManger) {
	            this._markerManager.addMarker(this);
	            this._markerAddedToManger = true;
	            this._addEventListeners();
	            return;
	        }
	        if (changes['latitude'] || changes['longitude']) {
	            this._markerManager.updateMarkerPosition(this);
	        }
	        if (changes['title']) {
	            this._markerManager.updateTitle(this);
	        }
	        if (changes['label']) {
	            this._markerManager.updateLabel(this);
	        }
	        if (changes['draggable']) {
	            this._markerManager.updateDraggable(this);
	        }
	        if (changes['iconUrl']) {
	            this._markerManager.updateIcon(this);
	        }
	        if (changes['opacity']) {
	            this._markerManager.updateOpacity(this);
	        }
	        if (changes['visible']) {
	            this._markerManager.updateVisible(this);
	        }
	        if (changes['zIndex']) {
	            this._markerManager.updateZIndex(this);
	        }
	    };
	    SebmGoogleMapMarker.prototype._addEventListeners = function () {
	        var _this = this;
	        var cs = this._markerManager.createEventObservable('click', this).subscribe(function () {
	            if (_this.openInfoWindow && _this.infoWindow != null) {
	                _this.infoWindow.open();
	            }
	            _this.markerClick.emit(null);
	        });
	        this._observableSubscriptions.push(cs);
	        var ds = this._markerManager.createEventObservable('dragend', this)
	            .subscribe(function (e) {
	            _this.dragEnd.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
	        });
	        this._observableSubscriptions.push(ds);
	        var mover = this._markerManager.createEventObservable('mouseover', this)
	            .subscribe(function (e) {
	            _this.mouseOver.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
	        });
	        this._observableSubscriptions.push(mover);
	        var mout = this._markerManager.createEventObservable('mouseout', this)
	            .subscribe(function (e) {
	            _this.mouseOut.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
	        });
	        this._observableSubscriptions.push(mout);
	    };
	    /** @internal */
	    SebmGoogleMapMarker.prototype.id = function () { return this._id; };
	    /** @internal */
	    SebmGoogleMapMarker.prototype.toString = function () { return 'SebmGoogleMapMarker-' + this._id.toString(); };
	    /** @internal */
	    SebmGoogleMapMarker.prototype.ngOnDestroy = function () {
	        this._markerManager.deleteMarker(this);
	        // unsubscribe all registered observable subscriptions
	        this._observableSubscriptions.forEach(function (s) { return s.unsubscribe(); });
	    };
	    SebmGoogleMapMarker.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'sebm-google-map-marker',
	                    inputs: [
	                        'latitude', 'longitude', 'title', 'label', 'draggable: markerDraggable', 'iconUrl',
	                        'openInfoWindow', 'opacity', 'visible', 'zIndex'
	                    ],
	                    outputs: ['markerClick', 'dragEnd', 'mouseOver', 'mouseOut']
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapMarker.ctorParameters = function () { return [
	        { type: marker_manager_1.MarkerManager, },
	    ]; };
	    SebmGoogleMapMarker.propDecorators = {
	        'infoWindow': [{ type: core_1.ContentChild, args: [google_map_info_window_1.SebmGoogleMapInfoWindow,] },],
	    };
	    return SebmGoogleMapMarker;
	}());
	exports.SebmGoogleMapMarker = SebmGoogleMapMarker;
	//# sourceMappingURL=google-map-marker.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var polygon_manager_1 = __webpack_require__(69);
	/**
	 * SebmGoogleMapPolygon renders a polygon on a {@link SebmGoogleMap}
	 *
	 * ### Example
	 * ```typescript
	 * import { Component } from '@angular/core';
	 * import { SebmGoogleMap, SebmGooglePolygon, LatLngLiteral } from 'angular2-maps/core';
	 *
	 * @Component({
	 *  selector: 'my-map-cmp',
	 *  styles: [`
	 *    .semb-map-container {
	 *      height: 300px;
	 *    }
	 * `],
	 *  template: `
	 *    <semb-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
	 *      <semb-map-polygon [paths]="paths">
	 *      </semb-map-polygon>
	 *    </semb-map>
	 *  `
	 * })
	 * export class MyMapCmp {
	 *   lat: number = 0;
	 *   lng: number = 0;
	 *   zoom: number = 10;
	 *   paths: Array<LatLngLiteral> = [
	 *     { lat: 0,  lng: 10 },
	 *     { lat: 0,  lng: 20 },
	 *     { lat: 10, lng: 20 },
	 *     { lat: 10, lng: 10 },
	 *     { lat: 0,  lng: 10 }
	 *   ]
	 *   // Nesting paths will create a hole where they overlap;
	 *   nestedPaths: Array<Array<LatLngLiteral>> = [[
	 *     { lat: 0,  lng: 10 },
	 *     { lat: 0,  lng: 20 },
	 *     { lat: 10, lng: 20 },
	 *     { lat: 10, lng: 10 },
	 *     { lat: 0,  lng: 10 }
	 *   ], [
	 *     { lat: 0, lng: 15 },
	 *     { lat: 0, lng: 20 },
	 *     { lat: 5, lng: 20 },
	 *     { lat: 5, lng: 15 },
	 *     { lat: 0, lng: 15 }
	 *   ]]
	 * }
	 * ```
	 */
	var SebmGoogleMapPolygon = (function () {
	    function SebmGoogleMapPolygon(_polygonManager) {
	        this._polygonManager = _polygonManager;
	        /**
	         * Indicates whether this Polygon handles mouse events. Defaults to true.
	         */
	        this.clickable = true;
	        /**
	         * If set to true, the user can drag this shape over the map. The geodesic
	         * property defines the mode of dragging. Defaults to false.
	         */
	        this.draggable = false;
	        /**
	         * If set to true, the user can edit this shape by dragging the control
	         * points shown at the vertices and on each segment. Defaults to false.
	         */
	        this.editable = false;
	        /**
	         * When true, edges of the polygon are interpreted as geodesic and will
	         * follow the curvature of the Earth. When false, edges of the polygon are
	         * rendered as straight lines in screen space. Note that the shape of a
	         * geodesic polygon may appear to change when dragged, as the dimensions
	         * are maintained relative to the surface of the earth. Defaults to false.
	         */
	        this.geodesic = false;
	        /**
	         * The ordered sequence of coordinates that designates a closed loop.
	         * Unlike polylines, a polygon may consist of one or more paths.
	         *  As a result, the paths property may specify one or more arrays of
	         * LatLng coordinates. Paths are closed automatically; do not repeat the
	         * first vertex of the path as the last vertex. Simple polygons may be
	         * defined using a single array of LatLngs. More complex polygons may
	         * specify an array of arrays. Any simple arrays are converted into Arrays.
	         * Inserting or removing LatLngs from the Array will automatically update
	         * the polygon on the map.
	         */
	        this.paths = [];
	        /**
	         * This event is fired when the DOM click event is fired on the Polygon.
	         */
	        this.polyClick = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM dblclick event is fired on the Polygon.
	         */
	        this.polyDblClick = new core_1.EventEmitter();
	        /**
	         * This event is repeatedly fired while the user drags the polygon.
	         */
	        this.polyDrag = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user stops dragging the polygon.
	         */
	        this.polyDragEnd = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user starts dragging the polygon.
	         */
	        this.polyDragStart = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousedown event is fired on the Polygon.
	         */
	        this.polyMouseDown = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousemove event is fired on the Polygon.
	         */
	        this.polyMouseMove = new core_1.EventEmitter();
	        /**
	         * This event is fired on Polygon mouseout.
	         */
	        this.polyMouseOut = new core_1.EventEmitter();
	        /**
	         * This event is fired on Polygon mouseover.
	         */
	        this.polyMouseOver = new core_1.EventEmitter();
	        /**
	         * This event is fired whe the DOM mouseup event is fired on the Polygon
	         */
	        this.polyMouseUp = new core_1.EventEmitter();
	        /**
	         * This even is fired when the Polygon is right-clicked on.
	         */
	        this.polyRightClick = new core_1.EventEmitter();
	        this._polygonAddedToManager = false;
	        this._subscriptions = [];
	    }
	    /** @internal */
	    SebmGoogleMapPolygon.prototype.ngAfterContentInit = function () {
	        if (!this._polygonAddedToManager) {
	            this._init();
	        }
	    };
	    SebmGoogleMapPolygon.prototype.ngOnChanges = function (changes) {
	        if (!this._polygonAddedToManager) {
	            this._init();
	            return;
	        }
	        this._polygonManager.setPolygonOptions(this, this._updatePolygonOptions(changes));
	    };
	    SebmGoogleMapPolygon.prototype._init = function () {
	        this._polygonManager.addPolygon(this);
	        this._polygonAddedToManager = true;
	        this._addEventListeners();
	    };
	    SebmGoogleMapPolygon.prototype._addEventListeners = function () {
	        var _this = this;
	        var handlers = [
	            { name: 'click', handler: function (ev) { return _this.polyClick.emit(ev); } },
	            { name: 'dbclick', handler: function (ev) { return _this.polyDblClick.emit(ev); } },
	            { name: 'drag', handler: function (ev) { return _this.polyDrag.emit(ev); } },
	            { name: 'dragend', handler: function (ev) { return _this.polyDragEnd.emit(ev); } },
	            { name: 'dragstart', handler: function (ev) { return _this.polyDragStart.emit(ev); } },
	            { name: 'mousedown', handler: function (ev) { return _this.polyMouseDown.emit(ev); } },
	            { name: 'mousemove', handler: function (ev) { return _this.polyMouseMove.emit(ev); } },
	            { name: 'mouseout', handler: function (ev) { return _this.polyMouseOut.emit(ev); } },
	            { name: 'mouseover', handler: function (ev) { return _this.polyMouseOver.emit(ev); } },
	            { name: 'mouseup', handler: function (ev) { return _this.polyMouseUp.emit(ev); } },
	            { name: 'rightclick', handler: function (ev) { return _this.polyRightClick.emit(ev); } },
	        ];
	        handlers.forEach(function (obj) {
	            var os = _this._polygonManager.createEventObservable(obj.name, _this).subscribe(obj.handler);
	            _this._subscriptions.push(os);
	        });
	    };
	    SebmGoogleMapPolygon.prototype._updatePolygonOptions = function (changes) {
	        return Object.keys(changes)
	            .filter(function (k) { return SebmGoogleMapPolygon._polygonOptionsAttributes.indexOf(k) !== -1; })
	            .reduce(function (obj, k) {
	            obj[k] = changes[k].currentValue;
	            return obj;
	        }, {});
	    };
	    /** @internal */
	    SebmGoogleMapPolygon.prototype.id = function () { return this._id; };
	    /** @internal */
	    SebmGoogleMapPolygon.prototype.ngOnDestroy = function () {
	        this._polygonManager.deletePolygon(this);
	        // unsubscribe all registered observable subscriptions
	        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });
	    };
	    SebmGoogleMapPolygon._polygonOptionsAttributes = [
	        'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'icon', 'map',
	        'paths', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'draggable',
	        'editable', 'visible'
	    ];
	    SebmGoogleMapPolygon.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'sebm-map-polygon',
	                    inputs: [
	                        'clickable',
	                        'draggable: polyDraggable',
	                        'editable',
	                        'fillColor',
	                        'fillOpacity',
	                        'geodesic',
	                        'paths',
	                        'strokeColor',
	                        'strokeOpacity',
	                        'strokeWeight',
	                        'visible',
	                        'zIndex',
	                    ],
	                    outputs: [
	                        'polyClick', 'polyDblClick', 'polyDrag', 'polyDragEnd', 'polyMouseDown', 'polyMouseMove',
	                        'polyMouseOut', 'polyMouseOver', 'polyMouseUp', 'polyRightClick'
	                    ]
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapPolygon.ctorParameters = function () { return [
	        { type: polygon_manager_1.PolygonManager, },
	    ]; };
	    return SebmGoogleMapPolygon;
	}());
	exports.SebmGoogleMapPolygon = SebmGoogleMapPolygon;
	//# sourceMappingURL=google-map-polygon.js.map

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var polyline_manager_1 = __webpack_require__(70);
	var google_map_polyline_point_1 = __webpack_require__(78);
	var polylineId = 0;
	/**
	 * SebmGoogleMapPolyline renders a polyline on a {@link SebmGoogleMap}
	 *
	 * ### Example
	 * ```typescript
	 * import { Component } from 'angular2/core';
	 * import { SebmGoogleMap, SebmGooglePolyline, SebmGooglePolylinePoint } from
	 * 'angular2-google-maps/core';
	 *
	 * @Component({
	 *  selector: 'my-map-cmp',
	 *  directives: [SebmGoogleMap, SebmGooglePolyline, SebmGooglePolylinePoint],
	 *  styles: [`
	 *    .sebm-google-map-container {
	 *      height: 300px;
	 *    }
	 * `],
	 *  template: `
	 *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
	 *      <sebm-google-map-polyline>
	 *          <sebm-google-map-polyline-point [latitude]="latA" [longitude]="lngA">
	 *          </sebm-google-map-polyline-point>
	 *          <sebm-google-map-polyline-point [latitude]="latB" [longitude]="lngB">
	 *          </sebm-google-map-polyline-point>
	 *      </sebm-google-map-polyline>
	 *    </sebm-google-map>
	 *  `
	 * })
	 * ```
	 */
	var SebmGoogleMapPolyline = (function () {
	    function SebmGoogleMapPolyline(_polylineManager) {
	        this._polylineManager = _polylineManager;
	        /**
	         * Indicates whether this Polyline handles mouse events. Defaults to true.
	         */
	        this.clickable = true;
	        /**
	         * If set to true, the user can drag this shape over the map. The geodesic property defines the
	         * mode of dragging. Defaults to false.
	         */
	        this.draggable = false;
	        /**
	         * If set to true, the user can edit this shape by dragging the control points shown at the
	         * vertices and on each segment. Defaults to false.
	         */
	        this.editable = false;
	        /**
	         * When true, edges of the polygon are interpreted as geodesic and will follow the curvature of
	         * the Earth. When false, edges of the polygon are rendered as straight lines in screen space.
	         * Note that the shape of a geodesic polygon may appear to change when dragged, as the dimensions
	         * are maintained relative to the surface of the earth. Defaults to false.
	         */
	        this.geodesic = false;
	        /**
	         * Whether this polyline is visible on the map. Defaults to true.
	         */
	        this.visible = true;
	        /**
	         * This event is fired when the DOM click event is fired on the Polyline.
	         */
	        this.lineClick = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM dblclick event is fired on the Polyline.
	         */
	        this.lineDblClick = new core_1.EventEmitter();
	        /**
	         * This event is repeatedly fired while the user drags the polyline.
	         */
	        this.lineDrag = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user stops dragging the polyline.
	         */
	        this.lineDragEnd = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user starts dragging the polyline.
	         */
	        this.lineDragStart = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousedown event is fired on the Polyline.
	         */
	        this.lineMouseDown = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousemove event is fired on the Polyline.
	         */
	        this.lineMouseMove = new core_1.EventEmitter();
	        /**
	         * This event is fired on Polyline mouseout.
	         */
	        this.lineMouseOut = new core_1.EventEmitter();
	        /**
	         * This event is fired on Polyline mouseover.
	         */
	        this.lineMouseOver = new core_1.EventEmitter();
	        /**
	         * This event is fired whe the DOM mouseup event is fired on the Polyline
	         */
	        this.lineMouseUp = new core_1.EventEmitter();
	        /**
	         * This even is fired when the Polyline is right-clicked on.
	         */
	        this.lineRightClick = new core_1.EventEmitter();
	        this._polylineAddedToManager = false;
	        this._subscriptions = [];
	        this._id = (polylineId++).toString();
	    }
	    /** @internal */
	    SebmGoogleMapPolyline.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        if (this.points.length) {
	            this.points.forEach(function (point) {
	                var s = point.positionChanged.subscribe(function () { _this._polylineManager.updatePolylinePoints(_this); });
	                _this._subscriptions.push(s);
	            });
	        }
	        if (!this._polylineAddedToManager) {
	            this._init();
	        }
	        var s = this.points.changes.subscribe(function () { return _this._polylineManager.updatePolylinePoints(_this); });
	        this._subscriptions.push(s);
	        this._polylineManager.updatePolylinePoints(this);
	    };
	    SebmGoogleMapPolyline.prototype.ngOnChanges = function (changes) {
	        if (!this._polylineAddedToManager) {
	            this._init();
	            return;
	        }
	        var options = {};
	        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMapPolyline._polylineOptionsAttributes.indexOf(k) !== -1; });
	        optionKeys.forEach(function (k) { return options[k] = changes[k].currentValue; });
	        this._polylineManager.setPolylineOptions(this, options);
	    };
	    SebmGoogleMapPolyline.prototype._init = function () {
	        this._polylineManager.addPolyline(this);
	        this._polylineAddedToManager = true;
	        this._addEventListeners();
	    };
	    SebmGoogleMapPolyline.prototype._addEventListeners = function () {
	        var _this = this;
	        var handlers = [
	            { name: 'click', handler: function (ev) { return _this.lineClick.emit(ev); } },
	            { name: 'dbclick', handler: function (ev) { return _this.lineDblClick.emit(ev); } },
	            { name: 'drag', handler: function (ev) { return _this.lineDrag.emit(ev); } },
	            { name: 'dragend', handler: function (ev) { return _this.lineDragEnd.emit(ev); } },
	            { name: 'dragstart', handler: function (ev) { return _this.lineDragStart.emit(ev); } },
	            { name: 'mousedown', handler: function (ev) { return _this.lineMouseDown.emit(ev); } },
	            { name: 'mousemove', handler: function (ev) { return _this.lineMouseMove.emit(ev); } },
	            { name: 'mouseout', handler: function (ev) { return _this.lineMouseOut.emit(ev); } },
	            { name: 'mouseover', handler: function (ev) { return _this.lineMouseOver.emit(ev); } },
	            { name: 'mouseup', handler: function (ev) { return _this.lineMouseUp.emit(ev); } },
	            { name: 'rightclick', handler: function (ev) { return _this.lineRightClick.emit(ev); } },
	        ];
	        handlers.forEach(function (obj) {
	            var os = _this._polylineManager.createEventObservable(obj.name, _this).subscribe(obj.handler);
	            _this._subscriptions.push(os);
	        });
	    };
	    /** @internal */
	    SebmGoogleMapPolyline.prototype._getPoints = function () {
	        if (this.points) {
	            return this.points.toArray();
	        }
	        return [];
	    };
	    /** @internal */
	    SebmGoogleMapPolyline.prototype.id = function () { return this._id; };
	    /** @internal */
	    SebmGoogleMapPolyline.prototype.ngOnDestroy = function () {
	        this._polylineManager.deletePolyline(this);
	        // unsubscribe all registered observable subscriptions
	        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });
	    };
	    SebmGoogleMapPolyline._polylineOptionsAttributes = [
	        'draggable', 'editable', 'visible', 'geodesic', 'strokeColor', 'strokeOpacity', 'strokeWeight',
	        'zIndex'
	    ];
	    SebmGoogleMapPolyline.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'sebm-google-map-polyline',
	                    inputs: [
	                        'clickable', 'draggable: polylineDraggable', 'editable', 'geodesic', 'strokeColor',
	                        'strokeWeight', 'strokeOpacity', 'visible', 'zIndex'
	                    ],
	                    outputs: [
	                        'lineClick', 'lineDblClick', 'lineDrag', 'lineDragEnd', 'lineMouseDown', 'lineMouseMove',
	                        'lineMouseOut', 'lineMouseOver', 'lineMouseUp', 'lineRightClick'
	                    ]
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapPolyline.ctorParameters = function () { return [
	        { type: polyline_manager_1.PolylineManager, },
	    ]; };
	    SebmGoogleMapPolyline.propDecorators = {
	        'points': [{ type: core_1.ContentChildren, args: [google_map_polyline_point_1.SebmGoogleMapPolylinePoint,] },],
	    };
	    return SebmGoogleMapPolyline;
	}());
	exports.SebmGoogleMapPolyline = SebmGoogleMapPolyline;
	//# sourceMappingURL=google-map-polyline.js.map

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	/**
	 * SebmGoogleMapPolylinePoint represents one element of a polyline within a  {@link
	 * SembGoogleMapPolyline}
	 */
	var SebmGoogleMapPolylinePoint = (function () {
	    function SebmGoogleMapPolylinePoint() {
	        /**
	         * This event emitter gets emitted when the position of the point changed.
	         */
	        this.positionChanged = new core_1.EventEmitter();
	    }
	    SebmGoogleMapPolylinePoint.prototype.ngOnChanges = function (changes) {
	        if (changes['latitude'] || changes['longitude']) {
	            var position = {
	                lat: changes['latitude'].currentValue,
	                lng: changes['longitude'].currentValue
	            };
	            this.positionChanged.emit(position);
	        }
	    };
	    SebmGoogleMapPolylinePoint.decorators = [
	        { type: core_1.Directive, args: [{ selector: 'sebm-google-map-polyline-point' },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapPolylinePoint.ctorParameters = function () { return []; };
	    SebmGoogleMapPolylinePoint.propDecorators = {
	        'latitude': [{ type: core_1.Input },],
	        'longitude': [{ type: core_1.Input },],
	        'positionChanged': [{ type: core_1.Output },],
	    };
	    return SebmGoogleMapPolylinePoint;
	}());
	exports.SebmGoogleMapPolylinePoint = SebmGoogleMapPolylinePoint;
	//# sourceMappingURL=google-map-polyline-point.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	exports.GoogleMapsAPIWrapper = google_maps_api_wrapper_1.GoogleMapsAPIWrapper;
	var circle_manager_1 = __webpack_require__(66);
	exports.CircleManager = circle_manager_1.CircleManager;
	var info_window_manager_1 = __webpack_require__(67);
	exports.InfoWindowManager = info_window_manager_1.InfoWindowManager;
	var marker_manager_1 = __webpack_require__(68);
	exports.MarkerManager = marker_manager_1.MarkerManager;
	var polygon_manager_1 = __webpack_require__(69);
	exports.PolygonManager = polygon_manager_1.PolygonManager;
	var polyline_manager_1 = __webpack_require__(70);
	exports.PolylineManager = polyline_manager_1.PolylineManager;
	var kml_layer_manager_1 = __webpack_require__(71);
	exports.KmlLayerManager = kml_layer_manager_1.KmlLayerManager;
	var lazy_maps_api_loader_1 = __webpack_require__(80);
	exports.GoogleMapsScriptProtocol = lazy_maps_api_loader_1.GoogleMapsScriptProtocol;
	exports.LAZY_MAPS_API_CONFIG = lazy_maps_api_loader_1.LAZY_MAPS_API_CONFIG;
	exports.LazyMapsAPILoader = lazy_maps_api_loader_1.LazyMapsAPILoader;
	var maps_api_loader_1 = __webpack_require__(65);
	exports.MapsAPILoader = maps_api_loader_1.MapsAPILoader;
	var noop_maps_api_loader_1 = __webpack_require__(82);
	exports.NoOpMapsAPILoader = noop_maps_api_loader_1.NoOpMapsAPILoader;
	//# sourceMappingURL=services.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(7);
	var browser_globals_1 = __webpack_require__(81);
	var maps_api_loader_1 = __webpack_require__(65);
	(function (GoogleMapsScriptProtocol) {
	    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTP"] = 1] = "HTTP";
	    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTPS"] = 2] = "HTTPS";
	    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["AUTO"] = 3] = "AUTO";
	})(exports.GoogleMapsScriptProtocol || (exports.GoogleMapsScriptProtocol = {}));
	var GoogleMapsScriptProtocol = exports.GoogleMapsScriptProtocol;
	/**
	 * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link
	 * LazyMapsAPILoaderConfig}.
	 */
	exports.LAZY_MAPS_API_CONFIG = new core_1.OpaqueToken('angular2-google-maps LAZY_MAPS_API_CONFIG');
	var LazyMapsAPILoader = (function (_super) {
	    __extends(LazyMapsAPILoader, _super);
	    function LazyMapsAPILoader(config, w, d) {
	        _super.call(this);
	        this._config = config || {};
	        this._windowRef = w;
	        this._documentRef = d;
	    }
	    LazyMapsAPILoader.prototype.load = function () {
	        var _this = this;
	        if (this._scriptLoadingPromise) {
	            return this._scriptLoadingPromise;
	        }
	        var script = this._documentRef.getNativeDocument().createElement('script');
	        script.type = 'text/javascript';
	        script.async = true;
	        script.defer = true;
	        var callbackName = "angular2GoogleMapsLazyMapsAPILoader";
	        script.src = this._getScriptSrc(callbackName);
	        this._scriptLoadingPromise = new Promise(function (resolve, reject) {
	            _this._windowRef.getNativeWindow()[callbackName] = function () { resolve(); };
	            script.onerror = function (error) { reject(error); };
	        });
	        this._documentRef.getNativeDocument().body.appendChild(script);
	        return this._scriptLoadingPromise;
	    };
	    LazyMapsAPILoader.prototype._getScriptSrc = function (callbackName) {
	        var protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;
	        var protocol;
	        switch (protocolType) {
	            case GoogleMapsScriptProtocol.AUTO:
	                protocol = '';
	                break;
	            case GoogleMapsScriptProtocol.HTTP:
	                protocol = 'http:';
	                break;
	            case GoogleMapsScriptProtocol.HTTPS:
	                protocol = 'https:';
	                break;
	        }
	        var hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
	        var queryParams = {
	            v: this._config.apiVersion || '3',
	            callback: callbackName,
	            key: this._config.apiKey,
	            client: this._config.clientId,
	            channel: this._config.channel,
	            libraries: this._config.libraries,
	            region: this._config.region,
	            language: this._config.language
	        };
	        var params = Object.keys(queryParams)
	            .filter(function (k) { return queryParams[k] != null; })
	            .filter(function (k) {
	            // remove empty arrays
	            return !Array.isArray(queryParams[k]) ||
	                (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
	        })
	            .map(function (k) {
	            // join arrays as comma seperated strings
	            var i = queryParams[k];
	            if (Array.isArray(i)) {
	                return { key: k, value: i.join(',') };
	            }
	            return { key: k, value: queryParams[k] };
	        })
	            .map(function (entry) { return entry.key + "=" + entry.value; })
	            .join('&');
	        return protocol + "//" + hostAndPath + "?" + params;
	    };
	    LazyMapsAPILoader.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    LazyMapsAPILoader.ctorParameters = function () { return [
	        { type: undefined, decorators: [{ type: core_1.Inject, args: [exports.LAZY_MAPS_API_CONFIG,] },] },
	        { type: browser_globals_1.WindowRef, },
	        { type: browser_globals_1.DocumentRef, },
	    ]; };
	    return LazyMapsAPILoader;
	}(maps_api_loader_1.MapsAPILoader));
	exports.LazyMapsAPILoader = LazyMapsAPILoader;
	//# sourceMappingURL=lazy-maps-api-loader.js.map

/***/ }),
/* 81 */
/***/ (function(module, exports) {

	"use strict";
	var WindowRef = (function () {
	    function WindowRef() {
	    }
	    WindowRef.prototype.getNativeWindow = function () { return window; };
	    return WindowRef;
	}());
	exports.WindowRef = WindowRef;
	var DocumentRef = (function () {
	    function DocumentRef() {
	    }
	    DocumentRef.prototype.getNativeDocument = function () { return document; };
	    return DocumentRef;
	}());
	exports.DocumentRef = DocumentRef;
	exports.BROWSER_GLOBALS_PROVIDERS = [WindowRef, DocumentRef];
	//# sourceMappingURL=browser-globals.js.map

/***/ }),
/* 82 */
/***/ (function(module, exports) {

	"use strict";
	/**
	 * When using the NoOpMapsAPILoader, the Google Maps API must be added to the page via a `<script>`
	 * Tag.
	 * It's important that the Google Maps API script gets loaded first on the page.
	 */
	var NoOpMapsAPILoader = (function () {
	    function NoOpMapsAPILoader() {
	    }
	    NoOpMapsAPILoader.prototype.load = function () {
	        if (!window.google || !window.google.maps) {
	            throw new Error('Google Maps API not loaded on page. Make sure window.google.maps is available!');
	        }
	        return Promise.resolve();
	    };
	    ;
	    return NoOpMapsAPILoader;
	}());
	exports.NoOpMapsAPILoader = NoOpMapsAPILoader;
	//# sourceMappingURL=noop-maps-api-loader.js.map

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var google_map_kml_layer_1 = __webpack_require__(74);
	var google_map_1 = __webpack_require__(63);
	var google_map_circle_1 = __webpack_require__(72);
	var google_map_info_window_1 = __webpack_require__(73);
	var google_map_marker_1 = __webpack_require__(75);
	var google_map_polygon_1 = __webpack_require__(76);
	var google_map_polyline_1 = __webpack_require__(77);
	var google_map_polyline_point_1 = __webpack_require__(78);
	var lazy_maps_api_loader_1 = __webpack_require__(80);
	var lazy_maps_api_loader_2 = __webpack_require__(80);
	var maps_api_loader_1 = __webpack_require__(65);
	var browser_globals_1 = __webpack_require__(81);
	/**
	 * @internal
	 */
	function coreDirectives() {
	    return [
	        google_map_1.SebmGoogleMap, google_map_marker_1.SebmGoogleMapMarker, google_map_info_window_1.SebmGoogleMapInfoWindow, google_map_circle_1.SebmGoogleMapCircle,
	        google_map_polygon_1.SebmGoogleMapPolygon, google_map_polyline_1.SebmGoogleMapPolyline, google_map_polyline_point_1.SebmGoogleMapPolylinePoint, google_map_kml_layer_1.SebmGoogleMapKmlLayer
	    ];
	}
	exports.coreDirectives = coreDirectives;
	;
	/**
	 * The angular2-google-maps core module. Contains all Directives/Services/Pipes
	 * of the core module. Please use `AgmCoreModule.forRoot()` in your app module.
	 */
	var AgmCoreModule = (function () {
	    function AgmCoreModule() {
	    }
	    /**
	     * Please use this method when you register the module at the root level.
	     */
	    AgmCoreModule.forRoot = function (lazyMapsAPILoaderConfig) {
	        return {
	            ngModule: AgmCoreModule,
	            providers: browser_globals_1.BROWSER_GLOBALS_PROVIDERS.concat([
	                { provide: maps_api_loader_1.MapsAPILoader, useClass: lazy_maps_api_loader_1.LazyMapsAPILoader },
	                { provide: lazy_maps_api_loader_2.LAZY_MAPS_API_CONFIG, useValue: lazyMapsAPILoaderConfig }
	            ]),
	        };
	    };
	    AgmCoreModule.decorators = [
	        { type: core_1.NgModule, args: [{ declarations: coreDirectives(), exports: coreDirectives() },] },
	    ];
	    /** @nocollapse */
	    AgmCoreModule.ctorParameters = function () { return []; };
	    return AgmCoreModule;
	}());
	exports.AgmCoreModule = AgmCoreModule;
	//# sourceMappingURL=core-module.js.map

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var practice_data_1 = __webpack_require__(85);
	var PracticeComponent = (function () {
	    function PracticeComponent() {
	        // Practice data to inject into our template
	        this.practiceData = practice_data_1.PRACTICE_DATA;
	    }
	    PracticeComponent.prototype.ngOnInit = function () { };
	    return PracticeComponent;
	}());
	PracticeComponent = __decorate([
	    core_1.Component({
	        selector: 'practice',
	        template: __webpack_require__(86),
	        styles: [__webpack_require__(87)]
	    }),
	    __metadata("design:paramtypes", [])
	], PracticeComponent);
	exports.PracticeComponent = PracticeComponent;


/***/ }),
/* 85 */
/***/ (function(module, exports) {

	"use strict";
	exports.PRACTICE_DATA = [
	    {
	        season: 'Fall',
	        what: 'Normal Practice',
	        time: '4:30PM-7PM',
	        when: 'Mondays & Wednesdays',
	        locationLabel: 'Complex Fields',
	        locationLink: 'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
	    },
	    {
	        season: 'Fall',
	        what: 'Weekend Invite Practice',
	        time: 'TBD',
	        when: 'Weekends',
	        locationLabel: 'Complex Fields',
	        locationLink: 'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
	    },
	    {
	        season: 'Winter',
	        what: 'Normal Practice',
	        time: '9:30PM-12AM',
	        when: 'Mondays & Wednesdays',
	        locationLabel: 'Armory',
	        locationLink: 'https://www.google.com/maps/place/Armory/@40.105402,-88.235534,17z/data=!3m1!5s0x880cd73b8c4fbb7d:0xa84890110afd0990!4m7!1m4!3m3!1s0x880cd73a16c1d78f:0xe1bb009225fc1225!2sE+Armory+Ave,+Champaign,+IL+61820!3b1!3m1!1s0x0000000000000000:0x0b21d56f2b951978'
	    },
	    {
	        season: 'Winter',
	        what: 'Indoor Field Practice',
	        time: '11PM-12AM',
	        when: 'Thursdays',
	        locationLabel: 'Irwin Facility',
	        locationLink: 'https://www.google.com/maps/place/Irwin+Indoor+Football+Facility,+University+of+Illinois+at+Urbana-Champaign,+Champaign,+IL+61820/@40.1006475,-88.2342204,17z/data=!3m1!4b1!4m6!1m3!3m2!1s0x880cd724a92655e9:0xa53c0525046826fa!2sUniversity+of+Illinois+at+Urbana-Champaign!3m1!1s0x880cd725292c02bd:0x18f5a03daad8677a'
	    },
	    {
	        season: 'Spring',
	        what: 'Normal Practice',
	        time: '9:30PM-12AM',
	        when: 'Mondays & Wednesdays',
	        locationLabel: 'Complex Fields',
	        locationLink: 'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
	    },
	    {
	        season: 'Spring',
	        what: 'A-Team Practice',
	        time: 'TBD',
	        when: 'Weekends',
	        locationLabel: 'Complex Fields',
	        locationLink: 'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
	    }
	];


/***/ }),
/* 86 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Practice</h1>\n<table class=\"ui celled table\">\n    <thead>\n        <tr>\n            <th>Season</th>\n            <th>What</th>\n            <th>Time</th>\n            <th>When</th>\n            <th>Location</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr *ngFor=\"let practiceRow of practiceData\">\n            <td>{{practiceRow.season}}</td>\n            <td>{{practiceRow.what}}</td>\n            <td>{{practiceRow.time}}</td>\n            <td>{{practiceRow.when}}</td>\n            <td><a href=\"{{practiceRow.locationLink}}\" target=\"_blank\">{{practiceRow.locationLabel}}</a></td>\n        </tr>\n    </tbody>\n</table>";

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(88);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "tr {\n  text-align: center;\n}\n", ""]);
	
	// exports


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var router_1 = __webpack_require__(90);
	var tournaments_data_1 = __webpack_require__(120);
	var TournamentsComponent = (function () {
	    // Inject the ActivatedRoute into our component
	    function TournamentsComponent(route) {
	        this.route = route;
	        // Tournament data to inject into our template
	        this.tournamentData = tournaments_data_1.TOURNAMENTS_DATA;
	    }
	    /**
	     * Subscribe to our route parameters (tournament year).
	     */
	    TournamentsComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.routeParamsSubscription = this.route.params.subscribe(function (params) {
	            // (+) converts string 'year' to a number
	            _this.year = +params['year'];
	        });
	    };
	    /**
	     * Unsubscribe to our route parameters (tournament year).
	     */
	    TournamentsComponent.prototype.ngOnDestroy = function () {
	        this.routeParamsSubscription.unsubscribe();
	    };
	    return TournamentsComponent;
	}());
	TournamentsComponent = __decorate([
	    core_1.Component({
	        selector: 'tournaments',
	        template: __webpack_require__(121),
	        styles: [__webpack_require__(122)]
	    }),
	    __metadata("design:paramtypes", [typeof (_a = typeof router_1.ActivatedRoute !== "undefined" && router_1.ActivatedRoute) === "function" && _a || Object])
	], TournamentsComponent);
	exports.TournamentsComponent = TournamentsComponent;
	var _a;


/***/ }),
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */
/***/ (function(module, exports) {

	"use strict";
	exports.TOURNAMENTS_DATA = [
	    {
	        year: 2017,
	        tournaments: [
	            {
	                season: 'Fall',
	                nameLabel: 'Boiler Breakaway',
	                nameLink: 'https://boilerlink.purdue.edu/organization/mensultimate/calendar/details/972920',
	                when: 'Sept. 17th-18th',
	                location: 'West Lafayette, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'No Wisconsequences',
	                nameLink: 'http://nowisconsequences.ultimatecentral.com',
	                when: 'Oct. 8th-9th',
	                location: 'Hartland, WI',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Missouri Loves Company',
	                nameLink: 'http://ultimate.missouri.edu/mlc/2016',
	                when: 'Nov. 5th-6th',
	                location: 'Columbia, MO',
	                result: '-'
	            },
	            {
	                season: 'Spring',
	                nameLabel: "President's Day Invite",
	                nameLink: 'http://play.usaultimate.org/events/Presidents-Day-Tournament-2017',
	                when: 'Feb. 17th-20th',
	                location: 'San Diego, CA',
	                result: '5th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Centex',
	                nameLink: 'http://play.usaultimate.org/events/Centex-2017-Open',
	                when: 'March 10th-13th',
	                location: 'Austin, TX',
	                result: '7th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Huck Finn',
	                nameLink: 'http://play.usaultimate.org/events/Huck-Finn-2017',
	                when: 'April 1st-2nd',
	                location: 'St. Louis, MO',
	                result: '11th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Illinois Conferences',
	                nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2017',
	                when: 'April 22nd-23rd',
	                location: 'Rantoul, IL',
	                result: '2nd'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Great Lakes Regionals',
	                nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2017',
	                when: 'May 6th-7th',
	                location: 'Fair Oaks, IN',
	                result: '6th'
	            }
	        ]
	    },
	    {
	        year: 2016,
	        tournaments: [
	            {
	                season: 'Fall',
	                nameLabel: 'Boiler Breakaway',
	                nameLink: 'https://www.reddit.com/r/ultimate/comments/38gy72/new_fields_boiler_breakaway_2015_hosted_by_undue',
	                when: 'Sept. 19th-20th',
	                location: 'Westfield, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Huck of the Irish',
	                nameLink: 'https://ndultimate.wordpress.com/hoti',
	                when: 'Oct. 3rd-4th',
	                location: 'South Bend, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Chicago Invite',
	                nameLink: 'http://www.chicagoinvite.com',
	                when: 'Oct. 17th-18th',
	                location: 'Rockford, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Missouri Loves Company',
	                nameLink: 'http://ultiworld.com/2015/11/12/missouri-loves-company-2015-tournament-recap-mens',
	                when: 'Nov. 7th-8th',
	                location: 'Columbia, MO',
	                result: '10th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Florida Warmup',
	                nameLink: 'http://play.usaultimate.org/events/Warm-up-A-Florida-Affair-2016',
	                when: 'Feb. 11th-14th',
	                location: 'Tampa, FL',
	                result: '15th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Easterns',
	                nameLink: 'http://play.usaultimate.org/events/College-Easterns-2016',
	                when: 'March 18th-20th',
	                location: 'North Myrtle Beach, SC',
	                result: '19th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Huck Finn',
	                nameLink: 'http://play.usaultimate.org/events/Huck-Finn-XX-2016',
	                when: 'Feb. 11th-14th',
	                location: 'St. Louis, MO',
	                result: '11th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Illinois Conferences',
	                nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2016',
	                when: 'April 16th-17th',
	                location: 'Rantoul, IL',
	                result: '3rd'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Great Lakes Regionals',
	                nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2016',
	                when: 'April 30th-May 1st',
	                location: 'Fair Oaks, IN',
	                result: '3rd'
	            }
	        ]
	    },
	    {
	        year: 2015,
	        tournaments: [
	            {
	                season: 'Fall',
	                nameLabel: 'Huck of the Irish',
	                nameLink: 'https://ndultimate.wordpress.com/whitesmoke',
	                when: 'Sept. 27th-28th',
	                location: 'South Bend, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Glory Days',
	                nameLink: 'http://www.sun-ultimate.org/glory-days.html',
	                when: 'Oct. 4th-5th',
	                location: 'Rockford, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Illinois Invite',
	                nameLink: 'https://illinois.collegiatelink.net/organization/illinoismensultimatefrisbeeteam/calendar/details/504204',
	                when: 'Oct. 18th-19th',
	                location: 'Rantoul, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Missouri Loves Company',
	                nameLink: 'http://ultiworld.com/2014/11/06/missouri-loves-company-2014-tournament-preview-mens',
	                when: 'Nov. 8th-9th',
	                location: 'Columbia, MO',
	                result: '-'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Florida Warmup',
	                nameLink: 'http://play.usaultimate.org/events/Warm-Up-A-Florida-Affair-2015',
	                when: 'Feb. 13th-15th',
	                location: 'Tampa, FL',
	                result: '13th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Centex Invite',
	                nameLink: 'http://play.usaultimate.org/events/Centex-Invite-2015',
	                when: 'March 14th-15th',
	                location: 'Austin, TX',
	                result: '17th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Easterns',
	                nameLink: 'http://play.usaultimate.org/events/Easterns-2015',
	                when: 'March 27th-29th',
	                location: 'North Myrtle Beach, SC',
	                result: '17th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Illinois Conferences',
	                nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2015',
	                when: 'April 11th-12th',
	                location: 'Rantoul, IL',
	                result: '2nd'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Great Lakes Regionals',
	                nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2015',
	                when: 'April 25th-26th',
	                location: 'Rockford, IL',
	                result: '1st'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'D-I National Championships',
	                nameLink: 'http://play.usaultimate.org/events/USA-Ultimate-D-I-College-Championships-2015',
	                when: 'May 22nd-25th',
	                location: 'Milwaukee, WI',
	                result: '13th'
	            }
	        ]
	    },
	    {
	        year: 2014,
	        tournaments: [
	            {
	                season: 'Fall',
	                nameLabel: 'Boiler Breakaway',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/13422',
	                when: 'Oct. 5th-6th',
	                location: 'West Lafayette, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Illinois Invite',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/13350',
	                when: 'Oct. 12th-13th',
	                location: 'Rantoul, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Michigan Round Robin',
	                nameLink: '',
	                when: 'Oct. 20th',
	                location: 'Ann Arbor, MI',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Glory Days',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/13499',
	                when: 'Oct. 26th-27th',
	                location: 'Rockford, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Missouri Loves Company',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/14017',
	                when: 'Nov. 9th-10th',
	                location: 'Columbia, MO',
	                result: '13th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Cat Fight',
	                nameLink: 'http://play.usaultimate.org/events/Cat-Fight',
	                when: 'Feb. 22nd-23rd',
	                location: 'Lexington, KY',
	                result: '1st'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Easterns',
	                nameLink: 'http://play.usaultimate.org/events/Easterns-and-DIII-Easterns',
	                when: 'March 22nd-23rd',
	                location: 'Little River, SC',
	                result: '13th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Illinois Conferences',
	                nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC',
	                when: 'April 12th-13th',
	                location: 'Rantoul, IL',
	                result: '1st'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Great Lakes Regionals',
	                nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals',
	                when: 'April 26th-27th',
	                location: 'Rockford, IL',
	                result: '5th'
	            }
	        ]
	    },
	    {
	        year: 2013,
	        tournaments: [
	            {
	                season: 'Fall',
	                nameLabel: 'Boiler Breakaway',
	                nameLink: 'http://scores.usaultimate.org/scores2012/#college-open/tournament/11432',
	                when: 'Sept. 22nd-23rd',
	                location: 'West Lafayette, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Illinois Invite',
	                nameLink: 'http://scores.usaultimate.org/scores2012/#college-open/tournament/11476',
	                when: 'Oct. 13th-14th',
	                location: 'Rantoul, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Missouri Loves Company',
	                nameLink: 'http://scores.usaultimate.org/scores2012/#college-open/tournament/11657',
	                when: 'Nov. 10th-11th',
	                location: 'Columbia, MO',
	                result: '-'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Huck Finn',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12115',
	                when: 'March 9th-10th',
	                location: 'Chesterfield, MO',
	                result: '13th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Centex',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12707',
	                when: 'March 16th-17th',
	                location: 'Austin, TX',
	                result: '4th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Illinois Conferences',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12604',
	                when: 'April 13th-14th',
	                location: 'Rantoul, IL',
	                result: '1st'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Great Lakes Regionals',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12667',
	                when: 'April 27th-28th',
	                location: 'Rockford, IL',
	                result: '1st'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'D-I National Championships',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12686',
	                when: 'May 24th-27th',
	                location: 'Madison, WI',
	                result: '17th'
	            }
	        ]
	    }
	];


/***/ }),
/* 121 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Tournaments</h1>\n<div class=\"ui secondary pointing menu\">\n    <a class=\"item\" routerLink=\"/tournaments/2013\" [ngClass]=\"{'active': year === 2013}\">2013</a>\n    <a class=\"item\" routerLink=\"/tournaments/2014\" [ngClass]=\"{'active': year === 2014}\">2014</a>\n    <a class=\"item\" routerLink=\"/tournaments/2015\" [ngClass]=\"{'active': year === 2015}\">2015</a>\n    <a class=\"item\" routerLink=\"/tournaments/2016\" [ngClass]=\"{'active': year === 2016}\">2016</a>\n    <a class=\"item\" routerLink=\"/tournaments/2017\" [ngClass]=\"{'active': year === 2017}\">2017</a>\n</div>\n<ng-container *ngFor=\"let tournamentYear of tournamentData\">\n    <ng-container *ngIf=\"tournamentYear.year === year\">\n        <table class=\"ui celled table\" *ngIf=\"tournamentData\">\n            <thead>\n                <tr>\n                    <th>Season</th>\n                    <th>Name</th>\n                    <th>When</th>\n                    <th>Location</th>\n                    <th>Result</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr *ngFor=\"let tournament of tournamentYear.tournaments\">\n                    <td>{{tournament.season}}</td>\n                    <td>\n                        <!--Only render a link if there is one provided in the data, otherwise just render the text-->\n                        <a *ngIf=\"tournament.nameLink\" href=\"{{tournament.nameLink}}\" target=\"_blank\">{{tournament.nameLabel}}</a>\n                        <ng-container *ngIf=\"!tournament.nameLink\">{{tournament.nameLabel}}</ng-container>\n                    </td>\n                    <td>{{tournament.when}}</td>\n                    <td>{{tournament.location}}</td>\n                    <td>{{tournament.result}}</td>\n                </tr>\n            </tbody>\n        </table>\n    </ng-container>\n</ng-container>";

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(123);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "", ""]);
	
	// exports


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var router_1 = __webpack_require__(90);
	var rosters_data_1 = __webpack_require__(125);
	var RosterComponent = (function () {
	    // Inject the ActivatedRoute into our component
	    function RosterComponent(route) {
	        this.route = route;
	        // Roster data to inject into our template
	        this.rosterData = rosters_data_1.ROSTER_DATA;
	    }
	    /**
	     * Subscribe to our route parameters (roster year).
	     */
	    RosterComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.routeParamsSubscription = this.route.params.subscribe(function (params) {
	            // (+) converts string 'year' to a number
	            _this.year = +params['year'];
	        });
	    };
	    /**
	     * Unsubscribe to our route parameters (roster year).
	     */
	    RosterComponent.prototype.ngOnDestroy = function () {
	        this.routeParamsSubscription.unsubscribe();
	    };
	    return RosterComponent;
	}());
	RosterComponent = __decorate([
	    core_1.Component({
	        selector: 'roster',
	        template: __webpack_require__(126),
	        styles: [__webpack_require__(127)]
	    }),
	    __metadata("design:paramtypes", [typeof (_a = typeof router_1.ActivatedRoute !== "undefined" && router_1.ActivatedRoute) === "function" && _a || Object])
	], RosterComponent);
	exports.RosterComponent = RosterComponent;
	var _a;


/***/ }),
/* 125 */
/***/ (function(module, exports) {

	"use strict";
	exports.ROSTER_DATA = [
	    {
	        year: 2017,
	        imagePath: './assets/team-photo-2017.jpg',
	        players: [
	            {
	                number: 2,
	                name: "Ben 'Beef' Sabourin",
	                year: 'Sophomore'
	            }
	        ]
	    },
	    {
	        year: 2016,
	        imagePath: './assets/team-photo-2016.jpg',
	        players: [
	            {
	                number: 1,
	                name: 'Nick Prozorovsky*',
	                year: 'Senior'
	            }
	        ]
	    },
	    {
	        year: 2015,
	        imagePath: './assets/team-photo-2015.jpg',
	        players: [
	            {
	                number: 1,
	                name: 'Nick Prozorovsky*',
	                year: 'Junior'
	            }
	        ]
	    }
	];


/***/ }),
/* 126 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Roster</h1>\n<div class=\"ui secondary pointing menu\">\n    <a class=\"item\" routerLink=\"/roster/2015\" [ngClass]=\"{'active': year === 2015}\">2015</a>\n    <a class=\"item\" routerLink=\"/roster/2016\" [ngClass]=\"{'active': year === 2016}\">2016</a>\n    <a class=\"item\" routerLink=\"/roster/2017\" [ngClass]=\"{'active': year === 2017}\">2017</a>\n</div>\n<ng-container *ngFor=\"let rosterYear of rosterData\">\n    <ng-container *ngIf=\"rosterYear.year === year\">\n        <img src=\"{{rosterYear.imagePath}}\"/>\n        <table class=\"ui celled table\">\n            <thead>\n                <tr>\n                    <th>#</th>\n                    <th>Name</th>\n                    <th>Year</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr *ngFor=\"let player of rosterYear.players\">\n                    <td>{{player.number}}</td>\n                    <td>{{player.name}}</td>\n                    <td>{{player.year}}</td>\n                </tr>\n            </tbody>\n        </table>\n        <p>(*) indicates captain for that year</p>\n    </ng-container>\n</ng-container>";

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(128);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "img {\n  width: 75%;\n  border: 1px solid #00004D;\n  border-radius: 0.28571429em;\n}\n", ""]);
	
	// exports


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var google_spreadsheet_service_1 = __webpack_require__(44);
	var AbsentComponent = (function () {
	    // Constructor with our http service injected
	    function AbsentComponent(spreadsheetService) {
	        this.spreadsheetService = spreadsheetService;
	        // API url for our personal server
	        this.googleSheetsApiUrl = 'https://nick-proz-google-sheet-api.herokuapp.com/sheets/11ijrHoysiIwsFfEggbSNM9Y8VvzU65jeuhQ3vkV5FGw/sheetIndex/1/rows/';
	        // API url for our backup server (sheetsu API)
	        // private googleSheetsBackupApiUrl = 'https://sheetsu.com/apis/v1.0/7a030ae60b7d';
	        this.googleSheetsBackupApiUrl = '';
	        // Error messages
	        this.validationErrors = 'Please do not leave any required fields blank.';
	        this.submissionError = 'Could not submit the form  due to a server error. Please try again soon or contact the web admins.';
	        // Boolean indicating if our form is in the process of submitting (to show our loading icon)
	        this.formIsSubmitting = false;
	        // Boolean indicating if our form was successfully submitted (to show our success message)
	        this.submitSuccess = false;
	    }
	    AbsentComponent.prototype.ngAfterViewInit = function () {
	        $(this.monthDropdown.nativeElement).dropdown();
	    };
	    AbsentComponent.prototype.handleSubmit = function (event, monthInput) {
	        event.preventDefault();
	        this.month = monthInput;
	        this.submitSuccess = false;
	        if (!this.formIsValid()) {
	            this.formErrors = this.validationErrors;
	        }
	        else {
	            this.formIsSubmitting = true;
	            this.formErrors = null;
	            var date = new Date();
	            var data = {
	                "Timestamp": date.toLocaleString(),
	                "First Name": this.firstName,
	                "Last Name": this.lastName,
	                "Time": this.time,
	                "Date": this.month + "/" + this.day,
	                "Reason": this.reason
	            };
	            this.submitAbsentForm(data);
	        }
	    };
	    /**
	     * Submits our form to the spreadsheet by calling our service method.
	     * On success, we show our confirmation modal and reset our rsvp modal.
	     * On failure, we hide our submitting dialog and show our submission error to the user.
	     *
	     * @param data - data to submit to our spreadsheet
	     */
	    AbsentComponent.prototype.submitAbsentForm = function (data) {
	        var _this = this;
	        this.spreadsheetService.postRowToSpreadsheet(this.googleSheetsApiUrl, this.googleSheetsBackupApiUrl, data)
	            .then(function () {
	            _this.resetForm();
	            _this.submitSuccess = true;
	        })
	            .catch(function () {
	            _this.formIsSubmitting = false;
	            _this.formErrors = _this.submissionError;
	        });
	    };
	    /**
	     * Clears our input fields, errors, and resets our form is submitting flag.
	     */
	    AbsentComponent.prototype.resetForm = function () {
	        this.firstName = null;
	        this.lastName = null;
	        this.reason = null;
	        this.time = null;
	        this.day = null;
	        this.month = null;
	        this.formErrors = null;
	        this.formIsSubmitting = false;
	    };
	    /**
	     * Front-end validation for our form.
	     * Our form is valid only if all fields are populated.
	     *
	     * @returns {boolean} - true if the form is valid, false otherwise
	     */
	    AbsentComponent.prototype.formIsValid = function () {
	        return this.firstName != null && this.firstName != ''
	            && this.lastName != null && this.lastName != ''
	            && this.reason != null && this.reason != ''
	            && this.time != null && this.time != ''
	            && this.month != null && this.month > 0
	            && this.day != null;
	    };
	    return AbsentComponent;
	}());
	__decorate([
	    core_1.ViewChild('monthDropdown'),
	    __metadata("design:type", typeof (_a = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _a || Object)
	], AbsentComponent.prototype, "monthDropdown", void 0);
	AbsentComponent = __decorate([
	    core_1.Component({
	        selector: 'absent',
	        template: __webpack_require__(131),
	        styles: [__webpack_require__(132)]
	    }),
	    __metadata("design:paramtypes", [typeof (_b = typeof google_spreadsheet_service_1.SpreadsheetService !== "undefined" && google_spreadsheet_service_1.SpreadsheetService) === "function" && _b || Object])
	], AbsentComponent);
	exports.AbsentComponent = AbsentComponent;
	var _a, _b;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(130)))

/***/ }),
/* 130 */,
/* 131 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Practice Absence Form</h1>\n<div *ngIf=\"formIsSubmitting\" class=\"ui active inverted dimmer\"><div class=\"ui text loader\">Submitting</div></div>\n<form class=\"ui form\">\n    <div class=\"two fields\">\n        <div class=\"field\">\n            <label>First Name <span class=\"required\">*</span></label>\n            <input [(ngModel)]=\"firstName\" type=\"text\" name=\"first-name\" placeholder=\"First Name\">\n        </div>\n        <div class=\"field\">\n            <label>Last Name <span class=\"required\">*</span></label>\n            <input [(ngModel)]=\"lastName\" type=\"text\" name=\"last-name\" placeholder=\"Last Name\">\n        </div>\n    </div>\n    <div class=\"field\">\n        <label>Reason for missing or being late to practice <span class=\"required\">*</span></label>\n        <input [(ngModel)]=\"reason\" type=\"text\" name=\"reason\" placeholder=\"Better be good...\">\n    </div>\n    <div class=\"field\">\n        <label>From what time to what time is your conflict? <span class=\"required\">*</span></label>\n        <input [(ngModel)]=\"time\" type=\"text\" name=\"time\" placeholder=\"Time\">\n    </div>\n    <div class=\"field\">\n        <div class=\"two fields\">\n            <div class=\"field\">\n                <label>Practice date <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"day\" maxlength=\"2\" type=\"text\" name=\"day\" placeholder=\"Day (0-31)\">\n            </div>\n            <div class=\"field\">\n                <label>&nbsp;</label>\n                <div #monthDropdown class=\"ui search selection dropdown\">\n                    <input #monthInput type=\"hidden\" name=\"month\">\n                    <i class=\"dropdown icon\"></i>\n                    <div class=\"default text\">Month</div>\n                    <div class=\"menu\">\n                        <div class=\"item\" data-value=\"01\">January</div>\n                        <div class=\"item\" data-value=\"02\">February</div>\n                        <div class=\"item\" data-value=\"03\">March</div>\n                        <div class=\"item\" data-value=\"04\">April</div>\n                        <div class=\"item\" data-value=\"05\">May</div>\n                        <div class=\"item\" data-value=\"06\">June</div>\n                        <div class=\"item\" data-value=\"07\">July</div>\n                        <div class=\"item\" data-value=\"08\">August</div>\n                        <div class=\"item\" data-value=\"09\">September</div>\n                        <div class=\"item\" data-value=\"10\">October</div>\n                        <div class=\"item\" data-value=\"11\">November</div>\n                        <div class=\"item\" data-value=\"12\">December</div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n    <button (click)=\"handleSubmit($event, monthInput.value)\" class=\"ui button\" type=\"submit\">Submit</button>\n    <div class=\"ui error message\" *ngIf=\"formErrors\">\n        <p>{{formErrors}}</p>\n    </div>\n    <div class=\"ui success message\" *ngIf=\"submitSuccess\">\n        <div class=\"header\">Form Submitted</div>\n        <p>The form was successfully submitted. Stop missing practice.</p>\n    </div>\n</form>";

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(133);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "label {\n  text-align: left;\n}\n.ui.form {\n  width: 80%;\n  margin: 0 auto;\n}\n.ui.form .ui.error.message,\n.ui.form .ui.success.message {\n  display: block;\n}\n.ui.form .ui.error.message p,\n.ui.form .ui.success.message p {\n  text-align: center;\n}\n.ui.selection.active.dropdown .menu,\n.ui.search.selection.dropdown.active.visible,\n.ui.selection.active.dropdown:hover {\n  border-color: #ff6226;\n}\n.ui.dropdown {\n  min-width: inherit;\n}\n", ""]);
	
	// exports


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var home_component_1 = __webpack_require__(33);
	var about_component_1 = __webpack_require__(39);
	var prospective_players_component_1 = __webpack_require__(43);
	var contact_component_1 = __webpack_require__(48);
	var practice_component_1 = __webpack_require__(84);
	var tournaments_component_1 = __webpack_require__(89);
	var roster_component_1 = __webpack_require__(124);
	var absent_component_1 = __webpack_require__(129);
	var team_history_component_1 = __webpack_require__(135);
	var awards_component_1 = __webpack_require__(140);
	var results_component_1 = __webpack_require__(145);
	exports.ROUTES = [
	    { path: '', component: home_component_1.HomeComponent },
	    { path: 'practice', component: practice_component_1.PracticeComponent },
	    { path: 'absent', component: absent_component_1.AbsentComponent },
	    { path: 'contact', component: contact_component_1.ContactComponent },
	    { path: 'home', component: home_component_1.HomeComponent },
	    { path: 'about', component: about_component_1.AboutComponent },
	    { path: 'prospects', component: prospective_players_component_1.ProspectivePlayersComponent },
	    { path: 'tournaments/:year', component: tournaments_component_1.TournamentsComponent },
	    { path: 'roster/:year', component: roster_component_1.RosterComponent },
	    { path: 'history/:year', component: team_history_component_1.TeamHistoryComponent },
	    { path: 'awards', component: awards_component_1.AwardsComponent },
	    { path: 'results', component: results_component_1.ResultsComponent },
	    { path: '**', component: home_component_1.HomeComponent },
	];


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var history_year_data_1 = __webpack_require__(136);
	var router_1 = __webpack_require__(90);
	var TeamHistoryComponent = (function () {
	    // Inject the ActivatedRoute into our component
	    function TeamHistoryComponent(route) {
	        this.route = route;
	        // Results data to inject into our template
	        this.historyData = history_year_data_1.HISTORY_DATA;
	    }
	    TeamHistoryComponent.prototype.ngAfterViewInit = function () {
	        $(this.firstDropdown.nativeElement).dropdown({});
	        $(this.secondDropdown.nativeElement).dropdown({});
	        $(this.thirdDropdown.nativeElement).dropdown({});
	    };
	    /**
	     * Subscribe to our route parameters (tournament year).
	     */
	    TeamHistoryComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.routeParamsSubscription = this.route.params.subscribe(function (params) {
	            // (+) converts string 'year' to a number
	            _this.year = +params['year'];
	        });
	    };
	    /**
	     * Unsubscribe to our route parameters (tournament year).
	     */
	    TeamHistoryComponent.prototype.ngOnDestroy = function () {
	        this.routeParamsSubscription.unsubscribe();
	    };
	    return TeamHistoryComponent;
	}());
	__decorate([
	    core_1.ViewChild('1994dropdown'),
	    __metadata("design:type", typeof (_a = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _a || Object)
	], TeamHistoryComponent.prototype, "firstDropdown", void 0);
	__decorate([
	    core_1.ViewChild('2000dropdown'),
	    __metadata("design:type", typeof (_b = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _b || Object)
	], TeamHistoryComponent.prototype, "secondDropdown", void 0);
	__decorate([
	    core_1.ViewChild('2010dropdown'),
	    __metadata("design:type", typeof (_c = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _c || Object)
	], TeamHistoryComponent.prototype, "thirdDropdown", void 0);
	TeamHistoryComponent = __decorate([
	    core_1.Component({
	        selector: 'team-history',
	        template: __webpack_require__(137),
	        styles: [__webpack_require__(138)]
	    }),
	    __metadata("design:paramtypes", [typeof (_d = typeof router_1.ActivatedRoute !== "undefined" && router_1.ActivatedRoute) === "function" && _d || Object])
	], TeamHistoryComponent);
	exports.TeamHistoryComponent = TeamHistoryComponent;
	var _a, _b, _c, _d;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(130)))

/***/ }),
/* 136 */
/***/ (function(module, exports) {

	"use strict";
	exports.HISTORY_DATA = [
	    {
	        year: 2016,
	        imagePath: './assets/team-photo-2016.jpg',
	        summaryMarkup: "\n            <p>Illinois Ultimate came into the 2016 season with a taste of success and big shoes to fill. Returning captain Nick Prozorovsky and new captains Prayag Patel and Chris Buchta were tasked with the difficult prospect of replacing the 12 graduating players as well as coach Matt Stupca. Boomland coach Erik Huemiller and recent alum Matt West were able to fill the leadership void as the team looked to reload for another run at Nationals.</p>\n            <p>The tryouts for the team were very competitive, with the biggest incoming class in recent memory. The final roster included 7 rookies, 1 grad student, 5 former Boomland players, and 12 returners. The newest iteration of Illinois Ultimate tested themselves at Missouri Loves Company, but returned with shoulder injuries to seniors Nick Prozorovsky and Alex Guy that would hamper them for the rest of the season.</p>\n            <p>This spring season had the team heading to Florida, South Carolina, and Missouri in search of elite competition.</p>\n            <p>Mid February had the team flying south to compete at Warm Up. Unfortunately, the week prior had grad student Cody Gray breaking his hand in Irwin and senior Wilson Wang pulling his hamstring in the Armory, both big handler losses. On Saturday, the team started with 10-13 and 11-13 losses to Texas and Florida State. The third game of the day was against perennial powerhouse Pittsburgh. Illinois came out sloppy and was pressured into making many errors, resulting in a 1-7 score at half and an embarrassing 2-12 loss, finishing 0-4 on the day after another loss to BYU. Saturday started off better with a 13-5 win over host South Florida, but was followed by big losses to Virginia Tech and Auburn. Illinois finished the tournament 2-7, with a universe loss to in region rival Northwestern and only wins coming against South Florida.</p>\n            <p>With most of the team finally healthy, the team made the trip to Easterns for the second tournament of the season. The first game of the tournament was a rematch against Pittsburgh. This time, Illinois was prepared for the intensity and was able to make it a closer game, but still lost 12-15. Another rematch against Virginia Tech ended similarly, losing 11-14, and the team ended Saturday 0-4, with a 10-15 loss to UNC Darkside and an 11-13 loss to regional rival Michigan. On a wet, cold, and windy Sunday, Illinois was not able to come out with any fire and lost badly to James Madison and Connecticut, going 0-6 on the weekend.</p>\n            <p>The final regular season tournament of the year was Huck Finn and the boys from Illinois looked to bounce back from a so far unsuccessful regular season. With a mindset of improving for the series the Illini came out with a 7-0 lead at half on Indiana and closed it out with an 11-4 win. Dayton was the next game, which was a 13-4 win for the Illini which meant that they would play Maryland for the pool. Ankle injuries to Prayag Patel and Ben Foster meant that the O line was playing without two key contributors, but the team was able to tough out a 14-11 win, setting up a crossover game against Illinois State. In a very windy game, Illinois triumphed over their in state competitors in a 10-6 victory, securing a quarterfinals berth. The team closed out the tournament with losses to Arkansas and Purdue, and prepared themselves for Conferences.</p>\n            <p>Once again, Rantoul was host to Conferences, but this time there could be no complaints about the weather. Illinois started out strong with comfortable wins over the rest of the pool, including an 11-4 victory over UChicago. Winning the pool lined up a semifinal game against Illinois State, which was won handily 13-7 and set up a classic Illinois - Northwestern rematch. Unfortunately, the team struggled to find the endzone and for the second year in a row, lost to Northwestern at Conferences. In the 2nd place match against UChicago, Illinois was unable to find a groove and lost 9-11. With Regionals in two weeks and only one bid for the region, Illinois had a lot of work to do.</p>\n            <p>In a change of pace, Regionals was not hosted in Rockford, but in Fair Oaks, Indiana. The conditions were terrible, low temperatures coupled with heavy wind and rain meant that it would be difficult getting a good grip. In the first game against Kentucky, both O and D line were able to perform well, giving up no breaks and handing out a few of their own and finishing with a score of 12-6. The trend continued against Indiana, with Illinois winning 13-6. Next up was Notre Dame, a rematch of last year\u2019s finals, winner takes the pool and quarterfinals berth. A completely upwind/downwind game found the d line with opportunities to break, but never able to finish the job. With neither team being broken, Notre Dame won the flip and the game, 9-10. Illinois finished up the day with a 13-5 win over Michigan State to set up a quarterfinals matchup against Northwestern.</p>\n            <p>Conditions on Sunday were better and with a little support from Walden Nelson, the team was ready to avenge their recent losses. Illinois started on D and Northwestern came out with an break early in the game, but the team fought back and breaks were traded to have it be on serve at half. The second half commenced with more of a cleaner game, with both teams trading offensive holds. A chance at a break due to a Nick Pro sky was called back on a controversial observer ruling and the game reached softcap with the score 10-11. Chris Buchta tied up the score with a huck from Kevin Lin and the d line went out to try and break with the season on the line. After a turn from Northwestern, Illinois worked the disc down the field and rookie Jacob Cuthbert took a timeout outside of the endzone. One endzone set later, Prayag found Cuthbert for the win, sending Illinois to the semifinals.</p>\n            <p>Due to the loss in pool play, Illinois\u2019s matchup in the semifinals was Michigan. Despite the tough game before, Illinois had to come out hot if they wanted to win the game. Michigan came out of the gate fast, scoring on a huck. Illinois followed suit, and the two teams traded offensive holds until Michigan broke for 3-5. As the game went on, the defensive pressure from Michigan intensified and Illinois\u2019 o line was not able to match the goals that Michigan\u2019s o line was putting out. Coming out of half at 5-8, Illinois turned and was broken again. A late injury to Prayag pushed the hope of a comeback a little further out of reach and a senior d line was unable to keep Michigan from seizing the victory 10-15. Michigan went on to defeat Notre Dame 15-9 to take the bid to Nationals. Illinois finished the season with a 11-10 victory over Purdue for 3rd in the region.</p>\n            <p>Captain Nick Prozorovsky and John Saniat received 1st team All-Region honors and Captain Prayag Patel received 2nd team All-Region. Ben Sabourin and Jacob Cuthbert were voted All-Freshmen for the region, with Ben winning Freshman of the Year.</p>\n        "
	    },
	    {
	        year: 2015,
	        imagePath: './assets/team-photo-2015.jpg',
	        summaryMarkup: "\n            Hello\n        "
	    },
	];


/***/ }),
/* 137 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Team History</h1>\n<div class=\"ui secondary pointing menu\">\n    <div #1994dropdown class=\"ui dropdown item\">\n        1994-1999<i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <div routerLink=\"/history/1994\" [routerLinkActive]=\"['active']\" class=\"item\">1994</div>\n            <div routerLink=\"/history/1995\" [routerLinkActive]=\"['active']\" class=\"item\">1995</div>\n            <div routerLink=\"/history/1996\" [routerLinkActive]=\"['active']\" class=\"item\">1996</div>\n            <div routerLink=\"/history/1997\" [routerLinkActive]=\"['active']\" class=\"item\">1997</div>\n            <div routerLink=\"/history/1998\" [routerLinkActive]=\"['active']\" class=\"item\">1998</div>\n            <div routerLink=\"/history/1999\" [routerLinkActive]=\"['active']\" class=\"item\">1999</div>\n        </div>\n    </div>\n    <div #2000dropdown class=\"ui dropdown item\">\n        2000-2009<i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <div routerLink=\"/history/2001\" [routerLinkActive]=\"['active']\" class=\"item\">2001</div>\n            <div routerLink=\"/history/2002\" [routerLinkActive]=\"['active']\" class=\"item\">2002</div>\n            <div routerLink=\"/history/2003\" [routerLinkActive]=\"['active']\" class=\"item\">2003</div>\n            <div routerLink=\"/history/2004\" [routerLinkActive]=\"['active']\" class=\"item\">2004</div>\n            <div routerLink=\"/history/2005\" [routerLinkActive]=\"['active']\" class=\"item\">2005</div>\n            <div routerLink=\"/history/2006\" [routerLinkActive]=\"['active']\" class=\"item\">2006</div>\n            <div routerLink=\"/history/2007\" [routerLinkActive]=\"['active']\" class=\"item\">2007</div>\n            <div routerLink=\"/history/2008\" [routerLinkActive]=\"['active']\" class=\"item\">2008</div>\n            <div routerLink=\"/history/2009\" [routerLinkActive]=\"['active']\" class=\"item\">2009</div>\n        </div>\n    </div>\n    <div #2010dropdown class=\"ui dropdown item\">\n        2010-2017<i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <div routerLink=\"/history/2010\" [routerLinkActive]=\"['active']\" class=\"item\">2010</div>\n            <div routerLink=\"/history/2011\" [routerLinkActive]=\"['active']\" class=\"item\">2011</div>\n            <div routerLink=\"/history/2012\" [routerLinkActive]=\"['active']\" class=\"item\">2012</div>\n            <div routerLink=\"/history/2013\" [routerLinkActive]=\"['active']\" class=\"item\">2013</div>\n            <div routerLink=\"/history/2014\" [routerLinkActive]=\"['active']\" class=\"item\">2014</div>\n            <div routerLink=\"/history/2015\" [routerLinkActive]=\"['active']\" class=\"item\">2015</div>\n            <div routerLink=\"/history/2016\" [routerLinkActive]=\"['active']\" class=\"item\">2016</div>\n            <div routerLink=\"/history/2017\" [routerLinkActive]=\"['active']\" class=\"item\">2017</div>\n\n        </div>\n    </div>\n</div>\n<h2 class=\"ui header\">{{year}}</h2>\n<ng-container *ngFor=\"let historyYear of historyData\">\n    <ng-container *ngIf=\"historyYear.year === year\">\n        <img src=\"{{historyYear.imagePath}}\"/>\n        <div class=\"summary\" [innerHTML]=\"historyYear.summaryMarkup\"></div>\n    </ng-container>\n</ng-container>\n<!--Only show the previous and next button if they are within the bounds of our history summaries-->\n<a *ngIf=\"year > 1994\" routerLink=\"/history/{{year - 1}}\"><i class=\"angle double left icon\"></i></a>\n<a *ngIf=\"year < 2017\" routerLink=\"/history/{{year + 1}}\"><i class=\"angle double right icon\"></i></a>";

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(139);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "img {\n  width: 75%;\n  border: 1px solid #00004D;\n  margin-bottom: 15px;\n  border-radius: 0.28571429em;\n}\ni {\n  font-size: 2em;\n}\ni.right {\n  float: right;\n}\ni.left {\n  float: left;\n}\n.summary {\n  text-align: left;\n  margin-bottom: 20px;\n}\n.item.active {\n  border: 0 !important;\n}\n.ui.dropdown.item {\n  height: 40px;\n}\n", ""]);
	
	// exports


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var awards_data_1 = __webpack_require__(141);
	var AwardsComponent = (function () {
	    function AwardsComponent() {
	        // Awards data to inject into our template
	        this.awardData = awards_data_1.AWARDS_DATA;
	    }
	    AwardsComponent.prototype.ngOnInit = function () { };
	    return AwardsComponent;
	}());
	AwardsComponent = __decorate([
	    core_1.Component({
	        selector: 'awards',
	        template: __webpack_require__(142),
	        styles: [__webpack_require__(143)]
	    }),
	    __metadata("design:paramtypes", [])
	], AwardsComponent);
	exports.AwardsComponent = AwardsComponent;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

	"use strict";
	exports.AWARDS_DATA = [
	    {
	        year: 2016,
	        name: 'Nick Prozorovsky',
	        award: '1st Team'
	    },
	    {
	        year: 2016,
	        name: 'Johnny Saniat',
	        award: '1st Team'
	    },
	    {
	        year: 2016,
	        name: 'Prayag Patel',
	        award: '2nd Team'
	    },
	    {
	        year: 2016,
	        name: 'Ben Sabourin',
	        award: 'All-Freshman/FOTY'
	    },
	    {
	        year: 2016,
	        name: 'Jacob Cuthbert',
	        award: 'All-Freshman'
	    },
	    {
	        year: 2015,
	        name: 'Matt Stupca',
	        award: 'COTY'
	    },
	    {
	        year: 2015,
	        name: 'Nick Prozorovsky',
	        award: '1st Team'
	    },
	    {
	        year: 2015,
	        name: 'Matt West',
	        award: '1st Team'
	    },
	    {
	        year: 2015,
	        name: 'Kevin Lin',
	        award: 'All-Freshman/FOTY'
	    },
	    {
	        year: 2014,
	        name: 'Neal Phelps',
	        award: '1st Team'
	    },
	    {
	        year: 2014,
	        name: 'Nick Prozorovsky',
	        award: '2nd Team'
	    },
	    {
	        year: 2013,
	        name: 'Nathan Gibbons',
	        award: '1st Team'
	    },
	    {
	        year: 2013,
	        name: 'Neal Phelps',
	        award: '1st Team'
	    },
	    {
	        year: 2013,
	        name: 'Ryan Smith',
	        award: '1st Team/POTY'
	    },
	    {
	        year: 2013,
	        name: 'Brad Bollinger',
	        award: '2nd Team'
	    },
	    {
	        year: 2013,
	        name: 'Nick Prozorovsky',
	        award: 'All Freshman'
	    },
	    {
	        year: 2013,
	        name: 'Johnny Saniat',
	        award: 'All Freshman'
	    },
	    {
	        year: 2013,
	        name: 'Derek Yan',
	        award: 'All Freshman'
	    },
	    {
	        year: 2012,
	        name: 'Ryan Smith',
	        award: '1st Team'
	    },
	    {
	        year: 2012,
	        name: 'Dane Jorgensen',
	        award: '2nd Team'
	    },
	    {
	        year: 2011,
	        name: 'Ryan Smith',
	        award: '1st Team'
	    },
	    {
	        year: 2010,
	        name: 'Walden Nelson',
	        award: '1st Team'
	    },
	    {
	        year: 2010,
	        name: 'Brian Phelan',
	        award: '1st Team'
	    },
	    {
	        year: 2010,
	        name: 'Ryan Smith',
	        award: '2nd Team'
	    },
	    {
	        year: 2009,
	        name: 'Matt Stupca',
	        award: 'COTY'
	    },
	    {
	        year: 2009,
	        name: 'Denis Agniel',
	        award: '2nd Team'
	    },
	    {
	        year: 2009,
	        name: 'Walden Nelson',
	        award: '2nd Team'
	    },
	    {
	        year: 2009,
	        name: 'Pavan Sarguru',
	        award: '2nd Team'
	    },
	    {
	        year: 2009,
	        name: 'Ryan Smith',
	        award: 'FOTY'
	    },
	    {
	        year: 2008,
	        name: 'Joel Koehneman',
	        award: '1st Team'
	    },
	    {
	        year: 2008,
	        name: 'Pat Stephens',
	        award: '1st Team'
	    },
	    {
	        year: 2007,
	        name: 'Joel Koehneman',
	        award: '1st Team'
	    },
	    {
	        year: 2007,
	        name: 'Brian Korbesmeyer',
	        award: '1st Team'
	    },
	    {
	        year: 2006,
	        name: 'Brian Phelan',
	        award: 'FOTY'
	    },
	    {
	        year: 2005,
	        name: 'Nick McDuffee',
	        award: '1st Team'
	    },
	    {
	        year: 2005,
	        name: 'Mike Clark',
	        award: '1st Team'
	    },
	    {
	        year: 2005,
	        name: 'David Abram',
	        award: 'FOTY'
	    },
	    {
	        year: 2004,
	        name: 'Matt Welsh',
	        award: '1st Team'
	    },
	    {
	        year: 2004,
	        name: 'Nick McDuffee',
	        award: '1st Team'
	    },
	    {
	        year: 2004,
	        name: 'Pat Stephens',
	        award: 'FOTY'
	    },
	    {
	        year: 2003,
	        name: 'Nate Bosscher',
	        award: '1st Team'
	    },
	    {
	        year: 2002,
	        name: 'Xi Xia',
	        award: '1st Team'
	    },
	    {
	        year: 2002,
	        name: 'Dane Olsen',
	        award: 'FOTY'
	    }
	];


/***/ }),
/* 142 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Awards</h1>\n<table class=\"ui celled table\">\n    <thead>\n        <tr>\n            <th>Year</th>\n            <th>Name</th>\n            <th>Award</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr *ngFor=\"let award of awardData\">\n            <td>{{award.year}}</td>\n            <td>{{award.name}}</td>\n            <td>{{award.award}}</td>\n        </tr>\n    </tbody>\n</table>\n<p>*All-Freshman team added in 2013, FOTY (Freshman of the Year) given to the All-Freshman member with the most 1st place votes</p>\n<p>*Player of the year award added in 2013, POTY (Player of the Year) given to the All-Region member with the most 1st place votes</p>\n<p>*COTY (Coach of the Year) added in 2009</p>\n<p>*2nd-Team All Region added in 2009</p>\n<p>*Awards first given out in 2002</p>";

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(144);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "p {\n  text-align: left;\n  text-indent: 0;\n}\n", ""]);
	
	// exports


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var results_data_1 = __webpack_require__(146);
	var ResultsComponent = (function () {
	    function ResultsComponent() {
	        // Results data to inject into our template
	        this.resultData = results_data_1.RESULTS_DATA;
	    }
	    ResultsComponent.prototype.ngOnInit = function () { };
	    return ResultsComponent;
	}());
	ResultsComponent = __decorate([
	    core_1.Component({
	        selector: 'results',
	        template: __webpack_require__(147),
	        styles: [__webpack_require__(148)]
	    }),
	    __metadata("design:paramtypes", [])
	], ResultsComponent);
	exports.ResultsComponent = ResultsComponent;


/***/ }),
/* 146 */
/***/ (function(module, exports) {

	"use strict";
	exports.RESULTS_DATA = [
	    {
	        year: 2016,
	        sectionals: '3rd',
	        regionals: '3rd',
	        nationals: '-',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://play.usaultimate.org/teams/events/Eventteam/?TeamId=nQzsCO0fKbUUEFZfKJ%2fOUotd%2f1PM6wo35HPaXJEMUC8%3d'
	    },
	    {
	        year: 2015,
	        sectionals: '2nd',
	        regionals: '1st',
	        nationals: '13th',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://play.usaultimate.org/teams/events/Eventteam/?TeamId=T%2bV6D2XyLTlkLA%2fX2WpaiPGnYy6S3Dn%2fmcblfo08DNo%3d'
	    }
	];


/***/ }),
/* 147 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Results</h1>\n<table class=\"ui celled table\">\n    <thead>\n    <tr>\n        <th>Year</th>\n        <th>Sectionals</th>\n        <th>Regionals</th>\n        <th>Nationals</th>\n        <th>Team Page</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr *ngFor=\"let result of resultData\">\n        <td>{{result.year}}</td>\n        <td>{{result.sectionals}}</td>\n        <td>{{result.regionals}}</td>\n        <td>{{result.nationals}}</td>\n        <td><a target=\"_blank\" href=\"{{result.teamPageLink}}\">{{result.teamPageLabel}}</a></td>\n    </tr>\n    </tbody>\n</table>";

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(149);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "", ""]);
	
	// exports


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var platform_browser_1 = __webpack_require__(25);
	var router_1 = __webpack_require__(90);
	var team_history_component_1 = __webpack_require__(135);
	var awards_component_1 = __webpack_require__(140);
	var results_component_1 = __webpack_require__(145);
	var app_routes_1 = __webpack_require__(134);
	var HistoryModule = (function () {
	    function HistoryModule() {
	    }
	    return HistoryModule;
	}());
	HistoryModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            platform_browser_1.BrowserModule,
	            router_1.RouterModule.forRoot(app_routes_1.ROUTES)
	        ],
	        declarations: [
	            team_history_component_1.TeamHistoryComponent,
	            awards_component_1.AwardsComponent,
	            results_component_1.ResultsComponent
	        ]
	    }),
	    __metadata("design:paramtypes", [])
	], HistoryModule);
	exports.HistoryModule = HistoryModule;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var router_1 = __webpack_require__(90);
	var menu_desktop_component_1 = __webpack_require__(152);
	var menu_mobile_component_1 = __webpack_require__(158);
	var left_sidebar_component_1 = __webpack_require__(162);
	var right_sidebar_component_1 = __webpack_require__(166);
	var page_frame_component_1 = __webpack_require__(173);
	var app_routes_1 = __webpack_require__(134);
	var footer_component_1 = __webpack_require__(177);
	var PageFrameModule = (function () {
	    function PageFrameModule() {
	    }
	    return PageFrameModule;
	}());
	PageFrameModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            router_1.RouterModule.forRoot(app_routes_1.ROUTES)
	        ],
	        declarations: [
	            page_frame_component_1.PageFrameComponent,
	            menu_desktop_component_1.MenuDesktopComponent,
	            menu_mobile_component_1.MenuMobileComponent,
	            left_sidebar_component_1.LeftSidebarComponent,
	            right_sidebar_component_1.RightSidebarComponent,
	            footer_component_1.FooterComponent
	        ],
	        exports: [
	            page_frame_component_1.PageFrameComponent
	        ]
	    }),
	    __metadata("design:paramtypes", [])
	], PageFrameModule);
	exports.PageFrameModule = PageFrameModule;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var MenuDesktopComponent = (function () {
	    function MenuDesktopComponent() {
	    }
	    /**
	     * Initialize our mobile menu dropdown.
	     */
	    MenuDesktopComponent.prototype.ngAfterViewInit = function () {
	        $(this.teamDropdown.nativeElement).dropdown({});
	        $(this.historyDropdown.nativeElement).dropdown({});
	    };
	    return MenuDesktopComponent;
	}());
	__decorate([
	    core_1.ViewChild('teamDropdown'),
	    __metadata("design:type", typeof (_a = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _a || Object)
	], MenuDesktopComponent.prototype, "teamDropdown", void 0);
	__decorate([
	    core_1.ViewChild('historyDropdown'),
	    __metadata("design:type", typeof (_b = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _b || Object)
	], MenuDesktopComponent.prototype, "historyDropdown", void 0);
	MenuDesktopComponent = __decorate([
	    core_1.Component({
	        selector: 'menu-desktop',
	        template: __webpack_require__(153),
	        styles: [__webpack_require__(155)]
	    }),
	    __metadata("design:paramtypes", [])
	], MenuDesktopComponent);
	exports.MenuDesktopComponent = MenuDesktopComponent;
	var _a, _b;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(130)))

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = "<div class=\"header\">\n    <a routerLink=\"/home\"><img class=\"crest\" src=\"" + __webpack_require__(154) + "\"/></a>\n    <a routerLink=\"/home\"><h1 class=\"header-text\">Illinois Ultimate</h1></a>\n</div>\n\n<div class=\"ui pointing stackable menu\">\n    <a routerLink=\"/home\"       [routerLinkActive]=\"['active']\" class=\"item active\"><i class=\"home icon\"></i>Home</a>\n    <a routerLink=\"/about\"      [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"info icon\"></i>About Us</a>\n    <a routerLink=\"/prospects\"  [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"child icon\"></i>Prospective Players</a>\n    <div #teamDropdown class=\"ui dropdown item\">\n        <i class=\"user icon\"></i>Team<i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <div routerLink=\"/practice\"          [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"soccer icon\"></i>Practice</div>\n            <div routerLink=\"/tournaments/2017\"  [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"calendar icon\"></i>Tournaments</div>\n            <div routerLink=\"/roster/2017\"       [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"ordered list icon\"></i>Roster</div>\n            <div routerLink=\"/absent\"            [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"remove icon\"></i>Absent Form</div>\n        </div>\n    </div>\n    <div #historyDropdown class=\"ui dropdown item\">\n        <i class=\"fast backward icon\"></i>History<i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <div routerLink=\"/history/2016\" [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"undo icon\"></i>Team History</div>\n            <div routerLink=\"/awards\"       [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"trophy icon\"></i>Awards</div>\n            <div routerLink=\"/results\"      [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"archive icon\"></i>Past Results</div>\n        </div>\n    </div>\n    <a href=\"http://www.illiniulti.blogspot.com/\" target=\"_blank\" class=\"item\"><i class=\"comment icon\"></i>Blog</a>\n    <a routerLink=\"/contact\" [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"mail icon\"></i>Contact Us</a>\n</div>";

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/crest.png";

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(156);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".header {\n  width: 100%;\n  background-image: url(" + __webpack_require__(157) + ");\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.header .header-text {\n  font-size: 72px;\n  font-family: 'Oswald', sans-serif;\n  color: #ff6226;\n  text-transform: uppercase;\n  padding: 25px;\n  margin: 0;\n  letter-spacing: 2px;\n  text-shadow: -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white, 1px 1px 0 white;\n}\n.header .crest {\n  max-height: 80px;\n  max-width: 50px;\n}\n.ui.menu {\n  margin-top: 0;\n  justify-content: center;\n  margin-bottom: 20px;\n}\n", ""]);
	
	// exports


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/header-background.jpg";

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var MenuMobileComponent = (function () {
	    function MenuMobileComponent() {
	    }
	    /**
	     * Initialize our mobile menu dropdown.
	     */
	    MenuMobileComponent.prototype.ngAfterViewInit = function () {
	        // $(this.teamDropdown.nativeElement).dropdown({});
	        // $(this.historyDropdown.nativeElement).dropdown({});
	        $(this.mobileDropdown.nativeElement).dropdown({});
	    };
	    return MenuMobileComponent;
	}());
	__decorate([
	    core_1.ViewChild('teamDropdown'),
	    __metadata("design:type", typeof (_a = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _a || Object)
	], MenuMobileComponent.prototype, "teamDropdown", void 0);
	__decorate([
	    core_1.ViewChild('historyDropdown'),
	    __metadata("design:type", typeof (_b = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _b || Object)
	], MenuMobileComponent.prototype, "historyDropdown", void 0);
	__decorate([
	    core_1.ViewChild('mobileDropdown'),
	    __metadata("design:type", typeof (_c = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _c || Object)
	], MenuMobileComponent.prototype, "mobileDropdown", void 0);
	MenuMobileComponent = __decorate([
	    core_1.Component({
	        selector: 'menu-mobile',
	        template: __webpack_require__(159),
	        styles: [__webpack_require__(160)]
	    }),
	    __metadata("design:paramtypes", [])
	], MenuMobileComponent);
	exports.MenuMobileComponent = MenuMobileComponent;
	var _a, _b, _c;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(130)))

/***/ }),
/* 159 */
/***/ (function(module, exports) {

	module.exports = "<div class=\"header\">\n    <div #mobileDropdown class=\"ui inline dropdown\">\n        <h1 class=\"header-text\">Illinois Ultimate</h1>\n        <i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <a routerLink=\"/home\"               [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"home icon\"></i>Home</a>\n            <a routerLink=\"/about\"              [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"info icon\"></i>About Us</a>\n            <a routerLink=\"/prospects\"          [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"child icon\"></i>Prospective Players</a>\n            <a routerLink=\"/practice\"           [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"soccer icon\"></i>Practice</a>\n            <a routerLink=\"/tournaments/2017\"   [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"calendar icon\"></i>Tournaments</a>\n            <a routerLink=\"/roster/2017\"        [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"ordered list icon\"></i>Roster</a>\n            <a routerLink=\"/absent\"             [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"remove icon\"></i>Absent Form</a>\n            <a routerLink=\"/history/2016\"       [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"undo icon\"></i>Team History</a>\n            <a routerLink=\"/awards\"             [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"trophy icon\"></i>Awards</a>\n            <a routerLink=\"/results\"            [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"archive icon\"></i>Past Results</a>\n            <a routerLink=\"/blog\"               [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"comment icon\"></i>Blog</a>\n            <a routerLink=\"/contact\"            [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"mail icon\"></i>Contact Us</a>\n        </div>\n    </div>\n</div>";

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(161);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".header {\n  width: 100%;\n  background-image: url(" + __webpack_require__(157) + ");\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-bottom: 20px;\n}\n.header .ui.dropdown {\n  text-align: center;\n}\n.header .header-text {\n  font-size: 72px;\n  font-family: 'Oswald', sans-serif;\n  color: #ff6226;\n  text-transform: uppercase;\n  padding: 10px;\n  margin: 0;\n  letter-spacing: 2px;\n  text-shadow: -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white, 1px 1px 0 white;\n}\n.header .dropdown.icon {\n  font-size: 20px;\n  color: white;\n}\n.header .menu {\n  width: 100%;\n}\n", ""]);
	
	// exports


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var LeftSidebarComponent = (function () {
	    function LeftSidebarComponent() {
	    }
	    LeftSidebarComponent.prototype.ngAfterViewInit = function () {
	        this.initializeTwitterWidget();
	    };
	    /**
	     * Twitter script for initializing our Twitter Timeline widget
	     */
	    LeftSidebarComponent.prototype.initializeTwitterWidget = function () {
	        !function (d, s, id) {
	            var js, fjs = d.getElementsByTagName(s)[0], p = 'https';
	            if (!d.getElementById(id)) {
	                js = d.createElement(s);
	                js.id = id;
	                js.src = p + "://platform.twitter.com/widgets.js";
	                fjs.parentNode.insertBefore(js, fjs);
	            }
	        }(document, "script", "twitter-wjs");
	    };
	    return LeftSidebarComponent;
	}());
	LeftSidebarComponent = __decorate([
	    core_1.Component({
	        selector: 'left-sidebar',
	        template: __webpack_require__(163),
	        styles: [__webpack_require__(164)]
	    }),
	    __metadata("design:paramtypes", [])
	], LeftSidebarComponent);
	exports.LeftSidebarComponent = LeftSidebarComponent;


/***/ }),
/* 163 */
/***/ (function(module, exports) {

	module.exports = "<div class=\"ui segment twitter-sidebar\">\n    <a class=\"twitter-timeline\" height=\"500px\" href=\"https://twitter.com/IlliniUlti\" data-widget-id=\"605414836369883136\">Tweets by @IlliniUlti</a>\n</div>";

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(165);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".twitter-sidebar {\n  padding: 0;\n  max-width: 200px;\n  margin-left: auto;\n  margin-right: auto;\n}\n", ""]);
	
	// exports


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var RightSidebarComponent = (function () {
	    function RightSidebarComponent() {
	    }
	    RightSidebarComponent.prototype.ngOnInit = function () { };
	    return RightSidebarComponent;
	}());
	RightSidebarComponent = __decorate([
	    core_1.Component({
	        selector: 'right-sidebar',
	        template: __webpack_require__(167),
	        styles: [__webpack_require__(171)]
	    }),
	    __metadata("design:paramtypes", [])
	], RightSidebarComponent);
	exports.RightSidebarComponent = RightSidebarComponent;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = "<div class=\"ui segment paypal-sidebar\">\n    <h2 class=\"ui header\">Help Out Illinois Ultimate!</h2>\n\n    <p>Illinois Ultimate is mostly student-funded, help us out by donating!</p>\n    <a href=\"https://www.paypal.me/illinoisUltimate\" target=\"_blank\">\n        <img class=\"paypal-donate\" src=\"" + __webpack_require__(168) + "\"/>\n    </a>\n</div>\n<a href=\"https://www.facebook.com/IllinoisUltimate\" target=\"_blank\">\n    <img class=\"social-media-button hvr-sink\" src=\"" + __webpack_require__(169) + "\"/>\n</a>\n<a href=\"https://twitter.com/illiniulti\" target=\"_blank\">\n    <img class=\"social-media-button hvr-sink\" src=\"" + __webpack_require__(170) + "\"/>\n</a>";

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/paypal-donate.png";

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/facebook-button.png";

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/twitter-button.png";

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(172);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".paypal-sidebar {\n  max-width: 200px;\n  margin-left: auto;\n  margin-right: auto;\n}\n.paypal-sidebar p {\n  text-indent: 0;\n  margin-bottom: 0;\n  padding-top: 15px;\n  padding-bottom: 15px;\n}\n.paypal-donate {\n  width: 100px;\n}\n.ui.header {\n  margin-bottom: 0;\n}\n.social-media-button {\n  width: 40%;\n  max-width: 70px;\n  display: inline-block;\n  margin: 3px;\n  border: 1px solid #00004D;\n  box-shadow: 0px 1px 2px 0 rgba(34, 36, 38, 0.15);\n  border-radius: 0.28571429em;\n}\n", ""]);
	
	// exports


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var PageFrameComponent = (function () {
	    function PageFrameComponent() {
	    }
	    PageFrameComponent.prototype.ngOnInit = function () { };
	    return PageFrameComponent;
	}());
	PageFrameComponent = __decorate([
	    core_1.Component({
	        selector: 'page-frame',
	        template: __webpack_require__(174),
	        styles: [__webpack_require__(175)]
	    }),
	    __metadata("design:paramtypes", [])
	], PageFrameComponent);
	exports.PageFrameComponent = PageFrameComponent;


/***/ }),
/* 174 */
/***/ (function(module, exports) {

	module.exports = "<!--Header-->\n<menu-desktop class=\"menu-desktop\"></menu-desktop>\n<menu-mobile class=\"menu-mobile\"></menu-mobile>\n\n<!--Content-->\n<div class=\"main-container\">\n    <div class=\"left-sidebar\">\n        <left-sidebar></left-sidebar>\n    </div>\n    <div class=\"main-content\">\n        <router-outlet></router-outlet>\n    </div>\n    <div class=\"right-sidebar\">\n        <right-sidebar></right-sidebar>\n    </div>\n    <footer></footer>\n</div>";

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(176);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".menu-desktop,\n.left-sidebar,\n.right-sidebar {\n  display: none;\n}\n.main-container {\n  margin-bottom: 50px;\n}\n@media screen and (min-width: 768px) {\n  .main-container {\n    display: flex;\n  }\n  .menu-mobile {\n    display: none;\n  }\n  .menu-desktop,\n  .left-sidebar,\n  .right-sidebar {\n    display: block;\n  }\n  .main-content {\n    padding: 0 10px;\n    width: 100%;\n  }\n  .left-sidebar {\n    margin-left: 10px;\n    flex: 0 0 200px;\n  }\n  .right-sidebar {\n    margin-right: 10px;\n    margin-left: auto;\n    flex: 0 0 150px;\n  }\n}\n@media screen and (min-width: 1024px) {\n  .main-content {\n    padding: 0 30px;\n  }\n  .left-sidebar {\n    margin-left: 50px;\n  }\n  .right-sidebar {\n    margin-right: 50px;\n    flex: 0 0 200px;\n  }\n}\n@media screen and (min-width: 1280px) {\n  .main-content {\n    padding: 0 50px;\n  }\n  .left-sidebar {\n    margin-left: 80px;\n  }\n  .right-sidebar {\n    margin-right: 80px;\n  }\n}\n", ""]);
	
	// exports


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var FooterComponent = (function () {
	    function FooterComponent() {
	    }
	    FooterComponent.prototype.ngAfterViewInit = function () { };
	    return FooterComponent;
	}());
	FooterComponent = __decorate([
	    core_1.Component({
	        selector: 'footer',
	        template: __webpack_require__(178),
	        styles: [__webpack_require__(179)]
	    }),
	    __metadata("design:paramtypes", [])
	], FooterComponent);
	exports.FooterComponent = FooterComponent;


/***/ }),
/* 178 */
/***/ (function(module, exports) {

	module.exports = "<div class=\"ui menu\">\n    <p>For support or to report website issues, email the admin at wcjphoenix@gmail.com or the creator at nick.prozorovsky@gmail.com</p>\n</div>";

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(180);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".ui.menu {\n  position: fixed;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  display: flex;\n  align-items: center;\n}\np {\n  margin: 0 auto;\n  font-size: 10px;\n}\n@media screen and (min-width: 768px) {\n  p {\n    font-size: 12px;\n  }\n}\n", ""]);
	
	// exports


/***/ })
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2hvbWUvaG9tZS5qcGciLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmxlc3M/NzIzNiIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvYWJvdXQvYWJvdXQuY29tcG9uZW50Lmxlc3M/YWFlNSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcHJvc3BlY3RpdmUtcGxheWVycy9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3NlcnZpY2UvZ29vZ2xlLXNwcmVhZHNoZWV0LnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50Lmxlc3M/MmI1MSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3Byb3NwZWN0aXZlLXBsYXllcnMvcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50Lmxlc3M/MTc2YyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9zaGFyZWQtc3R5bGUvc3R5bGVzLmNzcz9jOTY1Iiwid2VicGFjazovLy8uL3NyYy9hcHAvc2hhcmVkLXN0eWxlL3N0eWxlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2dsb2JhbC9iYWNrZ3JvdW5kLmpwZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5jb21wb25lbnQubGVzcz9jNjA3Iiwid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90ZWFtLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9tYXBzLWFwaS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL2NpcmNsZS1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9tYXJrZXItbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFuYWdlcnMvcG9seWdvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9rbWwtbGF5ZXItbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWNpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWluZm8td2luZG93LmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAta21sLWxheWVyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtbWFya2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbGF6eS1tYXBzLWFwaS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3V0aWxzL2Jyb3dzZXItZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL25vb3AtbWFwcy1hcGktbG9hZGVyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9jb3JlLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcHJhY3RpY2UvcHJhY3RpY2UuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9kYXRhL3ByYWN0aWNlLmRhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC90ZWFtL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9wcmFjdGljZS5jb21wb25lbnQubGVzcz84NzlhIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9wcmFjdGljZS5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vdG91cm5hbWVudHMvdG91cm5hbWVudHMuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy9kYXRhL3RvdXJuYW1lbnRzLmRhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC90ZWFtL3RvdXJuYW1lbnRzL3RvdXJuYW1lbnRzLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzcz85MmI0Iiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9kYXRhL3Jvc3RlcnMuZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQubGVzcz8zYmIwIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9yb3N0ZXIvcm9zdGVyLmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQubGVzcz83ZjlhIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLnJvdXRlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hpc3RvcnkvdGVhbS1oaXN0b3J5L3RlYW0taGlzdG9yeS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L3RlYW0taGlzdG9yeS9kYXRhL2hpc3RvcnkteWVhci5kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5sZXNzPzZjODUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L3RlYW0taGlzdG9yeS90ZWFtLWhpc3RvcnkuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L2F3YXJkcy9hd2FyZHMuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvZGF0YS9hd2FyZHMuZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQubGVzcz9hMTIwIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvYXdhcmRzLmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL2RhdGEvcmVzdWx0cy5kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L3Jlc3VsdHMvcmVzdWx0cy5jb21wb25lbnQubGVzcz85MjhjIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L2hpc3RvcnkubW9kdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9wYWdlLWZyYW1lLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1kZXNrdG9wL21lbnUtZGVza3RvcC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbWVudS9jcmVzdC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50Lmxlc3M/ODhkOCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1kZXNrdG9wL21lbnUtZGVza3RvcC5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9tZW51L2hlYWRlci1iYWNrZ3JvdW5kLmpwZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9tZW51LW1vYmlsZS9tZW51LW1vYmlsZS5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3M/ODczNSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzP2QzMTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvcGF5cGFsLWRvbmF0ZS5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL2ZhY2Vib29rLWJ1dHRvbi5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL3R3aXR0ZXItYnV0dG9uLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcmlnaHQtc2lkZWJhci9yaWdodC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzP2UxNjQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmxlc3M/M2FkMCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvZm9vdGVyL2Zvb3Rlci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50Lmxlc3M/Y2I2MCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvZm9vdGVyL2Zvb3Rlci5jb21wb25lbnQubGVzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLHlEQUEyRTtBQUMzRSxxQ0FBK0M7QUFFL0MsNENBQTZDO0FBQzdDOztHQUVFO0FBRUYsc0ZBQXFGO0FBQ3JGLEdBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDN0IscUJBQWMsRUFBRSxDQUFDO0FBQ3JCLEVBQUM7QUFDRCxhQUFZO0FBQ1osa0RBQXNCLEVBQUUsQ0FBQyxlQUFlLENBQUMsc0JBQVMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2JwRCxxQ0FBeUM7QUFDekMsd0NBQXlFO0FBQ3pFLGtEQUEyRDtBQUMzRCxzQ0FBMkM7QUFDM0MsdUNBQTZDO0FBRzdDLGdEQUFzRDtBQUN0RCxpREFBeUQ7QUFDekQsK0RBQWtHO0FBQ2xHLG1EQUErRDtBQUMvRCwrQ0FB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Qix5QkFBeUIsd0JBQXdCLHNCQUFzQixLQUFLLEdBQUcseUNBQXlDLG1CQUFtQixzQkFBc0IsS0FBSyxtQkFBbUIsd0JBQXdCLEtBQUssb0JBQW9CLHlCQUF5QixzQkFBc0IsS0FBSyxHQUFHLHlDQUF5QyxtQkFBbUIsc0JBQXNCLEtBQUssbUJBQW1CLHdCQUF3QixLQUFLLG9CQUFvQix5QkFBeUIsS0FBSyxHQUFHOztBQUV2OUI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUEEscUNBQXlEO0FBUXpEO0tBQUE7S0FHQSxDQUFDO0tBREcseUNBQWUsR0FBZixjQUF5QixDQUFDO0tBQzlCLHNCQUFDO0FBQUQsRUFBQztBQUhEO0tBTkMsZ0JBQVMsQ0FBQztTQUNQLFFBQVEsRUFBRSxRQUFRO1NBQ2xCLFFBQVEsRUFBRSxtQkFBTyxDQUFDLEdBQXlCLENBQUM7U0FDNUMsTUFBTSxFQUFFLENBQUMsbUJBQU8sQ0FBQyxHQUF5QixDQUFDLENBQUM7TUFDL0MsQ0FBQzs7b0JBS0Q7QUFIWSwwQ0FBZTs7Ozs7OztBQ1I1Qiw4TDs7Ozs7O0FDQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBLEU7Ozs7OztBQ1hBO0FBQ0E7OztBQUdBO0FBQ0EscUNBQW9DLG9CQUFvQixhQUFhLGNBQWMsWUFBWSxrQkFBa0Isd0JBQXdCLEdBQUcsS0FBSyxtQkFBbUIsb0JBQW9CLEdBQUcsd0NBQXdDLE9BQU8sc0JBQXNCLEtBQUssR0FBRzs7QUFFeFEiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG5pbXBvcnQgeyBlbmFibGVQcm9kTW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBcHBNb2R1bGUgfSBmcm9tICcuL2FwcC9hcHAubW9kdWxlJztcbi8qXG4gT3VyIGFwcGxpY2F0aW9uIGNvZGVcbiovXG5cbi8vIFR1cm5zIG9mZiBhc3NlcnRpb25zIGFuZCBvdGhlciBjaGVja3Mgd2l0aGluIHRoZSBmcmFtZXdvcmsgaWYgd2UgYXJlIGluIHByb2R1Y3Rpb25cbmlmIChwcm9jZXNzLmVudi5FTlYgPT09ICdwcm9kJykge1xuICAgIGVuYWJsZVByb2RNb2RlKCk7XG59XG4vLyBCb290c3RyYXBcbnBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL21haW4udHMiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSGFzaExvY2F0aW9uU3RyYXRlZ3ksIExvY2F0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9ICBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IEh0dHBNb2R1bGUgfSBmcm9tIFwiQGFuZ3VsYXIvaHR0cFwiO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcbmltcG9ydCB7IEFnbUNvcmVNb2R1bGUgfSBmcm9tICdhbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlJztcblxuaW1wb3J0IHsgSG9tZUNvbXBvbmVudCB9IGZyb20gXCIuL2hvbWUvaG9tZS5jb21wb25lbnRcIjtcbmltcG9ydCB7IEFib3V0Q29tcG9uZW50IH0gZnJvbSBcIi4vYWJvdXQvYWJvdXQuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBQcm9zcGVjdGl2ZVBsYXllcnNDb21wb25lbnQgfSBmcm9tIFwiLi9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBDb250YWN0Q29tcG9uZW50IH0gZnJvbSBcIi4vY29udGFjdC9jb250YWN0LmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcblxuaW1wb3J0IHsgVGVhbU1vZHVsZSB9IGZyb20gXCIuL3RlYW0vdGVhbS5tb2R1bGVcIjtcbmltcG9ydCB7IEhpc3RvcnlNb2R1bGUgfSBmcm9tIFwiLi9oaXN0b3J5L2hpc3RvcnkubW9kdWxlXCI7XG5pbXBvcnQgeyBQYWdlRnJhbWVNb2R1bGUgfSBmcm9tIFwiLi9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUubW9kdWxlXCI7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBCcm93c2VyTW9kdWxlLFxuICAgICAgICBIdHRwTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgLy8gQWdtQ29yZU1vZHVsZS5mb3JSb290KHtcbiAgICAgICAgLy8gICAgIGFwaUtleTogJ0FJemFTeUJSSVhBazV4ZHZuM2V6eXBzU2U1NWY4ZFpoY0hoZUFaOCdcbiAgICAgICAgLy8gfSksXG4gICAgICAgIFBhZ2VGcmFtZU1vZHVsZSxcbiAgICAgICAgVGVhbU1vZHVsZSxcbiAgICAgICAgSGlzdG9yeU1vZHVsZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEFwcENvbXBvbmVudCxcbiAgICAgICAgSG9tZUNvbXBvbmVudCxcbiAgICAgICAgQWJvdXRDb21wb25lbnQsXG4gICAgICAgIFByb3NwZWN0aXZlUGxheWVyc0NvbXBvbmVudCxcbiAgICAgICAgQ29udGFjdENvbXBvbmVudFxuICAgIF0sXG4gICAgLy8gVXNlIGhhc2ggc3RyYXRlZ3kgc28gcGFnZSByZWZyZXNoZXMgb24gR2l0aHViIHBhZ2VzIHJvdXRlIGNvcnJlY3RseVxuICAgIHByb3ZpZGVyczogWyB7cHJvdmlkZTogTG9jYXRpb25TdHJhdGVneSwgdXNlQ2xhc3M6IEhhc2hMb2NhdGlvblN0cmF0ZWd5fSBdLFxuICAgIGJvb3RzdHJhcDogWyBBcHBDb21wb25lbnQgXVxufSlcbmV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9hcHAubW9kdWxlLnRzIiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYyLjIuNFxuICogKGMpIDIwMTAtMjAxNiBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyksIHJlcXVpcmUoJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJyksIHJlcXVpcmUoJ3J4anMvU3ViamVjdCcpLCByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKSwgcmVxdWlyZSgncnhqcy9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAncnhqcy9vcGVyYXRvci90b1Byb21pc2UnLCAncnhqcy9TdWJqZWN0JywgJ3J4anMvT2JzZXJ2YWJsZScsICdyeGpzL29ic2VydmFibGUvZnJvbVByb21pc2UnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5mb3JtcyA9IGdsb2JhbC5uZy5mb3JtcyB8fCB7fSksZ2xvYmFsLm5nLmNvcmUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeCxnbG9iYWwuUngsZ2xvYmFsLlJ4Lk9ic2VydmFibGUpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsX2FuZ3VsYXJfY29yZSxyeGpzX29wZXJhdG9yX3RvUHJvbWlzZSxyeGpzX1N1YmplY3Qscnhqc19PYnNlcnZhYmxlLHJ4anNfb2JzZXJ2YWJsZV9mcm9tUHJvbWlzZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgY29udHJvbCBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogT25seSB1c2VkIGludGVybmFsbHkgaW4gdGhlIGZvcm1zIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCcpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wudmFsdWUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsaWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wudmFsaWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaW52YWxpZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5pbnZhbGlkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInBlbmRpbmdcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wucGVuZGluZyA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlcnJvcnNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuZXJyb3JzIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInByaXN0aW5lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnByaXN0aW5lIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImRpcnR5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmRpcnR5IDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvdWNoZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wudG91Y2hlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ1bnRvdWNoZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wudW50b3VjaGVkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmRpc2FibGVkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuZW5hYmxlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdGF0dXNDaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnN0YXR1c0NoYW5nZXMgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbHVlQ2hhbmdlcyA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbC5yZXNldCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUuaGFzRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmhhc0Vycm9yKGVycm9yQ29kZSwgcGF0aCkgOiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5nZXRFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuZ2V0RXJyb3IoZXJyb3JDb2RlLCBwYXRoKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpcmVjdGl2ZSB0aGF0IGNvbnRhaW5zIG11bHRpcGxlIHtAbGluayBOZ0NvbnRyb2x9cy5cbiAgICAgKlxuICAgICAqIE9ubHkgdXNlZCBieSB0aGUgZm9ybXMgbW9kdWxlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb250cm9sQ29udGFpbmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQ29udHJvbENvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ29udHJvbENvbnRhaW5lcigpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250cm9sQ29udGFpbmVyLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBmb3JtIHRvIHdoaWNoIHRoaXMgY29udGFpbmVyIGJlbG9uZ3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250cm9sQ29udGFpbmVyLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBwYXRoIHRvIHRoaXMgY29udGFpbmVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQ29udHJvbENvbnRhaW5lcjtcbiAgICB9KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSkpO1xuXG4gICAgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICE9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT0gbnVsbDtcbiAgICB9XG4gICAgLy8gSlMgaGFzIE5hTiAhPT0gTmFOXG4gICAgZnVuY3Rpb24gbG9vc2VJZGVudGljYWwoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYiB8fCB0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInICYmIGlzTmFOKGEpICYmIGlzTmFOKGIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0pzT2JqZWN0KG8pIHtcbiAgICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvID09PSAnb2JqZWN0Jyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgICAgICByZXR1cm4gIWlzSnNPYmplY3Qob2JqKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBKYXZhc2NyaXB0IE9iamVjdHNcbiAgICAgKi9cbiAgICB2YXIgU3RyaW5nTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN0cmluZ01hcFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5tZXJnZSA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICAgIHZhciBtID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMobTEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIG1ba10gPSBtMVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyhtMik7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0yW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIGsxID0gT2JqZWN0LmtleXMobTEpO1xuICAgICAgICAgICAgdmFyIGsyID0gT2JqZWN0LmtleXMobTIpO1xuICAgICAgICAgICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGsxW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtMVtrZXldICE9PSBtMltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cmluZ01hcFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTGlzdFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMaXN0V3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBbGwgPSBmdW5jdGlvbiAobGlzdCwgaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoaXRlbXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZmxhdHRlbiA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGZsYXQsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxhdEl0ZW0gPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gTGlzdFdyYXBwZXIuZmxhdHRlbihpdGVtKSA6IGl0ZW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYXQuY29uY2F0KGZsYXRJdGVtKTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgaXNQcm9taXNlID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmlzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGlzRW1wdHlJbnB1dFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcnMgZm9yIHZhbGlkYXRvcnMgdG8gYmUgdXNlZCBmb3Ige0BsaW5rIEZvcm1Db250cm9sfXMgaW4gYSBmb3JtLlxuICAgICAqXG4gICAgICogUHJvdmlkZSB0aGlzIHVzaW5nIGBtdWx0aTogdHJ1ZWAgdG8gYWRkIHZhbGlkYXRvcnMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZm9ybXMvdHMvbmdfdmFsaWRhdG9ycy9uZ192YWxpZGF0b3JzLnRzIHJlZ2lvbj0nbmdfdmFsaWRhdG9ycyd9XG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOR19WQUxJREFUT1JTID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ05nVmFsaWRhdG9ycycpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyBmb3IgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMgdG8gYmUgdXNlZCBmb3Ige0BsaW5rIEZvcm1Db250cm9sfXNcbiAgICAgKiBpbiBhIGZvcm0uXG4gICAgICpcbiAgICAgKiBQcm92aWRlIHRoaXMgdXNpbmcgYG11bHRpOiB0cnVlYCB0byBhZGQgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgTkdfVkFMSURBVE9SU30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTkdfQVNZTkNfVkFMSURBVE9SUyA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdOZ0FzeW5jVmFsaWRhdG9ycycpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgc2V0IG9mIHZhbGlkYXRvcnMgdXNlZCBieSBmb3JtIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQSB2YWxpZGF0b3IgaXMgYSBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBhIHtAbGluayBGb3JtQ29udHJvbH0gb3IgY29sbGVjdGlvbiBvZlxuICAgICAqIGNvbnRyb2xzIGFuZCByZXR1cm5zIGEgbWFwIG9mIGVycm9ycy4gQSBudWxsIG1hcCBtZWFucyB0aGF0IHZhbGlkYXRpb24gaGFzIHBhc3NlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdmFyIGxvZ2luQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbChcIlwiLCBWYWxpZGF0b3JzLnJlcXVpcmVkKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBWYWxpZGF0b3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmFsaWRhdG9ycygpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIG5vbi1lbXB0eSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMucmVxdWlyZWQgPSBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRW1wdHlJbnB1dFZhbHVlKGNvbnRyb2wudmFsdWUpID8geyAncmVxdWlyZWQnOiB0cnVlIH0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIHZhbHVlIG9mIGEgbWluaW11bSBsZW5ndGguXG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLm1pbkxlbmd0aCA9IGZ1bmN0aW9uIChtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0eXBlb2YgY29udHJvbC52YWx1ZSA9PT0gJ3N0cmluZycgPyBjb250cm9sLnZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCA8IG1pbkxlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgIHsgJ21pbmxlbmd0aCc6IHsgJ3JlcXVpcmVkTGVuZ3RoJzogbWluTGVuZ3RoLCAnYWN0dWFsTGVuZ3RoJzogbGVuZ3RoIH0gfSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIHZhbHVlIG9mIGEgbWF4aW11bSBsZW5ndGguXG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLm1heExlbmd0aCA9IGZ1bmN0aW9uIChtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0eXBlb2YgY29udHJvbC52YWx1ZSA9PT0gJ3N0cmluZycgPyBjb250cm9sLnZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCA+IG1heExlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgIHsgJ21heGxlbmd0aCc6IHsgJ3JlcXVpcmVkTGVuZ3RoJzogbWF4TGVuZ3RoLCAnYWN0dWFsTGVuZ3RoJzogbGVuZ3RoIH0gfSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgYSBjb250cm9sIHRvIG1hdGNoIGEgcmVnZXggdG8gaXRzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5wYXR0ZXJuID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmICghcGF0dGVybilcbiAgICAgICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5udWxsVmFsaWRhdG9yO1xuICAgICAgICAgICAgdmFyIHJlZ2V4O1xuICAgICAgICAgICAgdmFyIHJlZ2V4U3RyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlZ2V4U3RyID0gXCJeXCIgKyBwYXR0ZXJuICsgXCIkXCI7XG4gICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZ2V4U3RyID0gcGF0dGVybi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gcGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QodmFsdWUpID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgIHsgJ3BhdHRlcm4nOiB7ICdyZXF1aXJlZFBhdHRlcm4nOiByZWdleFN0ciwgJ2FjdHVhbFZhbHVlJzogdmFsdWUgfSB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vLW9wIHZhbGlkYXRvci5cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMubnVsbFZhbGlkYXRvciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9zZSBtdWx0aXBsZSB2YWxpZGF0b3JzIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB1bmlvblxuICAgICAgICAgKiBvZiB0aGUgaW5kaXZpZHVhbCBlcnJvciBtYXBzLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5jb21wb3NlID0gZnVuY3Rpb24gKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdG9ycylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciBwcmVzZW50VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMuZmlsdGVyKGlzUHJlc2VudCk7XG4gICAgICAgICAgICBpZiAocHJlc2VudFZhbGlkYXRvcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX21lcmdlRXJyb3JzKF9leGVjdXRlVmFsaWRhdG9ycyhjb250cm9sLCBwcmVzZW50VmFsaWRhdG9ycykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMgPSBmdW5jdGlvbiAodmFsaWRhdG9ycykge1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0b3JzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHByZXNlbnRWYWxpZGF0b3JzID0gdmFsaWRhdG9ycy5maWx0ZXIoaXNQcmVzZW50KTtcbiAgICAgICAgICAgIGlmIChwcmVzZW50VmFsaWRhdG9ycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IF9leGVjdXRlQXN5bmNWYWxpZGF0b3JzKGNvbnRyb2wsIHByZXNlbnRWYWxpZGF0b3JzKS5tYXAoX2NvbnZlcnRUb1Byb21pc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihfbWVyZ2VFcnJvcnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnM7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY29udmVydFRvUHJvbWlzZShvYmopIHtcbiAgICAgICAgcmV0dXJuIGlzUHJvbWlzZShvYmopID8gb2JqIDogcnhqc19vcGVyYXRvcl90b1Byb21pc2UudG9Qcm9taXNlLmNhbGwob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2V4ZWN1dGVWYWxpZGF0b3JzKGNvbnRyb2wsIHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcnMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2KGNvbnRyb2wpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2V4ZWN1dGVBc3luY1ZhbGlkYXRvcnMoY29udHJvbCwgdmFsaWRhdG9ycykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9ycy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYoY29udHJvbCk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbWVyZ2VFcnJvcnMoYXJyYXlPZkVycm9ycykge1xuICAgICAgICB2YXIgcmVzID0gYXJyYXlPZkVycm9ycy5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgZXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGVycm9ycykgPyBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKHJlcywgZXJyb3JzKSA6IHJlcztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzKS5sZW5ndGggPT09IDAgPyBudWxsIDogcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcHJvdmlkZSBhIHtAbGluayBDb250cm9sVmFsdWVBY2Nlc3Nvcn0gZm9yIGZvcm0gY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIERlZmF1bHRWYWx1ZUFjY2Vzc29yfSBmb3IgaG93IHRvIGltcGxlbWVudCBvbmUuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOR19WQUxVRV9BQ0NFU1NPUiA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdOZ1ZhbHVlQWNjZXNzb3InKTtcblxuICAgIHZhciBDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIG9uIGEgY2hlY2tib3ggaW5wdXQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAqICBgYGBcbiAgICAgKiAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5hbWU9XCJyZW1lbWJlckxvZ2luXCIgbmdNb2RlbD5cbiAgICAgKiAgYGBgXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2NoZWNrZWQnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPWNoZWNrYm94XVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9Y2hlY2tib3hdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPWNoZWNrYm94XVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LmNoZWNrZWQpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0NIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIHZhciBERUZBVUxUX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBEZWZhdWx0VmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyB0aGF0IGlzIHVzZWQgYnkgdGhlXG4gICAgICoge0BsaW5rIE5nTW9kZWx9LCB7QGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge0BsaW5rIEZvcm1Db250cm9sTmFtZX0gZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAqICBgYGBcbiAgICAgKiAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cInNlYXJjaFF1ZXJ5XCIgbmdNb2RlbD5cbiAgICAgKiAgYGBgXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBEZWZhdWx0VmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbm9ybWFsaXplZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtmb3JtQ29udHJvbE5hbWVdLHRleHRhcmVhW2Zvcm1Db250cm9sTmFtZV0saW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbZm9ybUNvbnRyb2xdLHRleHRhcmVhW2Zvcm1Db250cm9sXSxpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtuZ01vZGVsXSx0ZXh0YXJlYVtuZ01vZGVsXSxbbmdEZWZhdWx0Q29udHJvbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdnNhdmtpbiByZXBsYWNlIHRoZSBhYm92ZSBzZWxlY3RvciB3aXRoIHRoZSBvbmUgYmVsb3cgaXQgb25jZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzAxMSBpcyBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0b3I6ICdbbmdDb250cm9sXSxbbmdNb2RlbF0sW25nRm9ybUNvbnRyb2xdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbREVGQVVMVF9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gRGVmYXVsdFZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVWYWxpZGF0b3IodmFsaWRhdG9yKSB7XG4gICAgICAgIGlmICh2YWxpZGF0b3IudmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gdmFsaWRhdG9yLnZhbGlkYXRlKGMpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVBc3luY1ZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRvci52YWxpZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiB2YWxpZGF0b3IudmFsaWRhdGUoYyk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIE5VTUJFUl9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTnVtYmVyVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSBudW1iZXIgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIHRoYXQgaXMgdXNlZCBieSB0aGVcbiAgICAgKiB7QGxpbmsgTmdNb2RlbH0sIHtAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7QGxpbmsgRm9ybUNvbnRyb2xOYW1lfSBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogICMjIyBFeGFtcGxlXG4gICAgICogIGBgYFxuICAgICAqICA8aW5wdXQgdHlwZT1cIm51bWJlclwiIFsobmdNb2RlbCldPVwiYWdlXCI+XG4gICAgICogIGBgYFxuICAgICAqL1xuICAgIHZhciBOdW1iZXJWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTnVtYmVyVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIHZhbHVlIG5lZWRzIHRvIGJlIG5vcm1hbGl6ZWQgZm9yIElFOSwgb3RoZXJ3aXNlIGl0IGlzIHNldCB0byAnbnVsbCcgd2hlbiBudWxsXG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCBub3JtYWxpemVkVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7IGZuKHZhbHVlID09ICcnID8gbnVsbCA6IHBhcnNlRmxvYXQodmFsdWUpKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1udW1iZXJdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1udW1iZXJdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPW51bWJlcl1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTlVNQkVSX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE51bWJlclZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB1bmltcGxlbWVudGVkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBiYXNlIGNsYXNzIHRoYXQgYWxsIGNvbnRyb2wgZGlyZWN0aXZlIGV4dGVuZC5cbiAgICAgKiBJdCBiaW5kcyBhIHtAbGluayBGb3JtQ29udHJvbH0gb2JqZWN0IHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBVc2VkIGludGVybmFsbHkgYnkgQW5ndWxhciBmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDIoTmdDb250cm9sLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ0NvbnRyb2woKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2wucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2wucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE5nQ29udHJvbDtcbiAgICB9KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSkpO1xuXG4gICAgdmFyIFJBRElPX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNsYXNzIHVzZWQgYnkgQW5ndWxhciB0byB1bmNoZWNrIHJhZGlvIGJ1dHRvbnMgd2l0aCB0aGUgbWF0Y2hpbmcgbmFtZS5cbiAgICAgKi9cbiAgICB2YXIgUmFkaW9Db250cm9sUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSYWRpb0NvbnRyb2xSZWdpc3RyeSgpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2Vzc29ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoY29udHJvbCwgYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2Vzc29ycy5wdXNoKFtjb250cm9sLCBhY2Nlc3Nvcl0pO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGFjY2Vzc29yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fYWNjZXNzb3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FjY2Vzc29yc1tpXVsxXSA9PT0gYWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChhY2Nlc3Nvcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2FjY2Vzc29ycy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc1NhbWVHcm91cChjLCBhY2Nlc3NvcikgJiYgY1sxXSAhPT0gYWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY1sxXS5maXJlVW5jaGVjayhhY2Nlc3Nvci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5faXNTYW1lR3JvdXAgPSBmdW5jdGlvbiAoY29udHJvbFBhaXIsIGFjY2Vzc29yKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2xQYWlyWzBdLmNvbnRyb2wpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xQYWlyWzBdLl9wYXJlbnQgPT09IGFjY2Vzc29yLl9jb250cm9sLl9wYXJlbnQgJiZcbiAgICAgICAgICAgICAgICBjb250cm9sUGFpclsxXS5uYW1lID09PSBhY2Nlc3Nvci5uYW1lO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBSYWRpb0NvbnRyb2xSZWdpc3RyeTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzICBXcml0ZXMgcmFkaW8gY29udHJvbCB2YWx1ZXMgYW5kIGxpc3RlbnMgdG8gcmFkaW8gY29udHJvbCBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVXNlZCBieSB7QGxpbmsgTmdNb2RlbH0sIHtAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7QGxpbmsgRm9ybUNvbnRyb2xOYW1lfVxuICAgICAqIHRvIGtlZXAgdGhlIHZpZXcgc3luY2VkIHdpdGggdGhlIHtAbGluayBGb3JtQ29udHJvbH0gbW9kZWwuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGltcG9ydGVkIHRoZSB7QGxpbmsgRm9ybXNNb2R1bGV9IG9yIHRoZSB7QGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX0sIHRoaXNcbiAgICAgKiB2YWx1ZSBhY2Nlc3NvciB3aWxsIGJlIGFjdGl2ZSBvbiBhbnkgcmFkaW8gY29udHJvbCB0aGF0IGhhcyBhIGZvcm0gZGlyZWN0aXZlLiBZb3UgZG9cbiAgICAgKiAqKm5vdCoqIG5lZWQgdG8gYWRkIGEgc3BlY2lhbCBzZWxlY3RvciB0byBhY3RpdmF0ZSBpdC5cbiAgICAgKlxuICAgICAqICMjIyBIb3cgdG8gdXNlIHJhZGlvIGJ1dHRvbnMgd2l0aCBmb3JtIGRpcmVjdGl2ZXNcbiAgICAgKlxuICAgICAqIFRvIHVzZSByYWRpbyBidXR0b25zIGluIGEgdGVtcGxhdGUtZHJpdmVuIGZvcm0sIHlvdSdsbCB3YW50IHRvIGVuc3VyZSB0aGF0IHJhZGlvIGJ1dHRvbnNcbiAgICAgKiBpbiB0aGUgc2FtZSBncm91cCBoYXZlIHRoZSBzYW1lIGBuYW1lYCBhdHRyaWJ1dGUuICBSYWRpbyBidXR0b25zIHdpdGggZGlmZmVyZW50IGBuYW1lYFxuICAgICAqIGF0dHJpYnV0ZXMgZG8gbm90IGFmZmVjdCBlYWNoIG90aGVyLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3JhZGlvQnV0dG9ucy9yYWRpb19idXR0b25fZXhhbXBsZS50cyByZWdpb249J1RlbXBsYXRlRHJpdmVuJ31cbiAgICAgKlxuICAgICAqIFdoZW4gdXNpbmcgcmFkaW8gYnV0dG9ucyBpbiBhIHJlYWN0aXZlIGZvcm0sIHJhZGlvIGJ1dHRvbnMgaW4gdGhlIHNhbWUgZ3JvdXAgc2hvdWxkIGhhdmUgdGhlXG4gICAgICogc2FtZSBgZm9ybUNvbnRyb2xOYW1lYC4gWW91IGNhbiBhbHNvIGFkZCBhIGBuYW1lYCBhdHRyaWJ1dGUsIGJ1dCBpdCdzIG9wdGlvbmFsLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3JlYWN0aXZlUmFkaW9CdXR0b25zL3JlYWN0aXZlX3JhZGlvX2J1dHRvbl9leGFtcGxlLnRzIHJlZ2lvbj0nUmVhY3RpdmUnfVxuICAgICAqXG4gICAgICogICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmLCBfcmVnaXN0cnksIF9pbmplY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IF9yZWdpc3RyeTtcbiAgICAgICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbCA9IHRoaXMuX2luamVjdG9yLmdldChOZ0NvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tOYW1lKCk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RyeS5hZGQodGhpcy5fY29udHJvbCwgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9yZWdpc3RyeS5yZW1vdmUodGhpcyk7IH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gdmFsdWUgPT09IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnY2hlY2tlZCcsIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2ZuID0gZm47XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZuKF90aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVnaXN0cnkuc2VsZWN0KF90aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLmZpcmVVbmNoZWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMud3JpdGVWYWx1ZSh2YWx1ZSk7IH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9jaGVja05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lICYmIHRoaXMuZm9ybUNvbnRyb2xOYW1lICYmIHRoaXMubmFtZSAhPT0gdGhpcy5mb3JtQ29udHJvbE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd05hbWVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm5hbWUgJiYgdGhpcy5mb3JtQ29udHJvbE5hbWUpXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5mb3JtQ29udHJvbE5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl90aHJvd05hbWVFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgIElmIHlvdSBkZWZpbmUgYm90aCBhIG5hbWUgYW5kIGEgZm9ybUNvbnRyb2xOYW1lIGF0dHJpYnV0ZSBvbiB5b3VyIHJhZGlvIGJ1dHRvbiwgdGhlaXIgdmFsdWVzXFxuICAgICAgbXVzdCBtYXRjaC4gRXg6IDxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgZm9ybUNvbnRyb2xOYW1lPVxcXCJmb29kXFxcIiBuYW1lPVxcXCJmb29kXFxcIj5cXG4gICAgXCIpO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPXJhZGlvXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9cmFkaW9dW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXJhZGlvXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1JBRElPX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogUmFkaW9Db250cm9sUmVnaXN0cnksIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0b3IsIH0sXG4gICAgICAgIF07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICAgICAgJ2Zvcm1Db250cm9sTmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgUkFOR0VfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJhbmdlVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSByYW5nZSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgdGhhdCBpcyB1c2VkIGJ5IHRoZVxuICAgICAqIHtAbGluayBOZ01vZGVsfSwge0BsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfSwgYW5kIHtAbGluayBGb3JtQ29udHJvbE5hbWV9IGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgKiAgYGBgXG4gICAgICogIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBbKG5nTW9kZWwpXT1cImFnZVwiID5cbiAgICAgKiAgYGBgXG4gICAgICovXG4gICAgdmFyIFJhbmdlVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJhbmdlVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCBwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBmbih2YWx1ZSA9PSAnJyA/IG51bGwgOiBwYXJzZUZsb2F0KHZhbHVlKSk7IH07XG4gICAgICAgIH07XG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9cmFuZ2VdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1yYW5nZV1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9cmFuZ2VdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1JBTkdFX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gUmFuZ2VWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgU0VMRUNUX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBfYnVpbGRWYWx1ZVN0cmluZyhpZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlkID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICBpZiAoIWlzUHJpbWl0aXZlKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gJ09iamVjdCc7XG4gICAgICAgIHJldHVybiAoaWQgKyBcIjogXCIgKyB2YWx1ZSkuc2xpY2UoMCwgNTApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZXh0cmFjdElkKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVN0cmluZy5zcGxpdCgnOicpWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBXcml0ZXMgdmFsdWVzIGFuZCBsaXN0ZW5zIHRvIGNoYW5nZXMgb24gYSBzZWxlY3QgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFVzZWQgYnkge0BsaW5rIE5nTW9kZWx9LCB7QGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge0BsaW5rIEZvcm1Db250cm9sTmFtZX1cbiAgICAgKiB0byBrZWVwIHRoZSB2aWV3IHN5bmNlZCB3aXRoIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9IG1vZGVsLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBJZiB5b3UgaGF2ZSBpbXBvcnRlZCB0aGUge0BsaW5rIEZvcm1zTW9kdWxlfSBvciB0aGUge0BsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9LCB0aGlzXG4gICAgICogdmFsdWUgYWNjZXNzb3Igd2lsbCBiZSBhY3RpdmUgb24gYW55IHNlbGVjdCBjb250cm9sIHRoYXQgaGFzIGEgZm9ybSBkaXJlY3RpdmUuIFlvdSBkb1xuICAgICAqICoqbm90KiogbmVlZCB0byBhZGQgYSBzcGVjaWFsIHNlbGVjdG9yIHRvIGFjdGl2YXRlIGl0LlxuICAgICAqXG4gICAgICogIyMjIEhvdyB0byB1c2Ugc2VsZWN0IGNvbnRyb2xzIHdpdGggZm9ybSBkaXJlY3RpdmVzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgYSBzZWxlY3QgaW4gYSB0ZW1wbGF0ZS1kcml2ZW4gZm9ybSwgc2ltcGx5IGFkZCBhbiBgbmdNb2RlbGAgYW5kIGEgYG5hbWVgXG4gICAgICogYXR0cmlidXRlIHRvIHRoZSBtYWluIGA8c2VsZWN0PmAgdGFnLlxuICAgICAqXG4gICAgICogSWYgeW91ciBvcHRpb24gdmFsdWVzIGFyZSBzaW1wbGUgc3RyaW5ncywgeW91IGNhbiBiaW5kIHRvIHRoZSBub3JtYWwgYHZhbHVlYCBwcm9wZXJ0eVxuICAgICAqIG9uIHRoZSBvcHRpb24uICBJZiB5b3VyIG9wdGlvbiB2YWx1ZXMgaGFwcGVuIHRvIGJlIG9iamVjdHMgKGFuZCB5b3UnZCBsaWtlIHRvIHNhdmUgdGhlXG4gICAgICogc2VsZWN0aW9uIGluIHlvdXIgZm9ybSBhcyBhbiBvYmplY3QpLCB1c2UgYG5nVmFsdWVgIGluc3RlYWQ6XG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2VsZWN0Q29udHJvbC9zZWxlY3RfY29udHJvbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEluIHJlYWN0aXZlIGZvcm1zLCB5b3UnbGwgYWxzbyB3YW50IHRvIGFkZCB5b3VyIGZvcm0gZGlyZWN0aXZlIChgZm9ybUNvbnRyb2xOYW1lYCBvclxuICAgICAqIGBmb3JtQ29udHJvbGApIG9uIHRoZSBtYWluIGA8c2VsZWN0PmAgdGFnLiBMaWtlIGluIHRoZSBmb3JtZXIgZXhhbXBsZSwgeW91IGhhdmUgdGhlXG4gICAgICogY2hvaWNlIG9mIGJpbmRpbmcgdG8gdGhlICBgdmFsdWVgIG9yIGBuZ1ZhbHVlYCBwcm9wZXJ0eSBvbiB0aGUgc2VsZWN0J3Mgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9yZWFjdGl2ZVNlbGVjdENvbnRyb2wvcmVhY3RpdmVfc2VsZWN0X2NvbnRyb2xfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBOb3RlOiBXZSBsaXN0ZW4gdG8gdGhlICdjaGFuZ2UnIGV2ZW50IGJlY2F1c2UgJ2lucHV0JyBldmVudHMgYXJlbid0IGZpcmVkXG4gICAgICogZm9yIHNlbGVjdHMgaW4gRmlyZWZveCBhbmQgSUU6XG4gICAgICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTAyNDM1MFxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzQ2NjAwNDUvXG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZVN0cmluZyA9IF9idWlsZFZhbHVlU3RyaW5nKHRoaXMuX2dldE9wdGlvbklkKHZhbHVlKSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWVTdHJpbmcpO1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlU3RyaW5nO1xuICAgICAgICAgICAgICAgIGZuKF90aGlzLl9nZXRPcHRpb25WYWx1ZSh2YWx1ZVN0cmluZykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fcmVnaXN0ZXJPcHRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5faWRDb3VudGVyKyspLnRvU3RyaW5nKCk7IH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25JZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IEFycmF5LmZyb20odGhpcy5fb3B0aW9uTWFwLmtleXMoKSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChsb29zZUlkZW50aWNhbCh0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKSwgdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2dldE9wdGlvblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfZXh0cmFjdElkKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25NYXAuaGFzKGlkKSA/IHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpIDogdmFsdWVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWxlY3Q6bm90KFttdWx0aXBsZV0pW2Zvcm1Db250cm9sTmFtZV0sc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtmb3JtQ29udHJvbF0sc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtTRUxFQ1RfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgTWFya3MgYDxvcHRpb24+YCBhcyBkeW5hbWljLCBzbyBBbmd1bGFyIGNhbiBiZSBub3RpZmllZCB3aGVuIG9wdGlvbnMgY2hhbmdlLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBTZWUgZG9jcyBmb3Ige0BsaW5rIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yfSBmb3IgdXNhZ2UgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU2VsZWN0T3B0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdTZWxlY3RPcHRpb24oX2VsZW1lbnQsIF9yZW5kZXJlciwgX3NlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3QgPSBfc2VsZWN0O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdClcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5fc2VsZWN0Ll9yZWdpc3Rlck9wdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1NlbGVjdE9wdGlvbi5wcm90b3R5cGUsIFwibmdWYWx1ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLnNldCh0aGlzLmlkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLl9zZXRFbGVtZW50VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdvcHRpb24nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdTZWxlY3RPcHRpb24uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25nVmFsdWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nVmFsdWUnLF0gfSxdLFxuICAgICAgICAgICAgJ3ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyd2YWx1ZScsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ1NlbGVjdE9wdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFNFTEVDVF9NVUxUSVBMRV9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBfYnVpbGRWYWx1ZVN0cmluZyQxKGlkLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaWQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdmFsdWUgPSBcIidcIiArIHZhbHVlICsgXCInXCI7XG4gICAgICAgIGlmICghaXNQcmltaXRpdmUodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSAnT2JqZWN0JztcbiAgICAgICAgcmV0dXJuIChpZCArIFwiOiBcIiArIHZhbHVlKS5zbGljZSgwLCA1MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9leHRyYWN0SWQkMSh2YWx1ZVN0cmluZykge1xuICAgICAgICByZXR1cm4gdmFsdWVTdHJpbmcuc3BsaXQoJzonKVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIG9uIGEgc2VsZWN0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdmFsdWVzIHRvIGlkc1xuICAgICAgICAgICAgdmFyIGlkcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLl9nZXRPcHRpb25JZCh2KTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYXAuZm9yRWFjaChmdW5jdGlvbiAob3B0LCBvKSB7IG9wdC5fc2V0U2VsZWN0ZWQoaWRzLmluZGV4T2Yoby50b1N0cmluZygpKSA+IC0xKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoXy5oYXNPd25Qcm9wZXJ0eSgnc2VsZWN0ZWRPcHRpb25zJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfLnNlbGVjdGVkT3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0gb3B0aW9ucy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF90aGlzLl9nZXRPcHRpb25WYWx1ZShvcHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF8ub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0gb3B0aW9ucy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfdGhpcy5fZ2V0T3B0aW9uVmFsdWUob3B0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm4oc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fcmVnaXN0ZXJPcHRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9ICh0aGlzLl9pZENvdW50ZXIrKykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hcC5zZXQoaWQsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fZ2V0T3B0aW9uSWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBBcnJheS5mcm9tKHRoaXMuX29wdGlvbk1hcC5rZXlzKCkpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAobG9vc2VJZGVudGljYWwodGhpcy5fb3B0aW9uTWFwLmdldChpZCkuX3ZhbHVlLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZVN0cmluZykge1xuICAgICAgICAgICAgdmFyIGlkID0gX2V4dHJhY3RJZCQxKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25NYXAuaGFzKGlkKSA/IHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpLl92YWx1ZSA6IHZhbHVlU3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWxlY3RbbXVsdGlwbGVdW2Zvcm1Db250cm9sTmFtZV0sc2VsZWN0W211bHRpcGxlXVtmb3JtQ29udHJvbF0sc2VsZWN0W211bHRpcGxlXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0KScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtTRUxFQ1RfTVVMVElQTEVfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIE1hcmtzIGA8b3B0aW9uPmAgYXMgZHluYW1pYywgc28gQW5ndWxhciBjYW4gYmUgbm90aWZpZWQgd2hlbiBvcHRpb25zIGNoYW5nZS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8c2VsZWN0IG11bHRpcGxlIG5hbWU9XCJjaXR5XCIgbmdNb2RlbD5cbiAgICAgKiAgIDxvcHRpb24gKm5nRm9yPVwibGV0IGMgb2YgY2l0aWVzXCIgW3ZhbHVlXT1cImNcIj48L29wdGlvbj5cbiAgICAgKiA8L3NlbGVjdD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YXIgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24oX2VsZW1lbnQsIF9yZW5kZXJlciwgX3NlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3QgPSBfc2VsZWN0O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLl9zZWxlY3QuX3JlZ2lzdGVyT3B0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLnByb3RvdHlwZSwgXCJuZ1ZhbHVlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUoX2J1aWxkVmFsdWVTdHJpbmckMSh0aGlzLmlkLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUoX2J1aWxkVmFsdWVTdHJpbmckMSh0aGlzLmlkLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLnByb3RvdHlwZS5fc2V0RWxlbWVudFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUuX3NldFNlbGVjdGVkID0gZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ29wdGlvbicgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdWYWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdWYWx1ZScsXSB9LF0sXG4gICAgICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ3ZhbHVlJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nU2VsZWN0TXVsdGlwbGVPcHRpb247XG4gICAgfSgpKTtcblxuICAgIGZ1bmN0aW9uIGNvbnRyb2xQYXRoKG5hbWUsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LnBhdGguY29uY2F0KFtuYW1lXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFVwQ29udHJvbChjb250cm9sLCBkaXIpIHtcbiAgICAgICAgaWYgKCFjb250cm9sKVxuICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnQ2Fubm90IGZpbmQgY29udHJvbCB3aXRoJyk7XG4gICAgICAgIGlmICghZGlyLnZhbHVlQWNjZXNzb3IpXG4gICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdObyB2YWx1ZSBhY2Nlc3NvciBmb3IgZm9ybSBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgY29udHJvbC52YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW2NvbnRyb2wudmFsaWRhdG9yLCBkaXIudmFsaWRhdG9yXSk7XG4gICAgICAgIGNvbnRyb2wuYXN5bmNWYWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyhbY29udHJvbC5hc3luY1ZhbGlkYXRvciwgZGlyLmFzeW5jVmFsaWRhdG9yXSk7XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLndyaXRlVmFsdWUoY29udHJvbC52YWx1ZSk7XG4gICAgICAgIC8vIHZpZXcgLT4gbW9kZWxcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPbkNoYW5nZShmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGRpci52aWV3VG9Nb2RlbFVwZGF0ZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgICAgICBjb250cm9sLnNldFZhbHVlKG5ld1ZhbHVlLCB7IGVtaXRNb2RlbFRvVmlld0NoYW5nZTogZmFsc2UgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0b3VjaGVkXG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25Ub3VjaGVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2wubWFya0FzVG91Y2hlZCgpOyB9KTtcbiAgICAgICAgY29udHJvbC5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWx1ZSwgZW1pdE1vZGVsRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGNvbnRyb2wgLT4gdmlld1xuICAgICAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICAvLyBjb250cm9sIC0+IG5nTW9kZWxcbiAgICAgICAgICAgIGlmIChlbWl0TW9kZWxFdmVudClcbiAgICAgICAgICAgICAgICBkaXIudmlld1RvTW9kZWxVcGRhdGUobmV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpci52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2wucmVnaXN0ZXJPbkRpc2FibGVkQ2hhbmdlKGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7IGRpci52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlLXJ1biB2YWxpZGF0aW9uIHdoZW4gdmFsaWRhdG9yIGJpbmRpbmcgY2hhbmdlcywgZS5nLiBtaW5sZW5ndGg9MyAtPiBtaW5sZW5ndGg9NFxuICAgICAgICBkaXIuX3Jhd1ZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZGlyLl9yYXdBc3luY1ZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5VcENvbnRyb2woY29udHJvbCwgZGlyKSB7XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gX25vQ29udHJvbEVycm9yKGRpcik7IH0pO1xuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uVG91Y2hlZChmdW5jdGlvbiAoKSB7IHJldHVybiBfbm9Db250cm9sRXJyb3IoZGlyKTsgfSk7XG4gICAgICAgIGRpci5fcmF3VmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZGlyLl9yYXdBc3luY1ZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb250cm9sKVxuICAgICAgICAgICAgY29udHJvbC5fY2xlYXJDaGFuZ2VGbnMoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VXBGb3JtQ29udGFpbmVyKGNvbnRyb2wsIGRpcikge1xuICAgICAgICBpZiAoaXNCbGFuayhjb250cm9sKSlcbiAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ0Nhbm5vdCBmaW5kIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICBjb250cm9sLnZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbY29udHJvbC52YWxpZGF0b3IsIGRpci52YWxpZGF0b3JdKTtcbiAgICAgICAgY29udHJvbC5hc3luY1ZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKFtjb250cm9sLmFzeW5jVmFsaWRhdG9yLCBkaXIuYXN5bmNWYWxpZGF0b3JdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX25vQ29udHJvbEVycm9yKGRpcikge1xuICAgICAgICByZXR1cm4gX3Rocm93RXJyb3IoZGlyLCAnVGhlcmUgaXMgbm8gRm9ybUNvbnRyb2wgaW5zdGFuY2UgYXR0YWNoZWQgdG8gZm9ybSBjb250cm9sIGVsZW1lbnQgd2l0aCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfdGhyb3dFcnJvcihkaXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VFbmQ7XG4gICAgICAgIGlmIChkaXIucGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtZXNzYWdlRW5kID0gXCJwYXRoOiAnXCIgKyBkaXIucGF0aC5qb2luKCcgLT4gJykgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXIucGF0aFswXSkge1xuICAgICAgICAgICAgbWVzc2FnZUVuZCA9IFwibmFtZTogJ1wiICsgZGlyLnBhdGggKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFbmQgPSAndW5zcGVjaWZpZWQgbmFtZSBhdHRyaWJ1dGUnO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlICsgXCIgXCIgKyBtZXNzYWdlRW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcG9zZVZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHZhbGlkYXRvcnMpID8gVmFsaWRhdG9ycy5jb21wb3NlKHZhbGlkYXRvcnMubWFwKG5vcm1hbGl6ZVZhbGlkYXRvcikpIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodmFsaWRhdG9ycykgPyBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyh2YWxpZGF0b3JzLm1hcChub3JtYWxpemVBc3luY1ZhbGlkYXRvcikpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHZpZXdNb2RlbCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ21vZGVsJykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzWydtb2RlbCddO1xuICAgICAgICBpZiAoY2hhbmdlLmlzRmlyc3RDaGFuZ2UoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gIWxvb3NlSWRlbnRpY2FsKHZpZXdNb2RlbCwgY2hhbmdlLmN1cnJlbnRWYWx1ZSk7XG4gICAgfVxuICAgIHZhciBCVUlMVElOX0FDQ0VTU09SUyA9IFtcbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICBdO1xuICAgIGZ1bmN0aW9uIGlzQnVpbHRJbkFjY2Vzc29yKHZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIEJVSUxUSU5fQUNDRVNTT1JTLnNvbWUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHZhbHVlQWNjZXNzb3IuY29uc3RydWN0b3IgPT09IGE7IH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiB2c2F2a2luIHJlbW92ZSBpdCBvbmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzMwMTEgaXMgaW1wbGVtZW50ZWRcbiAgICBmdW5jdGlvbiBzZWxlY3RWYWx1ZUFjY2Vzc29yKGRpciwgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgaWYgKCF2YWx1ZUFjY2Vzc29ycylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgZGVmYXVsdEFjY2Vzc29yO1xuICAgICAgICB2YXIgYnVpbHRpbkFjY2Vzc29yO1xuICAgICAgICB2YXIgY3VzdG9tQWNjZXNzb3I7XG4gICAgICAgIHZhbHVlQWNjZXNzb3JzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh2LmNvbnN0cnVjdG9yID09PSBEZWZhdWx0VmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRBY2Nlc3NvciA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0J1aWx0SW5BY2Nlc3Nvcih2KSkge1xuICAgICAgICAgICAgICAgIGlmIChidWlsdGluQWNjZXNzb3IpXG4gICAgICAgICAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ01vcmUgdGhhbiBvbmUgYnVpbHQtaW4gdmFsdWUgYWNjZXNzb3IgbWF0Y2hlcyBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICAgICAgICAgIGJ1aWx0aW5BY2Nlc3NvciA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQWNjZXNzb3IpXG4gICAgICAgICAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ01vcmUgdGhhbiBvbmUgY3VzdG9tIHZhbHVlIGFjY2Vzc29yIG1hdGNoZXMgZm9ybSBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgICAgICAgICBjdXN0b21BY2Nlc3NvciA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3VzdG9tQWNjZXNzb3IpXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tQWNjZXNzb3I7XG4gICAgICAgIGlmIChidWlsdGluQWNjZXNzb3IpXG4gICAgICAgICAgICByZXR1cm4gYnVpbHRpbkFjY2Vzc29yO1xuICAgICAgICBpZiAoZGVmYXVsdEFjY2Vzc29yKVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRBY2Nlc3NvcjtcbiAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnTm8gdmFsaWQgdmFsdWUgYWNjZXNzb3IgZm9yIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGJhc2UgY2xhc3MgZm9yIGNvZGUgc2hhcmVkIGJldHdlZW4ge0BsaW5rIE5nTW9kZWxHcm91cH0gYW5kIHtAbGluayBGb3JtR3JvdXBOYW1lfS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkRm9ybUdyb3VwKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUZvcm1Hcm91cCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSB7QGxpbmsgRm9ybUdyb3VwfSBiYWNraW5nIHRoaXMgYmluZGluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm1EaXJlY3RpdmUuZ2V0Rm9ybUdyb3VwKHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBwYXRoIHRvIHRoaXMgY29udHJvbCBncm91cC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sUGF0aCh0aGlzLm5hbWUsIHRoaXMuX3BhcmVudCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHtAbGluayBGb3JtfSB0byB3aGljaCB0aGlzIGdyb3VwIGJlbG9uZ3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl92YWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX2FzeW5jVmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5fY2hlY2tQYXJlbnRUeXBlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgfShDb250cm9sQ29udGFpbmVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIEFic3RyYWN0Q29udHJvbFN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0Q29udHJvbFN0YXR1cyhjZCkge1xuICAgICAgICAgICAgdGhpcy5fY2QgPSBjZDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzVW50b3VjaGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wudW50b3VjaGVkIDogZmFsc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzVG91Y2hlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NkLmNvbnRyb2wgPyB0aGlzLl9jZC5jb250cm9sLnRvdWNoZWQgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NQcmlzdGluZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NkLmNvbnRyb2wgPyB0aGlzLl9jZC5jb250cm9sLnByaXN0aW5lIDogZmFsc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzRGlydHlcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC5kaXJ0eSA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1ZhbGlkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wudmFsaWQgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NJbnZhbGlkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wuaW52YWxpZCA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1BlbmRpbmdcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC5wZW5kaW5nIDogZmFsc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sU3RhdHVzO1xuICAgIH0oKSk7XG4gICAgdmFyIG5nQ29udHJvbFN0YXR1c0hvc3QgPSB7XG4gICAgICAgICdbY2xhc3MubmctdW50b3VjaGVkXSc6ICduZ0NsYXNzVW50b3VjaGVkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy10b3VjaGVkXSc6ICduZ0NsYXNzVG91Y2hlZCcsXG4gICAgICAgICdbY2xhc3MubmctcHJpc3RpbmVdJzogJ25nQ2xhc3NQcmlzdGluZScsXG4gICAgICAgICdbY2xhc3MubmctZGlydHldJzogJ25nQ2xhc3NEaXJ0eScsXG4gICAgICAgICdbY2xhc3MubmctdmFsaWRdJzogJ25nQ2xhc3NWYWxpZCcsXG4gICAgICAgICdbY2xhc3MubmctaW52YWxpZF0nOiAnbmdDbGFzc0ludmFsaWQnLFxuICAgICAgICAnW2NsYXNzLm5nLXBlbmRpbmddJzogJ25nQ2xhc3NQZW5kaW5nJyxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpcmVjdGl2ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gQW5ndWxhciBmb3JtIGNvbnRyb2xzIHRoYXQgc2V0cyBDU1MgY2xhc3Nlc1xuICAgICAqIGJhc2VkIG9uIGNvbnRyb2wgc3RhdHVzICh2YWxpZC9pbnZhbGlkL2RpcnR5L2V0YykuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nQ29udHJvbFN0YXR1cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQzKE5nQ29udHJvbFN0YXR1cywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdDb250cm9sU3RhdHVzKGNkKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjZCk7XG4gICAgICAgIH1cbiAgICAgICAgTmdDb250cm9sU3RhdHVzLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQ29udHJvbE5hbWVdLFtuZ01vZGVsXSxbZm9ybUNvbnRyb2xdJywgaG9zdDogbmdDb250cm9sU3RhdHVzSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nQ29udHJvbFN0YXR1cy5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBOZ0NvbnRyb2xTdGF0dXM7XG4gICAgfShBYnN0cmFjdENvbnRyb2xTdGF0dXMpKTtcbiAgICAvKipcbiAgICAgKiBEaXJlY3RpdmUgYXV0b21hdGljYWxseSBhcHBsaWVkIHRvIEFuZ3VsYXIgZm9ybSBncm91cHMgdGhhdCBzZXRzIENTUyBjbGFzc2VzXG4gICAgICogYmFzZWQgb24gY29udHJvbCBzdGF0dXMgKHZhbGlkL2ludmFsaWQvZGlydHkvZXRjKS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdDb250cm9sU3RhdHVzR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhOZ0NvbnRyb2xTdGF0dXNHcm91cCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdDb250cm9sU3RhdHVzR3JvdXAoY2QpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNkKTtcbiAgICAgICAgfVxuICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cE5hbWVdLFtmb3JtQXJyYXlOYW1lXSxbbmdNb2RlbEdyb3VwXSxbZm9ybUdyb3VwXSxmb3JtOm5vdChbbmdOb0Zvcm1dKSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBuZ0NvbnRyb2xTdGF0dXNIb3N0XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdDb250cm9sU3RhdHVzR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nQ29udHJvbFN0YXR1c0dyb3VwO1xuICAgIH0oQWJzdHJhY3RDb250cm9sU3RhdHVzKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlIGJ5IGRpcmVjdGl2ZXMgYW5kIGNvbXBvbmVudHMgdG8gZW1pdCBjdXN0b20gRXZlbnRzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVzXG4gICAgICpcbiAgICAgKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIGBaaXBweWAgYWx0ZXJuYXRpdmVseSBlbWl0cyBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIHdoZW4gaXRzXG4gICAgICogdGl0bGUgZ2V0cyBjbGlja2VkOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ3ppcHB5JyxcbiAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICogICA8ZGl2IGNsYXNzPVwiemlwcHlcIj5cbiAgICAgKiAgICAgPGRpdiAoY2xpY2spPVwidG9nZ2xlKClcIj5Ub2dnbGU8L2Rpdj5cbiAgICAgKiAgICAgPGRpdiBbaGlkZGVuXT1cIiF2aXNpYmxlXCI+XG4gICAgICogICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgPC9kaXY+YH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFppcHB5IHtcbiAgICAgKiAgIHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAqICAgQE91dHB1dCgpIG9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAqICAgQE91dHB1dCgpIGNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgKlxuICAgICAqICAgdG9nZ2xlKCkge1xuICAgICAqICAgICB0aGlzLnZpc2libGUgPSAhdGhpcy52aXNpYmxlO1xuICAgICAqICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICogICAgICAgdGhpcy5vcGVuLmVtaXQobnVsbCk7XG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgdGhpcy5jbG9zZS5lbWl0KG51bGwpO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlIGV2ZW50cyBwYXlsb2FkIGNhbiBiZSBhY2Nlc3NlZCBieSB0aGUgcGFyYW1ldGVyIGAkZXZlbnRgIG9uIHRoZSBjb21wb25lbnRzIG91dHB1dCBldmVudFxuICAgICAqIGhhbmRsZXI6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8emlwcHkgKG9wZW4pPVwib25PcGVuKCRldmVudClcIiAoY2xvc2UpPVwib25DbG9zZSgkZXZlbnQpXCI+PC96aXBweT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFVzZXMgUnguT2JzZXJ2YWJsZSBidXQgcHJvdmlkZXMgYW4gYWRhcHRlciB0byBtYWtlIGl0IHdvcmsgYXMgc3BlY2lmaWVkIGhlcmU6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2podXNhaW4vb2JzZXJ2YWJsZS1zcGVjXG4gICAgICpcbiAgICAgKiBPbmNlIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzcGVjIGlzIGF2YWlsYWJsZSwgc3dpdGNoIHRvIGl0LlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDUoRXZlbnRFbWl0dGVyLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBbRXZlbnRFbWl0dGVyXSwgd2hpY2ggZGVwZW5kaW5nIG9uIFtpc0FzeW5jXSxcbiAgICAgICAgICogZGVsaXZlcnMgZXZlbnRzIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoaXNBc3luYykge1xuICAgICAgICAgICAgaWYgKGlzQXN5bmMgPT09IHZvaWQgMCkgeyBpc0FzeW5jID0gZmFsc2U7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPSBpc0FzeW5jO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7IH07XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGdlbmVyYXRvck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICB2YXIgc2NoZWR1bGVyRm47XG4gICAgICAgICAgICB2YXIgZXJyb3JGbiA9IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICB2YXIgY29tcGxldGVGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0ICYmIHR5cGVvZiBnZW5lcmF0b3JPck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICh2YWx1ZSkgeyBnZW5lcmF0b3JPck5leHQubmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHsgZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAodmFsdWUpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckZuID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKGVycikgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yKGVycik7IH0pOyB9IDogZnVuY3Rpb24gKGVycikgeyBlcnJvcihlcnIpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICgpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wbGV0ZSgpOyB9KTsgfSA6IGZ1bmN0aW9uICgpIHsgY29tcGxldGUoKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zdWJzY3JpYmUuY2FsbCh0aGlzLCBzY2hlZHVsZXJGbiwgZXJyb3JGbiwgY29tcGxldGVGbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfShyeGpzX1N1YmplY3QuU3ViamVjdCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgRm9ybUNvbnRyb2wgaXMgdmFsaWQsIGkuZS4gdGhhdCBubyBlcnJvcnMgZXhpc3QgaW4gdGhlIGlucHV0IHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBWQUxJRCA9ICdWQUxJRCc7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBGb3JtQ29udHJvbCBpcyBpbnZhbGlkLCBpLmUuIHRoYXQgYW4gZXJyb3IgZXhpc3RzIGluIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgSU5WQUxJRCA9ICdJTlZBTElEJztcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIEZvcm1Db250cm9sIGlzIHBlbmRpbmcsIGkuZS4gdGhhdCBhc3luYyB2YWxpZGF0aW9uIGlzIG9jY3VycmluZyBhbmRcbiAgICAgKiBlcnJvcnMgYXJlIG5vdCB5ZXQgYXZhaWxhYmxlIGZvciB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIFBFTkRJTkcgPSAnUEVORElORyc7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBGb3JtQ29udHJvbCBpcyBkaXNhYmxlZCwgaS5lLiB0aGF0IHRoZSBjb250cm9sIGlzIGV4ZW1wdCBmcm9tIGFuY2VzdG9yXG4gICAgICogY2FsY3VsYXRpb25zIG9mIHZhbGlkaXR5IG9yIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBESVNBQkxFRCA9ICdESVNBQkxFRCc7XG4gICAgZnVuY3Rpb24gX2ZpbmQoY29udHJvbCwgcGF0aCwgZGVsaW1pdGVyKSB7XG4gICAgICAgIGlmIChwYXRoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoZGVsaW1pdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCBpbnN0YW5jZW9mIEFycmF5ICYmIChwYXRoLmxlbmd0aCA9PT0gMCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uICh2LCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIEZvcm1Hcm91cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2LmNvbnRyb2xzW25hbWVdIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIEZvcm1BcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2LmF0KG5hbWUpIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgY29udHJvbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvT2JzZXJ2YWJsZShyKSB7XG4gICAgICAgIHJldHVybiBpc1Byb21pc2UocikgPyByeGpzX29ic2VydmFibGVfZnJvbVByb21pc2UuZnJvbVByb21pc2UocikgOiByO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2VyY2VUb1ZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsaWRhdG9yKSA/IGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcikgOiB2YWxpZGF0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvZXJjZVRvQXN5bmNWYWxpZGF0b3IoYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXN5bmNWYWxpZGF0b3IpID8gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcikgOiBhc3luY1ZhbGlkYXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3Ige0BsaW5rIEZvcm1Db250cm9sfSwge0BsaW5rIEZvcm1Hcm91cH0sIGFuZFxuICAgICAqIHtAbGluayBGb3JtQXJyYXl9LlxuICAgICAqXG4gICAgICogSXQgcHJvdmlkZXMgc29tZSBvZiB0aGUgc2hhcmVkIGJlaGF2aW9yIHRoYXQgYWxsIGNvbnRyb2xzIGFuZCBncm91cHMgb2YgY29udHJvbHMgaGF2ZSwgbGlrZVxuICAgICAqIHJ1bm5pbmcgdmFsaWRhdG9ycywgY2FsY3VsYXRpbmcgc3RhdHVzLCBhbmQgcmVzZXR0aW5nIHN0YXRlLiBJdCBhbHNvIGRlZmluZXMgdGhlIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IGFyZSBzaGFyZWQgYmV0d2VlbiBhbGwgc3ViLWNsYXNzZXMsIGxpa2UgYHZhbHVlYCwgYHZhbGlkYCwgYW5kIGBkaXJ0eWAuIEl0IHNob3VsZG4ndCBiZVxuICAgICAqIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RDb250cm9sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWJzdHJhY3RDb250cm9sKHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gdmFsaWRhdG9yO1xuICAgICAgICAgICAgdGhpcy5hc3luY1ZhbGlkYXRvciA9IGFzeW5jVmFsaWRhdG9yO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHBhcmVudCBjb250cm9sLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbC4gVGhlcmUgYXJlIGZvdXIgcG9zc2libGVcbiAgICAgICAgICAgICAqIHZhbGlkYXRpb24gc3RhdHVzZXM6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKiAqKlZBTElEKio6ICBjb250cm9sIGhhcyBwYXNzZWQgYWxsIHZhbGlkYXRpb24gY2hlY2tzXG4gICAgICAgICAgICAgKiAqICoqSU5WQUxJRCoqOiBjb250cm9sIGhhcyBmYWlsZWQgYXQgbGVhc3Qgb25lIHZhbGlkYXRpb24gY2hlY2tcbiAgICAgICAgICAgICAqICogKipQRU5ESU5HKio6IGNvbnRyb2wgaXMgaW4gdGhlIG1pZHN0IG9mIGNvbmR1Y3RpbmcgYSB2YWxpZGF0aW9uIGNoZWNrXG4gICAgICAgICAgICAgKiAqICoqRElTQUJMRUQqKjogY29udHJvbCBpcyBleGVtcHQgZnJvbSB2YWxpZGF0aW9uIGNoZWNrc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZXNlIHN0YXR1c2VzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIGEgY29udHJvbCBjYW5ub3QgYmVcbiAgICAgICAgICAgICAqIGJvdGggdmFsaWQgQU5EIGludmFsaWQgb3IgaW52YWxpZCBBTkQgZGlzYWJsZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidmFsaWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYHZhbGlkYCB3aGVuIGl0cyBgc3RhdHVzID09PSBWQUxJRGAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3JkZXIgdG8gaGF2ZSB0aGlzIHN0YXR1cywgdGhlIGNvbnRyb2wgbXVzdCBoYXZlIHBhc3NlZCBhbGwgaXRzXG4gICAgICAgICAgICAgKiB2YWxpZGF0aW9uIGNoZWNrcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IFZBTElEOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiaW52YWxpZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgaW52YWxpZGAgd2hlbiBpdHMgYHN0YXR1cyA9PT0gSU5WQUxJRGAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3JkZXIgdG8gaGF2ZSB0aGlzIHN0YXR1cywgdGhlIGNvbnRyb2wgbXVzdCBoYXZlIGZhaWxlZFxuICAgICAgICAgICAgICogYXQgbGVhc3Qgb25lIG9mIGl0cyB2YWxpZGF0aW9uIGNoZWNrcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IElOVkFMSUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJwZW5kaW5nXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBwZW5kaW5nYCB3aGVuIGl0cyBgc3RhdHVzID09PSBQRU5ESU5HYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvcmRlciB0byBoYXZlIHRoaXMgc3RhdHVzLCB0aGUgY29udHJvbCBtdXN0IGJlIGluIHRoZVxuICAgICAgICAgICAgICogbWlkZGxlIG9mIGNvbmR1Y3RpbmcgYSB2YWxpZGF0aW9uIGNoZWNrLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PSBQRU5ESU5HOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYGRpc2FibGVkYCB3aGVuIGl0cyBgc3RhdHVzID09PSBESVNBQkxFRGAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogRGlzYWJsZWQgY29udHJvbHMgYXJlIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAgICAgICAgICogYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgYWdncmVnYXRlIHZhbHVlIG9mIHRoZWlyIGFuY2VzdG9yXG4gICAgICAgICAgICAgKiBjb250cm9scy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IERJU0FCTEVEOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgZW5hYmxlZGAgYXMgbG9uZyBhcyBpdHMgYHN0YXR1cyAhPT0gRElTQUJMRURgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzLCBpdCBoYXMgYSBzdGF0dXMgb2YgYFZBTElEYCwgYElOVkFMSURgLCBvclxuICAgICAgICAgICAgICogYFBFTkRJTkdgLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyAhPT0gRElTQUJMRUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJlcnJvcnNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFueSBlcnJvcnMgZ2VuZXJhdGVkIGJ5IGZhaWxpbmcgdmFsaWRhdGlvbi4gSWYgdGhlcmVcbiAgICAgICAgICAgICAqIGFyZSBubyBlcnJvcnMsIGl0IHdpbGwgcmV0dXJuIG51bGwuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZXJyb3JzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicHJpc3RpbmVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYHByaXN0aW5lYCBpZiB0aGUgdXNlciBoYXMgbm90IHlldCBjaGFuZ2VkXG4gICAgICAgICAgICAgKiB0aGUgdmFsdWUgaW4gdGhlIFVJLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCBwcm9ncmFtbWF0aWMgY2hhbmdlcyB0byBhIGNvbnRyb2wncyB2YWx1ZSB3aWxsXG4gICAgICAgICAgICAgKiAqbm90KiBtYXJrIGl0IGRpcnR5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ByaXN0aW5lOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZGlydHlcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYGRpcnR5YCBpZiB0aGUgdXNlciBoYXMgY2hhbmdlZCB0aGUgdmFsdWVcbiAgICAgICAgICAgICAqIGluIHRoZSBVSS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgcHJvZ3JhbW1hdGljIGNoYW5nZXMgdG8gYSBjb250cm9sJ3MgdmFsdWUgd2lsbFxuICAgICAgICAgICAgICogKm5vdCogbWFyayBpdCBkaXJ0eS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5wcmlzdGluZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInRvdWNoZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIEEgY29udHJvbCBpcyBtYXJrZWQgYHRvdWNoZWRgIG9uY2UgdGhlIHVzZXIgaGFzIHRyaWdnZXJlZFxuICAgICAgICAgICAgKiBhIGBibHVyYCBldmVudCBvbiBpdC5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RvdWNoZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ1bnRvdWNoZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYHVudG91Y2hlZGAgaWYgdGhlIHVzZXIgaGFzIG5vdCB5ZXQgdHJpZ2dlcmVkXG4gICAgICAgICAgICAgKiBhIGBibHVyYCBldmVudCBvbiBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5fdG91Y2hlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVtaXRzIGFuIGV2ZW50IGV2ZXJ5IHRpbWUgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sIGNoYW5nZXMsIGluXG4gICAgICAgICAgICAgKiB0aGUgVUkgb3IgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZUNoYW5nZXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJzdGF0dXNDaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW1pdHMgYW4gZXZlbnQgZXZlcnkgdGltZSB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIGNvbnRyb2xcbiAgICAgICAgICAgICAqIGlzIHJlLWNhbGN1bGF0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzQ2hhbmdlczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBzeW5jaHJvbm91cyB2YWxpZGF0b3JzIHRoYXQgYXJlIGFjdGl2ZSBvbiB0aGlzIGNvbnRyb2wuICBDYWxsaW5nXG4gICAgICAgICAqIHRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIHN5bmMgdmFsaWRhdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0VmFsaWRhdG9ycyA9IGZ1bmN0aW9uIChuZXdWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gY29lcmNlVG9WYWxpZGF0b3IobmV3VmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGFzeW5jIHZhbGlkYXRvcnMgdGhhdCBhcmUgYWN0aXZlIG9uIHRoaXMgY29udHJvbC4gQ2FsbGluZyB0aGlzXG4gICAgICAgICAqIHdpbGwgb3ZlcndyaXRlIGFueSBleGlzdGluZyBhc3luYyB2YWxpZGF0b3JzLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5zZXRBc3luY1ZhbGlkYXRvcnMgPSBmdW5jdGlvbiAobmV3VmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmFzeW5jVmFsaWRhdG9yID0gY29lcmNlVG9Bc3luY1ZhbGlkYXRvcihuZXdWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1wdGllcyBvdXQgdGhlIHN5bmMgdmFsaWRhdG9yIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmNsZWFyVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHsgdGhpcy52YWxpZGF0b3IgPSBudWxsOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1wdGllcyBvdXQgdGhlIGFzeW5jIHZhbGlkYXRvciBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5jbGVhckFzeW5jVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5hc3luY1ZhbGlkYXRvciA9IG51bGw7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgdG91Y2hlZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCBhbHNvIG1hcmsgYWxsIGRpcmVjdCBhbmNlc3RvcnMgYXMgYHRvdWNoZWRgIHRvIG1haW50YWluXG4gICAgICAgICAqIHRoZSBtb2RlbC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzVG91Y2hlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQubWFya0FzVG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGB1bnRvdWNoZWRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgYW55IGNoaWxkcmVuLCBpdCB3aWxsIGFsc28gbWFyayBhbGwgY2hpbGRyZW4gYXMgYHVudG91Y2hlZGBcbiAgICAgICAgICogdG8gbWFpbnRhaW4gdGhlIG1vZGVsLCBhbmQgcmUtY2FsY3VsYXRlIHRoZSBgdG91Y2hlZGAgc3RhdHVzIG9mIGFsbCBwYXJlbnRcbiAgICAgICAgICogY29udHJvbHMuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc1VudG91Y2hlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLm1hcmtBc1VudG91Y2hlZCh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYGRpcnR5YC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB3aWxsIGFsc28gbWFyayBhbGwgZGlyZWN0IGFuY2VzdG9ycyBhcyBgZGlydHlgIHRvIG1haW50YWluXG4gICAgICAgICAqIHRoZSBtb2RlbC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzRGlydHkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9wcmlzdGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQubWFya0FzRGlydHkoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgcHJpc3RpbmVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgYW55IGNoaWxkcmVuLCBpdCB3aWxsIGFsc28gbWFyayBhbGwgY2hpbGRyZW4gYXMgYHByaXN0aW5lYFxuICAgICAgICAgKiB0byBtYWludGFpbiB0aGUgbW9kZWwsIGFuZCByZS1jYWxjdWxhdGUgdGhlIGBwcmlzdGluZWAgc3RhdHVzIG9mIGFsbCBwYXJlbnRcbiAgICAgICAgICogY29udHJvbHMuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc1ByaXN0aW5lID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7IGNvbnRyb2wubWFya0FzUHJpc3RpbmUoeyBvbmx5U2VsZjogdHJ1ZSB9KTsgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgcGVuZGluZ2AuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc1BlbmRpbmcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBQRU5ESU5HO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQubWFya0FzUGVuZGluZyh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBjb250cm9sLiBUaGlzIG1lYW5zIHRoZSBjb250cm9sIHdpbGwgYmUgZXhlbXB0IGZyb20gdmFsaWRhdGlvbiBjaGVja3MgYW5kXG4gICAgICAgICAqIGV4Y2x1ZGVkIGZyb20gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiBhbnkgcGFyZW50LiBJdHMgc3RhdHVzIGlzIGBESVNBQkxFRGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBjaGlsZHJlbiwgYWxsIGNoaWxkcmVuIHdpbGwgYmUgZGlzYWJsZWQgdG8gbWFpbnRhaW4gdGhlIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gRElTQUJMRUQ7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7IGNvbnRyb2wuZGlzYWJsZSh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoZW1pdEV2ZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlcy5lbWl0KHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzLmVtaXQodGhpcy5fc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuY2VzdG9ycyhvbmx5U2VsZik7XG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZUZuKSB7IHJldHVybiBjaGFuZ2VGbih0cnVlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzIHRoZSBjb250cm9sLiBUaGlzIG1lYW5zIHRoZSBjb250cm9sIHdpbGwgYmUgaW5jbHVkZWQgaW4gdmFsaWRhdGlvbiBjaGVja3MgYW5kXG4gICAgICAgICAqIHRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgaXRzIHBhcmVudC4gSXRzIHN0YXR1cyBpcyByZS1jYWxjdWxhdGVkIGJhc2VkIG9uIGl0cyB2YWx1ZSBhbmRcbiAgICAgICAgICogaXRzIHZhbGlkYXRvcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBjaGlsZHJlbiwgYWxsIGNoaWxkcmVuIHdpbGwgYmUgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gVkFMSUQ7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5lbmFibGUoeyBvbmx5U2VsZjogdHJ1ZSB9KTsgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBbmNlc3RvcnMob25seVNlbGYpO1xuICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2VGbikgeyByZXR1cm4gY2hhbmdlRm4oZmFsc2UpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fdXBkYXRlQW5jZXN0b3JzID0gZnVuY3Rpb24gKG9ubHlTZWxmKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVQcmlzdGluZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlVG91Y2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHsgdGhpcy5fcGFyZW50ID0gcGFyZW50OyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmUtY2FsY3VsYXRlcyB0aGUgdmFsdWUgYW5kIHZhbGlkYXRpb24gc3RhdHVzIG9mIHRoZSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGFsc28gdXBkYXRlIHRoZSB2YWx1ZSBhbmQgdmFsaWRpdHkgb2YgaXRzIGFuY2VzdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX3NldEluaXRpYWxTdGF0dXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzID0gdGhpcy5fcnVuVmFsaWRhdG9yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gdGhpcy5fY2FsY3VsYXRlU3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gVkFMSUQgfHwgdGhpcy5fc3RhdHVzID09PSBQRU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3J1bkFzeW5jVmFsaWRhdG9yKGVtaXRFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVtaXRFdmVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZXMuZW1pdCh0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcy5lbWl0KHRoaXMuX3N0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVUcmVlVmFsaWRpdHkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBlbWl0RXZlbnQgPSAoX2EgPT09IHZvaWQgMCA/IHsgZW1pdEV2ZW50OiB0cnVlIH0gOiBfYSkuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjdHJsKSB7IHJldHVybiBjdHJsLl91cGRhdGVUcmVlVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTsgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3NldEluaXRpYWxTdGF0dXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3N0YXR1cyA9IHRoaXMuX2FsbENvbnRyb2xzRGlzYWJsZWQoKSA/IERJU0FCTEVEIDogVkFMSUQ7IH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3J1blZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRvciA/IHRoaXMudmFsaWRhdG9yKHRoaXMpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fcnVuQXN5bmNWYWxpZGF0b3IgPSBmdW5jdGlvbiAoZW1pdEV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBQRU5ESU5HO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbEV4aXN0aW5nU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9icyA9IHRvT2JzZXJ2YWJsZSh0aGlzLmFzeW5jVmFsaWRhdG9yKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24gPVxuICAgICAgICAgICAgICAgICAgICBvYnMuc3Vic2NyaWJlKHsgbmV4dDogZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX3RoaXMuc2V0RXJyb3JzKHJlcywgeyBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTsgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fY2FuY2VsRXhpc3RpbmdTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXN5bmNWYWxpZGF0aW9uU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGVycm9ycyBvbiBhIGZvcm0gY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyB1c2VkIHdoZW4gdmFsaWRhdGlvbnMgYXJlIHJ1biBtYW51YWxseSBieSB0aGUgdXNlciwgcmF0aGVyIHRoYW4gYXV0b21hdGljYWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2FsbGluZyBgc2V0RXJyb3JzYCB3aWxsIGFsc28gdXBkYXRlIHRoZSB2YWxpZGl0eSBvZiB0aGUgcGFyZW50IGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBjb25zdCBsb2dpbiA9IG5ldyBGb3JtQ29udHJvbChcInNvbWVMb2dpblwiKTtcbiAgICAgICAgICogbG9naW4uc2V0RXJyb3JzKHtcbiAgICAgICAgICogICBcIm5vdFVuaXF1ZVwiOiB0cnVlXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QobG9naW4udmFsaWQpLnRvRXF1YWwoZmFsc2UpO1xuICAgICAgICAgKiBleHBlY3QobG9naW4uZXJyb3JzKS50b0VxdWFsKHtcIm5vdFVuaXF1ZVwiOiB0cnVlfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGxvZ2luLnNldFZhbHVlKFwic29tZU90aGVyTG9naW5cIik7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChsb2dpbi52YWxpZCkudG9FcXVhbCh0cnVlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldEVycm9ycyA9IGZ1bmN0aW9uIChlcnJvcnMsIF9hKSB7XG4gICAgICAgICAgICB2YXIgZW1pdEV2ZW50ID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb250cm9sc0Vycm9ycyhlbWl0RXZlbnQgIT09IGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhIGNoaWxkIGNvbnRyb2wgZ2l2ZW4gdGhlIGNvbnRyb2wncyBuYW1lIG9yIHBhdGguXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhdGhzIGNhbiBiZSBwYXNzZWQgaW4gYXMgYW4gYXJyYXkgb3IgYSBzdHJpbmcgZGVsaW1pdGVkIGJ5IGEgZG90LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBnZXQgYSBjb250cm9sIG5lc3RlZCB3aXRoaW4gYSBgcGVyc29uYCBzdWItZ3JvdXA6XG4gICAgICAgICAqXG4gICAgICAgICAqICogYHRoaXMuZm9ybS5nZXQoJ3BlcnNvbi5uYW1lJyk7YFxuICAgICAgICAgKlxuICAgICAgICAgKiAtT1ItXG4gICAgICAgICAqXG4gICAgICAgICAqICogYHRoaXMuZm9ybS5nZXQoWydwZXJzb24nLCAnbmFtZSddKTtgXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBfZmluZCh0aGlzLCBwYXRoLCAnLicpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGggaGFzIHRoZSBlcnJvciBzcGVjaWZpZWQuIE90aGVyd2lzZVxuICAgICAgICAgKiByZXR1cm5zIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBubyBwYXRoIGlzIGdpdmVuLCBpdCBjaGVja3MgZm9yIHRoZSBlcnJvciBvbiB0aGUgcHJlc2VudCBjb250cm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5nZXRFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBjb250cm9sID0gcGF0aCA/IHRoaXMuZ2V0KHBhdGgpIDogdGhpcztcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sICYmIGNvbnRyb2wuX2Vycm9ycyA/IGNvbnRyb2wuX2Vycm9yc1tlcnJvckNvZGVdIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBwYXRoIGhhcyB0aGUgZXJyb3Igc3BlY2lmaWVkLiBPdGhlcndpc2VcbiAgICAgICAgICogcmV0dXJucyBmYWxzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbm8gcGF0aCBpcyBnaXZlbiwgaXQgY2hlY2tzIGZvciB0aGUgZXJyb3Igb24gdGhlIHByZXNlbnQgY29udHJvbC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuaGFzRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmdldEVycm9yKGVycm9yQ29kZSwgcGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInJvb3RcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIHRvcC1sZXZlbCBhbmNlc3RvciBvZiB0aGlzIGNvbnRyb2wuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcztcbiAgICAgICAgICAgICAgICB3aGlsZSAoeC5fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4Ll9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fdXBkYXRlQ29udHJvbHNFcnJvcnMgPSBmdW5jdGlvbiAoZW1pdEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSB0aGlzLl9jYWxjdWxhdGVTdGF0dXMoKTtcbiAgICAgICAgICAgIGlmIChlbWl0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzLmVtaXQodGhpcy5fc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZUNvbnRyb2xzRXJyb3JzKGVtaXRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5faW5pdE9ic2VydmFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fY2FsY3VsYXRlU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FsbENvbnRyb2xzRGlzYWJsZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRElTQUJMRUQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3JzKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyhQRU5ESU5HKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUEVORElORztcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbnlDb250cm9sc0hhdmVTdGF0dXMoSU5WQUxJRCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICByZXR1cm4gVkFMSUQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fYW55Q29udHJvbHNIYXZlU3RhdHVzID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FueUNvbnRyb2xzKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLnN0YXR1cyA9PT0gc3RhdHVzOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9sc0RpcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FueUNvbnRyb2xzKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLmRpcnR5OyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9sc1RvdWNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW55Q29udHJvbHMoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wudG91Y2hlZDsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fdXBkYXRlUHJpc3RpbmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9wcmlzdGluZSA9ICF0aGlzLl9hbnlDb250cm9sc0RpcnR5KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fdXBkYXRlVG91Y2hlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoZWQgPSB0aGlzLl9hbnlDb250cm9sc1RvdWNoZWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2lzQm94ZWRWYWx1ZSA9IGZ1bmN0aW9uIChmb3JtU3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybVN0YXRlID09PSAnb2JqZWN0JyAmJiBmb3JtU3RhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmxlbmd0aCA9PT0gMiAmJiAndmFsdWUnIGluIGZvcm1TdGF0ZSAmJiAnZGlzYWJsZWQnIGluIGZvcm1TdGF0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Q29udHJvbDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkYXRpb24gc3RhdHVzIG9mIGFuIGluZGl2aWR1YWwgZm9ybSBjb250cm9sLlxuICAgICAqXG4gICAgICogSXQgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3Mgb2YgQW5ndWxhciBmb3JtcywgYWxvbmcgd2l0aFxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9IGFuZCB7QGxpbmsgRm9ybUFycmF5fS5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogV2hlbiBpbnN0YW50aWF0aW5nIGEge0BsaW5rIEZvcm1Db250cm9sfSwgeW91IGNhbiBwYXNzIGluIGFuIGluaXRpYWwgdmFsdWUgYXMgdGhlXG4gICAgICogZmlyc3QgYXJndW1lbnQuIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGN0cmwgPSBuZXcgRm9ybUNvbnRyb2woJ3NvbWUgdmFsdWUnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnZhbHVlKTsgICAgIC8vICdzb21lIHZhbHVlJ1xuICAgICAqYGBgXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gaW5pdGlhbGl6ZSB0aGUgY29udHJvbCB3aXRoIGEgZm9ybSBzdGF0ZSBvYmplY3Qgb24gaW5zdGFudGlhdGlvbixcbiAgICAgKiB3aGljaCBpbmNsdWRlcyBib3RoIHRoZSB2YWx1ZSBhbmQgd2hldGhlciBvciBub3QgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQuXG4gICAgICogWW91IGNhbid0IHVzZSB0aGUgdmFsdWUga2V5IHdpdGhvdXQgdGhlIGRpc2FibGVkIGtleTsgYm90aCBhcmUgcmVxdWlyZWRcbiAgICAgKiB0byB1c2UgdGhpcyB3YXkgb2YgaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGN0cmwgPSBuZXcgRm9ybUNvbnRyb2woe3ZhbHVlOiAnbi9hJywgZGlzYWJsZWQ6IHRydWV9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnZhbHVlKTsgICAgIC8vICduL2EnXG4gICAgICogY29uc29sZS5sb2coY3RybC5zdGF0dXMpOyAgIC8vICdESVNBQkxFRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRvIGluY2x1ZGUgYSBzeW5jIHZhbGlkYXRvciAob3IgYW4gYXJyYXkgb2Ygc3luYyB2YWxpZGF0b3JzKSB3aXRoIHRoZSBjb250cm9sLFxuICAgICAqIHBhc3MgaXQgaW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudC4gQXN5bmMgdmFsaWRhdG9ycyBhcmUgYWxzbyBzdXBwb3J0ZWQsIGJ1dFxuICAgICAqIGhhdmUgdG8gYmUgcGFzc2VkIGluIHNlcGFyYXRlbHkgYXMgdGhlIHRoaXJkIGFyZy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICogY29uc29sZS5sb2coY3RybC52YWx1ZSk7ICAgICAvLyAnJ1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwuc3RhdHVzKTsgICAvLyAnSU5WQUxJRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSBpdHMgc3VwZXJjbGFzcywge0BsaW5rIEFic3RyYWN0Q29udHJvbH0sIGZvciBtb3JlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQ29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KEZvcm1Db250cm9sLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtQ29udHJvbChmb3JtU3RhdGUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmIChmb3JtU3RhdGUgPT09IHZvaWQgMCkgeyBmb3JtU3RhdGUgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjb2VyY2VUb1ZhbGlkYXRvcih2YWxpZGF0b3IpLCBjb2VyY2VUb0FzeW5jVmFsaWRhdG9yKGFzeW5jVmFsaWRhdG9yKSk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlGb3JtU3RhdGUoZm9ybVN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIGZvcm0gY29udHJvbCB0byBgdmFsdWVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgb25seVNlbGZgIGlzIGB0cnVlYCwgdGhpcyBjaGFuZ2Ugd2lsbCBvbmx5IGFmZmVjdCB0aGUgdmFsaWRhdGlvbiBvZiB0aGlzIGBGb3JtQ29udHJvbGBcbiAgICAgICAgICogYW5kIG5vdCBpdHMgcGFyZW50IGNvbXBvbmVudC4gVGhpcyBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGVtaXRFdmVudGAgaXMgYHRydWVgLCB0aGlzXG4gICAgICAgICAqIGNoYW5nZSB3aWxsIGNhdXNlIGEgYHZhbHVlQ2hhbmdlc2AgZXZlbnQgb24gdGhlIGBGb3JtQ29udHJvbGAgdG8gYmUgZW1pdHRlZC4gVGhpcyBkZWZhdWx0c1xuICAgICAgICAgKiB0byB0cnVlIChhcyBpdCBmYWxscyB0aHJvdWdoIHRvIGB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5YCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2VgIGlzIGB0cnVlYCwgdGhlIHZpZXcgd2lsbCBiZSBub3RpZmllZCBhYm91dCB0aGUgbmV3IHZhbHVlXG4gICAgICAgICAqIHZpYSBhbiBgb25DaGFuZ2VgIGV2ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlmIGBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2VgIGlzIG5vdFxuICAgICAgICAgKiBzcGVjaWZpZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBlbWl0Vmlld1RvTW9kZWxDaGFuZ2VgIGlzIGB0cnVlYCwgYW4gbmdNb2RlbENoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIHRvIHVwZGF0ZSB0aGVcbiAgICAgICAgICogbW9kZWwuICBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlmIGBlbWl0Vmlld1RvTW9kZWxDaGFuZ2VgIGlzIG5vdCBzcGVjaWZpZWQuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudCwgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlID0gX2IuZW1pdE1vZGVsVG9WaWV3Q2hhbmdlLCBlbWl0Vmlld1RvTW9kZWxDaGFuZ2UgPSBfYi5lbWl0Vmlld1RvTW9kZWxDaGFuZ2U7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlLmxlbmd0aCAmJiBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlRm4pIHsgcmV0dXJuIGNoYW5nZUZuKF90aGlzLl92YWx1ZSwgZW1pdFZpZXdUb01vZGVsQ2hhbmdlICE9PSBmYWxzZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdGNoZXMgdGhlIHZhbHVlIG9mIGEgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBmdW5jdGlvbmFsbHkgdGhlIHNhbWUgYXMge0BsaW5rIEZvcm1Db250cm9sLnNldFZhbHVlfSBhdCB0aGlzIGxldmVsLlxuICAgICAgICAgKiBJdCBleGlzdHMgZm9yIHN5bW1ldHJ5IHdpdGgge0BsaW5rIEZvcm1Hcm91cC5wYXRjaFZhbHVlfSBvbiBgRm9ybUdyb3Vwc2AgYW5kIGBGb3JtQXJyYXlzYCxcbiAgICAgICAgICogd2hlcmUgaXQgZG9lcyBiZWhhdmUgZGlmZmVyZW50bHkuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucGF0Y2hWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSBmb3JtIGNvbnRyb2wuIFRoaXMgbWVhbnMgYnkgZGVmYXVsdDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBpdCBpcyBtYXJrZWQgYXMgYHByaXN0aW5lYFxuICAgICAgICAgKiAqIGl0IGlzIG1hcmtlZCBhcyBgdW50b3VjaGVkYFxuICAgICAgICAgKiAqIHZhbHVlIGlzIHNldCB0byBudWxsXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWxzbyByZXNldCB0byBhIHNwZWNpZmljIGZvcm0gc3RhdGUgYnkgcGFzc2luZyB0aHJvdWdoIGEgc3RhbmRhbG9uZVxuICAgICAgICAgKiB2YWx1ZSBvciBhIGZvcm0gc3RhdGUgb2JqZWN0IHRoYXQgY29udGFpbnMgYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkIHN0YXRlXG4gICAgICAgICAqICh0aGVzZSBhcmUgdGhlIG9ubHkgdHdvIHByb3BlcnRpZXMgdGhhdCBjYW5ub3QgYmUgY2FsY3VsYXRlZCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4OlxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiB0aGlzLmNvbnRyb2wucmVzZXQoJ05hbmN5Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuY29udHJvbC52YWx1ZSk7ICAvLyAnTmFuY3knXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBPUlxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogdGhpcy5jb250cm9sLnJlc2V0KHt2YWx1ZTogJ05hbmN5JywgZGlzYWJsZWQ6IHRydWV9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5jb250cm9sLnZhbHVlKTsgIC8vICdOYW5jeSdcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5jb250cm9sLnN0YXR1cyk7ICAvLyAnRElTQUJMRUQnXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSwgX2EpIHtcbiAgICAgICAgICAgIGlmIChmb3JtU3RhdGUgPT09IHZvaWQgMCkgeyBmb3JtU3RhdGUgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlGb3JtU3RhdGUoZm9ybVN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMubWFya0FzUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLm1hcmtBc1VudG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fdmFsdWUsIHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9scyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2FsbENvbnRyb2xzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpc2FibGVkOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgY2hhbmdlIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlLnB1c2goZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2NsZWFyQ2hhbmdlRm5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIGRpc2FibGVkIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5yZWdpc3Rlck9uRGlzYWJsZWRDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UucHVzaChmbik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gKGNiKSB7IH07XG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fYXBwbHlGb3JtU3RhdGUgPSBmdW5jdGlvbiAoZm9ybVN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNCb3hlZFZhbHVlKGZvcm1TdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IGZvcm1TdGF0ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBmb3JtU3RhdGUuZGlzYWJsZWQgPyB0aGlzLmRpc2FibGUoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IGZvcm1TdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Db250cm9sO1xuICAgIH0oQWJzdHJhY3RDb250cm9sKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgVHJhY2tzIHRoZSB2YWx1ZSBhbmQgdmFsaWRpdHkgc3RhdGUgb2YgYSBncm91cCBvZiB7QGxpbmsgRm9ybUNvbnRyb2x9XG4gICAgICogaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQSBgRm9ybUdyb3VwYCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXMgb2YgZWFjaCBjaGlsZCB7QGxpbmsgRm9ybUNvbnRyb2x9IGludG8gb25lIG9iamVjdCxcbiAgICAgKiB3aXRoIGVhY2ggY29udHJvbCBuYW1lIGFzIHRoZSBrZXkuICBJdCBjYWxjdWxhdGVzIGl0cyBzdGF0dXMgYnkgcmVkdWNpbmcgdGhlIHN0YXR1c2VzXG4gICAgICogb2YgaXRzIGNoaWxkcmVuLiBGb3IgZXhhbXBsZSwgaWYgb25lIG9mIHRoZSBjb250cm9scyBpbiBhIGdyb3VwIGlzIGludmFsaWQsIHRoZSBlbnRpcmVcbiAgICAgKiBncm91cCBiZWNvbWVzIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBgRm9ybUdyb3VwYCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLFxuICAgICAqIGFsb25nIHdpdGgge0BsaW5rIEZvcm1Db250cm9sfSBhbmQge0BsaW5rIEZvcm1BcnJheX0uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFdoZW4gaW5zdGFudGlhdGluZyBhIHtAbGluayBGb3JtR3JvdXB9LCBwYXNzIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZCBjb250cm9scyBhcyB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gVGhlIGtleSBmb3IgZWFjaCBjaGlsZCB3aWxsIGJlIHRoZSBuYW1lIHVuZGVyIHdoaWNoIGl0IGlzIHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgnTmFuY3knLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gICAgICogICBsYXN0OiBuZXcgRm9ybUNvbnRyb2woJ0RyZXcnKSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogJ05hbmN5JywgbGFzdDsgJ0RyZXcnfVxuICAgICAqIGNvbnNvbGUubG9nKGZvcm0uc3RhdHVzKTsgIC8vICdWQUxJRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBpbmNsdWRlIGdyb3VwLWxldmVsIHZhbGlkYXRvcnMgYXMgdGhlIHNlY29uZCBhcmcsIG9yIGdyb3VwLWxldmVsIGFzeW5jXG4gICAgICogdmFsaWRhdG9ycyBhcyB0aGUgdGhpcmQgYXJnLiBUaGVzZSBjb21lIGluIGhhbmR5IHdoZW4geW91IHdhbnQgdG8gcGVyZm9ybSB2YWxpZGF0aW9uXG4gICAgICogdGhhdCBjb25zaWRlcnMgdGhlIHZhbHVlIG9mIG1vcmUgdGhhbiBvbmUgY2hpbGQgY29udHJvbC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICogICBwYXNzd29yZDogbmV3IEZvcm1Db250cm9sKCcnLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gICAgICogICBwYXNzd29yZENvbmZpcm06IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqIH0sIHBhc3N3b3JkTWF0Y2hWYWxpZGF0b3IpO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBwYXNzd29yZE1hdGNoVmFsaWRhdG9yKGc6IEZvcm1Hcm91cCkge1xuICAgICAqICAgIHJldHVybiBnLmdldCgncGFzc3dvcmQnKS52YWx1ZSA9PT0gZy5nZXQoJ3Bhc3N3b3JkQ29uZmlybScpLnZhbHVlXG4gICAgICogICAgICAgPyBudWxsIDogeydtaXNtYXRjaCc6IHRydWV9O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Hcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KEZvcm1Hcm91cCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUdyb3VwKGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgICAgIHRoaXMuX2luaXRPYnNlcnZhYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5fc2V0VXBDb250cm9scygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIGNvbnRyb2wgd2l0aCB0aGUgZ3JvdXAncyBsaXN0IG9mIGNvbnRyb2xzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1cGRhdGUgdmFsdWUgb3IgdmFsaWRpdHkgb2YgdGhlIGNvbnRyb2wsIHNvIGZvclxuICAgICAgICAgKiBtb3N0IGNhc2VzIHlvdSdsbCB3YW50IHRvIHVzZSB7QGxpbmsgRm9ybUdyb3VwLmFkZENvbnRyb2x9IGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnJlZ2lzdGVyQ29udHJvbCA9IGZ1bmN0aW9uIChuYW1lLCBjb250cm9sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tuYW1lXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHNbbmFtZV0gPSBjb250cm9sO1xuICAgICAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgICAgICBjb250cm9sLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSh0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2w7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBjb250cm9sIHRvIHRoaXMgZ3JvdXAuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSwgY29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckNvbnRyb2wobmFtZSwgY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGEgY29udHJvbCBmcm9tIHRoaXMgZ3JvdXAuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1tuYW1lXS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSAodGhpcy5jb250cm9sc1tuYW1lXSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwbGFjZSBhbiBleGlzdGluZyBjb250cm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5zZXRDb250cm9sID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW25hbWVdKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbbmFtZV0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICBkZWxldGUgKHRoaXMuY29udHJvbHNbbmFtZV0pO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlckNvbnRyb2wobmFtZSwgY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgd2hldGhlciB0aGVyZSBpcyBhbiBlbmFibGVkIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgZ3JvdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBkaXNhYmxlZCBjb250cm9scy4gSWYgeW91J2QgbGlrZSB0byBjaGVjayBmb3JcbiAgICAgICAgICogZXhpc3RlbmNlIGluIHRoZSBncm91cCBvbmx5LCB1c2Uge0BsaW5rIEFic3RyYWN0Q29udHJvbC5nZXR9IGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGNvbnRyb2xOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9scy5oYXNPd25Qcm9wZXJ0eShjb250cm9sTmFtZSkgJiYgdGhpcy5jb250cm9sc1tjb250cm9sTmFtZV0uZW5hYmxlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUge0BsaW5rIEZvcm1Hcm91cH0uIEl0IGFjY2VwdHMgYW4gb2JqZWN0IHRoYXQgbWF0Y2hlc1xuICAgICAgICAgKiAgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ3JvdXAsIHdpdGggY29udHJvbCBuYW1lcyBhcyBrZXlzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBzdHJpY3QgY2hlY2tzLCBzbyBpdCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnlcbiAgICAgICAgICogdG8gc2V0IHRoZSB2YWx1ZSBvZiBhIGNvbnRyb2wgdGhhdCBkb2Vzbid0IGV4aXN0IG9yIGlmIHlvdSBleGNsdWRlIHRoZVxuICAgICAgICAgKiB2YWx1ZSBvZiBhIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqICBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICAgICAqICAgICBmaXJzdDogbmV3IEZvcm1Db250cm9sKCksXG4gICAgICAgICAqICAgICBsYXN0OiBuZXcgRm9ybUNvbnRyb2woKVxuICAgICAgICAgKiAgfSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6IG51bGwsIGxhc3Q6IG51bGx9XG4gICAgICAgICAqXG4gICAgICAgICAqICBmb3JtLnNldFZhbHVlKHtmaXJzdDogJ05hbmN5JywgbGFzdDogJ0RyZXcnfSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6ICdOYW5jeScsIGxhc3Q6ICdEcmV3J31cbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tBbGxWYWx1ZXNQcmVzZW50KHZhbHVlKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rocm93SWZDb250cm9sTWlzc2luZyhuYW1lKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250cm9sc1tuYW1lXS5zZXRWYWx1ZSh2YWx1ZVtuYW1lXSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgUGF0Y2hlcyB0aGUgdmFsdWUgb2YgdGhlIHtAbGluayBGb3JtR3JvdXB9LiBJdCBhY2NlcHRzIGFuIG9iamVjdCB3aXRoIGNvbnRyb2xcbiAgICAgICAgICogIG5hbWVzIGFzIGtleXMsIGFuZCB3aWxsIGRvIGl0cyBiZXN0IHRvIG1hdGNoIHRoZSB2YWx1ZXMgdG8gdGhlIGNvcnJlY3QgY29udHJvbHNcbiAgICAgICAgICogIGluIHRoZSBncm91cC5cbiAgICAgICAgICpcbiAgICAgICAgICogIEl0IGFjY2VwdHMgYm90aCBzdXBlci1zZXRzIGFuZCBzdWItc2V0cyBvZiB0aGUgZ3JvdXAgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgICAgICpcbiAgICAgICAgICogICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgICAgICogICAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgICAgICogICAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICAgICAqICB9KTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogbnVsbCwgbGFzdDogbnVsbH1cbiAgICAgICAgICpcbiAgICAgICAgICogIGZvcm0ucGF0Y2hWYWx1ZSh7Zmlyc3Q6ICdOYW5jeSd9KTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogJ05hbmN5JywgbGFzdDogbnVsbH1cbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5wYXRjaFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb250cm9sc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250cm9sc1tuYW1lXS5wYXRjaFZhbHVlKHZhbHVlW25hbWVdLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIHtAbGluayBGb3JtR3JvdXB9LiBUaGlzIG1lYW5zIGJ5IGRlZmF1bHQ6XG4gICAgICAgICAqXG4gICAgICAgICAqICogVGhlIGdyb3VwIGFuZCBhbGwgZGVzY2VuZGFudHMgYXJlIG1hcmtlZCBgcHJpc3RpbmVgXG4gICAgICAgICAqICogVGhlIGdyb3VwIGFuZCBhbGwgZGVzY2VuZGFudHMgYXJlIG1hcmtlZCBgdW50b3VjaGVkYFxuICAgICAgICAgKiAqIFRoZSB2YWx1ZSBvZiBhbGwgZGVzY2VuZGFudHMgd2lsbCBiZSBudWxsIG9yIG51bGwgbWFwc1xuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgY2FuIGFsc28gcmVzZXQgdG8gYSBzcGVjaWZpYyBmb3JtIHN0YXRlIGJ5IHBhc3NpbmcgaW4gYSBtYXAgb2Ygc3RhdGVzXG4gICAgICAgICAqIHRoYXQgbWF0Y2hlcyB0aGUgc3RydWN0dXJlIG9mIHlvdXIgZm9ybSwgd2l0aCBjb250cm9sIG5hbWVzIGFzIGtleXMuIFRoZSBzdGF0ZVxuICAgICAgICAgKiBjYW4gYmUgYSBzdGFuZGFsb25lIHZhbHVlIG9yIGEgZm9ybSBzdGF0ZSBvYmplY3Qgd2l0aCBib3RoIGEgdmFsdWUgYW5kIGEgZGlzYWJsZWRcbiAgICAgICAgICogc3RhdHVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiB0aGlzLmZvcm0ucmVzZXQoe2ZpcnN0OiAnbmFtZScsIGxhc3Q6ICdsYXN0IG5hbWUnfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuZm9ybS52YWx1ZSk7ICAvLyB7Zmlyc3Q6ICduYW1lJywgbGFzdDogJ2xhc3QgbmFtZSd9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiAtIE9SIC1cbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHRoaXMuZm9ybS5yZXNldCh7XG4gICAgICAgICAqICAgZmlyc3Q6IHt2YWx1ZTogJ25hbWUnLCBkaXNhYmxlZDogdHJ1ZX0sXG4gICAgICAgICAqICAgbGFzdDogJ2xhc3QnXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmZvcm0udmFsdWUpOyAgLy8ge2ZpcnN0OiAnbmFtZScsIGxhc3Q6ICdsYXN0IG5hbWUnfVxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmZvcm0uZ2V0KCdmaXJzdCcpLnN0YXR1cyk7ICAvLyAnRElTQUJMRUQnXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0ge307IH1cbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlc2V0KHZhbHVlW25hbWVdLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByaXN0aW5lKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgdGhlIHtAbGluayBGb3JtR3JvdXB9LCBpbmNsdWRpbmcgYW55IGRpc2FibGVkIGNvbnRyb2xzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB5b3UnZCBsaWtlIHRvIGluY2x1ZGUgYWxsIHZhbHVlcyByZWdhcmRsZXNzIG9mIGRpc2FibGVkIHN0YXR1cywgdXNlIHRoaXMgbWV0aG9kLlxuICAgICAgICAgKiBPdGhlcndpc2UsIHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIHRoZSBiZXN0IHdheSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBncm91cC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuZ2V0UmF3VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlQ2hpbGRyZW4oe30sIGZ1bmN0aW9uIChhY2MsIGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBhY2NbbmFtZV0gPSBjb250cm9sLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl90aHJvd0lmQ29udHJvbE1pc3NpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2xzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICAgIFRoZXJlIGFyZSBubyBmb3JtIGNvbnRyb2xzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGdyb3VwIHlldC4gIElmIHlvdSdyZSB1c2luZyBuZ01vZGVsLFxcbiAgICAgICAgeW91IG1heSB3YW50IHRvIGNoZWNrIG5leHQgdGljayAoZS5nLiB1c2Ugc2V0VGltZW91dCkuXFxuICAgICAgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgZm9ybSBjb250cm9sIHdpdGggbmFtZTogXCIgKyBuYW1lICsgXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX2ZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgcmV0dXJuIGNiKF90aGlzLmNvbnRyb2xzW2tdLCBrKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fc2V0VXBDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnNldFBhcmVudChfdGhpcyk7XG4gICAgICAgICAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoX3RoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmFsdWUgPSB0aGlzLl9yZWR1Y2VWYWx1ZSgpOyB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX2FueUNvbnRyb2xzID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciByZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcyB8fCAoX3RoaXMuY29udGFpbnMobmFtZSkgJiYgY29uZGl0aW9uKGNvbnRyb2wpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9yZWR1Y2VWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVkdWNlQ2hpbGRyZW4oe30sIGZ1bmN0aW9uIChhY2MsIGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5lbmFibGVkIHx8IF90aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IGNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9yZWR1Y2VDaGlsZHJlbiA9IGZ1bmN0aW9uIChpbml0VmFsdWUsIGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gaW5pdFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7IHJlcyA9IGZuKHJlcywgY29udHJvbCwgbmFtZSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9hbGxDb250cm9sc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sTmFtZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tjb250cm9sTmFtZV0uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpLmxlbmd0aCA+IDAgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9jaGVja0FsbFZhbHVlc1ByZXNlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3VwcGx5IGEgdmFsdWUgZm9yIGZvcm0gY29udHJvbCB3aXRoIG5hbWU6ICdcIiArIG5hbWUgKyBcIicuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUdyb3VwO1xuICAgIH0oQWJzdHJhY3RDb250cm9sKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgVHJhY2tzIHRoZSB2YWx1ZSBhbmQgdmFsaWRpdHkgc3RhdGUgb2YgYW4gYXJyYXkgb2Yge0BsaW5rIEZvcm1Db250cm9sfVxuICAgICAqIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIEEgYEZvcm1BcnJheWAgYWdncmVnYXRlcyB0aGUgdmFsdWVzIG9mIGVhY2ggY2hpbGQge0BsaW5rIEZvcm1Db250cm9sfSBpbnRvIGFuIGFycmF5LlxuICAgICAqIEl0IGNhbGN1bGF0ZXMgaXRzIHN0YXR1cyBieSByZWR1Y2luZyB0aGUgc3RhdHVzZXMgb2YgaXRzIGNoaWxkcmVuLiBGb3IgZXhhbXBsZSwgaWYgb25lIG9mXG4gICAgICogdGhlIGNvbnRyb2xzIGluIGEgYEZvcm1BcnJheWAgaXMgaW52YWxpZCwgdGhlIGVudGlyZSBhcnJheSBiZWNvbWVzIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBgRm9ybUFycmF5YCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLFxuICAgICAqIGFsb25nIHdpdGgge0BsaW5rIEZvcm1Db250cm9sfSBhbmQge0BsaW5rIEZvcm1Hcm91cH0uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFdoZW4gaW5zdGFudGlhdGluZyBhIHtAbGluayBGb3JtQXJyYXl9LCBwYXNzIGluIGFuIGFycmF5IG9mIGNoaWxkIGNvbnRyb2xzIGFzIHRoZSBmaXJzdFxuICAgICAqIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGFyciA9IG5ldyBGb3JtQXJyYXkoW1xuICAgICAqICAgbmV3IEZvcm1Db250cm9sKCdOYW5jeScsIFZhbGlkYXRvcnMubWluTGVuZ3RoKDIpKSxcbiAgICAgKiAgIG5ldyBGb3JtQ29udHJvbCgnRHJldycpLFxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgJ0RyZXcnXVxuICAgICAqIGNvbnNvbGUubG9nKGFyci5zdGF0dXMpOyAgLy8gJ1ZBTElEJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogWW91IGNhbiBhbHNvIGluY2x1ZGUgYXJyYXktbGV2ZWwgdmFsaWRhdG9ycyBhcyB0aGUgc2Vjb25kIGFyZywgb3IgYXJyYXktbGV2ZWwgYXN5bmNcbiAgICAgKiB2YWxpZGF0b3JzIGFzIHRoZSB0aGlyZCBhcmcuIFRoZXNlIGNvbWUgaW4gaGFuZHkgd2hlbiB5b3Ugd2FudCB0byBwZXJmb3JtIHZhbGlkYXRpb25cbiAgICAgKiB0aGF0IGNvbnNpZGVycyB0aGUgdmFsdWUgb2YgbW9yZSB0aGFuIG9uZSBjaGlsZCBjb250cm9sLlxuICAgICAqXG4gICAgICogIyMjIEFkZGluZyBvciByZW1vdmluZyBjb250cm9sc1xuICAgICAqXG4gICAgICogVG8gY2hhbmdlIHRoZSBjb250cm9scyBpbiB0aGUgYXJyYXksIHVzZSB0aGUgYHB1c2hgLCBgaW5zZXJ0YCwgb3IgYHJlbW92ZUF0YCBtZXRob2RzXG4gICAgICogaW4gYEZvcm1BcnJheWAgaXRzZWxmLiBUaGVzZSBtZXRob2RzIGVuc3VyZSB0aGUgY29udHJvbHMgYXJlIHByb3Blcmx5IHRyYWNrZWQgaW4gdGhlXG4gICAgICogZm9ybSdzIGhpZXJhcmNoeS4gRG8gbm90IG1vZGlmeSB0aGUgYXJyYXkgb2YgYEFic3RyYWN0Q29udHJvbGBzIHVzZWQgdG8gaW5zdGFudGlhdGVcbiAgICAgKiB0aGUgYEZvcm1BcnJheWAgZGlyZWN0bHksIGFzIHRoYXQgd2lsbCByZXN1bHQgaW4gc3RyYW5nZSBhbmQgdW5leHBlY3RlZCBiZWhhdmlvciBzdWNoXG4gICAgICogYXMgYnJva2VuIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQXJyYXkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNihGb3JtQXJyYXksIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1BcnJheShjb250cm9scywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2x9IGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udHJvbHNbaW5kZXhdOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IGEgbmV3IHtAbGluayBBYnN0cmFjdENvbnRyb2x9IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMucHVzaChjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnQgYSBuZXcge0BsaW5rIEFic3RyYWN0Q29udHJvbH0gYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAwLCBjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGNvbnRyb2wgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5yZW1vdmVBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbaW5kZXhdKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbaW5kZXhdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2UgYW4gZXhpc3RpbmcgY29udHJvbC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuc2V0Q29udHJvbCA9IGZ1bmN0aW9uIChpbmRleCwgY29udHJvbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbaW5kZXhdKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbaW5kZXhdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShpbmRleCwgMCwgY29udHJvbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVuZ3RoIG9mIHRoZSBjb250cm9sIGFycmF5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbHMubGVuZ3RoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUge0BsaW5rIEZvcm1BcnJheX0uIEl0IGFjY2VwdHMgYW4gYXJyYXkgdGhhdCBtYXRjaGVzXG4gICAgICAgICAqICB0aGUgc3RydWN0dXJlIG9mIHRoZSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBzdHJpY3QgY2hlY2tzLCBzbyBpdCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnlcbiAgICAgICAgICogdG8gc2V0IHRoZSB2YWx1ZSBvZiBhIGNvbnRyb2wgdGhhdCBkb2Vzbid0IGV4aXN0IG9yIGlmIHlvdSBleGNsdWRlIHRoZVxuICAgICAgICAgKiB2YWx1ZSBvZiBhIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqICBjb25zdCBhcnIgPSBuZXcgRm9ybUFycmF5KFtcbiAgICAgICAgICogICAgIG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIF0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbbnVsbCwgbnVsbF1cbiAgICAgICAgICpcbiAgICAgICAgICogIGFyci5zZXRWYWx1ZShbJ05hbmN5JywgJ0RyZXcnXSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFsnTmFuY3knLCAnRHJldyddXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrQWxsVmFsdWVzUHJlc2VudCh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChuZXdWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGhyb3dJZkNvbnRyb2xNaXNzaW5nKGluZGV4KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hdChpbmRleCkuc2V0VmFsdWUobmV3VmFsdWUsIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogIFBhdGNoZXMgdGhlIHZhbHVlIG9mIHRoZSB7QGxpbmsgRm9ybUFycmF5fS4gSXQgYWNjZXB0cyBhbiBhcnJheSB0aGF0IG1hdGNoZXMgdGhlXG4gICAgICAgICAqICBzdHJ1Y3R1cmUgb2YgdGhlIGNvbnRyb2wsIGFuZCB3aWxsIGRvIGl0cyBiZXN0IHRvIG1hdGNoIHRoZSB2YWx1ZXMgdG8gdGhlIGNvcnJlY3RcbiAgICAgICAgICogIGNvbnRyb2xzIGluIHRoZSBncm91cC5cbiAgICAgICAgICpcbiAgICAgICAgICogIEl0IGFjY2VwdHMgYm90aCBzdXBlci1zZXRzIGFuZCBzdWItc2V0cyBvZiB0aGUgYXJyYXkgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgICAgICpcbiAgICAgICAgICogICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogIGNvbnN0IGFyciA9IG5ldyBGb3JtQXJyYXkoW1xuICAgICAgICAgKiAgICAgbmV3IEZvcm1Db250cm9sKCksXG4gICAgICAgICAqICAgICBuZXcgRm9ybUNvbnRyb2woKVxuICAgICAgICAgKiAgXSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFtudWxsLCBudWxsXVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYXJyLnBhdGNoVmFsdWUoWydOYW5jeSddKTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gWydOYW5jeScsIG51bGxdXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucGF0Y2hWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAobmV3VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmF0KGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdChpbmRleCkucGF0Y2hWYWx1ZShuZXdWYWx1ZSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSB7QGxpbmsgRm9ybUFycmF5fS4gVGhpcyBtZWFucyBieSBkZWZhdWx0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIFRoZSBhcnJheSBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHByaXN0aW5lYFxuICAgICAgICAgKiAqIFRoZSBhcnJheSBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHVudG91Y2hlZGBcbiAgICAgICAgICogKiBUaGUgdmFsdWUgb2YgYWxsIGRlc2NlbmRhbnRzIHdpbGwgYmUgbnVsbCBvciBudWxsIG1hcHNcbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhbHNvIHJlc2V0IHRvIGEgc3BlY2lmaWMgZm9ybSBzdGF0ZSBieSBwYXNzaW5nIGluIGFuIGFycmF5IG9mIHN0YXRlc1xuICAgICAgICAgKiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiB0aGUgY29udHJvbC4gVGhlIHN0YXRlIGNhbiBiZSBhIHN0YW5kYWxvbmUgdmFsdWVcbiAgICAgICAgICogb3IgYSBmb3JtIHN0YXRlIG9iamVjdCB3aXRoIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZCBzdGF0dXMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIHRoaXMuYXJyLnJlc2V0KFsnbmFtZScsICdsYXN0IG5hbWUnXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuYXJyLnZhbHVlKTsgIC8vIFsnbmFtZScsICdsYXN0IG5hbWUnXVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogLSBPUiAtXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiB0aGlzLmFyci5yZXNldChbXG4gICAgICAgICAqICAge3ZhbHVlOiAnbmFtZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgICAgICogICAnbGFzdCdcbiAgICAgICAgICogXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuYXJyLnZhbHVlKTsgIC8vIFsnbmFtZScsICdsYXN0IG5hbWUnXVxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmFyci5nZXQoMCkuc3RhdHVzKTsgIC8vICdESVNBQkxFRCdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBbXTsgfVxuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlc2V0KHZhbHVlW2luZGV4XSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWdncmVnYXRlIHZhbHVlIG9mIHRoZSBhcnJheSwgaW5jbHVkaW5nIGFueSBkaXNhYmxlZCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgeW91J2QgbGlrZSB0byBpbmNsdWRlIGFsbCB2YWx1ZXMgcmVnYXJkbGVzcyBvZiBkaXNhYmxlZCBzdGF0dXMsIHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyB0aGUgYmVzdCB3YXkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLmdldFJhd1ZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9scy5tYXAoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wudmFsdWU7IH0pOyB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3Rocm93SWZDb250cm9sTWlzc2luZyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgICAgVGhlcmUgYXJlIG5vIGZvcm0gY29udHJvbHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgYXJyYXkgeWV0LiAgSWYgeW91J3JlIHVzaW5nIG5nTW9kZWwsXFxuICAgICAgICB5b3UgbWF5IHdhbnQgdG8gY2hlY2sgbmV4dCB0aWNrIChlLmcuIHVzZSBzZXRUaW1lb3V0KS5cXG4gICAgICBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXQoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgZm9ybSBjb250cm9sIGF0IGluZGV4IFwiICsgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX2ZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sLCBpbmRleCkgeyBjYihjb250cm9sLCBpbmRleCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5jb250cm9scy5maWx0ZXIoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuZW5hYmxlZCB8fCBfdGhpcy5kaXNhYmxlZDsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLnZhbHVlOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9hbnlDb250cm9scyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLnNvbWUoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuZW5hYmxlZCAmJiBjb25kaXRpb24oY29udHJvbCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3NldFVwQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBfdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9jaGVja0FsbFZhbHVlc1ByZXNlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgaSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3VwcGx5IGEgdmFsdWUgZm9yIGZvcm0gY29udHJvbCBhdCBpbmRleDogXCIgKyBpICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX2FsbENvbnRyb2xzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jb250cm9sczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5lbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9scy5sZW5ndGggPiAwIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3JlZ2lzdGVyQ29udHJvbCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICBjb250cm9sLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQXJyYXk7XG4gICAgfShBYnN0cmFjdENvbnRyb2wpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgZm9ybURpcmVjdGl2ZVByb3ZpZGVyID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nRm9ybTsgfSlcbiAgICB9O1xuICAgIHZhciByZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHRvcC1sZXZlbCB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSBhbmQgYmluZHMgaXQgdG8gYSBmb3JtXG4gICAgICogdG8gdHJhY2sgYWdncmVnYXRlIGZvcm0gdmFsdWUgYW5kIHZhbGlkYXRpb24gc3RhdHVzLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBBcyBzb29uIGFzIHlvdSBpbXBvcnQgdGhlIGBGb3Jtc01vZHVsZWAsIHRoaXMgZGlyZWN0aXZlIGJlY29tZXMgYWN0aXZlIGJ5IGRlZmF1bHQgb25cbiAgICAgKiBhbGwgYDxmb3JtPmAgdGFncy4gIFlvdSBkb24ndCBuZWVkIHRvIGFkZCBhIHNwZWNpYWwgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZyBgbmdGb3JtYCBhcyB0aGUga2V5XG4gICAgICogKGV4OiBgI215Rm9ybT1cIm5nRm9ybVwiYCkuIFRoaXMgaXMgb3B0aW9uYWwsIGJ1dCB1c2VmdWwuICBNYW55IHByb3BlcnRpZXMgZnJvbSB0aGUgdW5kZXJseWluZ1xuICAgICAqIHtAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIGFyZSBkdXBsaWNhdGVkIG9uIHRoZSBkaXJlY3RpdmUgaXRzZWxmLCBzbyBhIHJlZmVyZW5jZSB0byBpdFxuICAgICAqIHdpbGwgZ2l2ZSB5b3UgYWNjZXNzIHRvIHRoZSBhZ2dyZWdhdGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXR1cyBvZiB0aGUgZm9ybSwgYXMgd2VsbCBhc1xuICAgICAqIHVzZXIgaW50ZXJhY3Rpb24gcHJvcGVydGllcyBsaWtlIGBkaXJ0eWAgYW5kIGB0b3VjaGVkYC5cbiAgICAgKlxuICAgICAqIFRvIHJlZ2lzdGVyIGNoaWxkIGNvbnRyb2xzIHdpdGggdGhlIGZvcm0sIHlvdSdsbCB3YW50IHRvIHVzZSB7QGxpbmsgTmdNb2RlbH0gd2l0aCBhXG4gICAgICogYG5hbWVgIGF0dHJpYnV0ZS4gIFlvdSBjYW4gYWxzbyB1c2Uge0BsaW5rIE5nTW9kZWxHcm91cH0gaWYgeW91J2QgbGlrZSB0byBjcmVhdGVcbiAgICAgKiBzdWItZ3JvdXBzIHdpdGhpbiB0aGUgZm9ybS5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gbGlzdGVuIHRvIHRoZSBkaXJlY3RpdmUncyBgbmdTdWJtaXRgIGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHVzZXIgaGFzXG4gICAgICogdHJpZ2dlcmVkIGEgZm9ybSBzdWJtaXNzaW9uLiBUaGUgYG5nU3VibWl0YCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgZm9ybVxuICAgICAqIHN1Ym1pc3Npb24gZXZlbnQuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybS9zaW1wbGVfZm9ybV9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqICoqTmdNb2R1bGUqKjogYEZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdGb3JtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDQoTmdGb3JtLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ0Zvcm0odmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybSA9XG4gICAgICAgICAgICAgICAgbmV3IEZvcm1Hcm91cCh7fSwgY29tcG9zZVZhbGlkYXRvcnModmFsaWRhdG9ycyksIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnMoYXN5bmNWYWxpZGF0b3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwic3VibWl0dGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3VibWl0dGVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwiY29udHJvbHNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm0uY29udHJvbHM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgZGlyLl9jb250cm9sID0gY29udGFpbmVyLnJlZ2lzdGVyQ29udHJvbChkaXIubmFtZSwgZGlyLmNvbnRyb2wpO1xuICAgICAgICAgICAgICAgIHNldFVwQ29udHJvbChkaXIuY29udHJvbCwgZGlyKTtcbiAgICAgICAgICAgICAgICBkaXIuY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLmdldENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTsgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNvbnRyb2woZGlyLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLmFkZEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAgICAgICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoZ3JvdXAsIGRpcik7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyQ29udHJvbChkaXIubmFtZSwgZ3JvdXApO1xuICAgICAgICAgICAgICAgIGdyb3VwLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVtb3ZlRm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNvbnRyb2woZGlyLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLmdldEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpOyB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLnVwZGF0ZU1vZGVsID0gZnVuY3Rpb24gKGRpciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0cmwgPSBfdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgY3RybC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLmNvbnRyb2wuc2V0VmFsdWUodmFsdWUpOyB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLm9uU3VibWl0ID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmdTdWJtaXQuZW1pdCgkZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLm9uUmVzZXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMucmVzZXRGb3JtKCk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVzZXRGb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgdGhpcy5mb3JtLnJlc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuX2ZpbmRDb250YWluZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA/IHRoaXMuZm9ybS5nZXQocGF0aCkgOiB0aGlzLmZvcm07XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZm9ybTpub3QoW25nTm9Gb3JtXSk6bm90KFtmb3JtR3JvdXBdKSxuZ0Zvcm0sW25nRm9ybV0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbZm9ybURpcmVjdGl2ZVByb3ZpZGVyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhzdWJtaXQpJzogJ29uU3VibWl0KCRldmVudCknLCAnKHJlc2V0KSc6ICdvblJlc2V0KCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbJ25nU3VibWl0J10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nRm9ybSdcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ0Zvcm0uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBOZ0Zvcm07XG4gICAgfShDb250cm9sQ29udGFpbmVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIEV4YW1wbGVzID0ge1xuICAgICAgICBmb3JtQ29udHJvbE5hbWU6IFwiXFxuICAgIDxkaXYgW2Zvcm1Hcm91cF09XFxcIm15R3JvdXBcXFwiPlxcbiAgICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XFxcImZpcnN0TmFtZVxcXCI+XFxuICAgIDwvZGl2PlxcblxcbiAgICBJbiB5b3VyIGNsYXNzOlxcblxcbiAgICB0aGlzLm15R3JvdXAgPSBuZXcgRm9ybUdyb3VwKHtcXG4gICAgICAgZmlyc3ROYW1lOiBuZXcgRm9ybUNvbnRyb2woKVxcbiAgICB9KTtcIixcbiAgICAgICAgZm9ybUdyb3VwTmFtZTogXCJcXG4gICAgPGRpdiBbZm9ybUdyb3VwXT1cXFwibXlHcm91cFxcXCI+XFxuICAgICAgIDxkaXYgZm9ybUdyb3VwTmFtZT1cXFwicGVyc29uXFxcIj5cXG4gICAgICAgICAgPGlucHV0IGZvcm1Db250cm9sTmFtZT1cXFwiZmlyc3ROYW1lXFxcIj5cXG4gICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICBJbiB5b3VyIGNsYXNzOlxcblxcbiAgICB0aGlzLm15R3JvdXAgPSBuZXcgRm9ybUdyb3VwKHtcXG4gICAgICAgcGVyc29uOiBuZXcgRm9ybUdyb3VwKHsgZmlyc3ROYW1lOiBuZXcgRm9ybUNvbnRyb2woKSB9KVxcbiAgICB9KTtcIixcbiAgICAgICAgZm9ybUFycmF5TmFtZTogXCJcXG4gICAgPGRpdiBbZm9ybUdyb3VwXT1cXFwibXlHcm91cFxcXCI+XFxuICAgICAgPGRpdiBmb3JtQXJyYXlOYW1lPVxcXCJjaXRpZXNcXFwiPlxcbiAgICAgICAgPGRpdiAqbmdGb3I9XFxcImxldCBjaXR5IG9mIGNpdHlBcnJheS5jb250cm9sczsgbGV0IGk9aW5kZXhcXFwiPlxcbiAgICAgICAgICA8aW5wdXQgW2Zvcm1Db250cm9sTmFtZV09XFxcImlcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICBJbiB5b3VyIGNsYXNzOlxcblxcbiAgICB0aGlzLmNpdHlBcnJheSA9IG5ldyBGb3JtQXJyYXkoW25ldyBGb3JtQ29udHJvbCgnU0YnKV0pO1xcbiAgICB0aGlzLm15R3JvdXAgPSBuZXcgRm9ybUdyb3VwKHtcXG4gICAgICBjaXRpZXM6IHRoaXMuY2l0eUFycmF5XFxuICAgIH0pO1wiLFxuICAgICAgICBuZ01vZGVsR3JvdXA6IFwiXFxuICAgIDxmb3JtPlxcbiAgICAgICA8ZGl2IG5nTW9kZWxHcm91cD1cXFwicGVyc29uXFxcIj5cXG4gICAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJwZXJzb24ubmFtZVxcXCIgbmFtZT1cXFwiZmlyc3ROYW1lXFxcIj5cXG4gICAgICAgPC9kaXY+XFxuICAgIDwvZm9ybT5cIixcbiAgICAgICAgbmdNb2RlbFdpdGhGb3JtR3JvdXA6IFwiXFxuICAgIDxkaXYgW2Zvcm1Hcm91cF09XFxcIm15R3JvdXBcXFwiPlxcbiAgICAgICA8aW5wdXQgZm9ybUNvbnRyb2xOYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcInNob3dNb3JlQ29udHJvbHNcXFwiIFtuZ01vZGVsT3B0aW9uc109XFxcIntzdGFuZGFsb25lOiB0cnVlfVxcXCI+XFxuICAgIDwvZGl2PlxcbiAgXCJcbiAgICB9O1xuXG4gICAgdmFyIFRlbXBsYXRlRHJpdmVuRXJyb3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGVEcml2ZW5FcnJvcnMoKSB7XG4gICAgICAgIH1cbiAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubW9kZWxQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBuZ01vZGVsIGNhbm5vdCBiZSB1c2VkIHRvIHJlZ2lzdGVyIGZvcm0gY29udHJvbHMgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgVHJ5IHVzaW5nXFxuICAgICAgZm9ybUdyb3VwJ3MgcGFydG5lciBkaXJlY3RpdmUgXFxcImZvcm1Db250cm9sTmFtZVxcXCIgaW5zdGVhZC4gIEV4YW1wbGU6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtQ29udHJvbE5hbWUgKyBcIlxcblxcbiAgICAgIE9yLCBpZiB5b3UnZCBsaWtlIHRvIGF2b2lkIHJlZ2lzdGVyaW5nIHRoaXMgZm9ybSBjb250cm9sLCBpbmRpY2F0ZSB0aGF0IGl0J3Mgc3RhbmRhbG9uZSBpbiBuZ01vZGVsT3B0aW9uczpcXG5cXG4gICAgICBFeGFtcGxlOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMubmdNb2RlbFdpdGhGb3JtR3JvdXApO1xuICAgICAgICB9O1xuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5mb3JtR3JvdXBOYW1lRXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgbmdNb2RlbCBjYW5ub3QgYmUgdXNlZCB0byByZWdpc3RlciBmb3JtIGNvbnRyb2xzIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwTmFtZSBvciBmb3JtQXJyYXlOYW1lIGRpcmVjdGl2ZS5cXG5cXG4gICAgICBPcHRpb24gMTogVXNlIGZvcm1Db250cm9sTmFtZSBpbnN0ZWFkIG9mIG5nTW9kZWwgKHJlYWN0aXZlIHN0cmF0ZWd5KTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Hcm91cE5hbWUgKyBcIlxcblxcbiAgICAgIE9wdGlvbiAyOiAgVXBkYXRlIG5nTW9kZWwncyBwYXJlbnQgYmUgbmdNb2RlbEdyb3VwICh0ZW1wbGF0ZS1kcml2ZW4gc3RyYXRlZ3kpOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMubmdNb2RlbEdyb3VwKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubWlzc2luZ05hbWVFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJZiBuZ01vZGVsIGlzIHVzZWQgd2l0aGluIGEgZm9ybSB0YWcsIGVpdGhlciB0aGUgbmFtZSBhdHRyaWJ1dGUgbXVzdCBiZSBzZXQgb3IgdGhlIGZvcm1cXG4gICAgICBjb250cm9sIG11c3QgYmUgZGVmaW5lZCBhcyAnc3RhbmRhbG9uZScgaW4gbmdNb2RlbE9wdGlvbnMuXFxuXFxuICAgICAgRXhhbXBsZSAxOiA8aW5wdXQgWyhuZ01vZGVsKV09XFxcInBlcnNvbi5maXJzdE5hbWVcXFwiIG5hbWU9XFxcImZpcnN0XFxcIj5cXG4gICAgICBFeGFtcGxlIDI6IDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwicGVyc29uLmZpcnN0TmFtZVxcXCIgW25nTW9kZWxPcHRpb25zXT1cXFwie3N0YW5kYWxvbmU6IHRydWV9XFxcIj5cIik7XG4gICAgICAgIH07XG4gICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1vZGVsR3JvdXBQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBuZ01vZGVsR3JvdXAgY2Fubm90IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLlxcblxcbiAgICAgIE9wdGlvbiAxOiBVc2UgZm9ybUdyb3VwTmFtZSBpbnN0ZWFkIG9mIG5nTW9kZWxHcm91cCAocmVhY3RpdmUgc3RyYXRlZ3kpOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSArIFwiXFxuXFxuICAgICAgT3B0aW9uIDI6ICBVc2UgYSByZWd1bGFyIGZvcm0gdGFnIGluc3RlYWQgb2YgdGhlIGZvcm1Hcm91cCBkaXJlY3RpdmUgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSk6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsR3JvdXApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVGVtcGxhdGVEcml2ZW5FcnJvcnM7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDggPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgbW9kZWxHcm91cFByb3ZpZGVyID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nTW9kZWxHcm91cDsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIENyZWF0ZXMgYW5kIGJpbmRzIGEge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCBhcyBhIGNoaWxkIG9mIHtAbGluayBOZ0Zvcm19IChvciBpbiBvdGhlciB3b3JkcyxcbiAgICAgKiB3aXRoaW4gYDxmb3JtPmAgdGFncykuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBkaXJlY3RpdmUgaWYgeW91J2QgbGlrZSB0byBjcmVhdGUgYSBzdWItZ3JvdXAgd2l0aGluIGEgZm9ybS4gVGhpcyBjYW5cbiAgICAgKiBjb21lIGluIGhhbmR5IGlmIHlvdSB3YW50IHRvIHZhbGlkYXRlIGEgc3ViLWdyb3VwIG9mIHlvdXIgZm9ybSBzZXBhcmF0ZWx5IGZyb21cbiAgICAgKiB0aGUgcmVzdCBvZiB5b3VyIGZvcm0sIG9yIGlmIHNvbWUgdmFsdWVzIGluIHlvdXIgZG9tYWluIG1vZGVsIG1ha2UgbW9yZSBzZW5zZSB0b1xuICAgICAqIGNvbnN1bWUgdG9nZXRoZXIgaW4gYSBuZXN0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogUGFzcyBpbiB0aGUgbmFtZSB5b3UnZCBsaWtlIHRoaXMgc3ViLWdyb3VwIHRvIGhhdmUgYW5kIGl0IHdpbGwgYmVjb21lIHRoZSBrZXlcbiAgICAgKiBmb3IgdGhlIHN1Yi1ncm91cCBpbiB0aGUgZm9ybSdzIGZ1bGwgdmFsdWUuIFlvdSBjYW4gYWxzbyBleHBvcnQgdGhlIGRpcmVjdGl2ZSBpbnRvXG4gICAgICogYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZyBgbmdNb2RlbEdyb3VwYCAoZXg6IGAjbXlHcm91cD1cIm5nTW9kZWxHcm91cFwiYCkuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvbmdNb2RlbEdyb3VwL25nX21vZGVsX2dyb3VwX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nTW9kZWxHcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ4KE5nTW9kZWxHcm91cCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdNb2RlbEdyb3VwKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdNb2RlbEdyb3VwLnByb3RvdHlwZS5fY2hlY2tQYXJlbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdNb2RlbEdyb3VwKSAmJiAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nRm9ybSkpIHtcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5tb2RlbEdyb3VwUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWxHcm91cC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdNb2RlbEdyb3VwXScsIHByb3ZpZGVyczogW21vZGVsR3JvdXBQcm92aWRlcl0sIGV4cG9ydEFzOiAnbmdNb2RlbEdyb3VwJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nTW9kZWxHcm91cC5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZiB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdNb2RlbEdyb3VwLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWxHcm91cCcsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ01vZGVsR3JvdXA7XG4gICAgfShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBmb3JtQ29udHJvbEJpbmRpbmcgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5nQ29udHJvbCxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ01vZGVsOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogYG5nTW9kZWxgIGZvcmNlcyBhbiBhZGRpdGlvbmFsIGNoYW5nZSBkZXRlY3Rpb24gcnVuIHdoZW4gaXRzIGlucHV0cyBjaGFuZ2U6XG4gICAgICogRS5nLjpcbiAgICAgKiBgYGBcbiAgICAgKiA8ZGl2Pnt7bXlNb2RlbC52YWxpZH19PC9kaXY+XG4gICAgICogPGlucHV0IFsobmdNb2RlbCldPVwibXlWYWx1ZVwiICNteU1vZGVsPVwibmdNb2RlbFwiPlxuICAgICAqIGBgYFxuICAgICAqIEkuZS4gYG5nTW9kZWxgIGNhbiBleHBvcnQgaXRzZWxmIG9uIHRoZSBlbGVtZW50IGFuZCB0aGVuIGJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLlxuICAgICAqIE5vcm1hbGx5LCB0aGlzIHdvdWxkIHJlc3VsdCBpbiBleHByZXNzaW9ucyBiZWZvcmUgdGhlIGBpbnB1dGAgdGhhdCB1c2UgdGhlIGV4cG9ydGVkIGRpcmVjdGl2ZVxuICAgICAqIHRvIGhhdmUgYW5kIG9sZCB2YWx1ZSBhcyB0aGV5IGhhdmUgYmVlblxuICAgICAqIGRpcnR5IGNoZWNrZWQgYmVmb3JlLiBBcyB0aGlzIGlzIGEgdmVyeSBjb21tb24gY2FzZSBmb3IgYG5nTW9kZWxgLCB3ZSBhZGRlZCB0aGlzIHNlY29uZCBjaGFuZ2VcbiAgICAgKiBkZXRlY3Rpb24gcnVuLlxuICAgICAqXG4gICAgICogTm90ZXM6XG4gICAgICogLSB0aGlzIGlzIGp1c3Qgb25lIGV4dHJhIHJ1biBubyBtYXR0ZXIgaG93IG1hbnkgYG5nTW9kZWxgIGhhdmUgYmVlbiBjaGFuZ2VkLlxuICAgICAqIC0gdGhpcyBpcyBhIGdlbmVyYWwgcHJvYmxlbSB3aGVuIHVzaW5nIGBleHBvcnRBc2AgZm9yIGRpcmVjdGl2ZXMhXG4gICAgICovXG4gICAgdmFyIHJlc29sdmVkUHJvbWlzZSQxID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIENyZWF0ZXMgYSB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIGZyb20gYSBkb21haW4gbW9kZWwgYW5kIGJpbmRzIGl0XG4gICAgICogdG8gYSBmb3JtIGNvbnRyb2wgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIHdpbGwgdHJhY2sgdGhlIHZhbHVlLCB1c2VyIGludGVyYWN0aW9uLCBhbmRcbiAgICAgKiB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbCBhbmQga2VlcCB0aGUgdmlldyBzeW5jZWQgd2l0aCB0aGUgbW9kZWwuIElmIHVzZWRcbiAgICAgKiB3aXRoaW4gYSBwYXJlbnQgZm9ybSwgdGhlIGRpcmVjdGl2ZSB3aWxsIGFsc28gcmVnaXN0ZXIgaXRzZWxmIHdpdGggdGhlIGZvcm0gYXMgYSBjaGlsZFxuICAgICAqIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGNhbiBiZSB1c2VkIGJ5IGl0c2VsZiBvciBhcyBwYXJ0IG9mIGEgbGFyZ2VyIGZvcm0uIEFsbCB5b3UgbmVlZCBpcyB0aGVcbiAgICAgKiBgbmdNb2RlbGAgc2VsZWN0b3IgdG8gYWN0aXZhdGUgaXQuXG4gICAgICpcbiAgICAgKiBJdCBhY2NlcHRzIGEgZG9tYWluIG1vZGVsIGFzIGFuIG9wdGlvbmFsIHtAbGluayBASW5wdXR9LiBJZiB5b3UgaGF2ZSBhIG9uZS13YXkgYmluZGluZ1xuICAgICAqIHRvIGBuZ01vZGVsYCB3aXRoIGBbXWAgc3ludGF4LCBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgdGhlIGRvbWFpbiBtb2RlbCBpbiB0aGUgY29tcG9uZW50XG4gICAgICogY2xhc3Mgd2lsbCBzZXQgdGhlIHZhbHVlIGluIHRoZSB2aWV3LiBJZiB5b3UgaGF2ZSBhIHR3by13YXkgYmluZGluZyB3aXRoIGBbKCldYCBzeW50YXhcbiAgICAgKiAoYWxzbyBrbm93biBhcyAnYmFuYW5hLWJveCBzeW50YXgnKSwgdGhlIHZhbHVlIGluIHRoZSBVSSB3aWxsIGFsd2F5cyBiZSBzeW5jZWQgYmFjayB0b1xuICAgICAqIHRoZSBkb21haW4gbW9kZWwgaW4geW91ciBjbGFzcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogSWYgeW91IHdpc2ggdG8gaW5zcGVjdCB0aGUgcHJvcGVydGllcyBvZiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgRm9ybUNvbnRyb2x9IChsaWtlXG4gICAgICogdmFsaWRpdHkgc3RhdGUpLCB5b3UgY2FuIGFsc28gZXhwb3J0IHRoZSBkaXJlY3RpdmUgaW50byBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nXG4gICAgICogYG5nTW9kZWxgIGFzIHRoZSBrZXkgKGV4OiBgI215VmFyPVwibmdNb2RlbFwiYCkuIFlvdSBjYW4gdGhlbiBhY2Nlc3MgdGhlIGNvbnRyb2wgdXNpbmcgdGhlXG4gICAgICogZGlyZWN0aXZlJ3MgYGNvbnRyb2xgIHByb3BlcnR5LCBidXQgbW9zdCBwcm9wZXJ0aWVzIHlvdSdsbCBuZWVkIChsaWtlIGB2YWxpZGAgYW5kIGBkaXJ0eWApXG4gICAgICogd2lsbCBmYWxsIHRocm91Z2ggdG8gdGhlIGNvbnRyb2wgYW55d2F5LCBzbyB5b3UgY2FuIGFjY2VzcyB0aGVtIGRpcmVjdGx5LiBZb3UgY2FuIHNlZSBhXG4gICAgICogZnVsbCBsaXN0IG9mIHByb3BlcnRpZXMgZGlyZWN0bHkgYXZhaWxhYmxlIGluIHtAbGluayBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBpcyBhbiBleGFtcGxlIG9mIGEgc2ltcGxlIHN0YW5kYWxvbmUgY29udHJvbCB1c2luZyBgbmdNb2RlbGA6XG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlTmdNb2RlbC9zaW1wbGVfbmdfbW9kZWxfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIHRoZSBgbmdNb2RlbGAgd2l0aGluIGA8Zm9ybT5gIHRhZ3MsIHlvdSdsbCBhbHNvIG5lZWQgdG8gc3VwcGx5IGEgYG5hbWVgIGF0dHJpYnV0ZVxuICAgICAqIHNvIHRoYXQgdGhlIGNvbnRyb2wgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgcGFyZW50IGZvcm0gdW5kZXIgdGhhdCBuYW1lLlxuICAgICAqXG4gICAgICogSXQncyB3b3J0aCBub3RpbmcgdGhhdCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBmb3JtLCB5b3Ugb2Z0ZW4gY2FuIHNraXAgb25lLXdheSBvclxuICAgICAqIHR3by13YXkgYmluZGluZyBiZWNhdXNlIHRoZSBwYXJlbnQgZm9ybSB3aWxsIHN5bmMgdGhlIHZhbHVlIGZvciB5b3UuIFlvdSBjYW4gYWNjZXNzXG4gICAgICogaXRzIHByb3BlcnRpZXMgYnkgZXhwb3J0aW5nIGl0IGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZyBgbmdGb3JtYCAoZXg6XG4gICAgICogYCNmPVwibmdGb3JtXCJgKS4gVGhlbiB5b3UgY2FuIHBhc3MgaXQgd2hlcmUgaXQgbmVlZHMgdG8gZ28gb24gc3VibWl0LlxuICAgICAqXG4gICAgICogSWYgeW91IGRvIG5lZWQgdG8gcG9wdWxhdGUgaW5pdGlhbCB2YWx1ZXMgaW50byB5b3VyIGZvcm0sIHVzaW5nIGEgb25lLXdheSBiaW5kaW5nIGZvclxuICAgICAqIGBuZ01vZGVsYCB0ZW5kcyB0byBiZSBzdWZmaWNpZW50IGFzIGxvbmcgYXMgeW91IHVzZSB0aGUgZXhwb3J0ZWQgZm9ybSdzIHZhbHVlIHJhdGhlclxuICAgICAqIHRoYW4gdGhlIGRvbWFpbiBtb2RlbCdzIHZhbHVlIG9uIHN1Ym1pdC5cbiAgICAgKlxuICAgICAqIFRha2UgYSBsb29rIGF0IGFuIGV4YW1wbGUgb2YgdXNpbmcgYG5nTW9kZWxgIHdpdGhpbiBhIGZvcm06XG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybS9zaW1wbGVfZm9ybV9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIFRvIHNlZSBgbmdNb2RlbGAgZXhhbXBsZXMgd2l0aCBkaWZmZXJlbnQgZm9ybSBjb250cm9sIHR5cGVzLCBzZWU6XG4gICAgICpcbiAgICAgKiAqIFJhZGlvIGJ1dHRvbnM6IHtAbGluayBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICAgICAqICogU2VsZWN0czoge0BsaW5rIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqKk5nTW9kdWxlKio6IGBGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nTW9kZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNyhOZ01vZGVsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ01vZGVsKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jb250cm9sID0gbmV3IEZvcm1Db250cm9sKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3Nvcih0aGlzLCB2YWx1ZUFjY2Vzc29ycyk7XG4gICAgICAgIH1cbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JFcnJvcnMoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVnaXN0ZXJlZClcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRVcENvbnRyb2woKTtcbiAgICAgICAgICAgIGlmICgnaXNEaXNhYmxlZCcgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZm9ybURpcmVjdGl2ZSAmJiB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlQ29udHJvbCh0aGlzKTsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250cm9sOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IGNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KSA6IFt0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3Jhd1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3NldFVwQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU3RhbmRhbG9uZSgpID8gdGhpcy5fc2V0VXBTdGFuZGFsb25lKCkgOlxuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRDb250cm9sKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9pc1N0YW5kYWxvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3BhcmVudCB8fCAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5zdGFuZGFsb25lKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3NldFVwU3RhbmRhbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFVwQ29udHJvbCh0aGlzLl9jb250cm9sLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9jaGVja0ZvckVycm9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNTdGFuZGFsb25lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1BhcmVudFR5cGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTmFtZSgpO1xuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fY2hlY2tQYXJlbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdNb2RlbEdyb3VwKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMuZm9ybUdyb3VwTmFtZUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ01vZGVsR3JvdXApICYmICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdGb3JtKSkge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1vZGVsUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9jaGVja05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5uYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMub3B0aW9ucy5uYW1lO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1N0YW5kYWxvbmUoKSAmJiAhdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubWlzc2luZ05hbWVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbihmdW5jdGlvbiAoKSB7IF90aGlzLmNvbnRyb2wuc2V0VmFsdWUodmFsdWUsIHsgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZSB9KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl91cGRhdGVEaXNhYmxlZCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRpc2FibGVkVmFsdWUgPSBjaGFuZ2VzWydpc0Rpc2FibGVkJ10uY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBkaXNhYmxlZFZhbHVlID09PSAnJyB8fCAoZGlzYWJsZWRWYWx1ZSAmJiBkaXNhYmxlZFZhbHVlICE9PSAnZmFsc2UnKTtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSQxLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkICYmICFfdGhpcy5jb250cm9sLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEaXNhYmxlZCAmJiBfdGhpcy5jb250cm9sLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ01vZGVsXTpub3QoW2Zvcm1Db250cm9sTmFtZV0pOm5vdChbZm9ybUNvbnRyb2xdKScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtmb3JtQ29udHJvbEJpbmRpbmddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ01vZGVsJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nTW9kZWwuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxVRV9BQ0NFU1NPUixdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ01vZGVsLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICdpc0Rpc2FibGVkJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydkaXNhYmxlZCcsXSB9LF0sXG4gICAgICAgICAgICAnbW9kZWwnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWwnLF0gfSxdLFxuICAgICAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWxPcHRpb25zJyxdIH0sXSxcbiAgICAgICAgICAgICd1cGRhdGUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk91dHB1dCwgYXJnczogWyduZ01vZGVsQ2hhbmdlJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kZWw7XG4gICAgfShOZ0NvbnRyb2wpKTtcblxuICAgIHZhciBSZWFjdGl2ZUVycm9ycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlYWN0aXZlRXJyb3JzKCkge1xuICAgICAgICB9XG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLmNvbnRyb2xQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtQ29udHJvbE5hbWUgbXVzdCBiZSB1c2VkIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwIGRpcmVjdGl2ZS4gIFlvdSdsbCB3YW50IHRvIGFkZCBhIGZvcm1Hcm91cFxcbiAgICAgICBkaXJlY3RpdmUgYW5kIHBhc3MgaXQgYW4gZXhpc3RpbmcgRm9ybUdyb3VwIGluc3RhbmNlICh5b3UgY2FuIGNyZWF0ZSBvbmUgaW4geW91ciBjbGFzcykuXFxuXFxuICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Db250cm9sTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLm5nTW9kZWxHcm91cEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Db250cm9sTmFtZSBjYW5ub3QgYmUgdXNlZCB3aXRoIGFuIG5nTW9kZWxHcm91cCBwYXJlbnQuIEl0IGlzIG9ubHkgY29tcGF0aWJsZSB3aXRoIHBhcmVudHNcXG4gICAgICAgdGhhdCBhbHNvIGhhdmUgYSBcXFwiZm9ybVxcXCIgcHJlZml4OiBmb3JtR3JvdXBOYW1lLCBmb3JtQXJyYXlOYW1lLCBvciBmb3JtR3JvdXAuXFxuXFxuICAgICAgIE9wdGlvbiAxOiAgVXBkYXRlIHRoZSBwYXJlbnQgdG8gYmUgZm9ybUdyb3VwTmFtZSAocmVhY3RpdmUgZm9ybSBzdHJhdGVneSlcXG5cXG4gICAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSArIFwiXFxuXFxuICAgICAgICBPcHRpb24gMjogVXNlIG5nTW9kZWwgaW5zdGVhZCBvZiBmb3JtQ29udHJvbE5hbWUgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSlcXG5cXG4gICAgICAgIFwiICsgRXhhbXBsZXMubmdNb2RlbEdyb3VwKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RpdmVFcnJvcnMubWlzc2luZ0Zvcm1FeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtR3JvdXAgZXhwZWN0cyBhIEZvcm1Hcm91cCBpbnN0YW5jZS4gUGxlYXNlIHBhc3Mgb25lIGluLlxcblxcbiAgICAgICBFeGFtcGxlOlxcblxcbiAgICAgICBcIiArIEV4YW1wbGVzLmZvcm1Db250cm9sTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLmdyb3VwUGFyZW50RXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybUdyb3VwTmFtZSBtdXN0IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgWW91J2xsIHdhbnQgdG8gYWRkIGEgZm9ybUdyb3VwXFxuICAgICAgZGlyZWN0aXZlIGFuZCBwYXNzIGl0IGFuIGV4aXN0aW5nIEZvcm1Hcm91cCBpbnN0YW5jZSAoeW91IGNhbiBjcmVhdGUgb25lIGluIHlvdXIgY2xhc3MpLlxcblxcbiAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtR3JvdXBOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuYXJyYXlQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtQXJyYXlOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcXG4gICAgICAgZGlyZWN0aXZlIGFuZCBwYXNzIGl0IGFuIGV4aXN0aW5nIEZvcm1Hcm91cCBpbnN0YW5jZSAoeW91IGNhbiBjcmVhdGUgb25lIGluIHlvdXIgY2xhc3MpLlxcblxcbiAgICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUFycmF5TmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLmRpc2FibGVkQXR0cldhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcXG4gICAgICBJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyB0aGUgZGlzYWJsZWQgYXR0cmlidXRlIHdpdGggYSByZWFjdGl2ZSBmb3JtIGRpcmVjdGl2ZS4gSWYgeW91IHNldCBkaXNhYmxlZCB0byB0cnVlXFxuICAgICAgd2hlbiB5b3Ugc2V0IHVwIHRoaXMgY29udHJvbCBpbiB5b3VyIGNvbXBvbmVudCBjbGFzcywgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSB3aWxsIGFjdHVhbGx5IGJlIHNldCBpbiB0aGUgRE9NIGZvclxcbiAgICAgIHlvdS4gV2UgcmVjb21tZW5kIHVzaW5nIHRoaXMgYXBwcm9hY2ggdG8gYXZvaWQgJ2NoYW5nZWQgYWZ0ZXIgY2hlY2tlZCcgZXJyb3JzLlxcbiAgICAgICBcXG4gICAgICBFeGFtcGxlOiBcXG4gICAgICBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XFxuICAgICAgICBmaXJzdDogbmV3IEZvcm1Db250cm9sKHt2YWx1ZTogJ05hbmN5JywgZGlzYWJsZWQ6IHRydWV9LCBWYWxpZGF0b3JzLnJlcXVpcmVkKSxcXG4gICAgICAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgnRHJldycsIFZhbGlkYXRvcnMucmVxdWlyZWQpXFxuICAgICAgfSk7XFxuICAgIFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlYWN0aXZlRXJyb3JzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ5ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGZvcm1Db250cm9sQmluZGluZyQxID0ge1xuICAgICAgICBwcm92aWRlOiBOZ0NvbnRyb2wsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUNvbnRyb2xEaXJlY3RpdmU7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBTeW5jcyBhIHN0YW5kYWxvbmUge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSB0byBhIGZvcm0gY29udHJvbCBlbGVtZW50LlxuICAgICAqXG4gICAgICogSW4gb3RoZXIgd29yZHMsIHRoaXMgZGlyZWN0aXZlIGVuc3VyZXMgdGhhdCBhbnkgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIHtAbGluayBGb3JtQ29udHJvbH1cbiAgICAgKiBpbnN0YW5jZSBwcm9ncmFtbWF0aWNhbGx5IHdpbGwgYmUgd3JpdHRlbiB0byB0aGUgRE9NIGVsZW1lbnQgKG1vZGVsIC0+IHZpZXcpLiBDb252ZXJzZWx5LFxuICAgICAqIGFueSB2YWx1ZXMgd3JpdHRlbiB0byB0aGUgRE9NIGVsZW1lbnQgdGhyb3VnaCB1c2VyIGlucHV0IHdpbGwgYmUgcmVmbGVjdGVkIGluIHRoZVxuICAgICAqIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgKHZpZXcgLT4gbW9kZWwpLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBkaXJlY3RpdmUgaWYgeW91J2QgbGlrZSB0byBjcmVhdGUgYW5kIG1hbmFnZSBhIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgZGlyZWN0bHkuXG4gICAgICogU2ltcGx5IGNyZWF0ZSBhIHtAbGluayBGb3JtQ29udHJvbH0sIHNhdmUgaXQgdG8geW91ciBjb21wb25lbnQgY2xhc3MsIGFuZCBwYXNzIGl0IGludG8gdGhlXG4gICAgICoge0BsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfS5cbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgYXMgYSBzdGFuZGFsb25lIGNvbnRyb2wuICBVbmxpa2Uge0BsaW5rIEZvcm1Db250cm9sTmFtZX0sXG4gICAgICogaXQgZG9lcyBub3QgcmVxdWlyZSB0aGF0IHlvdXIge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSBiZSBwYXJ0IG9mIGFueSBwYXJlbnRcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSwgYW5kIGl0IHdvbid0IGJlIHJlZ2lzdGVyZWQgdG8gYW55IHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9IHRoYXRcbiAgICAgKiBleGlzdHMgYWJvdmUgaXQuXG4gICAgICpcbiAgICAgKiAqKkdldCB0aGUgdmFsdWUqKjogdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgYWx3YXlzIHN5bmNlZCBhbmQgYXZhaWxhYmxlIG9uIHRoZVxuICAgICAqIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UuIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpblxuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2x9LlxuICAgICAqXG4gICAgICogKipTZXQgdGhlIHZhbHVlKio6IFlvdSBjYW4gcGFzcyBpbiBhbiBpbml0aWFsIHZhbHVlIHdoZW4gaW5zdGFudGlhdGluZyB0aGUge0BsaW5rIEZvcm1Db250cm9sfSxcbiAgICAgKiBvciB5b3UgY2FuIHNldCBpdCBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfS5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbC52YWx1ZUNoYW5nZXN9IGV2ZW50LiAgWW91IGNhbiBhbHNvIGxpc3RlbiB0b1xuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXNcbiAgICAgKiByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtQ29udHJvbC9zaW1wbGVfZm9ybV9jb250cm9sX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgUmVhY3RpdmVGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Db250cm9sRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoRm9ybUNvbnRyb2xEaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Db250cm9sRGlyZWN0aXZlKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9yYXdWYWxpZGF0b3JzID0gdmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNEaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7IFJlYWN0aXZlRXJyb3JzLmRpc2FibGVkQXR0cldhcm5pbmcoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNDb250cm9sQ2hhbmdlZChjaGFuZ2VzKSkge1xuICAgICAgICAgICAgICAgIHNldFVwQ29udHJvbCh0aGlzLmZvcm0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wuZGlzYWJsZWQgJiYgdGhpcy52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZm9ybS51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm0uc2V0VmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fcmF3VmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLnZpZXdUb01vZGVsVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUuZW1pdChuZXdWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5faXNDb250cm9sQ2hhbmdlZCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnZm9ybScpO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUNvbnRyb2xdJywgcHJvdmlkZXJzOiBbZm9ybUNvbnRyb2xCaW5kaW5nJDFdLCBleHBvcnRBczogJ25nRm9ybScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTFVFX0FDQ0VTU09SLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ2Zvcm0nOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Db250cm9sJyxdIH0sXSxcbiAgICAgICAgICAgICdtb2RlbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbCcsXSB9LF0sXG4gICAgICAgICAgICAndXBkYXRlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PdXRwdXQsIGFyZ3M6IFsnbmdNb2RlbENoYW5nZScsXSB9LF0sXG4gICAgICAgICAgICAnaXNEaXNhYmxlZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZGlzYWJsZWQnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUNvbnRyb2xEaXJlY3RpdmU7XG4gICAgfShOZ0NvbnRyb2wpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDExID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGZvcm1EaXJlY3RpdmVQcm92aWRlciQxID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1Hcm91cERpcmVjdGl2ZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIEJpbmRzIGFuIGV4aXN0aW5nIHtAbGluayBGb3JtR3JvdXB9IHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGFjY2VwdHMgYW4gZXhpc3Rpbmcge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UuIEl0IHdpbGwgdGhlbiB1c2UgdGhpc1xuICAgICAqIHtAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIHRvIG1hdGNoIGFueSBjaGlsZCB7QGxpbmsgRm9ybUNvbnRyb2x9LCB7QGxpbmsgRm9ybUdyb3VwfSxcbiAgICAgKiBhbmQge0BsaW5rIEZvcm1BcnJheX0gaW5zdGFuY2VzIHRvIGNoaWxkIHtAbGluayBGb3JtQ29udHJvbE5hbWV9LCB7QGxpbmsgRm9ybUdyb3VwTmFtZX0sXG4gICAgICogYW5kIHtAbGluayBGb3JtQXJyYXlOYW1lfSBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogKipTZXQgdmFsdWUqKjogWW91IGNhbiBzZXQgdGhlIGZvcm0ncyBpbml0aWFsIHZhbHVlIHdoZW4gaW5zdGFudGlhdGluZyB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSwgb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZyB0aGUge0BsaW5rIEZvcm1Hcm91cH0nc1xuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtAbGluayBBYnN0cmFjdENvbnRyb2wucGF0Y2hWYWx1ZX0gbWV0aG9kcy5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgZm9ybSwgeW91IGNhbiBzdWJzY3JpYmVcbiAgICAgKiB0byB0aGUge0BsaW5rIEZvcm1Hcm91cH0ncyB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICogaXRzIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXNcbiAgICAgKiByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogRnVydGhlcm1vcmUsIHlvdSBjYW4gbGlzdGVuIHRvIHRoZSBkaXJlY3RpdmUncyBgbmdTdWJtaXRgIGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHVzZXIgaGFzXG4gICAgICogdHJpZ2dlcmVkIGEgZm9ybSBzdWJtaXNzaW9uLiBUaGUgYG5nU3VibWl0YCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgZm9ybVxuICAgICAqIHN1Ym1pc3Npb24gZXZlbnQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogSW4gdGhpcyBleGFtcGxlLCB3ZSBjcmVhdGUgZm9ybSBjb250cm9scyBmb3IgZmlyc3QgbmFtZSBhbmQgbGFzdCBuYW1lLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm1Hcm91cC9zaW1wbGVfZm9ybV9ncm91cF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKipOZ01vZHVsZSoqOiB7QGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX1cbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Hcm91cERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMShGb3JtR3JvdXBEaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Hcm91cERpcmVjdGl2ZShfdmFsaWRhdG9ycywgX2FzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gX3ZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBfYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5nU3VibWl0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JtUHJlc2VudCgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2Zvcm0nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZhbGlkYXRvcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEb21WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJlZ2lzdHJhdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3VibWl0dGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3VibWl0dGVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgIHNldFVwQ29udHJvbChjdHJsLCBkaXIpO1xuICAgICAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5wdXNoKGRpcik7XG4gICAgICAgICAgICByZXR1cm4gY3RybDtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5nZXRDb250cm9sID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHsgTGlzdFdyYXBwZXIucmVtb3ZlKHRoaXMuZGlyZWN0aXZlcywgZGlyKTsgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5hZGRGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgY3RybCA9IHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgc2V0VXBGb3JtQ29udGFpbmVyKGN0cmwsIGRpcik7XG4gICAgICAgICAgICBjdHJsLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnJlbW92ZUZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHsgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5nZXRGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTsgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5hZGRGb3JtQXJyYXkgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgY3RybCA9IHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgc2V0VXBGb3JtQ29udGFpbmVyKGN0cmwsIGRpcik7XG4gICAgICAgICAgICBjdHJsLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnJlbW92ZUZvcm1BcnJheSA9IGZ1bmN0aW9uIChkaXIpIHsgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5nZXRGb3JtQXJyYXkgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTsgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uIChkaXIsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY3RybCA9IHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgY3RybC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUub25TdWJtaXQgPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdC5lbWl0KCRldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUub25SZXNldCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5yZXNldEZvcm0oKTsgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5yZXNldEZvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICB0aGlzLmZvcm0ucmVzZXQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5fdXBkYXRlRG9tVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgICAgIHZhciBuZXdDdHJsID0gX3RoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIuX2NvbnRyb2wgIT09IG5ld0N0cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5VcENvbnRyb2woZGlyLl9jb250cm9sLCBkaXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q3RybClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFVwQ29udHJvbChuZXdDdHJsLCBkaXIpO1xuICAgICAgICAgICAgICAgICAgICBkaXIuX2NvbnRyb2wgPSBuZXdDdHJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5mb3JtLl91cGRhdGVUcmVlVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVSZWdpc3RyYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZm9ybS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3VwZGF0ZURvbVZhbHVlKCk7IH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29sZEZvcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5fb2xkRm9ybS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29sZEZvcm0gPSB0aGlzLmZvcm07XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZVZhbGlkYXRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3luYyA9IGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgdGhpcy5mb3JtLnZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbdGhpcy5mb3JtLnZhbGlkYXRvciwgc3luY10pO1xuICAgICAgICAgICAgdmFyIGFzeW5jID0gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgdGhpcy5mb3JtLmFzeW5jVmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMoW3RoaXMuZm9ybS5hc3luY1ZhbGlkYXRvciwgYXN5bmNdKTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5fY2hlY2tGb3JtUHJlc2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JtKSB7XG4gICAgICAgICAgICAgICAgUmVhY3RpdmVFcnJvcnMubWlzc2luZ0Zvcm1FeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbZm9ybUdyb3VwXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtmb3JtRGlyZWN0aXZlUHJvdmlkZXIkMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoc3VibWl0KSc6ICdvblN1Ym1pdCgkZXZlbnQpJywgJyhyZXNldCknOiAnb25SZXNldCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ0Zvcm0nXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnZm9ybSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUdyb3VwJyxdIH0sXSxcbiAgICAgICAgICAgICduZ1N1Ym1pdCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3V0cHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Hcm91cERpcmVjdGl2ZTtcbiAgICB9KENvbnRyb2xDb250YWluZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGZvcm1Hcm91cE5hbWVQcm92aWRlciA9IHtcbiAgICAgICAgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBGb3JtR3JvdXBOYW1lOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgU3luY3MgYSBuZXN0ZWQge0BsaW5rIEZvcm1Hcm91cH0gdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGEgcGFyZW50IHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9IChzZWxlY3RvcjpcbiAgICAgKiBgW2Zvcm1Hcm91cF1gKS5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgdGhlIHN0cmluZyBuYW1lIG9mIHRoZSBuZXN0ZWQge0BsaW5rIEZvcm1Hcm91cH0geW91IHdhbnQgdG8gbGluaywgYW5kXG4gICAgICogd2lsbCBsb29rIGZvciBhIHtAbGluayBGb3JtR3JvdXB9IHJlZ2lzdGVyZWQgd2l0aCB0aGF0IG5hbWUgaW4gdGhlIHBhcmVudFxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIHlvdSBwYXNzZWQgaW50byB7QGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfS5cbiAgICAgKlxuICAgICAqIE5lc3RlZCBmb3JtIGdyb3VwcyBjYW4gY29tZSBpbiBoYW5keSB3aGVuIHlvdSB3YW50IHRvIHZhbGlkYXRlIGEgc3ViLWdyb3VwIG9mIGFcbiAgICAgKiBmb3JtIHNlcGFyYXRlbHkgZnJvbSB0aGUgcmVzdCBvciB3aGVuIHlvdSdkIGxpa2UgdG8gZ3JvdXAgdGhlIHZhbHVlcyBvZiBjZXJ0YWluXG4gICAgICogY29udHJvbHMgaW50byB0aGVpciBvd24gbmVzdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqQWNjZXNzIHRoZSBncm91cCoqOiBZb3UgY2FuIGFjY2VzcyB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgRm9ybUdyb3VwfSB1c2luZyB0aGVcbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sLmdldH0gbWV0aG9kLiBFeDogYHRoaXMuZm9ybS5nZXQoJ25hbWUnKWAuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gYWNjZXNzIGluZGl2aWR1YWwgY29udHJvbHMgd2l0aGluIHRoZSBncm91cCB1c2luZyBkb3Qgc3ludGF4LlxuICAgICAqIEV4OiBgdGhpcy5mb3JtLmdldCgnbmFtZS5maXJzdCcpYFxuICAgICAqXG4gICAgICogKipHZXQgdGhlIHZhbHVlKio6IHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIGFsd2F5cyBzeW5jZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfS4gU2VlIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIGluIHtAbGluayBBYnN0cmFjdENvbnRyb2x9LlxuICAgICAqXG4gICAgICogKipTZXQgdGhlIHZhbHVlKio6IFlvdSBjYW4gc2V0IGFuIGluaXRpYWwgdmFsdWUgZm9yIGVhY2ggY2hpbGQgY29udHJvbCB3aGVuIGluc3RhbnRpYXRpbmdcbiAgICAgKiB0aGUge0BsaW5rIEZvcm1Hcm91cH0sIG9yIHlvdSBjYW4gc2V0IGl0IHByb2dyYW1tYXRpY2FsbHkgbGF0ZXIgdXNpbmdcbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnNldFZhbHVlfSBvciB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnBhdGNoVmFsdWV9LlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBncm91cCwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbC52YWx1ZUNoYW5nZXN9IGV2ZW50LiAgWW91IGNhbiBhbHNvIGxpc3RlbiB0b1xuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXNcbiAgICAgKiByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9uZXN0ZWRGb3JtR3JvdXAvbmVzdGVkX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBSZWFjdGl2ZUZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtR3JvdXBOYW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEyKEZvcm1Hcm91cE5hbWUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Hcm91cE5hbWUocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IHZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXBOYW1lLnByb3RvdHlwZS5fY2hlY2tQYXJlbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF9oYXNJbnZhbGlkUGFyZW50KHRoaXMuX3BhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5ncm91cFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBOYW1lLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtR3JvdXBOYW1lXScsIHByb3ZpZGVyczogW2Zvcm1Hcm91cE5hbWVQcm92aWRlcl0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtR3JvdXBOYW1lLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZiB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgRm9ybUdyb3VwTmFtZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydmb3JtR3JvdXBOYW1lJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Hcm91cE5hbWU7XG4gICAgfShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSkpO1xuICAgIHZhciBmb3JtQXJyYXlOYW1lUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUFycmF5TmFtZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFN5bmNzIGEgbmVzdGVkIHtAbGluayBGb3JtQXJyYXl9IHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgd2l0aCBhIHBhcmVudCB7QGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfSAoc2VsZWN0b3I6XG4gICAgICogYFtmb3JtR3JvdXBdYCkuXG4gICAgICpcbiAgICAgKiBJdCBhY2NlcHRzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgbmVzdGVkIHtAbGluayBGb3JtQXJyYXl9IHlvdSB3YW50IHRvIGxpbmssIGFuZFxuICAgICAqIHdpbGwgbG9vayBmb3IgYSB7QGxpbmsgRm9ybUFycmF5fSByZWdpc3RlcmVkIHdpdGggdGhhdCBuYW1lIGluIHRoZSBwYXJlbnRcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSB5b3UgcGFzc2VkIGludG8ge0BsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0uXG4gICAgICpcbiAgICAgKiBOZXN0ZWQgZm9ybSBhcnJheXMgY2FuIGNvbWUgaW4gaGFuZHkgd2hlbiB5b3UgaGF2ZSBhIGdyb3VwIG9mIGZvcm0gY29udHJvbHMgYnV0XG4gICAgICogeW91J3JlIG5vdCBzdXJlIGhvdyBtYW55IHRoZXJlIHdpbGwgYmUuIEZvcm0gYXJyYXlzIGFsbG93IHlvdSB0byBjcmVhdGUgbmV3XG4gICAgICogZm9ybSBjb250cm9scyBkeW5hbWljYWxseS5cbiAgICAgKlxuICAgICAqICoqQWNjZXNzIHRoZSBhcnJheSoqOiBZb3UgY2FuIGFjY2VzcyB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgRm9ybUFycmF5fSB1c2luZyB0aGVcbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sLmdldH0gbWV0aG9kIG9uIHRoZSBwYXJlbnQge0BsaW5rIEZvcm1Hcm91cH0uXG4gICAgICogRXg6IGB0aGlzLmZvcm0uZ2V0KCdjaXRpZXMnKWAuXG4gICAgICpcbiAgICAgKiAqKkdldCB0aGUgdmFsdWUqKjogdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgYWx3YXlzIHN5bmNlZCBhbmQgYXZhaWxhYmxlIG9uIHRoZVxuICAgICAqIHtAbGluayBGb3JtQXJyYXl9LiBTZWUgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHByb3BlcnRpZXMgaW4ge0BsaW5rIEFic3RyYWN0Q29udHJvbH0uXG4gICAgICpcbiAgICAgKiAqKlNldCB0aGUgdmFsdWUqKjogWW91IGNhbiBzZXQgYW4gaW5pdGlhbCB2YWx1ZSBmb3IgZWFjaCBjaGlsZCBjb250cm9sIHdoZW4gaW5zdGFudGlhdGluZ1xuICAgICAqIHRoZSB7QGxpbmsgRm9ybUFycmF5fSwgb3IgeW91IGNhbiBzZXQgdGhlIHZhbHVlIHByb2dyYW1tYXRpY2FsbHkgbGF0ZXIgdXNpbmcgdGhlXG4gICAgICoge0BsaW5rIEZvcm1BcnJheX0ncyB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnNldFZhbHVlfSBvciB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnBhdGNoVmFsdWV9XG4gICAgICogbWV0aG9kcy5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgYXJyYXksIHlvdSBjYW5cbiAgICAgKiBzdWJzY3JpYmUgdG8gdGhlIHtAbGluayBGb3JtQXJyYXl9J3Mge0BsaW5rIEFic3RyYWN0Q29udHJvbC52YWx1ZUNoYW5nZXN9IGV2ZW50LiAgWW91IGNhbiBhbHNvXG4gICAgICogbGlzdGVuIHRvIGl0cyB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c0NoYW5nZXN9IGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHZhbGlkYXRpb25cbiAgICAgKiBzdGF0dXMgaXMgcmUtY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqICoqQWRkIG5ldyBjb250cm9scyoqOiBZb3UgY2FuIGFkZCBuZXcgY29udHJvbHMgdG8gdGhlIHtAbGluayBGb3JtQXJyYXl9IGR5bmFtaWNhbGx5IGJ5XG4gICAgICogY2FsbGluZyBpdHMge0BsaW5rIEZvcm1BcnJheS5wdXNofSBtZXRob2QuXG4gICAgICogIEV4OiBgdGhpcy5mb3JtLmdldCgnY2l0aWVzJykucHVzaChuZXcgRm9ybUNvbnRyb2woKSk7YFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9uZXN0ZWRGb3JtQXJyYXkvbmVzdGVkX2Zvcm1fYXJyYXlfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBSZWFjdGl2ZUZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQXJyYXlOYW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEyKEZvcm1BcnJheU5hbWUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1BcnJheU5hbWUocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IHZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgIH1cbiAgICAgICAgRm9ybUFycmF5TmFtZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1BhcmVudFR5cGUoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRGb3JtQXJyYXkodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1BcnJheU5hbWUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVGb3JtQXJyYXkodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtRGlyZWN0aXZlLmdldEZvcm1BcnJheSh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sUGF0aCh0aGlzLm5hbWUsIHRoaXMuX3BhcmVudCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5TmFtZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5TmFtZS5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX2FzeW5jVmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3RvdHlwZS5fY2hlY2tQYXJlbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF9oYXNJbnZhbGlkUGFyZW50KHRoaXMuX3BhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5hcnJheVBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtQXJyYXlOYW1lLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQXJyYXlOYW1lXScsIHByb3ZpZGVyczogW2Zvcm1BcnJheU5hbWVQcm92aWRlcl0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQXJyYXlOYW1lLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZiB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgRm9ybUFycmF5TmFtZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydmb3JtQXJyYXlOYW1lJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1BcnJheU5hbWU7XG4gICAgfShDb250cm9sQ29udGFpbmVyKSk7XG4gICAgZnVuY3Rpb24gX2hhc0ludmFsaWRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIHJldHVybiAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmICEocGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwRGlyZWN0aXZlKSAmJlxuICAgICAgICAgICAgIShwYXJlbnQgaW5zdGFuY2VvZiBGb3JtQXJyYXlOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBjb250cm9sTmFtZUJpbmRpbmcgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5nQ29udHJvbCxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBGb3JtQ29udHJvbE5hbWU7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyAgU3luY3MgYSB7QGxpbmsgRm9ybUNvbnRyb2x9IGluIGFuIGV4aXN0aW5nIHtAbGluayBGb3JtR3JvdXB9IHRvIGEgZm9ybSBjb250cm9sXG4gICAgICogZWxlbWVudCBieSBuYW1lLlxuICAgICAqXG4gICAgICogSW4gb3RoZXIgd29yZHMsIHRoaXMgZGlyZWN0aXZlIGVuc3VyZXMgdGhhdCBhbnkgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIHtAbGluayBGb3JtQ29udHJvbH1cbiAgICAgKiBpbnN0YW5jZSBwcm9ncmFtbWF0aWNhbGx5IHdpbGwgYmUgd3JpdHRlbiB0byB0aGUgRE9NIGVsZW1lbnQgKG1vZGVsIC0+IHZpZXcpLiBDb252ZXJzZWx5LFxuICAgICAqIGFueSB2YWx1ZXMgd3JpdHRlbiB0byB0aGUgRE9NIGVsZW1lbnQgdGhyb3VnaCB1c2VyIGlucHV0IHdpbGwgYmUgcmVmbGVjdGVkIGluIHRoZVxuICAgICAqIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgKHZpZXcgLT4gbW9kZWwpLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggYSBwYXJlbnQge0BsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0gKHNlbGVjdG9yOlxuICAgICAqIGBbZm9ybUdyb3VwXWApLlxuICAgICAqXG4gICAgICogSXQgYWNjZXB0cyB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgeW91IHdhbnQgdG9cbiAgICAgKiBsaW5rLCBhbmQgd2lsbCBsb29rIGZvciBhIHtAbGluayBGb3JtQ29udHJvbH0gcmVnaXN0ZXJlZCB3aXRoIHRoYXQgbmFtZSBpbiB0aGVcbiAgICAgKiBjbG9zZXN0IHtAbGluayBGb3JtR3JvdXB9IG9yIHtAbGluayBGb3JtQXJyYXl9IGFib3ZlIGl0LlxuICAgICAqXG4gICAgICogKipBY2Nlc3MgdGhlIGNvbnRyb2wqKjogWW91IGNhbiBhY2Nlc3MgdGhlIHtAbGluayBGb3JtQ29udHJvbH0gYXNzb2NpYXRlZCB3aXRoXG4gICAgICogdGhpcyBkaXJlY3RpdmUgYnkgdXNpbmcgdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2wuZ2V0fSBtZXRob2QuXG4gICAgICogRXg6IGB0aGlzLmZvcm0uZ2V0KCdmaXJzdCcpO2BcbiAgICAgKlxuICAgICAqICoqR2V0IHZhbHVlKio6IHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIGFsd2F5cyBzeW5jZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGUge0BsaW5rIEZvcm1Db250cm9sfS5cbiAgICAgKiBTZWUgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHByb3BlcnRpZXMgaW4ge0BsaW5rIEFic3RyYWN0Q29udHJvbH0uXG4gICAgICpcbiAgICAgKiAgKipTZXQgdmFsdWUqKjogWW91IGNhbiBzZXQgYW4gaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGNvbnRyb2wgd2hlbiBpbnN0YW50aWF0aW5nIHRoZVxuICAgICAqICB7QGxpbmsgRm9ybUNvbnRyb2x9LCBvciB5b3UgY2FuIHNldCBpdCBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nXG4gICAgICogIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtAbGluayBBYnN0cmFjdENvbnRyb2wucGF0Y2hWYWx1ZX0uXG4gICAgICpcbiAgICAgKiAqKkxpc3RlbiB0byB2YWx1ZSoqOiBJZiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wsIHlvdSBjYW5cbiAgICAgKiBzdWJzY3JpYmUgdG8gdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2wudmFsdWVDaGFuZ2VzfSBldmVudC4gIFlvdSBjYW4gYWxzbyBsaXN0ZW4gdG9cbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c0NoYW5nZXN9IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHZhbGlkYXRpb24gc3RhdHVzIGlzXG4gICAgICogcmUtY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGNyZWF0ZSBmb3JtIGNvbnRyb2xzIGZvciBmaXJzdCBuYW1lIGFuZCBsYXN0IG5hbWUuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybUdyb3VwL3NpbXBsZV9mb3JtX2dyb3VwX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogVG8gc2VlIGBmb3JtQ29udHJvbE5hbWVgIGV4YW1wbGVzIHdpdGggZGlmZmVyZW50IGZvcm0gY29udHJvbCB0eXBlcywgc2VlOlxuICAgICAqXG4gICAgICogKiBSYWRpbyBidXR0b25zOiB7QGxpbmsgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvcn1cbiAgICAgKiAqIFNlbGVjdHM6IHtAbGluayBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvcn1cbiAgICAgKlxuICAgICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKipOZ01vZHVsZSoqOiB7QGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX1cbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Db250cm9sTmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMChGb3JtQ29udHJvbE5hbWUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Db250cm9sTmFtZShwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJpc0Rpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHsgUmVhY3RpdmVFcnJvcnMuZGlzYWJsZWRBdHRyV2FybmluZygpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2FkZGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbCgpO1xuICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUudXBkYXRlTW9kZWwodGhpcywgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUNvbnRyb2wodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl9yYXdWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRyb2w7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBOYW1lKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgUmVhY3RpdmVFcnJvcnMubmdNb2RlbEdyb3VwRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwRGlyZWN0aXZlKSAmJlxuICAgICAgICAgICAgICAgICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUFycmF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5jb250cm9sUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUuX3NldFVwQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbCA9IHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRDb250cm9sKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbC5kaXNhYmxlZCAmJiB0aGlzLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Db250cm9sTmFtZV0nLCBwcm92aWRlcnM6IFtjb250cm9sTmFtZUJpbmRpbmddIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ta2lwU2VsZiB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTFVFX0FDQ0VTU09SLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydmb3JtQ29udHJvbE5hbWUnLF0gfSxdLFxuICAgICAgICAgICAgJ21vZGVsJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ01vZGVsJyxdIH0sXSxcbiAgICAgICAgICAgICd1cGRhdGUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk91dHB1dCwgYXJnczogWyduZ01vZGVsQ2hhbmdlJyxdIH0sXSxcbiAgICAgICAgICAgICdpc0Rpc2FibGVkJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydkaXNhYmxlZCcsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQ29udHJvbE5hbWU7XG4gICAgfShOZ0NvbnRyb2wpKTtcblxuICAgIHZhciBSRVFVSVJFRF9WQUxJREFUT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gUmVxdWlyZWRWYWxpZGF0b3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBEaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgcmVxdWlyZWRgIHZhbGlkYXRvciB0byBhbnkgY29udHJvbHMgbWFya2VkIHdpdGggdGhlXG4gICAgICogYHJlcXVpcmVkYCBhdHRyaWJ1dGUsIHZpYSB0aGUge0BsaW5rIE5HX1ZBTElEQVRPUlN9IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGlucHV0IG5hbWU9XCJmdWxsTmFtZVwiIG5nTW9kZWwgcmVxdWlyZWQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFJlcXVpcmVkVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVxdWlyZWRWYWxpZGF0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlcXVpcmVkVmFsaWRhdG9yLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlcXVpcmVkOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1aXJlZCA9IHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlICYmIFwiXCIgKyB2YWx1ZSAhPT0gJ2ZhbHNlJztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVkID8gVmFsaWRhdG9ycy5yZXF1aXJlZChjKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLnByb3RvdHlwZS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbcmVxdWlyZWRdW2Zvcm1Db250cm9sTmFtZV0sW3JlcXVpcmVkXVtmb3JtQ29udHJvbF0sW3JlcXVpcmVkXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSRVFVSVJFRF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIucmVxdWlyZWRdJzogJ3JlcXVpcmVkID8gXCJcIiA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdyZXF1aXJlZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlciB3aGljaCBhZGRzIHtAbGluayBNaW5MZW5ndGhWYWxpZGF0b3J9IHRvIHtAbGluayBOR19WQUxJREFUT1JTfS5cbiAgICAgKlxuICAgICAqICMjIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL2Zvcm1zL3RzL3ZhbGlkYXRvcnMvdmFsaWRhdG9ycy50cyByZWdpb249J21pbid9XG4gICAgICovXG4gICAgdmFyIE1JTl9MRU5HVEhfVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1pbkxlbmd0aFZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpcmVjdGl2ZSB3aGljaCBpbnN0YWxscyB0aGUge0BsaW5rIE1pbkxlbmd0aFZhbGlkYXRvcn0gZm9yIGFueSBgZm9ybUNvbnRyb2xOYW1lYCxcbiAgICAgKiBgZm9ybUNvbnRyb2xgLCBvciBjb250cm9sIHdpdGggYG5nTW9kZWxgIHRoYXQgYWxzbyBoYXMgYSBgbWlubGVuZ3RoYCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE1pbkxlbmd0aFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1pbkxlbmd0aFZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICgnbWlubGVuZ3RoJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlVmFsaWRhdG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbmxlbmd0aCA9PSBudWxsID8gbnVsbCA6IHRoaXMuX3ZhbGlkYXRvcihjKTtcbiAgICAgICAgfTtcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUuX2NyZWF0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvciA9IFZhbGlkYXRvcnMubWluTGVuZ3RoKHBhcnNlSW50KHRoaXMubWlubGVuZ3RoLCAxMCkpO1xuICAgICAgICB9O1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttaW5sZW5ndGhdW2Zvcm1Db250cm9sTmFtZV0sW21pbmxlbmd0aF1bZm9ybUNvbnRyb2xdLFttaW5sZW5ndGhdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01JTl9MRU5HVEhfVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLm1pbmxlbmd0aF0nOiAnbWlubGVuZ3RoID8gbWlubGVuZ3RoIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbWlubGVuZ3RoJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNaW5MZW5ndGhWYWxpZGF0b3I7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlciB3aGljaCBhZGRzIHtAbGluayBNYXhMZW5ndGhWYWxpZGF0b3J9IHRvIHtAbGluayBOR19WQUxJREFUT1JTfS5cbiAgICAgKlxuICAgICAqICMjIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL2Zvcm1zL3RzL3ZhbGlkYXRvcnMvdmFsaWRhdG9ycy50cyByZWdpb249J21heCd9XG4gICAgICovXG4gICAgdmFyIE1BWF9MRU5HVEhfVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1heExlbmd0aFZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpcmVjdGl2ZSB3aGljaCBpbnN0YWxscyB0aGUge0BsaW5rIE1heExlbmd0aFZhbGlkYXRvcn0gZm9yIGFueSBgZm9ybUNvbnRyb2xOYW1lLFxuICAgICAqIGBmb3JtQ29udHJvbGAsXG4gICAgICogb3IgY29udHJvbCB3aXRoIGBuZ01vZGVsYCB0aGF0IGFsc28gaGFzIGEgYG1heGxlbmd0aGAgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBNYXhMZW5ndGhWYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNYXhMZW5ndGhWYWxpZGF0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoJ21heGxlbmd0aCcgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhsZW5ndGggIT0gbnVsbCA/IHRoaXMuX3ZhbGlkYXRvcihjKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLl9jcmVhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLm1heExlbmd0aChwYXJzZUludCh0aGlzLm1heGxlbmd0aCwgMTApKTtcbiAgICAgICAgfTtcbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWF4bGVuZ3RoXVtmb3JtQ29udHJvbE5hbWVdLFttYXhsZW5ndGhdW2Zvcm1Db250cm9sXSxbbWF4bGVuZ3RoXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNQVhfTEVOR1RIX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5tYXhsZW5ndGhdJzogJ21heGxlbmd0aCA/IG1heGxlbmd0aCA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ21heGxlbmd0aCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWF4TGVuZ3RoVmFsaWRhdG9yO1xuICAgIH0oKSk7XG4gICAgdmFyIFBBVFRFUk5fVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBhdHRlcm5WYWxpZGF0b3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBEaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgcGF0dGVybmAgdmFsaWRhdG9yIHRvIGFueSBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAgICAgKiBgcGF0dGVybmAgYXR0cmlidXRlLCB2aWEgdGhlIHtAbGluayBOR19WQUxJREFUT1JTfSBiaW5kaW5nLiBVc2VzIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIGFzIHRoZSByZWdleCB0byB2YWxpZGF0ZSBDb250cm9sIHZhbHVlIGFnYWluc3QuICBGb2xsb3dzIHBhdHRlcm4gYXR0cmlidXRlXG4gICAgICogc2VtYW50aWNzOyBpLmUuIHJlZ2V4IG11c3QgbWF0Y2ggZW50aXJlIENvbnRyb2wgdmFsdWUuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGlucHV0IFtuYW1lXT1cImZ1bGxOYW1lXCIgcGF0dGVybj1cIlthLXpBLVogXSpcIiBuZ01vZGVsPlxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUGF0dGVyblZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBhdHRlcm5WYWxpZGF0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKCdwYXR0ZXJuJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlVmFsaWRhdG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiB0aGlzLl92YWxpZGF0b3IoYyk7IH07XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm90b3R5cGUuX2NyZWF0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5wYXR0ZXJuKHRoaXMucGF0dGVybik7IH07XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1twYXR0ZXJuXVtmb3JtQ29udHJvbE5hbWVdLFtwYXR0ZXJuXVtmb3JtQ29udHJvbF0sW3BhdHRlcm5dW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1BBVFRFUk5fVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLnBhdHRlcm5dJzogJ3BhdHRlcm4gPyBwYXR0ZXJuIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdwYXR0ZXJuJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQYXR0ZXJuVmFsaWRhdG9yO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBDcmVhdGVzIGFuIHtAbGluayBBYnN0cmFjdENvbnRyb2x9IGZyb20gYSB1c2VyLXNwZWNpZmllZCBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogSXQgaXMgZXNzZW50aWFsbHkgc3ludGFjdGljIHN1Z2FyIHRoYXQgc2hvcnRlbnMgdGhlIGBuZXcgRm9ybUdyb3VwKClgLFxuICAgICAqIGBuZXcgRm9ybUNvbnRyb2woKWAsIGFuZCBgbmV3IEZvcm1BcnJheSgpYCBib2lsZXJwbGF0ZSB0aGF0IGNhbiBidWlsZCB1cCBpbiBsYXJnZXJcbiAgICAgKiBmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVG8gdXNlLCBpbmplY3QgYEZvcm1CdWlsZGVyYCBpbnRvIHlvdXIgY29tcG9uZW50IGNsYXNzLiBZb3UgY2FuIHRoZW4gY2FsbCBpdHMgbWV0aG9kc1xuICAgICAqIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL2Zvcm1CdWlsZGVyL2Zvcm1fYnVpbGRlcl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogICogKipOZ01vZHVsZSoqOiB7QGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX1cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBGb3JtQnVpbGRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IHtAbGluayBGb3JtR3JvdXB9IHdpdGggdGhlIGdpdmVuIG1hcCBvZiBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBWYWxpZCBrZXlzIGZvciB0aGUgYGV4dHJhYCBwYXJhbWV0ZXIgbWFwIGFyZSBgdmFsaWRhdG9yYCBhbmQgYGFzeW5jVmFsaWRhdG9yYC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIHRoZSB7QGxpbmsgRm9ybUdyb3VwfSBjb25zdHJ1Y3RvciBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnLCBleHRyYSkge1xuICAgICAgICAgICAgaWYgKGV4dHJhID09PSB2b2lkIDApIHsgZXh0cmEgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgY29udHJvbHMgPSB0aGlzLl9yZWR1Y2VDb250cm9scyhjb250cm9sc0NvbmZpZyk7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gaXNQcmVzZW50KGV4dHJhKSA/IGV4dHJhWyd2YWxpZGF0b3InXSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgYXN5bmNWYWxpZGF0b3IgPSBpc1ByZXNlbnQoZXh0cmEpID8gZXh0cmFbJ2FzeW5jVmFsaWRhdG9yJ10gOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtR3JvdXAoY29udHJvbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IHtAbGluayBGb3JtQ29udHJvbH0gd2l0aCB0aGUgZ2l2ZW4gYGZvcm1TdGF0ZWAsYHZhbGlkYXRvcmAsIGFuZFxuICAgICAgICAgKiBgYXN5bmNWYWxpZGF0b3JgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgZm9ybVN0YXRlYCBjYW4gZWl0aGVyIGJlIGEgc3RhbmRhbG9uZSB2YWx1ZSBmb3IgdGhlIGZvcm0gY29udHJvbCBvciBhbiBvYmplY3RcbiAgICAgICAgICogdGhhdCBjb250YWlucyBib3RoIGEgdmFsdWUgYW5kIGEgZGlzYWJsZWQgc3RhdHVzLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmNvbnRyb2wgPSBmdW5jdGlvbiAoZm9ybVN0YXRlLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1Db250cm9sKGZvcm1TdGF0ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSB7QGxpbmsgRm9ybUFycmF5fSBmcm9tIHRoZSBnaXZlbiBgY29udHJvbHNDb25maWdgIGFycmF5IG9mXG4gICAgICAgICAqIGNvbmZpZ3VyYXRpb24sIHdpdGggdGhlIGdpdmVuIG9wdGlvbmFsIGB2YWxpZGF0b3JgIGFuZCBgYXN5bmNWYWxpZGF0b3JgLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gY29udHJvbHNDb25maWcubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5fY3JlYXRlQ29udHJvbChjKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1BcnJheShjb250cm9scywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLl9yZWR1Y2VDb250cm9scyA9IGZ1bmN0aW9uIChjb250cm9sc0NvbmZpZykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBjb250cm9scyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udHJvbHNDb25maWcpLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbHNbY29udHJvbE5hbWVdID0gX3RoaXMuX2NyZWF0ZUNvbnRyb2woY29udHJvbHNDb25maWdbY29udHJvbE5hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xzO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5fY3JlYXRlQ29udHJvbCA9IGZ1bmN0aW9uIChjb250cm9sQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbENvbmZpZyBpbnN0YW5jZW9mIEZvcm1Db250cm9sIHx8IGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBGb3JtR3JvdXAgfHxcbiAgICAgICAgICAgICAgICBjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgRm9ybUFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbnRyb2xDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY29udHJvbENvbmZpZ1swXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gY29udHJvbENvbmZpZy5sZW5ndGggPiAxID8gY29udHJvbENvbmZpZ1sxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGFzeW5jVmFsaWRhdG9yID0gY29udHJvbENvbmZpZy5sZW5ndGggPiAyID8gY29udHJvbENvbmZpZ1syXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbCh2YWx1ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sKGNvbnRyb2xDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtQnVpbGRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1CdWlsZGVyLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBGb3JtQnVpbGRlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFNIQVJFRF9GT1JNX0RJUkVDVElWRVMgPSBbXG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLCBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLCBEZWZhdWx0VmFsdWVBY2Nlc3NvciwgTnVtYmVyVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLCBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciwgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciwgTmdDb250cm9sU3RhdHVzLFxuICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cCwgUmVxdWlyZWRWYWxpZGF0b3IsIE1pbkxlbmd0aFZhbGlkYXRvciwgTWF4TGVuZ3RoVmFsaWRhdG9yLCBQYXR0ZXJuVmFsaWRhdG9yXG4gICAgXTtcbiAgICB2YXIgVEVNUExBVEVfRFJJVkVOX0RJUkVDVElWRVMgPSBbTmdNb2RlbCwgTmdNb2RlbEdyb3VwLCBOZ0Zvcm1dO1xuICAgIHZhciBSRUFDVElWRV9EUklWRU5fRElSRUNUSVZFUyA9IFtGb3JtQ29udHJvbERpcmVjdGl2ZSwgRm9ybUdyb3VwRGlyZWN0aXZlLCBGb3JtQ29udHJvbE5hbWUsIEZvcm1Hcm91cE5hbWUsIEZvcm1BcnJheU5hbWVdO1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZHVsZSB1c2VkIGZvciBzaGFyaW5nIGRpcmVjdGl2ZXMgYmV0d2VlbiBGb3Jtc01vZHVsZSBhbmQgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICAgICAqL1xuICAgIHZhciBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFNIQVJFRF9GT1JNX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBTSEFSRURfRk9STV9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuZyBtb2R1bGUgZm9yIGZvcm1zLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybXNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBGb3Jtc01vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBGb3Jtc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBURU1QTEFURV9EUklWRU5fRElSRUNUSVZFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1JhZGlvQ29udHJvbFJlZ2lzdHJ5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLCBURU1QTEFURV9EUklWRU5fRElSRUNUSVZFU11cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3Jtc01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gRm9ybXNNb2R1bGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmcgbW9kdWxlIGZvciByZWFjdGl2ZSBmb3Jtcy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFJlYWN0aXZlRm9ybXNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWFjdGl2ZUZvcm1zTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1JFQUNUSVZFX0RSSVZFTl9ESVJFQ1RJVkVTXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0Zvcm1CdWlsZGVyLCBSYWRpb0NvbnRyb2xSZWdpc3RyeV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSwgUkVBQ1RJVkVfRFJJVkVOX0RJUkVDVElWRVNdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gUmVhY3RpdmVGb3Jtc01vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgZXhwb3J0cy5BYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUgPSBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5BYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSA9IEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciA9IENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5Db250cm9sQ29udGFpbmVyID0gQ29udHJvbENvbnRhaW5lcjtcbiAgICBleHBvcnRzLk5HX1ZBTFVFX0FDQ0VTU09SID0gTkdfVkFMVUVfQUNDRVNTT1I7XG4gICAgZXhwb3J0cy5EZWZhdWx0VmFsdWVBY2Nlc3NvciA9IERlZmF1bHRWYWx1ZUFjY2Vzc29yO1xuICAgIGV4cG9ydHMuTmdDb250cm9sID0gTmdDb250cm9sO1xuICAgIGV4cG9ydHMuTmdDb250cm9sU3RhdHVzID0gTmdDb250cm9sU3RhdHVzO1xuICAgIGV4cG9ydHMuTmdDb250cm9sU3RhdHVzR3JvdXAgPSBOZ0NvbnRyb2xTdGF0dXNHcm91cDtcbiAgICBleHBvcnRzLk5nRm9ybSA9IE5nRm9ybTtcbiAgICBleHBvcnRzLk5nTW9kZWwgPSBOZ01vZGVsO1xuICAgIGV4cG9ydHMuTmdNb2RlbEdyb3VwID0gTmdNb2RlbEdyb3VwO1xuICAgIGV4cG9ydHMuUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciA9IFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5Gb3JtQ29udHJvbERpcmVjdGl2ZSA9IEZvcm1Db250cm9sRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuRm9ybUNvbnRyb2xOYW1lID0gRm9ybUNvbnRyb2xOYW1lO1xuICAgIGV4cG9ydHMuRm9ybUdyb3VwRGlyZWN0aXZlID0gRm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuRm9ybUFycmF5TmFtZSA9IEZvcm1BcnJheU5hbWU7XG4gICAgZXhwb3J0cy5Gb3JtR3JvdXBOYW1lID0gRm9ybUdyb3VwTmFtZTtcbiAgICBleHBvcnRzLk5nU2VsZWN0T3B0aW9uID0gTmdTZWxlY3RPcHRpb247XG4gICAgZXhwb3J0cy5TZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciA9IFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIGV4cG9ydHMuU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciA9IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5NYXhMZW5ndGhWYWxpZGF0b3IgPSBNYXhMZW5ndGhWYWxpZGF0b3I7XG4gICAgZXhwb3J0cy5NaW5MZW5ndGhWYWxpZGF0b3IgPSBNaW5MZW5ndGhWYWxpZGF0b3I7XG4gICAgZXhwb3J0cy5QYXR0ZXJuVmFsaWRhdG9yID0gUGF0dGVyblZhbGlkYXRvcjtcbiAgICBleHBvcnRzLlJlcXVpcmVkVmFsaWRhdG9yID0gUmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgZXhwb3J0cy5Gb3JtQnVpbGRlciA9IEZvcm1CdWlsZGVyO1xuICAgIGV4cG9ydHMuQWJzdHJhY3RDb250cm9sID0gQWJzdHJhY3RDb250cm9sO1xuICAgIGV4cG9ydHMuRm9ybUFycmF5ID0gRm9ybUFycmF5O1xuICAgIGV4cG9ydHMuRm9ybUNvbnRyb2wgPSBGb3JtQ29udHJvbDtcbiAgICBleHBvcnRzLkZvcm1Hcm91cCA9IEZvcm1Hcm91cDtcbiAgICBleHBvcnRzLk5HX0FTWU5DX1ZBTElEQVRPUlMgPSBOR19BU1lOQ19WQUxJREFUT1JTO1xuICAgIGV4cG9ydHMuTkdfVkFMSURBVE9SUyA9IE5HX1ZBTElEQVRPUlM7XG4gICAgZXhwb3J0cy5WYWxpZGF0b3JzID0gVmFsaWRhdG9ycztcbiAgICBleHBvcnRzLkZvcm1zTW9kdWxlID0gRm9ybXNNb2R1bGU7XG4gICAgZXhwb3J0cy5SZWFjdGl2ZUZvcm1zTW9kdWxlID0gUmVhY3RpdmVGb3Jtc01vZHVsZTtcblxufSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaG9tZScsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vaG9tZS5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vaG9tZS5jb21wb25lbnQubGVzcycpXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxufSlcblxuZXhwb3J0IGNsYXNzIEhvbWVDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdIb21lIENvbXBvbmVudCEnKTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGltZyBjbGFzcz1cXFwiaG9tZS1pbWFnZVxcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi9wdWJsaWMvYXNzZXRzL2ltYWdlcy9ob21lL2hvbWUuanBnXCIpICsgXCJcXFwiLz5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvaG9tZS5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9ob21lL2hvbWUuanBnXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL2hvbWUuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmhvbWUtaW1hZ2Uge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAwIHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjMDAwMDREO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhYm91dCcsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYWJvdXQuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2Fib3V0LmNvbXBvbmVudC5sZXNzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgQWJvdXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBYm91dCBDb21wb25lbnQhJyk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+QWJvdXQgVXM8L2gxPlxcbjxwPklsbGlub2lzIFVsdGltYXRlIGlzIG9uZSBvZiB0aGUgcHJlbWllciB1bHRpbWF0ZSBwcm9ncmFtcyBpbiB0aGUgTWlkd2VzdCBhbmQgZnJlcXVlbnRseSByYW5rcyBpbiB0aGUgTmF0aW9uYWwgdG9wIDI1LiBXZSBzdHJpdmUgdG8gY29udGVuZCB3aXRoIHRoZSBiZXN0IHByb2dyYW1zIGluIHRoZSBjb3VudHJ5IGFuZCBoYXZlIHF1YWxpZmllZCB0byBjb21wZXRlIGF0IE5hdGlvbmFscyA3IG9mIHRoZSBsYXN0IDEwIHllYXJzLiBXZSBhcmUgYSBwcm9ncmFtIHRoYXQgcHJpZGVzIGl0c2VsZiBvbiBkZXZlbG9waW5nIHBsYXllcnMgd2hvIGNvbWUgdG8gSWxsaW5vaXMgd2l0aCBubyBleHBlcmllbmNlIHBsYXlpbmcgY29tcGV0aXRpdmUgdWx0aW1hdGUuIFdlIHRlYWNoIGFsbCBsZXZlbHMgb2YgdWx0aW1hdGUsIGZyb20gdGhlIGJhc2ljcyBvZiB0aHJvd2luZyBhIGZvcmVoYW5kIGFsbCB0aGUgd2F5IHRvIHRocm93aW5nIGJvbWJzIGluIHRoZSB3b3JzdCBvZiB3ZWF0aGVyLjwvcD5cXG48aDIgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+TWlzc2lvbiBTdGF0ZW1lbnQ8L2gyPlxcbjxwPldlIHdhbnQgdG8gY29tcGV0ZSBhdCB0aGUgaGlnaGVzdCBsZXZlbCBwb3NzaWJsZSBpbiBjb2xsZWdlIHVsdGltYXRlIHdoaWxlIHJlbWFpbmluZyByZXNwZWN0ZnVsIHRvIG91ciBvcHBvbmVudHMuICBXZSB3YW50IHRvIGRldmVsb3AgYWxsIG91ciBvZiBwbGF5ZXJzIHRvIGJlY29tZSB0aGUgYmVzdCB0aGV5IGNhbiBiZSBhdCB1bHRpbWF0ZSwgYXMgd2VsbCBhcyBwbGF5ZXJzIHdobyBleGVtcGxpZnkgdGhlIHRydWUgbWVhbmluZyBvZiBzcG9ydHNtYW5zaGlwLCB3aGljaCBpcyBwaXZvdGFsIHRvIHRoZSBwcm9ncmVzcyBvZiB1bHRpbWF0ZSBmcmlzYmVlIGluIGl0cyBjdXJyZW50IHN0YXRlLjwvcD5cXG48aDIgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+VGVhbSBTdHJ1Y3R1cmUvQWZmaWxpYXRpb24gd2l0aCBVbml2ZXJzaXR5PC9oMj5cXG48cD5PdXIgdGVhbSBpcyBhIFJlZ2lzdGVyZWQgU3R1ZGVudCBPcmdhbml6YXRpb24gKFJTTykgYXQgdGhlIFVuaXZlcnNpdHkgb2YgSWxsaW5vaXMgYW5kIHdlIGFyZSBjbGFzc2lmaWVkIGFzIGEgY2x1YiBzcG9ydC4gV2UgcmVjZWl2ZSBzb21lIGZ1bmRpbmcgZnJvbSB0aGUgVW5pdmVyc2l0eSB0aGF0IGhlbHBzIHBheSBmb3Igb3VyIHRyYXZlbCBjb3N0cyBhbmQgaG90ZWxzIHdoaWxlIHdlIGFyZSBhdCB0b3VybmFtZW50cy48L3A+XFxuPHA+V2UgYXJlIGEgbWVtYmVyIG9mIHRoZSBVU0FVICBDb2xsZWdlIFNlcmllcyBhbmQgY29tcGV0ZSBpbiBhIHNlcmllcyBvZiB0b3VybmFtZW50cyB0aGF0ICBjdWxtaW5hdGUgaW4gdGhlIENvbGxlZ2UgQ2hhbXBpb25zaGlwcyBoZWxkIGV2ZXJ5IHllYXIgZHVyaW5nIE1lbW9yaWFsIERheSB3ZWVrZW5kLiBNb3N0LCBpZiBub3QgYWxsLCBzdGF0ZSBzY2hvb2xzIGhhdmUgZXN0YWJsaXNoZWQgdWx0aW1hdGUgdGVhbXMgYW5kIG1hbnkgc21hbGxlciBzY2hvb2xzIGhhdmUgdGVhbXMgYXMgd2VsbC4gIFdlIGNvbXBldGUgaW4gdGhlIElsbGlub2lzIGNvbmZlcmVuY2Ugd2hpY2ggaXMgYXMgeW91IGNhbiBndWVzcywgdGhlIHNjaG9vbHMgaW4gdGhlIHN0YXRlIG9mIElsbGlub2lzLiBUaGUgbmV4dCBsYXJnZXN0IGRpdmlzaW9uIGlzIHRoZSBHcmVhdCBMYWtlcyBSZWdpb24sIHdoaWNoIGluY2x1ZGVzIHRoZSBzdGF0ZXMgb2YgSWxsaW5vaXMsIEluZGlhbmEsIE1pY2hpZ2FuLCBhbmQgS2VudHVja3kuIFRoZSBmaW5hbCBzdGVwIGlzIHRoZSBhZm9yZW1lbnRpb25lZCBOYXRpb25hbCBDaGFtcGlvbnNoaXBzLjwvcD5cXG48cD5PdXIgcHJvZ3JhbSBpcyBzcGxpdCB1cCBpbnRvIHR3byB0ZWFtcywgQSBhbmQgQi4gT3VyIEEgdGVhbSBpcyBhIGdyb3VwIG9mIGluZGl2aWR1YWxzIHdobyBhcmUgdmVyeSBkZWRpY2F0ZWQgdG8gdGhlIHRlYW0gYW5kIHdobyBwdXQgaW4gYSBsYXJnZSBhbW91bnQgb2YgdGltZSBmb3IgcHJhY3RpY2VzIGFzIHdlbGwgYXMgdHJhaW5pbmcgb3V0c2lkZSBvZiBwcmFjdGljZXMuIE91ciBCIHRlYW0gaXMgbW9yZSBvcmllbnRlZCB0b3dhcmRzIHRoZSBkZXZlbG9wbWVudCBvZiB5b3VuZ2VyIG9yIGluZXhwZXJpZW5jZWQgcGxheWVycy4gQiB0ZWFtIHByb3ZpZGVzIGEgbXVjaCBtb3JlIHJlbGF4ZWQgYXRtb3NwaGVyZSBidXQgc3RpbGwgcmVtYWlucyBjb21wZXRpdGl2ZSB3aXRoIGFsbCBvdGhlciBCIHRlYW1zIGluIHRoZSByZWdpb24sIGFuZCBldmVuIGJlYXRzIHNvbWUgc21hbGxlciBzY2hvb2xzJyBBIHRlYW1zLjwvcD5cXG48cD5BIHRlYW0gaGFzIHRyeW91dHMgZWFjaCB5ZWFyLiBUaGlzIHllYXIncyB0cnlvdXRzIHdpbGwgY29uc2lzdCBvZiBmb3VyIGZhbGwgdG91cm5hbWVudHMuIFRoZXJlIHdpbGwgYmUgYSByb3VuZCBvZiBjdXRzIG1hZGUgYWZ0ZXIgdGhlIHNlY29uZCB0b3VybmFtZW50LiBUaGUgdHJ5b3V0IHJvc3RlciB3aWxsIHRoZW4gYmUgbmFycm93ZWQgZG93biB0byBvbmUgdGVhbSBiZWZvcmUgdGhlIGZpbmFsIHRvdXJuYW1lbnQgb2YgdGhlIGZhbGwsIHZpYSBjdXRzIG9uIGEgcm9sbGluZyBiYXNpcy4gUGxheWVycyBtYXkgYmUgbW92ZWQgYmV0d2VlbiB0aGUgQSBhbmQgQiB0ZWFtIHJvc3RlcnMgYXMgbmVjZXNzYXJ5LjwvcD5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvYWJvdXQvYWJvdXQuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vYWJvdXQuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJwIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvYWJvdXQvYWJvdXQuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFNwcmVhZHNoZWV0U2VydmljZSB9IGZyb20gXCIuLi9zZXJ2aWNlL2dvb2dsZS1zcHJlYWRzaGVldC5zZXJ2aWNlXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncHJvc3BlY3RpdmUtcGxheWVycycsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQubGVzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIFByb3NwZWN0aXZlUGxheWVyc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvLyBBUEkgdXJsIGZvciBvdXIgcGVyc29uYWwgc2VydmVyXG4gICAgcHJpdmF0ZSBnb29nbGVTaGVldHNBcGlVcmwgPSAnaHR0cHM6Ly9uaWNrLXByb3otZ29vZ2xlLXNoZWV0LWFwaS5oZXJva3VhcHAuY29tL3NoZWV0cy8xMWlqckhveXNpSXdzRmZFZ2diU05NOVk4VnZ6VTY1amV1aFEzdmtWNUZHdy9zaGVldEluZGV4LzIvcm93cy8nO1xuICAgIC8vIEFQSSB1cmwgZm9yIG91ciBiYWNrdXAgc2VydmVyIChzaGVldHN1IEFQSSlcbiAgICAvLyBwcml2YXRlIGdvb2dsZVNoZWV0c0JhY2t1cEFwaVVybCA9ICdodHRwczovL3NoZWV0c3UuY29tL2FwaXMvdjEuMC83YTAzMGFlNjBiN2QnO1xuICAgIHByaXZhdGUgZ29vZ2xlU2hlZXRzQmFja3VwQXBpVXJsID0gJyc7XG5cbiAgICAvLyBFcnJvciBtZXNzYWdlc1xuICAgIHByaXZhdGUgdmFsaWRhdGlvbkVycm9yczogc3RyaW5nID0gJ1BsZWFzZSBkbyBub3QgbGVhdmUgYW55IHJlcXVpcmVkIGZpZWxkcyBibGFuay4nO1xuICAgIHByaXZhdGUgc3VibWlzc2lvbkVycm9yOiBzdHJpbmcgPSAnQ291bGQgbm90IHN1Ym1pdCB0aGUgZm9ybSAgZHVlIHRvIGEgc2VydmVyIGVycm9yLiBQbGVhc2UgdHJ5IGFnYWluIHNvb24gb3IgY29udGFjdCB0aGUgd2ViIGFkbWlucy4nO1xuXG4gICAgLy8gRmlyc3QgbmFtZSBpbnB1dFxuICAgIHByaXZhdGUgZmlyc3ROYW1lOiBzdHJpbmc7XG4gICAgLy8gTGFzdCBuYW1lIGlucHV0XG4gICAgcHJpdmF0ZSBsYXN0TmFtZTogc3RyaW5nO1xuICAgIC8vIFJlYXNvbiBpbnB1dFxuICAgIHByaXZhdGUgZW1haWxBZGRyZXNzOiBzdHJpbmc7XG4gICAgLy8gVGltZSBpbnB1dFxuICAgIHByaXZhdGUgaG9tZXRvd246IHN0cmluZztcbiAgICAvLyBEYXkgaW5wdXRcbiAgICBwcml2YXRlIGhpZ2hzY2hvb2w6IHN0cmluZztcbiAgICAvLyBNb250aCBpbnB1dFxuICAgIHByaXZhdGUgbWFqb3I6IHN0cmluZztcbiAgICAvLyBFeHBlcmllbmNlIGlucHV0XG4gICAgcHJpdmF0ZSBleHBlcmllbmNlOiBzdHJpbmc7XG4gICAgLy8gT3RoZXIgQ2x1YnMgaW5wdXRcbiAgICBwcml2YXRlIG90aGVyQ2x1YnM6IHN0cmluZztcbiAgICAvLyBDb250YWN0IGlucHV0XG4gICAgcHJpdmF0ZSBjb250YWN0OiBzdHJpbmcgPSAnWWVzJztcbiAgICAvLyBCb29sZWFuIGluZGljYXRpbmcgaWYgb3VyIGZvcm0gaXMgaW4gdGhlIHByb2Nlc3Mgb2Ygc3VibWl0dGluZyAodG8gc2hvdyBvdXIgbG9hZGluZyBpY29uKVxuICAgIHByaXZhdGUgZm9ybUlzU3VibWl0dGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIC8vIEJvb2xlYW4gaW5kaWNhdGluZyBpZiBvdXIgZm9ybSB3YXMgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZCAodG8gc2hvdyBvdXIgc3VjY2VzcyBtZXNzYWdlKVxuICAgIHByaXZhdGUgc3VibWl0U3VjY2VzczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIC8vIEZvcm0gZXJyb3JzIG91dHB1dFxuICAgIHByaXZhdGUgZm9ybUVycm9yczogc3RyaW5nO1xuXG4gICAgLy8gQ29uc3RydWN0b3Igd2l0aCBvdXIgaHR0cCBzZXJ2aWNlIGluamVjdGVkXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBzcHJlYWRzaGVldFNlcnZpY2U6IFNwcmVhZHNoZWV0U2VydmljZSkge31cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge31cblxuICAgIGhhbmRsZVN1Ym1pdChldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuc3VibWl0U3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCF0aGlzLmZvcm1Jc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUVycm9ycyA9IHRoaXMudmFsaWRhdGlvbkVycm9ycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUlzU3VibWl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1FcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgXCJUaW1lc3RhbXBcIjogZGF0ZS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgIFwiRmlyc3QgTmFtZVwiOiB0aGlzLmZpcnN0TmFtZSxcbiAgICAgICAgICAgICAgICBcIkxhc3QgTmFtZVwiOiB0aGlzLmxhc3ROYW1lLFxuICAgICAgICAgICAgICAgIFwiRW1haWwgQWRkcmVzc1wiOiB0aGlzLmVtYWlsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBcIkhvbWV0b3duXCI6IHRoaXMuaG9tZXRvd24sXG4gICAgICAgICAgICAgICAgXCJIaWdoc2Nob29sXCI6IHRoaXMuaGlnaHNjaG9vbCxcbiAgICAgICAgICAgICAgICBcIk1ham9yXCI6IHRoaXMubWFqb3IsXG4gICAgICAgICAgICAgICAgXCJFeHBlcmllbmNlXCI6IHRoaXMuZXhwZXJpZW5jZSxcbiAgICAgICAgICAgICAgICBcIk90aGVyIENsdWJzXCI6IHRoaXMub3RoZXJDbHVicyxcbiAgICAgICAgICAgICAgICBcIkNvbnRhY3QgTWVcIjogdGhpcy5jb250YWN0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdWJtaXRBYnNlbnRGb3JtKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3VibWl0cyBvdXIgZm9ybSB0byB0aGUgc3ByZWFkc2hlZXQgYnkgY2FsbGluZyBvdXIgc2VydmljZSBtZXRob2QuXG4gICAgICogT24gc3VjY2Vzcywgd2Ugc2hvdyBvdXIgY29uZmlybWF0aW9uIG1vZGFsIGFuZCByZXNldCBvdXIgcnN2cCBtb2RhbC5cbiAgICAgKiBPbiBmYWlsdXJlLCB3ZSBoaWRlIG91ciBzdWJtaXR0aW5nIGRpYWxvZyBhbmQgc2hvdyBvdXIgc3VibWlzc2lvbiBlcnJvciB0byB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIC0gZGF0YSB0byBzdWJtaXQgdG8gb3VyIHNwcmVhZHNoZWV0XG4gICAgICovXG4gICAgcHJpdmF0ZSBzdWJtaXRBYnNlbnRGb3JtKGRhdGE6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNwcmVhZHNoZWV0U2VydmljZS5wb3N0Um93VG9TcHJlYWRzaGVldCh0aGlzLmdvb2dsZVNoZWV0c0FwaVVybCwgdGhpcy5nb29nbGVTaGVldHNCYWNrdXBBcGlVcmwsIGRhdGEpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEZvcm0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ym1pdFN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtSXNTdWJtaXR0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRXJyb3JzID0gdGhpcy5zdWJtaXNzaW9uRXJyb3I7XG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBvdXIgaW5wdXQgZmllbGRzLCBlcnJvcnMsIGFuZCByZXNldHMgb3VyIGZvcm0gaXMgc3VibWl0dGluZyBmbGFnLlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVzZXRGb3JtKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZpcnN0TmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmVtYWlsQWRkcmVzcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaG9tZXRvd24gPSBudWxsO1xuICAgICAgICB0aGlzLmhpZ2hzY2hvb2wgPSBudWxsO1xuICAgICAgICB0aGlzLm1ham9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5leHBlcmllbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vdGhlckNsdWJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JtRXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb3JtSXNTdWJtaXR0aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnJvbnQtZW5kIHZhbGlkYXRpb24gZm9yIG91ciBmb3JtLlxuICAgICAqIE91ciBmb3JtIGlzIHZhbGlkIG9ubHkgaWYgYWxsIGZpZWxkcyBhcmUgcG9wdWxhdGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgZm9ybSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgcHJpdmF0ZSBmb3JtSXNWYWxpZCgpOiBib29sZWFuIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5maXJzdE5hbWUgIT0gbnVsbCAgICAgICAmJiB0aGlzLmZpcnN0TmFtZSAhPSAnJ1xuICAgICAgICAgICAgJiYgdGhpcy5sYXN0TmFtZSAhPSBudWxsICAgICAgICAmJiB0aGlzLmxhc3ROYW1lICE9ICcnXG4gICAgICAgICAgICAmJiB0aGlzLmVtYWlsQWRkcmVzcyAhPSBudWxsICAgICYmIHRoaXMuZW1haWxBZGRyZXNzICE9ICcnXG4gICAgICAgICAgICAmJiB0aGlzLmhvbWV0b3duICE9IG51bGwgICAgICAgICYmIHRoaXMuaG9tZXRvd24gIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMuaGlnaHNjaG9vbCAhPSBudWxsICAgICAgJiYgdGhpcy5oaWdoc2Nob29sICE9ICcnXG4gICAgICAgICAgICAmJiB0aGlzLm1ham9yICE9IG51bGwgICAgICAgICAgICYmIHRoaXMubWFqb3IgIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMuZXhwZXJpZW5jZSAhPSBudWxsICAgICAgJiYgdGhpcy5leHBlcmllbmNlICE9ICcnXG4gICAgICAgICAgICAmJiB0aGlzLm90aGVyQ2x1YnMgIT0gbnVsbCAgICAgICYmIHRoaXMub3RoZXJDbHVicyAhPSAnJ1xuICAgICAgICAgICAgJiYgdGhpcy5jb250YWN0ICE9IG51bGwgICAgICAgICAmJiB0aGlzLmNvbnRhY3QgIT0gJyc7XG5cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvcHJvc3BlY3RpdmUtcGxheWVycy9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudC50cyIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSGVhZGVycywgSHR0cCB9IGZyb20gXCJAYW5ndWxhci9odHRwXCI7XG5cbi8qKlxuICogU2VydmljZSB0byBpbnRlcmFjdCB3aXRoIG91ciBHb29nbGUgc3ByZWFkc2hlZXQuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTcHJlYWRzaGVldFNlcnZpY2Uge1xuXG4gICAgLy8gSFRUUCBoZWFkZXJzXG4gICAgcHJpdmF0ZSBoZWFkZXJzID0gbmV3IEhlYWRlcnMoeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbid9KTtcblxuICAgIC8vIENvbnN0cnVjdG9yIHdpdGggb3VyIGh0dHAgc2VydmljZSBpbmplY3RlZFxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cDogSHR0cCkge31cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHBvc3QgdGhlIGRhdGEgcGFzc2VkIGluIHRvIG91ciBzcHJlYWRzaGVldC5cbiAgICAgKiBSZWplY3RzIHRoZSBwcm9taXNlIGlmIHRoZXJlIGlzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFwaVVybCAtIHVybCBvZiB0aGUgZ29vZ2xlIHNoZWV0cyBBUElcbiAgICAgKiBAcGFyYW0gYmFja3VwQXBpVXJsIC0gdXJsIG9mIGh0ZSBnb29nbGUgc2hlZXRzIGJhY2t1cCBBUElcbiAgICAgKiBAcGFyYW0gZGF0YSAtIGRhdGEgdG8gYWRkIHRvIG91ciBzcHJlYWRzaGVldFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEpTT04+fSAtIFByb21pc2UgaG9sZGluZyB0aGUgc3VjY2Vzc2Z1bGx5IHBvc3RlZCBvYmplY3QsIG9yIGEgcmVqZWN0ZWQgcHJvbWlzZSB3aXRoIGFuIGVycm9yXG4gICAgICovXG4gICAgcHVibGljIHBvc3RSb3dUb1NwcmVhZHNoZWV0KGFwaVVybDogc3RyaW5nLCBiYWNrdXBBcGlVcmw6IHN0cmluZywgZGF0YTogT2JqZWN0KTogUHJvbWlzZTxKU09OPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBcbiAgICAgICAgICAgIC5wb3N0KGFwaVVybCwgZGF0YSwge2hlYWRlcnM6IHRoaXMuaGVhZGVyc30pXG4gICAgICAgICAgICAudG9Qcm9taXNlKClcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB0aGlzLnBvc3RSb3dUb1NwcmVhZHNoZWV0QmFja3VwKGJhY2t1cEFwaVVybCwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHBvc3QgdGhlIGRhdGEgcGFzc2VkIGluIHRvIG91ciBiYWNrdXAgc3ByZWFkc2hlZXQuXG4gICAgICogVGhpcyBpcyBhIGJhY2t1cCBwb3N0IGluIGNhc2Ugb3VyIHBlcnNvbmFsIHNlcnZlciBmYWlscy5cbiAgICAgKiBSZWplY3RzIHRoZSBwcm9taXNlIGlmIHRoZXJlIGlzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhY2t1cEFwaVVybCAtIHVybCBvZiBodGUgZ29vZ2xlIHNoZWV0cyBiYWNrdXAgQVBJXG4gICAgICogQHBhcmFtIGRhdGEgLSBkYXRhIHRvIGFkZCB0byBvdXIgc3ByZWFkc2hlZXRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxKU09OPn0gLSBQcm9taXNlIGhvbGRpbmcgdGhlIHN1Y2Nlc3NmdWxseSBwb3N0ZWQgb2JqZWN0LCBvciBhIHJlamVjdGVkIHByb21pc2Ugd2l0aCBhbiBlcnJvclxuICAgICAqL1xuICAgIHB1YmxpYyBwb3N0Um93VG9TcHJlYWRzaGVldEJhY2t1cChiYWNrdXBBcGlVcmw6IHN0cmluZywgZGF0YTogT2JqZWN0KTogUHJvbWlzZTxKU09OPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHBcbiAgICAgICAgICAgIC5wb3N0KGJhY2t1cEFwaVVybCwgZGF0YSwge2hlYWRlcnM6IHRoaXMuaGVhZGVyc30pXG4gICAgICAgICAgICAudG9Qcm9taXNlKClcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgICAgIC5jYXRjaChTcHJlYWRzaGVldFNlcnZpY2UuaGFuZGxlRXJyb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYWxsIHJzdnAgc2VydmljZSBlcnJvcnMgKGFmdGVyIG91ciBiYWNrdXAgY2FsbCkgd2hlbiBpbnRlcmZhY2luZ1xuICAgICAqIHdpdGggdGhlIGdvb2dsZSBzcHJlYWRzaGVldCBhcGkuIFdlIGxvZyB0aGUgZXJyb3IgYW5kIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnJvciAtIEVycm9yIHRvIGxvZyBhbmQgcmVqZWN0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gLSBBIHJlamVjdGVkIHByb21pc2VcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBoYW5kbGVFcnJvcihlcnJvcjogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiBhdHRlbXB0aW5nIHRvIHNlbmQgZGF0YSB0byBvdXIgc3ByZWFkc2hlZXQ6ICcsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3NlcnZpY2UvZ29vZ2xlLXNwcmVhZHNoZWV0LnNlcnZpY2UudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGgxIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPlByb3NwZWN0aXZlIFBsYXllcnM8L2gxPlxcbjxwPklsbGlub2lzIFVsdGltYXRlIGhhcyBoYWQgYSBsb25nIGhpc3Rvcnkgc2luY2UgaXRzIGluY2VwdGlvbiBpbiB0aGUgZWFybHkgMTk5MHMgYW5kIG5vdyBjb25zaXN0ZW50bHkgY29tcGV0ZXMgd2l0aCBiZXN0IGNvbXBldGl0aW9uIGFyb3VuZCB0aGUgY291bnRyeS4gSWxsaW5vaXMgaGFzIHF1YWxpZmllZCBmb3IgbmF0aW9uYWwgY2hhbXBpb25zaGlwcyA2IG91dCBvZiB0aGUgbGFzdCA5IHllYXJzIGJlaGluZCBvdXIgZGVkaWNhdGlvbiwgZGV0ZXJtaW5hdGlvbiwgYW5kIGRpc3Rpbmd1aXNoZWQgY2hhcmFjdGVyIG9uIGFuZCBvZmYgdGhlIGZpZWxkLiBJbGxpbm9pcyBhbHVtbmkgaGF2ZSBnb25lIG9uIHRvIHBsYXkgZm9yIG5hdGlvbmFscyBjYWxpYmVyIGNsdWIgdGVhbXMgc3VjaCBhcyBDaGljYWdvIE1hY2hpbmUsIE1pbm5lYXBvbGlzIERyYWcgJ24gVGhydXN0LCBDaW5jaW5uYXRpIFN0ZWFtYm9hdCwgQXRsYW50YSBDaGFpbiBMaWdodG5pbmcsIGFuZCBTYW4gRnJhbmNpc2NvIEJsYWNrYmlyZC4gQWx1bW5pIGhhdmUgcGxheWVkIG9uIHByb2Zlc3Npb25hbCBBVURMIHRlYW1zIHN1Y2ggYXMgdGhlIENoaWNhZ28gV2lsZGZpcmUsIE1pbm5lc290YSBXaW5kY2hpbGwsIENpbmNpbm5hdGkgUmV2b2x1dGlvbiwgYW5kIHRoZSBTYW4gSm9zZSBTcGlkZXJzLiBUaGV5IGhhdmUgYWxzbyBjcmVhdGVkIGFuZCBjYXB0YWluZWQgY2x1YiB0ZWFtcyBpbmNsdWRpbmcgQ2hpY2FnbyBNYWNoaW5lLCBCbGFjayBNYXJrZXQgVWx0aW1hdGUsIGFuZCBCZWFjaGZyb250IFVsdGltYXRlLCBhbmQgaGF2ZSBnb25lIG9uIHRvIGNvYWNoIGNvbGxlZ2UgdWx0aW1hdGUgYXQgdGhlIFVuaXZlcnNpdHkgb2YgSWxsaW5vaXMsIHRoZSBVbml2ZXJzaXR5IG9mIENoaWNhZ28sIE5vcnRod2VzdGVybiBVbml2ZXJzaXR5LCBhbmQgdGhlIFVuaXZlcnNpdHkgb2YgS2VudHVja3kuIEl0J3Mgc2FmZSB0byBzYXkgdGhhdCBvbmNlIHlvdSBwbGF5IHVsdGltYXRlIGF0IElsbGlub2lzIHlvdSBhcmUgb3BlbmVkIHVwIHRvIGEgd29ybGQgb2Ygb3Bwb3J0dW5pdHkgdGhyb3VnaCBvdXIgYWx1bW5pIG5ldHdvcmssIHdobyBhcmUgbW9yZSB0aGFuIHdpbGxpbmcgdG8gYXNzaXN0IHlvdSBvbiB5b3VyIGpvdXJuZXkgdGhvdWdoIHVsdGltYXRlIGR1cmluZyBhbmQgYmV5b25kIHlvdXIgY29sbGVnZSB5ZWFycy48L3A+XFxuPHA+V2hpbGUgeW91IGFyZSBhdCBJbGxpbm9pcyB5b3Ugd2lsbCBlbmpveSBhIG51bWJlciBvZiBleHBlcmllbmNlcy4gVGhpcyByYW5nZXMgZnJvbSB0ZWFtIHNvY2lhbHMgdG8gc3R1ZHkgZ3JvdXBzIGFuZCBmcm9tIHByYWN0aWNlcyBpbiBJcndpbiBGaWVsZGhvdXNlIHRvIHBsYXlpbmcgZ2FtZXMgb24gdGhlIHNob3JlcyBvZiBTYW4gRGllZ28uIFlvdXIgdGVhbW1hdGVzIHdvbid0IG9ubHkgYmUgeW91ciBiZXN0IGZyaWVuZHMsIHRoZXkgd2lsbCBiZSBmYW1pbHkuIFlvdSB3aWxsIGxlYXJuIHRoZSB2YXJpb3VzIHdheXMgdWx0aW1hdGUgaXMgcGxheWVkLCBob3cgdG8gZXhwYW5kIHlvdXIgdGhyb3dpbmcgYXJzZW5hbCwgaG93IHRvIGltcHJvdmUgeW91ciBhdGhsZXRpY2lzbSwgYW5kIGhvdyB0byB0YWtlIHlvdXIgZ2FtZSB0byB0aGUgbmV4dCBsZXZlbC4gQSBtYWpvcml0eSBvZiBvdXIgdGVhbSBkaWRuJ3QgcGxheSBvcmdhbml6ZWQgdWx0aW1hdGUgYmVmb3JlIGNvbWluZyB0byBjb2xsZWdlLCBhbmQgYXJlIG5vdyBzb21lIG9mIHRoZSBiZXN0IHBsYXllcnMgaW4gdGhlIEdyZWF0IExha2VzIHJlZ2lvbiAoc2VlIG91ciBBbGwtUmVnaW9ucyBob25vcnMgcGFnZSkuPC9wPlxcbjxwPldlIGVuY291cmFnZSBwcm9zcGVjdGl2ZSBwbGF5ZXJzIHRvIGZpbGwgb3V0IG91ciBpbnRlcmVzdCBmb3JtIGFuZCB0byByZWFjaCBvdXQgdG8gdGhlIGNhcHRhaW5zIGVzcGVjaWFsbHkgaWYgeW91IHdpbGwgYmUgb24gY2FtcHVzLiBXZSBhcmUgbW9yZSB0aGFuIGhhcHB5IHRvIG1lZXQgdXAgYW5kIGRpc2N1c3Mgd2hhdCBJbGxpbm9pcyBjYW4gZG8gZm9yIHlvdSwgYW5kIHRvIHNlZSB3aGF0IHlvdSBjYW4gZG8gdG8gYmUgcmVhZHkgZm9yIElsbGlub2lzIG9uY2UgeW91IGdldCBvbiBjYW1wdXMuIE91ciBjb250YWN0IGluZm9ybWF0aW9uIGlzIGJlbG93LiBUaGFuayB5b3UgZm9yIHRha2luZyB0aGUgdGltZSB0byB2aXNpdCBvdXIgd2Vic2l0ZSwgYW5kIHdlIGhvcGUgdG8gaGVhciBmcm9tIHlvdSBzb29uLjwvcD5cXG5cXG48Zm9ybSBjbGFzcz1cXFwidWkgZm9ybVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0d28gZmllbGRzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD5GaXJzdCBOYW1lIDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcImZpcnN0TmFtZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwiZmlyc3QtbmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIkZpcnN0IE5hbWVcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxhYmVsPkxhc3QgTmFtZSA8c3BhbiBjbGFzcz1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJsYXN0TmFtZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwibGFzdC1uYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiTGFzdCBOYW1lXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidHdvIGZpZWxkc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+RW1haWwgQWRkcmVzcyA8c3BhbiBjbGFzcz1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJlbWFpbEFkZHJlc3NcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcImVtYWlsLWFkZHJlc3NcXFwiIHBsYWNlaG9sZGVyPVxcXCJFbWFpbCBBZGRyZXNzXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD5XaGF0IGlzIHlvdXIgSG9tZXRvd24/IDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcImhvbWV0b3duXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJob21lLXRvd25cXFwiIHBsYWNlaG9sZGVyPVxcXCJIb21ldG93blxcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInR3byBmaWVsZHNcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxhYmVsPldoYXQgaGlnaCBzY2hvb2wgZGlkIHlvdSBhdHRlbmQ/IDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcImhpZ2hzY2hvb2xcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcImhpZ2hzY2hvb2xcXFwiIHBsYWNlaG9sZGVyPVxcXCJIaWdoc2Nob29sXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD5XaGF0IG1ham9yIGFyZSB5b3UgcGxhbm5pbmcgb24gZ29pbmcgaW50bz8gPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwibWFqb3JcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcIm1ham9yXFxcIiBwbGFjZWhvbGRlcj1cXFwiTWFqb3JcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPkhvdyBsb25nIGhhdmUgeW91IHBsYXllZCB1bHRpbWF0ZS93aGF0IGtpbmQgb2YgZXhwZXJpZW5jZSBkbyB5b3UgaGF2ZT8gPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgPHRleHRhcmVhIFsobmdNb2RlbCldPVxcXCJleHBlcmllbmNlXFxcIiBuYW1lPVxcXCJleHBlcmllbmNlXFxcIiByb3dzPVxcXCIyXFxcIj48L3RleHRhcmVhPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPldoYXQgb3RoZXIgY2x1YnMvb3JnYW5pemF0aW9ucyBhcmUgeW91IHBsYW5uaW5nIG9uIGpvaW5pbmcgd2hlbiB5b3UgYXJyaXZlIG9uIGNhbXB1cz8gPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgPHRleHRhcmVhIFsobmdNb2RlbCldPVxcXCJvdGhlckNsdWJzXFxcIiBuYW1lPVxcXCJvdGhlci1jbHVic1xcXCIgcm93cz1cXFwiMlxcXCI+PC90ZXh0YXJlYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5saW5lIGZpZWxkc1xcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPldvdWxkIHlvdSBiZSBhbHJpZ2h0IHdpdGggYSBjYXB0YWluIG9yIGNvYWNoIHJlYWNoaW5nIG91dCB0byB5b3U/IDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWkgcmFkaW8gY2hlY2tib3hcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJjb250YWN0LXllc1xcXCIgWyhuZ01vZGVsKV09XFxcImNvbnRhY3RcXFwiIHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJjb250YWN0XFxcIiB2YWx1ZT1cXFwiWWVzXFxcIiBjaGVja2VkPVxcXCJjaGVja2VkXFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcImhpZGRlblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJjb250YWN0LXllc1xcXCI+WWVzPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aSByYWRpbyBjaGVja2JveFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgaWQ9XFxcImNvbnRhY3Qtbm9cXFwiIFsobmdNb2RlbCldPVxcXCJjb250YWN0XFxcIiB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwiY29udGFjdFxcXCIgdmFsdWU9XFxcIk5vXFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcImhpZGRlblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJjb250YWN0LW5vXFxcIj5ObzwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDxidXR0b24gKGNsaWNrKT1cXFwiaGFuZGxlU3VibWl0KCRldmVudClcXFwiIGNsYXNzPVxcXCJ1aSBidXR0b25cXFwiIHR5cGU9XFxcInN1Ym1pdFxcXCI+U3VibWl0PC9idXR0b24+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpIGVycm9yIG1lc3NhZ2VcXFwiICpuZ0lmPVxcXCJmb3JtRXJyb3JzXFxcIj5cXG4gICAgICAgIDxwPnt7Zm9ybUVycm9yc319PC9wPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWkgc3VjY2VzcyBtZXNzYWdlXFxcIiAqbmdJZj1cXFwic3VibWl0U3VjY2Vzc1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoZWFkZXJcXFwiPkZvcm0gU3VibWl0dGVkPC9kaXY+XFxuICAgICAgICA8cD5UaGUgZm9ybSB3YXMgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZCEgVGhhbmtzIGZvciB0YWtpbmcgdGhlIHRpbWUgdG8gZmlsbCBpdCBvdXQuPC9wPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiAqbmdJZj1cXFwiZm9ybUlzU3VibWl0dGluZ1xcXCIgY2xhc3M9XFxcInVpIGFjdGl2ZSBpbnZlcnRlZCBkaW1tZXJcXFwiPjxkaXYgY2xhc3M9XFxcInVpIHRleHQgbG9hZGVyXFxcIj5TdWJtaXR0aW5nPC9kaXY+PC9kaXY+XFxuPC9mb3JtPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcHJvc3BlY3RpdmUtcGxheWVycy9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJwLFxcbmxhYmVsIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbi51aS5mb3JtIHtcXG4gIG1hcmdpbjogMjBweCBhdXRvO1xcbn1cXG4udWkuZm9ybSAudWkuZXJyb3IubWVzc2FnZSxcXG4udWkuZm9ybSAudWkuc3VjY2Vzcy5tZXNzYWdlIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4udWkuZm9ybSAudWkuZXJyb3IubWVzc2FnZSBwLFxcbi51aS5mb3JtIC51aS5zdWNjZXNzLm1lc3NhZ2UgcCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvcHJvc3BlY3RpdmUtcGxheWVycy9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2NvbnRhY3QnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2NvbnRhY3QuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2NvbnRhY3QuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBDb250YWN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICBjb25zb2xlLmxvZygnQ29udGFjdCBDb21wb25lbnQhJyk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGgxIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPkNvbnRhY3QgVXM8L2gxPlxcbjxwPkZvciBhbnkgcXVlc3Rpb25zIHJlZ2FyZGluZyBwcmFjdGljZSBvciBjbHViIGRldGFpbHMsIGZlZWwgZnJlZSB0byBjb250YWN0IGFueSBvZiB0aGUgY3VycmVudCBjYXB0YWluczo8L3A+XFxuXFxuPHAgY2xhc3M9XFxcImNhcHRhaW5cXFwiPkNocmlzIEJ1Y2h0YSAtLSBjYnVjaHRhMkBnbWFpbC5jb208L3A+XFxuPHAgY2xhc3M9XFxcImNhcHRhaW5cXFwiPkJlbiBGb3N0ZXIgLS0gYmVuLmZvc3RlcjIzNEBnbWFpbC5jb208L3A+XFxuPHAgY2xhc3M9XFxcImNhcHRhaW5cXFwiPkphY29iIEtvbWVuZGEgLS0gamFjb2Iua29tZW5kYUBnbWFpbC5jb208L3A+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9jb250YWN0LmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5jYXB0YWluIHtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvY29udGFjdC9jb250YWN0LmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgJy4vc2hhcmVkLXN0eWxlL3N0eWxlcy5jc3MnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FwcCcsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYXBwLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9hcHAuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2FwcC5jb21wb25lbnQudHMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZXMuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3R5bGVzLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZXMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvc2hhcmVkLXN0eWxlL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIEdlbmVyYWwgRWxlbWVudHMgKi9cXG5ib2R5IHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgcmVxdWlyZShcIi4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2dsb2JhbC9iYWNrZ3JvdW5kLmpwZ1wiKSArIFwiKTtcXG4gICAgZm9udC1mYW1pbHk6ICdRdWF0dHJvY2VudG8nLCBzZXJpZjtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBvdmVyZmxvdy15OiBzY3JvbGw7XFxufVxcbnAge1xcbiAgICB0ZXh0LWluZGVudDogMjVweDtcXG4gICAgcGFkZGluZzogNXB4O1xcbn1cXG5hIHtcXG4gICAgY29sb3I6ICNmZjYyMjY7XFxufVxcbmE6aG92ZXIge1xcbiAgICBjb2xvcjogIzAwMDA0RDtcXG59XFxuaW5wdXQge1xcbiAgICBmb250LWZhbWlseTogJ1F1YXR0cm9jZW50bycsIHNlcmlmICFpbXBvcnRhbnQ7XFxufVxcblxcbmlucHV0OmZvY3VzIHtcXG4gICAgIGJvcmRlci1jb2xvcjogI2ZmNjIyNiAhaW1wb3J0YW50O1xcbn1cXG5cXG4vKiBIZWFkZXJzICovXFxuLnVpLmhlYWRlciB7XFxuICAgIGZvbnQtZmFtaWx5OiAnT3N3YWxkJywgc2Fucy1zZXJpZjtcXG4gICAgY29sb3I6ICMwMDAwNEQ7XFxuICAgIGxldHRlci1zcGFjaW5nOiAxcHg7XFxuICAgIC8qdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsqL1xcbn1cXG5cXG4vKiBUYWJsZXMgKi9cXG4udWkudGFibGUgdHIsIC51aS50YWJsZSB0ZCB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYm9yZGVyLXRvcDogMDtcXG59XFxuXFxuLyogU2Vjb25kYXJ5IE1lbnVzICovXFxuLnVpLnNlY29uZGFyeS5wb2ludGluZy5tZW51IHtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcbi51aS5zZWNvbmRhcnkucG9pbnRpbmcubWVudSAuaXRlbS5hY3RpdmUge1xcbiAgICBib3JkZXItY29sb3I6ICMwMDAwNEQ7XFxufVxcblxcbi8qIFJhbmRvbSAqL1xcbi5idXR0b24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmY2MjI2ICFpbXBvcnRhbnQ7XFxuICAgIGNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xcbn1cXG4ucmVxdWlyZWQge1xcbiAgICBjb2xvcjogI2ZmNjIyNjtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9zcmMvYXBwL3NoYXJlZC1zdHlsZS9zdHlsZXMuY3NzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvYmFja2dyb3VuZC5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9nbG9iYWwvYmFja2dyb3VuZC5qcGdcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8bWFpbiBjbGFzcz1cXFwibWFpbi1jb250YWluZXJcXFwiPlxcbiAgICA8cGFnZS1mcmFtZT48L3BhZ2UtZnJhbWU+XFxuPC9tYWluPlxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9hcHAuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9hcHAuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5tYWluLWNvbnRhaW5lciB7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvYXBwLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWdtQ29yZU1vZHVsZSB9IGZyb20gJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCI7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuXG5pbXBvcnQgeyBQcmFjdGljZUNvbXBvbmVudCB9IGZyb20gXCIuL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgVG91cm5hbWVudHNDb21wb25lbnQgfSBmcm9tIFwiLi90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnRcIjtcbmltcG9ydCB7IFJvc3RlckNvbXBvbmVudCB9IGZyb20gXCIuL3Jvc3Rlci9yb3N0ZXIuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBBYnNlbnRDb21wb25lbnQgfSBmcm9tIFwiLi9hYnNlbnQvYWJzZW50LmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL3JvdXRlclwiO1xuaW1wb3J0IHsgUk9VVEVTIH0gZnJvbSBcIi4uL2FwcC5yb3V0ZXNcIjtcbmltcG9ydCB7IFNwcmVhZHNoZWV0U2VydmljZSB9IGZyb20gXCIuLi9zZXJ2aWNlL2dvb2dsZS1zcHJlYWRzaGVldC5zZXJ2aWNlXCI7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBCcm93c2VyTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgQWdtQ29yZU1vZHVsZS5mb3JSb290KHtcbiAgICAgICAgICAgIGFwaUtleTogJ0FJemFTeUJSSVhBazV4ZHZuM2V6eXBzU2U1NWY4ZFpoY0hoZUFaOCdcbiAgICAgICAgfSksXG4gICAgICAgIFJvdXRlck1vZHVsZS5mb3JSb290KFJPVVRFUylcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBQcmFjdGljZUNvbXBvbmVudCxcbiAgICAgICAgVG91cm5hbWVudHNDb21wb25lbnQsXG4gICAgICAgIFJvc3RlckNvbXBvbmVudCxcbiAgICAgICAgQWJzZW50Q29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFsgU3ByZWFkc2hlZXRTZXJ2aWNlIF1cbn0pXG5leHBvcnQgY2xhc3MgVGVhbU1vZHVsZSB7fVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3RlYW0vdGVhbS5tb2R1bGUudHMiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG4vLyBtYWluIG1vZHVsZXNcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZGlyZWN0aXZlcycpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc2VydmljZXMnKSk7XG4vLyBHb29nbGUgTWFwcyB0eXBlc1xuLy8gY29yZSBtb2R1bGVcbi8vIHdlIGV4cGxpY2l0bHkgZXhwb3J0IHRoZSBtb2R1bGUgaGVyZSB0byBwcmV2ZW50IHRoaXMgSW9uaWMgMiBidWc6XG4vLyBodHRwOi8vc3RldmVtaWNoZWxvdHRpLmNvbS9pbnRlZ3JhdGUtYW5ndWxhci0yLWdvb2dsZS1tYXBzLWludG8taW9uaWMtMi9cbnZhciBjb3JlX21vZHVsZV8xID0gcmVxdWlyZSgnLi9jb3JlLW1vZHVsZScpO1xuZXhwb3J0cy5BZ21Db3JlTW9kdWxlID0gY29yZV9tb2R1bGVfMS5BZ21Db3JlTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGdvb2dsZV9tYXBfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXAgPSBnb29nbGVfbWFwXzEuU2VibUdvb2dsZU1hcDtcbnZhciBnb29nbGVfbWFwX2NpcmNsZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtY2lyY2xlJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBDaXJjbGUgPSBnb29nbGVfbWFwX2NpcmNsZV8xLlNlYm1Hb29nbGVNYXBDaXJjbGU7XG52YXIgZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtaW5mby13aW5kb3cnKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgPSBnb29nbGVfbWFwX2luZm9fd2luZG93XzEuU2VibUdvb2dsZU1hcEluZm9XaW5kb3c7XG52YXIgZ29vZ2xlX21hcF9rbWxfbGF5ZXJfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwLWttbC1sYXllcicpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwS21sTGF5ZXIgPSBnb29nbGVfbWFwX2ttbF9sYXllcl8xLlNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbnZhciBnb29nbGVfbWFwX21hcmtlcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtbWFya2VyJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBNYXJrZXIgPSBnb29nbGVfbWFwX21hcmtlcl8xLlNlYm1Hb29nbGVNYXBNYXJrZXI7XG52YXIgZ29vZ2xlX21hcF9wb2x5Z29uXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5Z29uJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBQb2x5Z29uID0gZ29vZ2xlX21hcF9wb2x5Z29uXzEuU2VibUdvb2dsZU1hcFBvbHlnb247XG52YXIgZ29vZ2xlX21hcF9wb2x5bGluZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUnKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlsaW5lID0gZ29vZ2xlX21hcF9wb2x5bGluZV8xLlNlYm1Hb29nbGVNYXBQb2x5bGluZTtcbnZhciBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCcpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludCA9IGdvb2dsZV9tYXBfcG9seWxpbmVfcG9pbnRfMS5TZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9nb29nbGUtbWFwcy1hcGktd3JhcHBlcicpO1xudmFyIGNpcmNsZV9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9jaXJjbGUtbWFuYWdlcicpO1xudmFyIGluZm9fd2luZG93X21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL2luZm8td2luZG93LW1hbmFnZXInKTtcbnZhciBtYXJrZXJfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvbWFya2VyLW1hbmFnZXInKTtcbnZhciBwb2x5Z29uX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlnb24tbWFuYWdlcicpO1xudmFyIHBvbHlsaW5lX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlsaW5lLW1hbmFnZXInKTtcbnZhciBrbWxfbGF5ZXJfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi8uLi9zZXJ2aWNlcy9tYW5hZ2Vycy9rbWwtbGF5ZXItbWFuYWdlcicpO1xuLyoqXG4gKiBTZWJNR29vZ2xlTWFwIHJlbmRlcnMgYSBHb29nbGUgTWFwLlxuICogKipJbXBvcnRhbnQgbm90ZSoqOiBUbyBiZSBhYmxlIHNlZSBhIG1hcCBpbiB0aGUgYnJvd3NlciwgeW91IGhhdmUgdG8gZGVmaW5lIGEgaGVpZ2h0IGZvciB0aGUgQ1NTXG4gKiBjbGFzcyBgc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lcmAuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgU2VibUdvb2dsZU1hcCB9IGZyb20gJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgZGlyZWN0aXZlczogW1NlYm1Hb29nbGVNYXBdLFxuICogIHN0eWxlczogW2BcbiAqICAgIC5zZWJtLWdvb2dsZS1tYXAtY29udGFpbmVyIHtcbiAqICAgICAgaGVpZ2h0OiAzMDBweDtcbiAqICAgIH1cbiAqIGBdLFxuICogIHRlbXBsYXRlOiBgXG4gKiAgICA8c2VibS1nb29nbGUtbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cbiAqICAgIDwvc2VibS1nb29nbGUtbWFwPlxuICogIGBcbiAqIH0pXG4gKiBgYGBcbiAqL1xudmFyIFNlYm1Hb29nbGVNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXAoX2VsZW0sIF9tYXBzV3JhcHBlcikge1xuICAgICAgICB0aGlzLl9lbGVtID0gX2VsZW07XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvbmdpdHVkZSB0aGF0IGRlZmluZXMgdGhlIGNlbnRlciBvZiB0aGUgbWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb25naXR1ZGUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhdGl0dWRlIHRoYXQgZGVmaW5lcyB0aGUgY2VudGVyIG9mIHRoZSBtYXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhdGl0dWRlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIFRoZSBkZWZhdWx0IHpvb20gbGV2ZWwgaXMgOC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuem9vbSA9IDg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzL2Rpc2FibGVzIGlmIG1hcCBpcyBkcmFnZ2FibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHpvb20gYW5kIGNlbnRlciBvbiBkb3VibGUgY2xpY2suIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZURvdWJsZUNsaWNrWm9vbSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcy9kaXNhYmxlcyBhbGwgZGVmYXVsdCBVSSBvZiB0aGUgR29vZ2xlIG1hcC4gUGxlYXNlIG5vdGU6IFdoZW4gdGhlIG1hcCBpcyBjcmVhdGVkLCB0aGlzXG4gICAgICAgICAqIHZhbHVlIGNhbm5vdCBnZXQgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZURlZmF1bHRVSSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZmFsc2UsIGRpc2FibGVzIHNjcm9sbHdoZWVsIHpvb21pbmcgb24gdGhlIG1hcC4gVGhlIHNjcm9sbHdoZWVsIGlzIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsd2hlZWwgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZmFsc2UsIHByZXZlbnRzIHRoZSBtYXAgZnJvbSBiZWluZyBjb250cm9sbGVkIGJ5IHRoZSBrZXlib2FyZC4gS2V5Ym9hcmQgc2hvcnRjdXRzIGFyZVxuICAgICAgICAgKiBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlbmFibGVkL2Rpc2FibGVkIHN0YXRlIG9mIHRoZSBab29tIGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb21Db250cm9sID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0eWxlcyB0byBhcHBseSB0byBlYWNoIG9mIHRoZSBkZWZhdWx0IG1hcCB0eXBlcy4gTm90ZSB0aGF0IGZvciBTYXRlbGxpdGUvSHlicmlkIGFuZCBUZXJyYWluXG4gICAgICAgICAqIG1vZGVzLCB0aGVzZSBzdHlsZXMgd2lsbCBvbmx5IGFwcGx5IHRvIGxhYmVscyBhbmQgZ2VvbWV0cnkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0cnVlIGFuZCB0aGUgbGF0aXR1ZGUgYW5kL29yIGxvbmdpdHVkZSB2YWx1ZXMgY2hhbmdlcywgdGhlIEdvb2dsZSBNYXBzIHBhblRvIG1ldGhvZCBpc1xuICAgICAgICAgKiB1c2VkIHRvXG4gICAgICAgICAqIGNlbnRlciB0aGUgbWFwLiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNNYXBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlUGFubmluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZSBvZiB0aGUgU3RyZWV0IFZpZXcgUGVnbWFuIGNvbnRyb2wuXG4gICAgICAgICAqIFRoaXMgY29udHJvbCBpcyBwYXJ0IG9mIHRoZSBkZWZhdWx0IFVJLCBhbmQgc2hvdWxkIGJlIHNldCB0byBmYWxzZSB3aGVuIGRpc3BsYXlpbmcgYSBtYXAgdHlwZVxuICAgICAgICAgKiBvbiB3aGljaCB0aGUgU3RyZWV0IFZpZXcgcm9hZCBvdmVybGF5IHNob3VsZCBub3QgYXBwZWFyIChlLmcuIGEgbm9uLUVhcnRoIG1hcCB0eXBlKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RyZWV0Vmlld0NvbnRyb2wgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdmlld3BvcnQgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXRCb3VuZHMgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZSBvZiB0aGUgU2NhbGUgY29udHJvbC4gVGhpcyBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2FsZUNvbnRyb2wgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbml0aWFsIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2YgdGhlIE1hcCB0eXBlIGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcFR5cGVDb250cm9sID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrIG9uIGFcbiAgICAgICAgICogbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgcmlnaHQtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXG4gICAgICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBSaWdodENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXG4gICAgICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBEYmxDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIGNlbnRlciBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZW50ZXJDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB2aWV3cG9ydCBib3VuZHMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBtYXAgYmVjb21lcyBpZGxlIGFmdGVyIHBhbm5pbmcgb3Igem9vbWluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWRsZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHpvb20gbGV2ZWwgaGFzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb21DaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRvZG86IHRoaXMgc2hvdWxkIGJlIHNvbHZlZCB3aXRoIGEgbmV3IGNvbXBvbmVudCBhbmQgYSB2aWV3Q2hpbGQgZGVjb3JhdG9yXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9lbGVtLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXItaW5uZXInKTtcbiAgICAgICAgdGhpcy5faW5pdE1hcEluc3RhbmNlKGNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5faW5pdE1hcEluc3RhbmNlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyLmNyZWF0ZU1hcChlbCwge1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogdGhpcy5sYXRpdHVkZSB8fCAwLCBsbmc6IHRoaXMubG9uZ2l0dWRlIHx8IDAgfSxcbiAgICAgICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgICAgIG1pblpvb206IHRoaXMubWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4Wm9vbSxcbiAgICAgICAgICAgIGRpc2FibGVEZWZhdWx0VUk6IHRoaXMuZGlzYWJsZURlZmF1bHRVSSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRoaXMuZHJhZ2dhYmxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlQ3Vyc29yOiB0aGlzLmRyYWdnYWJsZUN1cnNvcixcbiAgICAgICAgICAgIGRyYWdnaW5nQ3Vyc29yOiB0aGlzLmRyYWdnaW5nQ3Vyc29yLFxuICAgICAgICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IHRoaXMua2V5Ym9hcmRTaG9ydGN1dHMsXG4gICAgICAgICAgICB6b29tQ29udHJvbDogdGhpcy56b29tQ29udHJvbCxcbiAgICAgICAgICAgIHN0eWxlczogdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICBzdHJlZXRWaWV3Q29udHJvbDogdGhpcy5zdHJlZXRWaWV3Q29udHJvbCxcbiAgICAgICAgICAgIHNjYWxlQ29udHJvbDogdGhpcy5zY2FsZUNvbnRyb2wsXG4gICAgICAgICAgICBtYXBUeXBlQ29udHJvbDogdGhpcy5tYXBUeXBlQ29udHJvbFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX2hhbmRsZU1hcENlbnRlckNoYW5nZSgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVNYXBab29tQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZU1hcE1vdXNlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUJvdW5kc0NoYW5nZSgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVJZGxlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgfTtcbiAgICAvKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hcE9wdGlvbnNDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbihjaGFuZ2VzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl91cGRhdGVNYXBPcHRpb25zQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBTZWJtR29vZ2xlTWFwLl9tYXBPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMTsgfSk7XG4gICAgICAgIG9wdGlvbktleXMuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBvcHRpb25zW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7IH0pO1xuICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5zZXRNYXBPcHRpb25zKG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYSByZXNpemUgZXZlbnQgb24gdGhlIGdvb2dsZSBtYXAgaW5zdGFuY2UuXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBnZXRzIHJlc29sdmVkIGFmdGVyIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLnRyaWdnZXJSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE5vdGU6IFdoZW4gd2Ugd291bGQgdHJpZ2dlciB0aGUgcmVzaXplIGV2ZW50IGFuZCBzaG93IHRoZSBtYXAgaW4gdGhlIHNhbWUgdHVybiAod2hpY2ggaXMgYVxuICAgICAgICAvLyBjb21tb24gY2FzZSBmb3IgdHJpZ2dlcmluZyBhIHJlc2l6ZSBldmVudCksIHRoZW4gdGhlIHJlc2l6ZSBldmVudCB3b3VsZCBub3RcbiAgICAgICAgLy8gd29yayAodG8gc2hvdyB0aGUgbWFwKSwgc28gd2UgdHJpZ2dlciB0aGUgZXZlbnQgaW4gYSB0aW1lb3V0LlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLnRyaWdnZXJNYXBFdmVudCgncmVzaXplJykudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snbGF0aXR1ZGUnXSA9PSBudWxsICYmIGNoYW5nZXNbJ2xvbmdpdHVkZSddID09IG51bGwgJiZcbiAgICAgICAgICAgIGNoYW5nZXNbJ2ZpdEJvdW5kcyddID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIHBvc2l0aW9uIHVwZGF0ZSBuZWVkZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBwcmVmZXIgZml0Qm91bmRzIGluIGNoYW5nZXNcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2ZpdEJvdW5kcyddICYmIHRoaXMuZml0Qm91bmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpdEJvdW5kcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sYXRpdHVkZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMubG9uZ2l0dWRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdDZW50ZXIgPSB7XG4gICAgICAgICAgICBsYXQ6IHRoaXMubGF0aXR1ZGUsXG4gICAgICAgICAgICBsbmc6IHRoaXMubG9uZ2l0dWRlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy51c2VQYW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5wYW5UbyhuZXdDZW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIuc2V0Q2VudGVyKG5ld0NlbnRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9maXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZVBhbm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcHNXcmFwcGVyLnBhblRvQm91bmRzKHRoaXMuZml0Qm91bmRzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5maXRCb3VuZHModGhpcy5maXRCb3VuZHMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUuX2hhbmRsZU1hcENlbnRlckNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9tYXBzV3JhcHBlci5zdWJzY3JpYmVUb01hcEV2ZW50KCdjZW50ZXJfY2hhbmdlZCcpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWFwc1dyYXBwZXIuZ2V0Q2VudGVyKCkudGhlbihmdW5jdGlvbiAoY2VudGVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGF0aXR1ZGUgPSBjZW50ZXIubGF0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9uZ2l0dWRlID0gY2VudGVyLmxuZygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNlbnRlckNoYW5nZS5lbWl0KHsgbGF0OiBfdGhpcy5sYXRpdHVkZSwgbG5nOiBfdGhpcy5sb25naXR1ZGUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLnB1c2gocyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5faGFuZGxlQm91bmRzQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcyA9IHRoaXMuX21hcHNXcmFwcGVyLnN1YnNjcmliZVRvTWFwRXZlbnQoJ2JvdW5kc19jaGFuZ2VkJykuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9tYXBzV3JhcHBlci5nZXRCb3VuZHMoKS50aGVuKGZ1bmN0aW9uIChib3VuZHMpIHsgX3RoaXMuYm91bmRzQ2hhbmdlLmVtaXQoYm91bmRzKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKHMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUuX2hhbmRsZU1hcFpvb21DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzID0gdGhpcy5fbWFwc1dyYXBwZXIuc3Vic2NyaWJlVG9NYXBFdmVudCgnem9vbV9jaGFuZ2VkJykuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9tYXBzV3JhcHBlci5nZXRab29tKCkudGhlbihmdW5jdGlvbiAoeikge1xuICAgICAgICAgICAgICAgIF90aGlzLnpvb20gPSB6O1xuICAgICAgICAgICAgICAgIF90aGlzLnpvb21DaGFuZ2UuZW1pdCh6KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9oYW5kbGVJZGxlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzID0gdGhpcy5fbWFwc1dyYXBwZXIuc3Vic2NyaWJlVG9NYXBFdmVudCgnaWRsZScpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IF90aGlzLmlkbGUuZW1pdCh2b2lkIDApOyB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9oYW5kbGVNYXBNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgZW1pdHRlcjogdGhpcy5tYXBDbGljayB9LFxuICAgICAgICAgICAgeyBuYW1lOiAncmlnaHRjbGljaycsIGVtaXR0ZXI6IHRoaXMubWFwUmlnaHRDbGljayB9LFxuICAgICAgICBdO1xuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBfdGhpcy5fbWFwc1dyYXBwZXIuc3Vic2NyaWJlVG9NYXBFdmVudChlLm5hbWUpLnN1YnNjcmliZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB7IGNvb3JkczogeyBsYXQ6IGV2ZW50LmxhdExuZy5sYXQoKSwgbG5nOiBldmVudC5sYXRMbmcubG5nKCkgfSB9O1xuICAgICAgICAgICAgICAgIGUuZW1pdHRlci5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLnB1c2gocyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFwIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgY2FuIGNoYW5nZSBvdmVyIHRpbWVcbiAgICAgKi9cbiAgICBTZWJtR29vZ2xlTWFwLl9tYXBPcHRpb25zQXR0cmlidXRlcyA9IFtcbiAgICAgICAgJ2Rpc2FibGVEb3VibGVDbGlja1pvb20nLCAnc2Nyb2xsd2hlZWwnLCAnZHJhZ2dhYmxlJywgJ2RyYWdnYWJsZUN1cnNvcicsICdkcmFnZ2luZ0N1cnNvcicsXG4gICAgICAgICdrZXlib2FyZFNob3J0Y3V0cycsICd6b29tQ29udHJvbCcsICdzdHlsZXMnLCAnc3RyZWV0Vmlld0NvbnRyb2wnLCAnem9vbScsICdtYXBUeXBlQ29udHJvbCcsXG4gICAgICAgICdtaW5ab29tJywgJ21heFpvb20nXG4gICAgXTtcbiAgICBTZWJtR29vZ2xlTWFwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkNvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIG1hcmtlcl9tYW5hZ2VyXzEuTWFya2VyTWFuYWdlciwgaW5mb193aW5kb3dfbWFuYWdlcl8xLkluZm9XaW5kb3dNYW5hZ2VyLCBjaXJjbGVfbWFuYWdlcl8xLkNpcmNsZU1hbmFnZXIsIHBvbHlsaW5lX21hbmFnZXJfMS5Qb2x5bGluZU1hbmFnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uX21hbmFnZXJfMS5Qb2x5Z29uTWFuYWdlciwga21sX2xheWVyX21hbmFnZXJfMS5LbWxMYXllck1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJywgJ3pvb20nLCAnbWluWm9vbScsICdtYXhab29tJywgJ2RyYWdnYWJsZTogbWFwRHJhZ2dhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlRG91YmxlQ2xpY2tab29tJywgJ2Rpc2FibGVEZWZhdWx0VUknLCAnc2Nyb2xsd2hlZWwnLCAnYmFja2dyb3VuZENvbG9yJywgJ2RyYWdnYWJsZUN1cnNvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZHJhZ2dpbmdDdXJzb3InLCAna2V5Ym9hcmRTaG9ydGN1dHMnLCAnem9vbUNvbnRyb2wnLCAnc3R5bGVzJywgJ3VzZVBhbm5pbmcnLCAnc3RyZWV0Vmlld0NvbnRyb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpdEJvdW5kcycsICdzY2FsZUNvbnRyb2wnLCAnbWFwVHlwZUNvbnRyb2wnXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXBDbGljaycsICdtYXBSaWdodENsaWNrJywgJ21hcERibENsaWNrJywgJ2NlbnRlckNoYW5nZScsICdpZGxlJywgJ2JvdW5kc0NoYW5nZScsICd6b29tQ2hhbmdlJ1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbY2xhc3Muc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lcl0nOiAndHJ1ZScgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbXCJcXG4gICAgLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXItaW5uZXIge1xcbiAgICAgIHdpZHRoOiBpbmhlcml0O1xcbiAgICAgIGhlaWdodDogaW5oZXJpdDtcXG4gICAgfVxcbiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRlbnQge1xcbiAgICAgIGRpc3BsYXk6bm9uZTtcXG4gICAgfVxcbiAgXCJdLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdiBjbGFzcz0nc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lci1pbm5lcic+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9J3NlYm0tZ29vZ2xlLW1hcC1jb250ZW50Jz5cXG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgIDwvZGl2PlxcbiAgXCJcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBTZWJtR29vZ2xlTWFwO1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcCA9IFNlYm1Hb29nbGVNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb29nbGUtbWFwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIG1hcHNfYXBpX2xvYWRlcl8xID0gcmVxdWlyZSgnLi9tYXBzLWFwaS1sb2FkZXIvbWFwcy1hcGktbG9hZGVyJyk7XG4vKipcbiAqIFdyYXBwZXIgY2xhc3MgdGhhdCBoYW5kbGVzIHRoZSBjb21tdW5pY2F0aW9uIHdpdGggdGhlIEdvb2dsZSBNYXBzIEphdmFzY3JpcHRcbiAqIEFQSSB2M1xuICovXG52YXIgR29vZ2xlTWFwc0FQSVdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdvb2dsZU1hcHNBUElXcmFwcGVyKF9sb2FkZXIsIF96b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xvYWRlciA9IF9sb2FkZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFwID1cbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IF90aGlzLl9tYXBSZXNvbHZlciA9IHJlc29sdmU7IH0pO1xuICAgIH1cbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY3JlYXRlTWFwID0gZnVuY3Rpb24gKGVsLCBtYXBPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZXIubG9hZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoZWwsIG1hcE9wdGlvbnMpO1xuICAgICAgICAgICAgX3RoaXMuX21hcFJlc29sdmVyKG1hcCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnNldE1hcE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobSkgeyBtLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGdvb2dsZSBtYXAgbWFya2VyIHdpdGggdGhlIG1hcCBjb250ZXh0XG4gICAgICovXG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmNyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBvcHRpb25zLm1hcCA9IG1hcDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVJbmZvV2luZG93ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KG9wdGlvbnMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBnb29nbGUubWFwLkNpcmNsZSBmb3IgdGhlIGN1cnJlbnQgbWFwLlxuICAgICAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVDaXJjbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgb3B0aW9ucy5tYXAgPSBtYXA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZShvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY3JlYXRlUG9seWxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVNYXAoKS50aGVuKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKG9wdGlvbnMpO1xuICAgICAgICAgICAgbGluZS5zZXRNYXAobWFwKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVQb2x5Z29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlTWFwKCkudGhlbihmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBnb29nbGUubWFwcy5Qb2x5Z29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgcG9seWdvbi5zZXRNYXAobWFwKTtcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgZ2l2ZW4gY29vcmRpbmF0ZXMgYXJlIGluc2l0ZSBhIFBvbHlnb24gcGF0aC5cbiAgICAgKi9cbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY29udGFpbnNMb2NhdGlvbiA9IGZ1bmN0aW9uIChsYXRMbmcsIHBvbHlnb24pIHtcbiAgICAgICAgcmV0dXJuIGdvb2dsZS5tYXBzLmdlb21ldHJ5LnBvbHkuY29udGFpbnNMb2NhdGlvbihsYXRMbmcsIHBvbHlnb24pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnN1YnNjcmliZVRvTWFwRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGFyZykgeyBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChhcmcpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGxhdExuZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLnNldENlbnRlcihsYXRMbmcpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5nZXRab29tID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLmdldFpvb20oKTsgfSk7IH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIG1hcC5nZXRCb3VuZHMoKTsgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uICh6b29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7IHJldHVybiBtYXAuc2V0Wm9vbSh6b29tKTsgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLmdldENlbnRlcigpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5wYW5UbyA9IGZ1bmN0aW9uIChsYXRMbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIG1hcC5wYW5UbyhsYXRMbmcpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5maXRCb3VuZHMgPSBmdW5jdGlvbiAobGF0TG5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7IHJldHVybiBtYXAuZml0Qm91bmRzKGxhdExuZyk7IH0pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnBhblRvQm91bmRzID0gZnVuY3Rpb24gKGxhdExuZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLnBhblRvQm91bmRzKGxhdExuZyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmF0aXZlIEdvb2dsZSBNYXBzIE1hcCBpbnN0YW5jZS4gQmUgY2FyZWZ1bCB3aGVuIHVzaW5nIHRoaXMgaW5zdGFuY2UgZGlyZWN0bHkuXG4gICAgICovXG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmdldE5hdGl2ZU1hcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcDsgfTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgZ2l2ZW4gZXZlbnQgbmFtZSBvbiB0aGUgbWFwIGluc3RhbmNlLlxuICAgICAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS50cmlnZ2VyTWFwRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtLCBldmVudE5hbWUpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IG1hcHNfYXBpX2xvYWRlcl8xLk1hcHNBUElMb2FkZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBHb29nbGVNYXBzQVBJV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLkdvb2dsZU1hcHNBUElXcmFwcGVyID0gR29vZ2xlTWFwc0FQSVdyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb29nbGUtbWFwcy1hcGktd3JhcHBlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9nb29nbGUtbWFwcy1hcGktd3JhcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE1hcHNBUElMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcHNBUElMb2FkZXIoKSB7XG4gICAgfVxuICAgIE1hcHNBUElMb2FkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTWFwc0FQSUxvYWRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYXBzQVBJTG9hZGVyO1xufSgpKTtcbmV4cG9ydHMuTWFwc0FQSUxvYWRlciA9IE1hcHNBUElMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBzLWFwaS1sb2FkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL21hcHMtYXBpLWxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEgPSByZXF1aXJlKCcuLi9nb29nbGUtbWFwcy1hcGktd3JhcHBlcicpO1xudmFyIENpcmNsZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENpcmNsZU1hbmFnZXIoX2FwaVdyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX2FwaVdyYXBwZXIgPSBfYXBpV3JhcHBlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9jaXJjbGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5hZGRDaXJjbGUgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHRoaXMuX2NpcmNsZXMuc2V0KGNpcmNsZSwgdGhpcy5fYXBpV3JhcHBlci5jcmVhdGVDaXJjbGUoe1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogY2lyY2xlLmxhdGl0dWRlLCBsbmc6IGNpcmNsZS5sb25naXR1ZGUgfSxcbiAgICAgICAgICAgIGNsaWNrYWJsZTogY2lyY2xlLmNsaWNrYWJsZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogY2lyY2xlLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBjaXJjbGUuZWRpdGFibGUsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IGNpcmNsZS5maWxsQ29sb3IsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogY2lyY2xlLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgcmFkaXVzOiBjaXJjbGUucmFkaXVzLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IGNpcmNsZS5zdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IGNpcmNsZS5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlUG9zaXRpb246IGNpcmNsZS5zdHJva2VQb3NpdGlvbixcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogY2lyY2xlLnN0cm9rZVdlaWdodCxcbiAgICAgICAgICAgIHZpc2libGU6IGNpcmNsZS52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBjaXJjbGUuekluZGV4XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjaXJjbGUgZnJvbSB0aGUgbWFwLlxuICAgICAqL1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUNpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgYy5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICBfdGhpcy5fY2lyY2xlcy5kZWxldGUoY2lyY2xlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKGNpcmNsZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5nZXRCb3VuZHMoKTsgfSk7XG4gICAgfTtcbiAgICA7XG4gICAgQ2lyY2xlTWFuYWdlci5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmdldENlbnRlcigpOyB9KTtcbiAgICB9O1xuICAgIDtcbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRSYWRpdXMgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuZ2V0UmFkaXVzKCk7IH0pO1xuICAgIH07XG4gICAgQ2lyY2xlTWFuYWdlci5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldENlbnRlcih7IGxhdDogY2lyY2xlLmxhdGl0dWRlLCBsbmc6IGNpcmNsZS5sb25naXR1ZGUgfSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldEVkaXRhYmxlID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldEVkaXRhYmxlKGNpcmNsZS5lZGl0YWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zZXREcmFnZ2FibGUoY2lyY2xlLmRyYWdnYWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuc2V0VmlzaWJsZShjaXJjbGUudmlzaWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldFJhZGl1cyA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zZXRSYWRpdXMoY2lyY2xlLnJhZGl1cyk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNpcmNsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoZSk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaXJjbGVNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIENpcmNsZU1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIENpcmNsZU1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5DaXJjbGVNYW5hZ2VyID0gQ2lyY2xlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNpcmNsZS1tYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL2NpcmNsZS1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJyk7XG52YXIgbWFya2VyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vbWFya2VyLW1hbmFnZXInKTtcbnZhciBJbmZvV2luZG93TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5mb1dpbmRvd01hbmFnZXIoX21hcHNXcmFwcGVyLCBfem9uZSwgX21hcmtlck1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlciA9IF9tYXJrZXJNYW5hZ2VyO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93cyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUluZm9XaW5kb3cgPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaVdpbmRvdyA9IHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KTtcbiAgICAgICAgaWYgKGlXaW5kb3cgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaW5mbyB3aW5kb3cgYWxyZWFkeSBkZWxldGVkXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlXaW5kb3cudGhlbihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9pbmZvV2luZG93cy5kZWxldGUoaW5mb1dpbmRvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5mb1dpbmRvd3MuZ2V0KGluZm9XaW5kb3cpLnRoZW4oZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2V0UG9zaXRpb24oe1xuICAgICAgICAgICAgbGF0OiBpbmZvV2luZG93LmxhdGl0dWRlLFxuICAgICAgICAgICAgbG5nOiBpbmZvV2luZG93LmxvbmdpdHVkZVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gKGluZm9XaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2V0WkluZGV4KGluZm9XaW5kb3cuekluZGV4KTsgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChpbmZvV2luZG93KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKGluZm9XaW5kb3cuaG9zdE1hcmtlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9tYXJrZXJNYW5hZ2VyLmdldE5hdGl2ZU1hcmtlcihpbmZvV2luZG93Lmhvc3RNYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gdy5vcGVuKG1hcCwgbWFya2VyKTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gdy5vcGVuKG1hcCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChpbmZvV2luZG93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAodykgeyByZXR1cm4gdy5jbG9zZSgpOyB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKGluZm9XaW5kb3csIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KS50aGVuKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmFkZEluZm9XaW5kb3cgPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGluZm9XaW5kb3cuY29udGVudCxcbiAgICAgICAgICAgIG1heFdpZHRoOiBpbmZvV2luZG93Lm1heFdpZHRoLFxuICAgICAgICAgICAgekluZGV4OiBpbmZvV2luZG93LnpJbmRleCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvV2luZG93LmxhdGl0dWRlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgaW5mb1dpbmRvdy5sb25naXR1ZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0geyBsYXQ6IGluZm9XaW5kb3cubGF0aXR1ZGUsIGxuZzogaW5mb1dpbmRvdy5sb25naXR1ZGUgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mb1dpbmRvd1Byb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVJbmZvV2luZG93KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93cy5zZXQoaW5mb1dpbmRvdywgaW5mb1dpbmRvd1Byb21pc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEdvb2dsZSBNYXBzIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gSW5mb1dpbmRvdyBhcyBhbiBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGluZm9XaW5kb3cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIGkuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoZSk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBtYXJrZXJfbWFuYWdlcl8xLk1hcmtlck1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW5mb1dpbmRvd01hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5JbmZvV2luZG93TWFuYWdlciA9IEluZm9XaW5kb3dNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mby13aW5kb3ctbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4vLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbnZhciBNYXJrZXJNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXJrZXJNYW5hZ2VyKF9tYXBzV3JhcHBlciwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFya2VycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcik7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG1hcmtlciBhbHJlYWR5IGRlbGV0ZWRcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBtLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWFya2Vycy5kZWxldGUobWFya2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU1hcmtlclBvc2l0aW9uID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnNldFBvc2l0aW9uKHsgbGF0OiBtYXJrZXIubGF0aXR1ZGUsIGxuZzogbWFya2VyLmxvbmdpdHVkZSB9KTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVUaXRsZSA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRUaXRsZShtYXJrZXIudGl0bGUpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUxhYmVsID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IG0uc2V0TGFiZWwobWFya2VyLmxhYmVsKTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVEcmFnZ2FibGUgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2V0RHJhZ2dhYmxlKG1hcmtlci5kcmFnZ2FibGUpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUljb24gPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2V0SWNvbihtYXJrZXIuaWNvblVybCk7IH0pO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUudXBkYXRlT3BhY2l0eSA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRPcGFjaXR5KG1hcmtlci5vcGFjaXR5KTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVWaXNpYmxlID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnNldFZpc2libGUobWFya2VyLnZpc2libGUpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVpJbmRleCA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRaSW5kZXgobWFya2VyLnpJbmRleCk7IH0pO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUuYWRkTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICB2YXIgbWFya2VyUHJvbWlzZSA9IHRoaXMuX21hcHNXcmFwcGVyLmNyZWF0ZU1hcmtlcih7XG4gICAgICAgICAgICBwb3NpdGlvbjogeyBsYXQ6IG1hcmtlci5sYXRpdHVkZSwgbG5nOiBtYXJrZXIubG9uZ2l0dWRlIH0sXG4gICAgICAgICAgICBsYWJlbDogbWFya2VyLmxhYmVsLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBtYXJrZXIuZHJhZ2dhYmxlLFxuICAgICAgICAgICAgaWNvbjogbWFya2VyLmljb25VcmwsXG4gICAgICAgICAgICBvcGFjaXR5OiBtYXJrZXIub3BhY2l0eSxcbiAgICAgICAgICAgIHZpc2libGU6IG1hcmtlci52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBtYXJrZXIuekluZGV4LFxuICAgICAgICAgICAgdGl0bGU6IG1hcmtlci50aXRsZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWFya2Vycy5zZXQobWFya2VyLCBtYXJrZXJQcm9taXNlKTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLmdldE5hdGl2ZU1hcmtlciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcik7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBtYXJrZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZlci5uZXh0KGUpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE1hcmtlck1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIE1hcmtlck1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5NYXJrZXJNYW5hZ2VyID0gTWFya2VyTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcmtlci1tYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL21hcmtlci1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJyk7XG52YXIgUG9seWdvbk1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvbHlnb25NYW5hZ2VyKF9tYXBzV3JhcHBlciwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fcG9seWdvbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS5hZGRQb2x5Z29uID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHBvbHlnb25Qcm9taXNlID0gdGhpcy5fbWFwc1dyYXBwZXIuY3JlYXRlUG9seWdvbih7XG4gICAgICAgICAgICBjbGlja2FibGU6IHBhdGguY2xpY2thYmxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBwYXRoLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBwYXRoLmVkaXRhYmxlLFxuICAgICAgICAgICAgZmlsbENvbG9yOiBwYXRoLmZpbGxDb2xvcixcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBwYXRoLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgZ2VvZGVzaWM6IHBhdGguZ2VvZGVzaWMsXG4gICAgICAgICAgICBwYXRoczogcGF0aC5wYXRocyxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBwYXRoLnN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogcGF0aC5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBwYXRoLnN0cm9rZVdlaWdodCxcbiAgICAgICAgICAgIHZpc2libGU6IHBhdGgudmlzaWJsZSxcbiAgICAgICAgICAgIHpJbmRleDogcGF0aC56SW5kZXgsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wb2x5Z29ucy5zZXQocGF0aCwgcG9seWdvblByb21pc2UpO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVBvbHlnb24gPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLnRoZW4oZnVuY3Rpb24gKGwpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IGwuc2V0UGF0aHMocG9seWdvbi5wYXRocyk7IH0pOyB9KTtcbiAgICB9O1xuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRQb2x5Z29uT3B0aW9ucyA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29ucy5nZXQocGF0aCkudGhlbihmdW5jdGlvbiAobCkgeyBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZVBvbHlnb24gPSBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG0gPSB0aGlzLl9wb2x5Z29ucy5nZXQocGF0aHMpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbC5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3BvbHlnb25zLmRlbGV0ZShwYXRocyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb2x5Z29uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlRXZlbnRPYnNlcnZhYmxlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMuX3BvbHlnb25zLmdldChwYXRoKS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgbC5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChlKTsgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgUG9seWdvbk1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFBvbHlnb25NYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuUG9seWdvbk1hbmFnZXIgPSBQb2x5Z29uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlnb24tbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5Z29uLW1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKTtcbnZhciBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xID0gcmVxdWlyZSgnLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbnZhciBQb2x5bGluZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvbHlsaW5lTWFuYWdlcihfbWFwc1dyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgUG9seWxpbmVNYW5hZ2VyLl9jb252ZXJ0UG9pbnRzID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBsaW5lLl9nZXRQb2ludHMoKS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyBsYXQ6IHBvaW50LmxhdGl0dWRlLCBsbmc6IHBvaW50LmxvbmdpdHVkZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICBQb2x5bGluZU1hbmFnZXIucHJvdG90eXBlLmFkZFBvbHlsaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBQb2x5bGluZU1hbmFnZXIuX2NvbnZlcnRQb2ludHMobGluZSk7XG4gICAgICAgIHZhciBwb2x5bGluZVByb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVQb2x5bGluZSh7XG4gICAgICAgICAgICBjbGlja2FibGU6IGxpbmUuY2xpY2thYmxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBsaW5lLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBsaW5lLmVkaXRhYmxlLFxuICAgICAgICAgICAgZ2VvZGVzaWM6IGxpbmUuZ2VvZGVzaWMsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogbGluZS5zdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IGxpbmUuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogbGluZS5zdHJva2VXZWlnaHQsXG4gICAgICAgICAgICB2aXNpYmxlOiBsaW5lLnZpc2libGUsXG4gICAgICAgICAgICB6SW5kZXg6IGxpbmUuekluZGV4LFxuICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVzLnNldChsaW5lLCBwb2x5bGluZVByb21pc2UpO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVQb2x5bGluZVBvaW50cyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYXRoID0gUG9seWxpbmVNYW5hZ2VyLl9jb252ZXJ0UG9pbnRzKGxpbmUpO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGZ1bmN0aW9uIChsKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyBsLnNldFBhdGgocGF0aCk7IH0pOyB9KTtcbiAgICB9O1xuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUuc2V0UG9seWxpbmVPcHRpb25zID0gZnVuY3Rpb24gKGxpbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSkudGhlbihmdW5jdGlvbiAobCkgeyBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVQb2x5bGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtID0gdGhpcy5fcG9seWxpbmVzLmdldChsaW5lKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLnRoZW4oZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGwuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9wb2x5bGluZXMuZGVsZXRlKGxpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fcG9seWxpbmVzLmdldChsaW5lKS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgbC5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChlKTsgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFBvbHlsaW5lTWFuYWdlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xLkdvb2dsZU1hcHNBUElXcmFwcGVyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5OZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gUG9seWxpbmVNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuUG9seWxpbmVNYW5hZ2VyID0gUG9seWxpbmVNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9seWxpbmUtbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4vLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbi8qKlxuICogTWFuYWdlcyBhbGwgS01MIExheWVycyBmb3IgYSBHb29nbGUgTWFwIGluc3RhbmNlLlxuICovXG52YXIgS21sTGF5ZXJNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLbWxMYXllck1hbmFnZXIoX3dyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIgPSBfd3JhcHBlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9sYXllcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgS01MIExheWVyIHRvIHRoZSBtYXAuXG4gICAgICovXG4gICAgS21sTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5hZGRLbWxMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICB2YXIgbmV3TGF5ZXIgPSB0aGlzLl93cmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuS21sTGF5ZXIoe1xuICAgICAgICAgICAgICAgIGNsaWNrYWJsZTogbGF5ZXIuY2xpY2thYmxlLFxuICAgICAgICAgICAgICAgIG1hcDogbSxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVZpZXdwb3J0OiBsYXllci5wcmVzZXJ2ZVZpZXdwb3J0LFxuICAgICAgICAgICAgICAgIHNjcmVlbk92ZXJsYXlzOiBsYXllci5zY3JlZW5PdmVybGF5cyxcbiAgICAgICAgICAgICAgICBzdXBwcmVzc0luZm9XaW5kb3dzOiBsYXllci5zdXBwcmVzc0luZm9XaW5kb3dzLFxuICAgICAgICAgICAgICAgIHVybDogbGF5ZXIudXJsLFxuICAgICAgICAgICAgICAgIHpJbmRleDogbGF5ZXIuekluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xheWVycy5zZXQobGF5ZXIsIG5ld0xheWVyKTtcbiAgICB9O1xuICAgIEttbExheWVyTWFuYWdlci5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChsYXllciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKS50aGVuKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgS21sTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVLbWxMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICBsLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIF90aGlzLl9sYXllcnMuZGVsZXRlKGxheWVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR29vZ2xlIE1hcHMgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBLbWxMYXllciBhcyBhbiBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgS21sTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsYXllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMuX2xheWVycy5nZXQobGF5ZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZlci5uZXh0KGUpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLbWxMYXllck1hbmFnZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgS21sTGF5ZXJNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBLbWxMYXllck1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5LbWxMYXllck1hbmFnZXIgPSBLbWxMYXllck1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rbWwtbGF5ZXItbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9rbWwtbGF5ZXItbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNpcmNsZV9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9jaXJjbGUtbWFuYWdlcicpO1xudmFyIFNlYm1Hb29nbGVNYXBDaXJjbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBDaXJjbGUoX21hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlciA9IF9tYW5hZ2VyO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBDaXJjbGUgaGFuZGxlcyBtb3VzZSBldmVudHMuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGRyYWcgdGhpcyBjaXJjbGUgb3ZlciB0aGUgbWFwLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGVkaXQgdGhpcyBjaXJjbGUgYnkgZHJhZ2dpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIHNob3duIGF0XG4gICAgICAgICAqIHRoZSBjZW50ZXIgYW5kIGFyb3VuZCB0aGUgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2lyY2xlLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByYWRpdXMgaW4gbWV0ZXJzIG9uIHRoZSBFYXJ0aCdzIHN1cmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3Ryb2tlIHBvc2l0aW9uLiBEZWZhdWx0cyB0byBDRU5URVIuXG4gICAgICAgICAqIFRoaXMgcHJvcGVydHkgaXMgbm90IHN1cHBvcnRlZCBvbiBJbnRlcm5ldCBFeHBsb3JlciA4IGFuZCBlYXJsaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHJva2VQb3NpdGlvbiA9ICdDRU5URVInO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0cm9rZSB3aWR0aCBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0cm9rZVdlaWdodCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgY2lyY2xlIGlzIHZpc2libGUgb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGNpcmNsZSdzIGNlbnRlciBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZW50ZXJDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaXJjbGVDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNpcmNsZURibENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcmVwZWF0ZWRseSBmaXJlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnRW5kID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIGNpcmNsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlZG93biBldmVudCBpcyBmaXJlZCBvbiB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vtb3ZlIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlTW92ZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIGNpcmNsZSBtb3VzZW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW91c2VPdXQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBjaXJjbGUgbW91c2VvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZU92ZXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZVVwID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgY2lyY2xlJ3MgcmFkaXVzIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1c0NoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGNpcmNsZSBpcyByaWdodC1jbGlja2VkIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yaWdodENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fY2lyY2xlQWRkZWRUb01hbmFnZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXZlbnRTdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5hZGRDaXJjbGUodGhpcyk7XG4gICAgICAgIHRoaXMuX2NpcmNsZUFkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudExpc3RlbmVycygpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jaXJjbGVBZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLnNldENlbnRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snZWRpdGFibGUnXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5zZXRFZGl0YWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snZHJhZ2dhYmxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIuc2V0RHJhZ2dhYmxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd2aXNpYmxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIuc2V0VmlzaWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1sncmFkaXVzJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIuc2V0UmFkaXVzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNpcmNsZU9wdGlvbnNDaGFuZ2VzKGNoYW5nZXMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcENpcmNsZS5wcm90b3R5cGUuX3VwZGF0ZUNpcmNsZU9wdGlvbnNDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFNlYm1Hb29nbGVNYXBDaXJjbGUuX21hcE9wdGlvbnMuaW5kZXhPZihrKSAhPT0gLTE7IH0pO1xuICAgICAgICBvcHRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHsgb3B0aW9uc1trXSA9IGNoYW5nZXNba10uY3VycmVudFZhbHVlOyB9KTtcbiAgICAgICAgaWYgKG9wdGlvbktleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5fcmVnaXN0ZXJFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZXZlbnRzLnNldCgnY2VudGVyX2NoYW5nZWQnLCB0aGlzLmNlbnRlckNoYW5nZSk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ2NsaWNrJywgdGhpcy5jaXJjbGVDbGljayk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ2RibGNsaWNrJywgdGhpcy5jaXJjbGVEYmxDbGljayk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ2RyYWcnLCB0aGlzLmRyYWcpO1xuICAgICAgICBldmVudHMuc2V0KCdkcmFnZW5kJywgdGhpcy5kcmFnRW5kKTtcbiAgICAgICAgZXZlbnRzLnNldCgnZHJhZ1N0YXJ0JywgdGhpcy5kcmFnU3RhcnQpO1xuICAgICAgICBldmVudHMuc2V0KCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlRG93bik7XG4gICAgICAgIGV2ZW50cy5zZXQoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlKTtcbiAgICAgICAgZXZlbnRzLnNldCgnbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0KTtcbiAgICAgICAgZXZlbnRzLnNldCgnbW91c2VvdmVyJywgdGhpcy5tb3VzZU92ZXIpO1xuICAgICAgICBldmVudHMuc2V0KCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwKTtcbiAgICAgICAgZXZlbnRzLnNldCgncmFkaXVzX2NoYW5nZWQnLCB0aGlzLnJhZGl1c0NoYW5nZSk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ3JpZ2h0Y2xpY2snLCB0aGlzLnJpZ2h0Q2xpY2spO1xuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRFbWl0dGVyLCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgIF90aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMucHVzaChfdGhpcy5fbWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUoZXZlbnROYW1lLCBfdGhpcykuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGl1c19jaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYW5hZ2VyLmdldFJhZGl1cyhfdGhpcykudGhlbihmdW5jdGlvbiAocmFkaXVzKSB7IHJldHVybiBldmVudEVtaXR0ZXIuZW1pdChyYWRpdXMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXJfY2hhbmdlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbWFuYWdlci5nZXRDZW50ZXIoX3RoaXMpLnRoZW4oZnVuY3Rpb24gKGNlbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudEVtaXR0ZXIuZW1pdCh7IGxhdDogY2VudGVyLmxhdCgpLCBsbmc6IGNlbnRlci5sbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCh7IGNvb3JkczogeyBsYXQ6IHZhbHVlLmxhdExuZy5sYXQoKSwgbG5nOiB2YWx1ZS5sYXRMbmcubG5nKCkgfSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocykgeyBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgICAgICB0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLnJlbW92ZUNpcmNsZSh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGlzIENpcmNsZS5cbiAgICAgKi9cbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYW5hZ2VyLmdldEJvdW5kcyh0aGlzKTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYW5hZ2VyLmdldENlbnRlcih0aGlzKTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLl9tYXBPcHRpb25zID0gW1xuICAgICAgICAnZmlsbENvbG9yJywgJ2ZpbGxPcGFjaXR5JywgJ3N0cm9rZUNvbG9yJywgJ3N0cm9rZU9wYWNpdHknLCAnc3Ryb2tlUG9zaXRpb24nLCAnc3Ryb2tlV2VpZ2h0JyxcbiAgICAgICAgJ3Zpc2libGUnLCAnekluZGV4J1xuICAgIF07XG4gICAgU2VibUdvb2dsZU1hcENpcmNsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VibS1nb29nbGUtbWFwLWNpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xhdGl0dWRlJywgJ2xvbmdpdHVkZScsICdjbGlja2FibGUnLCAnZHJhZ2dhYmxlOiBjaXJjbGVEcmFnZ2FibGUnLCAnZWRpdGFibGUnLCAnZmlsbENvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsT3BhY2l0eScsICdyYWRpdXMnLCAnc3Ryb2tlQ29sb3InLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VQb3NpdGlvbicsICdzdHJva2VXZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc2libGUnLCAnekluZGV4J1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2VudGVyQ2hhbmdlJywgJ2NpcmNsZUNsaWNrJywgJ2NpcmNsZURibENsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnU3RhcnQnLCAnbW91c2VEb3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncmFkaXVzQ2hhbmdlJywgJ3JpZ2h0Q2xpY2snXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogY2lyY2xlX21hbmFnZXJfMS5DaXJjbGVNYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBDaXJjbGU7XG59KCkpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwQ2lyY2xlID0gU2VibUdvb2dsZU1hcENpcmNsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtY2lyY2xlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1jaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBpbmZvX3dpbmRvd19tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyJyk7XG52YXIgaW5mb1dpbmRvd0lkID0gMDtcbi8qKlxuICogU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgcmVuZGVycyBhIGluZm8gd2luZG93IGluc2lkZSBhIHtAbGluayBTZWJtR29vZ2xlTWFwTWFya2VyfSBvciBzdGFuZGFsb25lLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIsIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93IH0gZnJvbVxuICogJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgZGlyZWN0aXZlczogW1NlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIsIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93XSxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlYm0tZ29vZ2xlLW1hcCBbbGF0aXR1ZGVdPVwibGF0XCIgW2xvbmdpdHVkZV09XCJsbmdcIiBbem9vbV09XCJ6b29tXCI+XG4gKiAgICAgIDxzZWJtLWdvb2dsZS1tYXAtbWFya2VyIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFtsYWJlbF09XCInTSdcIj5cbiAqICAgICAgICA8c2VibS1nb29nbGUtbWFwLWluZm8td2luZG93IFtkaXNhYmxlQXV0b1Bhbl09XCJ0cnVlXCI+XG4gKiAgICAgICAgICBIaSwgdGhpcyBpcyB0aGUgY29udGVudCBvZiB0aGUgPHN0cm9uZz5pbmZvIHdpbmRvdzwvc3Ryb25nPlxuICogICAgICAgIDwvc2VibS1nb29nbGUtbWFwLWluZm8td2luZG93PlxuICogICAgICA8L3NlYm0tZ29vZ2xlLW1hcC1tYXJrZXI+XG4gKiAgICA8L3NlYm0tZ29vZ2xlLW1hcD5cbiAqICBgXG4gKiB9KVxuICogYGBgXG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcEluZm9XaW5kb3coX2luZm9XaW5kb3dNYW5hZ2VyLCBfZWwpIHtcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvd01hbmFnZXIgPSBfaW5mb1dpbmRvd01hbmFnZXI7XG4gICAgICAgIHRoaXMuX2VsID0gX2VsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgb3BlbiBzdGF0ZSBmb3IgdGhlIEluZm9XaW5kb3cuIFlvdSBjYW4gYWxzbyBjYWxsIHRoZSBvcGVuKCkgYW5kIGNsb3NlKCkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBpbmZvIHdpbmRvdyBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZm9XaW5kb3dDbG9zZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3dBZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pZCA9IChpbmZvV2luZG93SWQrKykudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWJtLWdvb2dsZS1tYXAtaW5mby13aW5kb3ctY29udGVudCcpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93TWFuYWdlci5hZGRJbmZvV2luZG93KHRoaXMpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93QWRkZWRUb01hbmFnZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl91cGRhdGVPcGVuU3RhdGUoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudExpc3RlbmVycygpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5mb1dpbmRvd0FkZGVkVG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSAmJiB0eXBlb2YgdGhpcy5sYXRpdHVkZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmxvbmdpdHVkZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLnNldFBvc2l0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd6SW5kZXgnXSkge1xuICAgICAgICAgICAgdGhpcy5faW5mb1dpbmRvd01hbmFnZXIuc2V0WkluZGV4KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydpc09wZW4nXSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlT3BlblN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0SW5mb1dpbmRvd09wdGlvbnMoY2hhbmdlcyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuX3JlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnY2xvc2VjbGljaycsIHRoaXMpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLmluZm9XaW5kb3dDbG9zZS5lbWl0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLl91cGRhdGVPcGVuU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNPcGVuID8gdGhpcy5vcGVuKCkgOiB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuX3NldEluZm9XaW5kb3dPcHRpb25zID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93Ll9pbmZvV2luZG93T3B0aW9uc0lucHV0cy5pbmRleE9mKGspICE9PSAtMTsgfSk7XG4gICAgICAgIG9wdGlvbktleXMuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBvcHRpb25zW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7IH0pO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93TWFuYWdlci5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGluZm8gd2luZG93LlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW5mb1dpbmRvd01hbmFnZXIub3Blbih0aGlzKTsgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGluZm8gd2luZG93LlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmNsb3NlKHRoaXMpLnRoZW4oZnVuY3Rpb24gKCkgeyBfdGhpcy5pbmZvV2luZG93Q2xvc2UuZW1pdCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZDsgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1NlYm1Hb29nbGVNYXBJbmZvV2luZG93LScgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmRlbGV0ZUluZm9XaW5kb3codGhpcyk7IH07XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cuX2luZm9XaW5kb3dPcHRpb25zSW5wdXRzID0gWydkaXNhYmxlQXV0b1BhbicsICdtYXhXaWR0aCddO1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkNvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAtaW5mby13aW5kb3cnLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFsnbGF0aXR1ZGUnLCAnbG9uZ2l0dWRlJywgJ2Rpc2FibGVBdXRvUGFuJywgJ2lzT3BlbicsICd6SW5kZXgnLCAnbWF4V2lkdGgnXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWydpbmZvV2luZG93Q2xvc2UnXSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz0nc2VibS1nb29nbGUtbWFwLWluZm8td2luZG93LWNvbnRlbnQnPlxcbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgPC9kaXY+XFxuICBcIlxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogaW5mb193aW5kb3dfbWFuYWdlcl8xLkluZm9XaW5kb3dNYW5hZ2VyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5FbGVtZW50UmVmLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93O1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgPSBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtaW5mby13aW5kb3cuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWluZm8td2luZG93LmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIga21sX2xheWVyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vLi4vc2VydmljZXMvbWFuYWdlcnMva21sLWxheWVyLW1hbmFnZXInKTtcbnZhciBsYXllcklkID0gMDtcbnZhciBTZWJtR29vZ2xlTWFwS21sTGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBLbWxMYXllcihfbWFuYWdlcikge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyID0gX21hbmFnZXI7XG4gICAgICAgIHRoaXMuX2FkZGVkVG9NYW5hZ2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lkID0gKGxheWVySWQrKykudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGxheWVyIHJlY2VpdmVzIG1vdXNlIGV2ZW50cy4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGlucHV0IG1hcCBpcyBjZW50ZXJlZCBhbmQgem9vbWVkIHRvIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgKiBsYXllci5cbiAgICAgICAgICogSWYgdGhpcyBvcHRpb24gaXMgc2V0IHRvIHRydWUsIHRoZSB2aWV3cG9ydCBpcyBsZWZ0IHVuY2hhbmdlZCwgdW5sZXNzIHRoZSBtYXAncyBjZW50ZXIgYW5kIHpvb21cbiAgICAgICAgICogd2VyZSBuZXZlciBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXNlcnZlVmlld3BvcnQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gcmVuZGVyIHRoZSBzY3JlZW4gb3ZlcmxheXMuIERlZmF1bHQgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NyZWVuT3ZlcmxheXMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VwcHJlc3MgdGhlIHJlbmRlcmluZyBvZiBpbmZvIHdpbmRvd3Mgd2hlbiBsYXllciBmZWF0dXJlcyBhcmUgY2xpY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcHJlc3NJbmZvV2luZG93cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgS01MIGRvY3VtZW50IHRvIGRpc3BsYXkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpJbmRleCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBmZWF0dXJlIGluIHRoZSBsYXllciBpcyBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXllckNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgS01MIGxheWVycyBkZWZhdWx0IHZpZXdwb3J0IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0Vmlld3BvcnRDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBLTUwgbGF5ZXIgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgICAqIEF0IHRoaXMgcG9pbnQgaXQgaXMgc2FmZSB0byByZWFkIHRoZSBzdGF0dXMgcHJvcGVydHkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBsYXllciBsb2FkZWRcbiAgICAgICAgICogc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkZWRUb01hbmFnZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYW5hZ2VyLmFkZEttbExheWVyKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRlZFRvTWFuYWdlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvbHlnb25PcHRpb25zKGNoYW5nZXMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLnByb3RvdHlwZS5fdXBkYXRlUG9seWdvbk9wdGlvbnMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBTZWJtR29vZ2xlTWFwS21sTGF5ZXIuX2ttbExheWVyT3B0aW9ucy5pbmRleE9mKGspICE9PSAtMTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaykge1xuICAgICAgICAgICAgb2JqW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBLbWxMYXllci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxheWVyQ2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RlZmF1bHR2aWV3cG9ydF9jaGFuZ2VkJywgaGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGVmYXVsdFZpZXdwb3J0Q2hhbmdlLmVtaXQoKTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnc3RhdHVzX2NoYW5nZWQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdGF0dXNDaGFuZ2UuZW1pdCgpOyB9IH0sXG4gICAgICAgIF07XG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9tYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZShvYmoubmFtZSwgX3RoaXMpLnN1YnNjcmliZShvYmouaGFuZGxlcik7XG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKG9zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJTZWJtR29vZ2xlTWFwS21sTGF5ZXItXCIgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLmRlbGV0ZUttbExheWVyKHRoaXMpO1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBhbGwgcmVnaXN0ZXJlZCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLl9rbWxMYXllck9wdGlvbnMgPSBbJ2NsaWNrYWJsZScsICdwcmVzZXJ2ZVZpZXdwb3J0JywgJ3NjcmVlbk92ZXJsYXlzJywgJ3N1cHByZXNzSW5mb1dpbmRvd3MnLCAndXJsJywgJ3pJbmRleCddO1xuICAgIFNlYm1Hb29nbGVNYXBLbWxMYXllci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VibS1nb29nbGUtbWFwLWttbC1sYXllcicsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydjbGlja2FibGUnLCAncHJlc2VydmVWaWV3cG9ydCcsICdzY3JlZW5PdmVybGF5cycsICdzdXBwcmVzc0luZm9XaW5kb3dzJywgJ3VybCcsICd6SW5kZXgnXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWydsYXllckNsaWNrJywgJ2RlZmF1bHRWaWV3cG9ydENoYW5nZScsICdzdGF0dXNDaGFuZ2UnXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGttbF9sYXllcl9tYW5hZ2VyXzEuS21sTGF5ZXJNYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBLbWxMYXllciA9IFNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAta21sLWxheWVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1rbWwtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBtYXJrZXJfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvbWFya2VyLW1hbmFnZXInKTtcbnZhciBnb29nbGVfbWFwX2luZm9fd2luZG93XzEgPSByZXF1aXJlKCcuL2dvb2dsZS1tYXAtaW5mby13aW5kb3cnKTtcbnZhciBtYXJrZXJJZCA9IDA7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBNYXJrZXIgcmVuZGVycyBhIG1hcCBtYXJrZXIgaW5zaWRlIGEge0BsaW5rIFNlYm1Hb29nbGVNYXB9LlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIgfSBmcm9tICdhbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxuICogIGRpcmVjdGl2ZXM6IFtTZWJtR29vZ2xlTWFwLCBTZWJtR29vZ2xlTWFwTWFya2VyXSxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlYm0tZ29vZ2xlLW1hcCBbbGF0aXR1ZGVdPVwibGF0XCIgW2xvbmdpdHVkZV09XCJsbmdcIiBbem9vbV09XCJ6b29tXCI+XG4gKiAgICAgIDxzZWJtLWdvb2dsZS1tYXAtbWFya2VyIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFtsYWJlbF09XCInTSdcIj5cbiAqICAgICAgPC9zZWJtLWdvb2dsZS1tYXAtbWFya2VyPlxuICogICAgPC9zZWJtLWdvb2dsZS1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGBgYFxuICovXG52YXIgU2VibUdvb2dsZU1hcE1hcmtlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcE1hcmtlcihfbWFya2VyTWFuYWdlcikge1xuICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyID0gX21hcmtlck1hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgbWFya2VyIGNhbiBiZSBkcmFnZ2VkLiBEZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSBtYXJrZXIgaXMgdmlzaWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBvcGVuIHRoZSBjaGlsZCBpbmZvIHdpbmRvdyB3aGVuIHRoZSBtYXJrZXIgaXMgY2xpY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbkluZm9XaW5kb3cgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1hcmtlcidzIG9wYWNpdHkgYmV0d2VlbiAwLjAgYW5kIDEuMC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgbWFya2VycyBhcmUgZGlzcGxheWVkIG9uIHRoZSBtYXAgaW4gb3JkZXIgb2YgdGhlaXIgekluZGV4LCB3aXRoIGhpZ2hlciB2YWx1ZXMgZGlzcGxheWluZyBpblxuICAgICAgICAgKiBmcm9udCBvZiBtYXJrZXJzIHdpdGggbG93ZXIgdmFsdWVzLiBCeSBkZWZhdWx0LCBtYXJrZXJzIGFyZSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvIHRoZWlyXG4gICAgICAgICAqIHZlcnRpY2FsIHBvc2l0aW9uIG9uIHNjcmVlbiwgd2l0aCBsb3dlciBtYXJrZXJzIGFwcGVhcmluZyBpbiBmcm9udCBvZiBtYXJrZXJzIGZ1cnRoZXIgdXAgdGhlXG4gICAgICAgICAqIHNjcmVlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuekluZGV4ID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcmtlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFya2VyQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdFbmQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIG1vdXNlcyBvdmVyIHRoZSBtYXJrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlT3ZlciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgbW91c2VzIG91dHNpZGUgdGhlIG1hcmtlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW91c2VPdXQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuX2lkID0gKG1hcmtlcklkKyspLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5mb1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZm9XaW5kb3cuaG9zdE1hcmtlciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sYXRpdHVkZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMubG9uZ2l0dWRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlcikge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlci5hZGRNYXJrZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xhdGl0dWRlJ10gfHwgY2hhbmdlc1snbG9uZ2l0dWRlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlTWFya2VyUG9zaXRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ3RpdGxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlVGl0bGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xhYmVsJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlTGFiZWwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2RyYWdnYWJsZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZURyYWdnYWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snaWNvblVybCddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZUljb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ29wYWNpdHknXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlci51cGRhdGVPcGFjaXR5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd2aXNpYmxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlVmlzaWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snekluZGV4J10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlWkluZGV4KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjcyA9IHRoaXMuX21hcmtlck1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKCdjbGljaycsIHRoaXMpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3BlbkluZm9XaW5kb3cgJiYgX3RoaXMuaW5mb1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5mb1dpbmRvdy5vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5tYXJrZXJDbGljay5lbWl0KG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChjcyk7XG4gICAgICAgIHZhciBkcyA9IHRoaXMuX21hcmtlck1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKCdkcmFnZW5kJywgdGhpcylcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmRyYWdFbmQuZW1pdCh7IGNvb3JkczogeyBsYXQ6IGUubGF0TG5nLmxhdCgpLCBsbmc6IGUubGF0TG5nLmxuZygpIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKGRzKTtcbiAgICAgICAgdmFyIG1vdmVyID0gdGhpcy5fbWFya2VyTWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUoJ21vdXNlb3ZlcicsIHRoaXMpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5tb3VzZU92ZXIuZW1pdCh7IGNvb3JkczogeyBsYXQ6IGUubGF0TG5nLmxhdCgpLCBsbmc6IGUubGF0TG5nLmxuZygpIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKG1vdmVyKTtcbiAgICAgICAgdmFyIG1vdXQgPSB0aGlzLl9tYXJrZXJNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnbW91c2VvdXQnLCB0aGlzKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMubW91c2VPdXQuZW1pdCh7IGNvb3JkczogeyBsYXQ6IGUubGF0TG5nLmxhdCgpLCBsbmc6IGUubGF0TG5nLmxuZygpIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKG1vdXQpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWQ7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1NlYm1Hb29nbGVNYXBNYXJrZXItJyArIHRoaXMuX2lkLnRvU3RyaW5nKCk7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLmRlbGV0ZU1hcmtlcih0aGlzKTtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAtbWFya2VyJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGF0aXR1ZGUnLCAnbG9uZ2l0dWRlJywgJ3RpdGxlJywgJ2xhYmVsJywgJ2RyYWdnYWJsZTogbWFya2VyRHJhZ2dhYmxlJywgJ2ljb25VcmwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5JbmZvV2luZG93JywgJ29wYWNpdHknLCAndmlzaWJsZScsICd6SW5kZXgnXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFsnbWFya2VyQ2xpY2snLCAnZHJhZ0VuZCcsICdtb3VzZU92ZXInLCAnbW91c2VPdXQnXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcE1hcmtlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBtYXJrZXJfbWFuYWdlcl8xLk1hcmtlck1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaW5mb1dpbmRvdyc6IFt7IHR5cGU6IGNvcmVfMS5Db250ZW50Q2hpbGQsIGFyZ3M6IFtnb29nbGVfbWFwX2luZm9fd2luZG93XzEuU2VibUdvb2dsZU1hcEluZm9XaW5kb3csXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gU2VibUdvb2dsZU1hcE1hcmtlcjtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBNYXJrZXIgPSBTZWJtR29vZ2xlTWFwTWFya2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z29vZ2xlLW1hcC1tYXJrZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLW1hcmtlci5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIHBvbHlnb25fbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvcG9seWdvbi1tYW5hZ2VyJyk7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBQb2x5Z29uIHJlbmRlcnMgYSBwb2x5Z29uIG9uIGEge0BsaW5rIFNlYm1Hb29nbGVNYXB9XG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgU2VibUdvb2dsZU1hcCwgU2VibUdvb2dsZVBvbHlnb24sIExhdExuZ0xpdGVyYWwgfSBmcm9tICdhbmd1bGFyMi1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgc3R5bGVzOiBbYFxuICogICAgLnNlbWItbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlbWItbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cbiAqICAgICAgPHNlbWItbWFwLXBvbHlnb24gW3BhdGhzXT1cInBhdGhzXCI+XG4gKiAgICAgIDwvc2VtYi1tYXAtcG9seWdvbj5cbiAqICAgIDwvc2VtYi1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBNeU1hcENtcCB7XG4gKiAgIGxhdDogbnVtYmVyID0gMDtcbiAqICAgbG5nOiBudW1iZXIgPSAwO1xuICogICB6b29tOiBudW1iZXIgPSAxMDtcbiAqICAgcGF0aHM6IEFycmF5PExhdExuZ0xpdGVyYWw+ID0gW1xuICogICAgIHsgbGF0OiAwLCAgbG5nOiAxMCB9LFxuICogICAgIHsgbGF0OiAwLCAgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiAxMCwgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiAxMCwgbG5nOiAxMCB9LFxuICogICAgIHsgbGF0OiAwLCAgbG5nOiAxMCB9XG4gKiAgIF1cbiAqICAgLy8gTmVzdGluZyBwYXRocyB3aWxsIGNyZWF0ZSBhIGhvbGUgd2hlcmUgdGhleSBvdmVybGFwO1xuICogICBuZXN0ZWRQYXRoczogQXJyYXk8QXJyYXk8TGF0TG5nTGl0ZXJhbD4+ID0gW1tcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMTAgfSxcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMjAgfSxcbiAqICAgICB7IGxhdDogMTAsIGxuZzogMjAgfSxcbiAqICAgICB7IGxhdDogMTAsIGxuZzogMTAgfSxcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMTAgfVxuICogICBdLCBbXG4gKiAgICAgeyBsYXQ6IDAsIGxuZzogMTUgfSxcbiAqICAgICB7IGxhdDogMCwgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiA1LCBsbmc6IDIwIH0sXG4gKiAgICAgeyBsYXQ6IDUsIGxuZzogMTUgfSxcbiAqICAgICB7IGxhdDogMCwgbG5nOiAxNSB9XG4gKiAgIF1dXG4gKiB9XG4gKiBgYGBcbiAqL1xudmFyIFNlYm1Hb29nbGVNYXBQb2x5Z29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWJtR29vZ2xlTWFwUG9seWdvbihfcG9seWdvbk1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIgPSBfcG9seWdvbk1hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIFBvbHlnb24gaGFuZGxlcyBtb3VzZSBldmVudHMuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGRyYWcgdGhpcyBzaGFwZSBvdmVyIHRoZSBtYXAuIFRoZSBnZW9kZXNpY1xuICAgICAgICAgKiBwcm9wZXJ0eSBkZWZpbmVzIHRoZSBtb2RlIG9mIGRyYWdnaW5nLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGVkaXQgdGhpcyBzaGFwZSBieSBkcmFnZ2luZyB0aGUgY29udHJvbFxuICAgICAgICAgKiBwb2ludHMgc2hvd24gYXQgdGhlIHZlcnRpY2VzIGFuZCBvbiBlYWNoIHNlZ21lbnQuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0cnVlLCBlZGdlcyBvZiB0aGUgcG9seWdvbiBhcmUgaW50ZXJwcmV0ZWQgYXMgZ2VvZGVzaWMgYW5kIHdpbGxcbiAgICAgICAgICogZm9sbG93IHRoZSBjdXJ2YXR1cmUgb2YgdGhlIEVhcnRoLiBXaGVuIGZhbHNlLCBlZGdlcyBvZiB0aGUgcG9seWdvbiBhcmVcbiAgICAgICAgICogcmVuZGVyZWQgYXMgc3RyYWlnaHQgbGluZXMgaW4gc2NyZWVuIHNwYWNlLiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGFcbiAgICAgICAgICogZ2VvZGVzaWMgcG9seWdvbiBtYXkgYXBwZWFyIHRvIGNoYW5nZSB3aGVuIGRyYWdnZWQsIGFzIHRoZSBkaW1lbnNpb25zXG4gICAgICAgICAqIGFyZSBtYWludGFpbmVkIHJlbGF0aXZlIHRvIHRoZSBzdXJmYWNlIG9mIHRoZSBlYXJ0aC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlb2Rlc2ljID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3JkZXJlZCBzZXF1ZW5jZSBvZiBjb29yZGluYXRlcyB0aGF0IGRlc2lnbmF0ZXMgYSBjbG9zZWQgbG9vcC5cbiAgICAgICAgICogVW5saWtlIHBvbHlsaW5lcywgYSBwb2x5Z29uIG1heSBjb25zaXN0IG9mIG9uZSBvciBtb3JlIHBhdGhzLlxuICAgICAgICAgKiAgQXMgYSByZXN1bHQsIHRoZSBwYXRocyBwcm9wZXJ0eSBtYXkgc3BlY2lmeSBvbmUgb3IgbW9yZSBhcnJheXMgb2ZcbiAgICAgICAgICogTGF0TG5nIGNvb3JkaW5hdGVzLiBQYXRocyBhcmUgY2xvc2VkIGF1dG9tYXRpY2FsbHk7IGRvIG5vdCByZXBlYXQgdGhlXG4gICAgICAgICAqIGZpcnN0IHZlcnRleCBvZiB0aGUgcGF0aCBhcyB0aGUgbGFzdCB2ZXJ0ZXguIFNpbXBsZSBwb2x5Z29ucyBtYXkgYmVcbiAgICAgICAgICogZGVmaW5lZCB1c2luZyBhIHNpbmdsZSBhcnJheSBvZiBMYXRMbmdzLiBNb3JlIGNvbXBsZXggcG9seWdvbnMgbWF5XG4gICAgICAgICAqIHNwZWNpZnkgYW4gYXJyYXkgb2YgYXJyYXlzLiBBbnkgc2ltcGxlIGFycmF5cyBhcmUgY29udmVydGVkIGludG8gQXJyYXlzLlxuICAgICAgICAgKiBJbnNlcnRpbmcgb3IgcmVtb3ZpbmcgTGF0TG5ncyBmcm9tIHRoZSBBcnJheSB3aWxsIGF1dG9tYXRpY2FsbHkgdXBkYXRlXG4gICAgICAgICAqIHRoZSBwb2x5Z29uIG9uIHRoZSBtYXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdGhzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9seUNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIGRibGNsaWNrIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5RGJsQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyByZXBlYXRlZGx5IGZpcmVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBwb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5RHJhZyA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlnb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlEcmFnRW5kID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIHBvbHlnb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlEcmFnU3RhcnQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vkb3duIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VEb3duID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9seU1vdXNlTW92ZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIFBvbHlnb24gbW91c2VvdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlNb3VzZU91dCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIFBvbHlnb24gbW91c2VvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VPdmVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VVcCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW4gaXMgZmlyZWQgd2hlbiB0aGUgUG9seWdvbiBpcyByaWdodC1jbGlja2VkIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5UmlnaHRDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWdvbi5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWdvbi5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BvbHlnb25NYW5hZ2VyLnNldFBvbHlnb25PcHRpb25zKHRoaXMsIHRoaXMuX3VwZGF0ZVBvbHlnb25PcHRpb25zKGNoYW5nZXMpKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIuYWRkUG9seWdvbih0aGlzKTtcbiAgICAgICAgdGhpcy5fcG9seWdvbkFkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5Q2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RiY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEYmxDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZycsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seURyYWcuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdlbmQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEcmFnRW5kLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEcmFnU3RhcnQuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlZG93bicsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seU1vdXNlRG93bi5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5TW91c2VNb3ZlLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seU1vdXNlT3V0LmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlNb3VzZU92ZXIuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNldXAnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlNb3VzZVVwLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5UmlnaHRDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICBdO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9wb2x5Z29uTWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUob2JqLm5hbWUsIF90aGlzKS5zdWJzY3JpYmUob2JqLmhhbmRsZXIpO1xuICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChvcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlnb24ucHJvdG90eXBlLl91cGRhdGVQb2x5Z29uT3B0aW9ucyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjaGFuZ2VzKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gU2VibUdvb2dsZU1hcFBvbHlnb24uX3BvbHlnb25PcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaykge1xuICAgICAgICAgICAgb2JqW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlnb24ucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWQ7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIuZGVsZXRlUG9seWdvbih0aGlzKTtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gcy51bnN1YnNjcmliZSgpOyB9KTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLl9wb2x5Z29uT3B0aW9uc0F0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdjbGlja2FibGUnLCAnZHJhZ2dhYmxlJywgJ2VkaXRhYmxlJywgJ2ZpbGxDb2xvcicsICdmaWxsT3BhY2l0eScsICdnZW9kZXNpYycsICdpY29uJywgJ21hcCcsXG4gICAgICAgICdwYXRocycsICdzdHJva2VDb2xvcicsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdlaWdodCcsICd2aXNpYmxlJywgJ3pJbmRleCcsICdkcmFnZ2FibGUnLFxuICAgICAgICAnZWRpdGFibGUnLCAndmlzaWJsZSdcbiAgICBdO1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLW1hcC1wb2x5Z29uJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xpY2thYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkcmFnZ2FibGU6IHBvbHlEcmFnZ2FibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2VkaXRhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsQ29sb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGxPcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZW9kZXNpYycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF0aHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VXZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3pJbmRleCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb2x5Q2xpY2snLCAncG9seURibENsaWNrJywgJ3BvbHlEcmFnJywgJ3BvbHlEcmFnRW5kJywgJ3BvbHlNb3VzZURvd24nLCAncG9seU1vdXNlTW92ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9seU1vdXNlT3V0JywgJ3BvbHlNb3VzZU92ZXInLCAncG9seU1vdXNlVXAnLCAncG9seVJpZ2h0Q2xpY2snXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHBvbHlnb25fbWFuYWdlcl8xLlBvbHlnb25NYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBQb2x5Z29uO1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlnb24gPSBTZWJtR29vZ2xlTWFwUG9seWdvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtcG9seWdvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIHBvbHlsaW5lX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlsaW5lLW1hbmFnZXInKTtcbnZhciBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEgPSByZXF1aXJlKCcuL2dvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQnKTtcbnZhciBwb2x5bGluZUlkID0gMDtcbi8qKlxuICogU2VibUdvb2dsZU1hcFBvbHlsaW5lIHJlbmRlcnMgYSBwb2x5bGluZSBvbiBhIHtAbGluayBTZWJtR29vZ2xlTWFwfVxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVQb2x5bGluZSwgU2VibUdvb2dsZVBvbHlsaW5lUG9pbnQgfSBmcm9tXG4gKiAnYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZSc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcbiAqICBkaXJlY3RpdmVzOiBbU2VibUdvb2dsZU1hcCwgU2VibUdvb2dsZVBvbHlsaW5lLCBTZWJtR29vZ2xlUG9seWxpbmVQb2ludF0sXG4gKiAgc3R5bGVzOiBbYFxuICogICAgLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXIge1xuICogICAgICBoZWlnaHQ6IDMwMHB4O1xuICogICAgfVxuICogYF0sXG4gKiAgdGVtcGxhdGU6IGBcbiAqICAgIDxzZWJtLWdvb2dsZS1tYXAgW2xhdGl0dWRlXT1cImxhdFwiIFtsb25naXR1ZGVdPVwibG5nXCIgW3pvb21dPVwiem9vbVwiPlxuICogICAgICA8c2VibS1nb29nbGUtbWFwLXBvbHlsaW5lPlxuICogICAgICAgICAgPHNlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCBbbGF0aXR1ZGVdPVwibGF0QVwiIFtsb25naXR1ZGVdPVwibG5nQVwiPlxuICogICAgICAgICAgPC9zZWJtLWdvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQ+XG4gKiAgICAgICAgICA8c2VibS1nb29nbGUtbWFwLXBvbHlsaW5lLXBvaW50IFtsYXRpdHVkZV09XCJsYXRCXCIgW2xvbmdpdHVkZV09XCJsbmdCXCI+XG4gKiAgICAgICAgICA8L3NlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludD5cbiAqICAgICAgPC9zZWJtLWdvb2dsZS1tYXAtcG9seWxpbmU+XG4gKiAgICA8L3NlYm0tZ29vZ2xlLW1hcD5cbiAqICBgXG4gKiB9KVxuICogYGBgXG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwUG9seWxpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBQb2x5bGluZShfcG9seWxpbmVNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlciA9IF9wb2x5bGluZU1hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIFBvbHlsaW5lIGhhbmRsZXMgbW91c2UgZXZlbnRzLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBkcmFnIHRoaXMgc2hhcGUgb3ZlciB0aGUgbWFwLiBUaGUgZ2VvZGVzaWMgcHJvcGVydHkgZGVmaW5lcyB0aGVcbiAgICAgICAgICogbW9kZSBvZiBkcmFnZ2luZy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBlZGl0IHRoaXMgc2hhcGUgYnkgZHJhZ2dpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIHNob3duIGF0IHRoZVxuICAgICAgICAgKiB2ZXJ0aWNlcyBhbmQgb24gZWFjaCBzZWdtZW50LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdHJ1ZSwgZWRnZXMgb2YgdGhlIHBvbHlnb24gYXJlIGludGVycHJldGVkIGFzIGdlb2Rlc2ljIGFuZCB3aWxsIGZvbGxvdyB0aGUgY3VydmF0dXJlIG9mXG4gICAgICAgICAqIHRoZSBFYXJ0aC4gV2hlbiBmYWxzZSwgZWRnZXMgb2YgdGhlIHBvbHlnb24gYXJlIHJlbmRlcmVkIGFzIHN0cmFpZ2h0IGxpbmVzIGluIHNjcmVlbiBzcGFjZS5cbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBzaGFwZSBvZiBhIGdlb2Rlc2ljIHBvbHlnb24gbWF5IGFwcGVhciB0byBjaGFuZ2Ugd2hlbiBkcmFnZ2VkLCBhcyB0aGUgZGltZW5zaW9uc1xuICAgICAgICAgKiBhcmUgbWFpbnRhaW5lZCByZWxhdGl2ZSB0byB0aGUgc3VyZmFjZSBvZiB0aGUgZWFydGguIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW9kZXNpYyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHBvbHlsaW5lIGlzIHZpc2libGUgb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVEYmxDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHJlcGVhdGVkbHkgZmlyZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIHBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lRHJhZyA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lRHJhZ0VuZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBwb2x5bGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZURyYWdTdGFydCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZWRvd24gZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lTW91c2VEb3duID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVNb3VzZU1vdmUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBQb2x5bGluZSBtb3VzZW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZU1vdXNlT3V0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWxpbmUgbW91c2VvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lTW91c2VPdmVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZU1vdXNlVXAgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVuIGlzIGZpcmVkIHdoZW4gdGhlIFBvbHlsaW5lIGlzIHJpZ2h0LWNsaWNrZWQgb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVSaWdodENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVBZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuX2lkID0gKHBvbHlsaW5lSWQrKykudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gcG9pbnQucG9zaXRpb25DaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IF90aGlzLl9wb2x5bGluZU1hbmFnZXIudXBkYXRlUG9seWxpbmVQb2ludHMoX3RoaXMpOyB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wb2x5bGluZUFkZGVkVG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSB0aGlzLnBvaW50cy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcG9seWxpbmVNYW5hZ2VyLnVwZGF0ZVBvbHlsaW5lUG9pbnRzKF90aGlzKTsgfSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVNYW5hZ2VyLnVwZGF0ZVBvbHlsaW5lUG9pbnRzKHRoaXMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5fcG9seWxpbmVBZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBTZWJtR29vZ2xlTWFwUG9seWxpbmUuX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTE7IH0pO1xuICAgICAgICBvcHRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHsgcmV0dXJuIG9wdGlvbnNba10gPSBjaGFuZ2VzW2tdLmN1cnJlbnRWYWx1ZTsgfSk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlci5zZXRQb2x5bGluZU9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb2x5bGluZU1hbmFnZXIuYWRkUG9seWxpbmUodGhpcyk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lQWRkZWRUb01hbmFnZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lQ2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RiY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVEYmxDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZycsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZURyYWcuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdlbmQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVEcmFnRW5kLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVEcmFnU3RhcnQuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlZG93bicsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZU1vdXNlRG93bi5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lTW91c2VNb3ZlLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZU1vdXNlT3V0LmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVNb3VzZU92ZXIuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNldXAnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVNb3VzZVVwLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lUmlnaHRDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICBdO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9wb2x5bGluZU1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKG9iai5uYW1lLCBfdGhpcykuc3Vic2NyaWJlKG9iai5oYW5kbGVyKTtcbiAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25zLnB1c2gob3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvdG90eXBlLl9nZXRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb2x5bGluZU1hbmFnZXIuZGVsZXRlUG9seWxpbmUodGhpcyk7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGFsbCByZWdpc3RlcmVkIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUuX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdkcmFnZ2FibGUnLCAnZWRpdGFibGUnLCAndmlzaWJsZScsICdnZW9kZXNpYycsICdzdHJva2VDb2xvcicsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdlaWdodCcsXG4gICAgICAgICd6SW5kZXgnXG4gICAgXTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3NlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZScsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsaWNrYWJsZScsICdkcmFnZ2FibGU6IHBvbHlsaW5lRHJhZ2dhYmxlJywgJ2VkaXRhYmxlJywgJ2dlb2Rlc2ljJywgJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VXZWlnaHQnLCAnc3Ryb2tlT3BhY2l0eScsICd2aXNpYmxlJywgJ3pJbmRleCdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmVDbGljaycsICdsaW5lRGJsQ2xpY2snLCAnbGluZURyYWcnLCAnbGluZURyYWdFbmQnLCAnbGluZU1vdXNlRG93bicsICdsaW5lTW91c2VNb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lTW91c2VPdXQnLCAnbGluZU1vdXNlT3ZlcicsICdsaW5lTW91c2VVcCcsICdsaW5lUmlnaHRDbGljaydcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHBvbHlsaW5lX21hbmFnZXJfMS5Qb2x5bGluZU1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdwb2ludHMnOiBbeyB0eXBlOiBjb3JlXzEuQ29udGVudENoaWxkcmVuLCBhcmdzOiBbZ29vZ2xlX21hcF9wb2x5bGluZV9wb2ludF8xLlNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50LF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBQb2x5bGluZTtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBQb2x5bGluZSA9IFNlYm1Hb29nbGVNYXBQb2x5bGluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtcG9seWxpbmUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50IHJlcHJlc2VudHMgb25lIGVsZW1lbnQgb2YgYSBwb2x5bGluZSB3aXRoaW4gYSAge0BsaW5rXG4gKiBTZW1iR29vZ2xlTWFwUG9seWxpbmV9XG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZWQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snbGF0aXR1ZGUnXSB8fCBjaGFuZ2VzWydsb25naXR1ZGUnXSkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIGxhdDogY2hhbmdlc1snbGF0aXR1ZGUnXS5jdXJyZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgbG5nOiBjaGFuZ2VzWydsb25naXR1ZGUnXS5jdXJyZW50VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlZC5lbWl0KHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ3NlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCcgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnbGF0aXR1ZGUnOiBbeyB0eXBlOiBjb3JlXzEuSW5wdXQgfSxdLFxuICAgICAgICAnbG9uZ2l0dWRlJzogW3sgdHlwZTogY29yZV8xLklucHV0IH0sXSxcbiAgICAgICAgJ3Bvc2l0aW9uQ2hhbmdlZCc6IFt7IHR5cGU6IGNvcmVfMS5PdXRwdXQgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50O1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQgPSBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lLXBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9nb29nbGUtbWFwcy1hcGktd3JhcHBlcicpO1xuZXhwb3J0cy5Hb29nbGVNYXBzQVBJV3JhcHBlciA9IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXI7XG52YXIgY2lyY2xlX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMvY2lyY2xlLW1hbmFnZXInKTtcbmV4cG9ydHMuQ2lyY2xlTWFuYWdlciA9IGNpcmNsZV9tYW5hZ2VyXzEuQ2lyY2xlTWFuYWdlcjtcbnZhciBpbmZvX3dpbmRvd19tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hbmFnZXJzL2luZm8td2luZG93LW1hbmFnZXInKTtcbmV4cG9ydHMuSW5mb1dpbmRvd01hbmFnZXIgPSBpbmZvX3dpbmRvd19tYW5hZ2VyXzEuSW5mb1dpbmRvd01hbmFnZXI7XG52YXIgbWFya2VyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMvbWFya2VyLW1hbmFnZXInKTtcbmV4cG9ydHMuTWFya2VyTWFuYWdlciA9IG1hcmtlcl9tYW5hZ2VyXzEuTWFya2VyTWFuYWdlcjtcbnZhciBwb2x5Z29uX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMvcG9seWdvbi1tYW5hZ2VyJyk7XG5leHBvcnRzLlBvbHlnb25NYW5hZ2VyID0gcG9seWdvbl9tYW5hZ2VyXzEuUG9seWdvbk1hbmFnZXI7XG52YXIgcG9seWxpbmVfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyJyk7XG5leHBvcnRzLlBvbHlsaW5lTWFuYWdlciA9IHBvbHlsaW5lX21hbmFnZXJfMS5Qb2x5bGluZU1hbmFnZXI7XG52YXIga21sX2xheWVyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMva21sLWxheWVyLW1hbmFnZXInKTtcbmV4cG9ydHMuS21sTGF5ZXJNYW5hZ2VyID0ga21sX2xheWVyX21hbmFnZXJfMS5LbWxMYXllck1hbmFnZXI7XG52YXIgbGF6eV9tYXBzX2FwaV9sb2FkZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyJyk7XG5leHBvcnRzLkdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbCA9IGxhenlfbWFwc19hcGlfbG9hZGVyXzEuR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sO1xuZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyA9IGxhenlfbWFwc19hcGlfbG9hZGVyXzEuTEFaWV9NQVBTX0FQSV9DT05GSUc7XG5leHBvcnRzLkxhenlNYXBzQVBJTG9hZGVyID0gbGF6eV9tYXBzX2FwaV9sb2FkZXJfMS5MYXp5TWFwc0FQSUxvYWRlcjtcbnZhciBtYXBzX2FwaV9sb2FkZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL21hcHMtYXBpLWxvYWRlcicpO1xuZXhwb3J0cy5NYXBzQVBJTG9hZGVyID0gbWFwc19hcGlfbG9hZGVyXzEuTWFwc0FQSUxvYWRlcjtcbnZhciBub29wX21hcHNfYXBpX2xvYWRlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbm9vcC1tYXBzLWFwaS1sb2FkZXInKTtcbmV4cG9ydHMuTm9PcE1hcHNBUElMb2FkZXIgPSBub29wX21hcHNfYXBpX2xvYWRlcl8xLk5vT3BNYXBzQVBJTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGJyb3dzZXJfZ2xvYmFsc18xID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3Nlci1nbG9iYWxzJyk7XG52YXIgbWFwc19hcGlfbG9hZGVyXzEgPSByZXF1aXJlKCcuL21hcHMtYXBpLWxvYWRlcicpO1xuKGZ1bmN0aW9uIChHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wpIHtcbiAgICBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2xbR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW1wiSFRUUFwiXSA9IDFdID0gXCJIVFRQXCI7XG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkhUVFBTXCJdID0gMl0gPSBcIkhUVFBTXCI7XG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkFVVE9cIl0gPSAzXSA9IFwiQVVUT1wiO1xufSkoZXhwb3J0cy5Hb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wgfHwgKGV4cG9ydHMuR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sID0ge30pKTtcbnZhciBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wgPSBleHBvcnRzLkdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbDtcbi8qKlxuICogVG9rZW4gZm9yIHRoZSBjb25maWcgb2YgdGhlIExhenlNYXBzQVBJTG9hZGVyLiBQbGVhc2UgcHJvdmlkZSBhbiBvYmplY3Qgb2YgdHlwZSB7QGxpbmtcbiAqIExhenlNYXBzQVBJTG9hZGVyQ29uZmlnfS5cbiAqL1xuZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyA9IG5ldyBjb3JlXzEuT3BhcXVlVG9rZW4oJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzIExBWllfTUFQU19BUElfQ09ORklHJyk7XG52YXIgTGF6eU1hcHNBUElMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXp5TWFwc0FQSUxvYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXp5TWFwc0FQSUxvYWRlcihjb25maWcsIHcsIGQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgdGhpcy5fd2luZG93UmVmID0gdztcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWYgPSBkO1xuICAgIH1cbiAgICBMYXp5TWFwc0FQSUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmlwdCA9IHRoaXMuX2RvY3VtZW50UmVmLmdldE5hdGl2ZURvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIHZhciBjYWxsYmFja05hbWUgPSBcImFuZ3VsYXIyR29vZ2xlTWFwc0xhenlNYXBzQVBJTG9hZGVyXCI7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLl9nZXRTY3JpcHRTcmMoY2FsbGJhY2tOYW1lKTtcbiAgICAgICAgdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5fd2luZG93UmVmLmdldE5hdGl2ZVdpbmRvdygpW2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoKSB7IHJlc29sdmUoKTsgfTtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7IHJlamVjdChlcnJvcik7IH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kb2N1bWVudFJlZi5nZXROYXRpdmVEb2N1bWVudCgpLmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlO1xuICAgIH07XG4gICAgTGF6eU1hcHNBUElMb2FkZXIucHJvdG90eXBlLl9nZXRTY3JpcHRTcmMgPSBmdW5jdGlvbiAoY2FsbGJhY2tOYW1lKSB7XG4gICAgICAgIHZhciBwcm90b2NvbFR5cGUgPSAodGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5wcm90b2NvbCkgfHwgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFBTO1xuICAgICAgICB2YXIgcHJvdG9jb2w7XG4gICAgICAgIHN3aXRjaCAocHJvdG9jb2xUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5BVVRPOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5IVFRQOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHA6JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFBTOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHBzOic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvc3RBbmRQYXRoID0gdGhpcy5fY29uZmlnLmhvc3RBbmRQYXRoIHx8ICdtYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzJztcbiAgICAgICAgdmFyIHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgICAgICAgdjogdGhpcy5fY29uZmlnLmFwaVZlcnNpb24gfHwgJzMnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrTmFtZSxcbiAgICAgICAgICAgIGtleTogdGhpcy5fY29uZmlnLmFwaUtleSxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5fY29uZmlnLmNsaWVudElkLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5fY29uZmlnLmNoYW5uZWwsXG4gICAgICAgICAgICBsaWJyYXJpZXM6IHRoaXMuX2NvbmZpZy5saWJyYXJpZXMsXG4gICAgICAgICAgICByZWdpb246IHRoaXMuX2NvbmZpZy5yZWdpb24sXG4gICAgICAgICAgICBsYW5ndWFnZTogdGhpcy5fY29uZmlnLmxhbmd1YWdlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhxdWVyeVBhcmFtcylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHF1ZXJ5UGFyYW1zW2tdICE9IG51bGw7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgYXJyYXlzXG4gICAgICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pICYmIHF1ZXJ5UGFyYW1zW2tdLmxlbmd0aCA+IDApO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgLy8gam9pbiBhcnJheXMgYXMgY29tbWEgc2VwZXJhdGVkIHN0cmluZ3NcbiAgICAgICAgICAgIHZhciBpID0gcXVlcnlQYXJhbXNba107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGtleTogaywgdmFsdWU6IGkuam9pbignLCcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGssIHZhbHVlOiBxdWVyeVBhcmFtc1trXSB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmtleSArIFwiPVwiICsgZW50cnkudmFsdWU7IH0pXG4gICAgICAgICAgICAuam9pbignJicpO1xuICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBcIi8vXCIgKyBob3N0QW5kUGF0aCArIFwiP1wiICsgcGFyYW1zO1xuICAgIH07XG4gICAgTGF6eU1hcHNBUElMb2FkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTGF6eU1hcHNBUElMb2FkZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IGJyb3dzZXJfZ2xvYmFsc18xLldpbmRvd1JlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBicm93c2VyX2dsb2JhbHNfMS5Eb2N1bWVudFJlZiwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBMYXp5TWFwc0FQSUxvYWRlcjtcbn0obWFwc19hcGlfbG9hZGVyXzEuTWFwc0FQSUxvYWRlcikpO1xuZXhwb3J0cy5MYXp5TWFwc0FQSUxvYWRlciA9IExhenlNYXBzQVBJTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eS1tYXBzLWFwaS1sb2FkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBXaW5kb3dSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd1JlZigpIHtcbiAgICB9XG4gICAgV2luZG93UmVmLnByb3RvdHlwZS5nZXROYXRpdmVXaW5kb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3c7IH07XG4gICAgcmV0dXJuIFdpbmRvd1JlZjtcbn0oKSk7XG5leHBvcnRzLldpbmRvd1JlZiA9IFdpbmRvd1JlZjtcbnZhciBEb2N1bWVudFJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9jdW1lbnRSZWYoKSB7XG4gICAgfVxuICAgIERvY3VtZW50UmVmLnByb3RvdHlwZS5nZXROYXRpdmVEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50OyB9O1xuICAgIHJldHVybiBEb2N1bWVudFJlZjtcbn0oKSk7XG5leHBvcnRzLkRvY3VtZW50UmVmID0gRG9jdW1lbnRSZWY7XG5leHBvcnRzLkJST1dTRVJfR0xPQkFMU19QUk9WSURFUlMgPSBbV2luZG93UmVmLCBEb2N1bWVudFJlZl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLWdsb2JhbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvdXRpbHMvYnJvd3Nlci1nbG9iYWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogV2hlbiB1c2luZyB0aGUgTm9PcE1hcHNBUElMb2FkZXIsIHRoZSBHb29nbGUgTWFwcyBBUEkgbXVzdCBiZSBhZGRlZCB0byB0aGUgcGFnZSB2aWEgYSBgPHNjcmlwdD5gXG4gKiBUYWcuXG4gKiBJdCdzIGltcG9ydGFudCB0aGF0IHRoZSBHb29nbGUgTWFwcyBBUEkgc2NyaXB0IGdldHMgbG9hZGVkIGZpcnN0IG9uIHRoZSBwYWdlLlxuICovXG52YXIgTm9PcE1hcHNBUElMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vT3BNYXBzQVBJTG9hZGVyKCkge1xuICAgIH1cbiAgICBOb09wTWFwc0FQSUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cuZ29vZ2xlIHx8ICF3aW5kb3cuZ29vZ2xlLm1hcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR29vZ2xlIE1hcHMgQVBJIG5vdCBsb2FkZWQgb24gcGFnZS4gTWFrZSBzdXJlIHdpbmRvdy5nb29nbGUubWFwcyBpcyBhdmFpbGFibGUhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBOb09wTWFwc0FQSUxvYWRlcjtcbn0oKSk7XG5leHBvcnRzLk5vT3BNYXBzQVBJTG9hZGVyID0gTm9PcE1hcHNBUElMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub29wLW1hcHMtYXBpLWxvYWRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbm9vcC1tYXBzLWFwaS1sb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBnb29nbGVfbWFwX2ttbF9sYXllcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAta21sLWxheWVyJyk7XG52YXIgZ29vZ2xlX21hcF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAnKTtcbnZhciBnb29nbGVfbWFwX2NpcmNsZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtY2lyY2xlJyk7XG52YXIgZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtaW5mby13aW5kb3cnKTtcbnZhciBnb29nbGVfbWFwX21hcmtlcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtbWFya2VyJyk7XG52YXIgZ29vZ2xlX21hcF9wb2x5Z29uXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5Z29uJyk7XG52YXIgZ29vZ2xlX21hcF9wb2x5bGluZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUnKTtcbnZhciBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCcpO1xudmFyIGxhenlfbWFwc19hcGlfbG9hZGVyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9sYXp5LW1hcHMtYXBpLWxvYWRlcicpO1xudmFyIGxhenlfbWFwc19hcGlfbG9hZGVyXzIgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9sYXp5LW1hcHMtYXBpLWxvYWRlcicpO1xudmFyIG1hcHNfYXBpX2xvYWRlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbWFwcy1hcGktbG9hZGVyJyk7XG52YXIgYnJvd3Nlcl9nbG9iYWxzXzEgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXItZ2xvYmFscycpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY29yZURpcmVjdGl2ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZ29vZ2xlX21hcF8xLlNlYm1Hb29nbGVNYXAsIGdvb2dsZV9tYXBfbWFya2VyXzEuU2VibUdvb2dsZU1hcE1hcmtlciwgZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xLlNlYm1Hb29nbGVNYXBJbmZvV2luZG93LCBnb29nbGVfbWFwX2NpcmNsZV8xLlNlYm1Hb29nbGVNYXBDaXJjbGUsXG4gICAgICAgIGdvb2dsZV9tYXBfcG9seWdvbl8xLlNlYm1Hb29nbGVNYXBQb2x5Z29uLCBnb29nbGVfbWFwX3BvbHlsaW5lXzEuU2VibUdvb2dsZU1hcFBvbHlsaW5lLCBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEuU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQsIGdvb2dsZV9tYXBfa21sX2xheWVyXzEuU2VibUdvb2dsZU1hcEttbExheWVyXG4gICAgXTtcbn1cbmV4cG9ydHMuY29yZURpcmVjdGl2ZXMgPSBjb3JlRGlyZWN0aXZlcztcbjtcbi8qKlxuICogVGhlIGFuZ3VsYXIyLWdvb2dsZS1tYXBzIGNvcmUgbW9kdWxlLiBDb250YWlucyBhbGwgRGlyZWN0aXZlcy9TZXJ2aWNlcy9QaXBlc1xuICogb2YgdGhlIGNvcmUgbW9kdWxlLiBQbGVhc2UgdXNlIGBBZ21Db3JlTW9kdWxlLmZvclJvb3QoKWAgaW4geW91ciBhcHAgbW9kdWxlLlxuICovXG52YXIgQWdtQ29yZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWdtQ29yZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxlYXNlIHVzZSB0aGlzIG1ldGhvZCB3aGVuIHlvdSByZWdpc3RlciB0aGUgbW9kdWxlIGF0IHRoZSByb290IGxldmVsLlxuICAgICAqL1xuICAgIEFnbUNvcmVNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uIChsYXp5TWFwc0FQSUxvYWRlckNvbmZpZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEFnbUNvcmVNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IGJyb3dzZXJfZ2xvYmFsc18xLkJST1dTRVJfR0xPQkFMU19QUk9WSURFUlMuY29uY2F0KFtcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IG1hcHNfYXBpX2xvYWRlcl8xLk1hcHNBUElMb2FkZXIsIHVzZUNsYXNzOiBsYXp5X21hcHNfYXBpX2xvYWRlcl8xLkxhenlNYXBzQVBJTG9hZGVyIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBsYXp5X21hcHNfYXBpX2xvYWRlcl8yLkxBWllfTUFQU19BUElfQ09ORklHLCB1c2VWYWx1ZTogbGF6eU1hcHNBUElMb2FkZXJDb25maWcgfVxuICAgICAgICAgICAgXSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBZ21Db3JlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nTW9kdWxlLCBhcmdzOiBbeyBkZWNsYXJhdGlvbnM6IGNvcmVEaXJlY3RpdmVzKCksIGV4cG9ydHM6IGNvcmVEaXJlY3RpdmVzKCkgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBBZ21Db3JlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIEFnbUNvcmVNb2R1bGU7XG59KCkpO1xuZXhwb3J0cy5BZ21Db3JlTW9kdWxlID0gQWdtQ29yZU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUtbW9kdWxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2NvcmUtbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUFJBQ1RJQ0VfREFUQSB9IGZyb20gXCIuL2RhdGEvcHJhY3RpY2UuZGF0YVwiO1xuaW1wb3J0IHsgUHJhY3RpY2UgfSBmcm9tIFwiLi9tb2RlbC9wcmFjdGljZS5tb2RlbFwiO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3ByYWN0aWNlJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9wcmFjdGljZS5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vcHJhY3RpY2UuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBQcmFjdGljZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvLyBQcmFjdGljZSBkYXRhIHRvIGluamVjdCBpbnRvIG91ciB0ZW1wbGF0ZVxuICAgIHByaXZhdGUgcHJhY3RpY2VEYXRhOiBQcmFjdGljZVtdID0gUFJBQ1RJQ0VfREFUQTtcblxuICAgIG5nT25Jbml0KCk6IHZvaWQge31cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudC50cyIsImltcG9ydCB7IFByYWN0aWNlIH0gZnJvbSBcIi4uL21vZGVsL3ByYWN0aWNlLm1vZGVsXCI7XG5cbmV4cG9ydCBjb25zdCBQUkFDVElDRV9EQVRBOiBQcmFjdGljZVtdID0gW1xuICAgIHtcbiAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgIHdoYXQ6ICdOb3JtYWwgUHJhY3RpY2UnLFxuICAgICAgICB0aW1lOiAnNDozMFBNLTdQTScsXG4gICAgICAgIHdoZW46ICdNb25kYXlzICYgV2VkbmVzZGF5cycsXG4gICAgICAgIGxvY2F0aW9uTGFiZWw6ICdDb21wbGV4IEZpZWxkcycsXG4gICAgICAgIGxvY2F0aW9uTGluazogJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20vbWFwcy9wbGFjZS9GbG9yaWRhK2FuZCtMaW5jb2xuK1BsYXlpbmcrRmllbGQvQDQwLjA5NjY5NjQsLTg4LjIyNDI4MDYsMTZ6L2RhdGE9ITRtNSExbTIhMm0xITFzY29tcGxleCtmaWVsZHMhM20xITFzMHgwMDAwMDAwMDAwMDAwMDAwOjB4MTM2MzM4NDA4OTZlMjViZidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgIHdoYXQ6ICdXZWVrZW5kIEludml0ZSBQcmFjdGljZScsXG4gICAgICAgIHRpbWU6ICdUQkQnLFxuICAgICAgICB3aGVuOiAnV2Vla2VuZHMnLFxuICAgICAgICBsb2NhdGlvbkxhYmVsOiAnQ29tcGxleCBGaWVsZHMnLFxuICAgICAgICBsb2NhdGlvbkxpbms6ICdodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvcGxhY2UvRmxvcmlkYSthbmQrTGluY29sbitQbGF5aW5nK0ZpZWxkL0A0MC4wOTY2OTY0LC04OC4yMjQyODA2LDE2ei9kYXRhPSE0bTUhMW0yITJtMSExc2NvbXBsZXgrZmllbGRzITNtMSExczB4MDAwMDAwMDAwMDAwMDAwMDoweDEzNjMzODQwODk2ZTI1YmYnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHNlYXNvbjogJ1dpbnRlcicsXG4gICAgICAgIHdoYXQ6ICdOb3JtYWwgUHJhY3RpY2UnLFxuICAgICAgICB0aW1lOiAnOTozMFBNLTEyQU0nLFxuICAgICAgICB3aGVuOiAnTW9uZGF5cyAmIFdlZG5lc2RheXMnLFxuICAgICAgICBsb2NhdGlvbkxhYmVsOiAnQXJtb3J5JyxcbiAgICAgICAgbG9jYXRpb25MaW5rOiAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL3BsYWNlL0FybW9yeS9ANDAuMTA1NDAyLC04OC4yMzU1MzQsMTd6L2RhdGE9ITNtMSE1czB4ODgwY2Q3M2I4YzRmYmI3ZDoweGE4NDg5MDExMGFmZDA5OTAhNG03ITFtNCEzbTMhMXMweDg4MGNkNzNhMTZjMWQ3OGY6MHhlMWJiMDA5MjI1ZmMxMjI1ITJzRStBcm1vcnkrQXZlLCtDaGFtcGFpZ24sK0lMKzYxODIwITNiMSEzbTEhMXMweDAwMDAwMDAwMDAwMDAwMDA6MHgwYjIxZDU2ZjJiOTUxOTc4J1xuICAgIH0sXG4gICAge1xuICAgICAgICBzZWFzb246ICdXaW50ZXInLFxuICAgICAgICB3aGF0OiAnSW5kb29yIEZpZWxkIFByYWN0aWNlJyxcbiAgICAgICAgdGltZTogJzExUE0tMTJBTScsXG4gICAgICAgIHdoZW46ICdUaHVyc2RheXMnLFxuICAgICAgICBsb2NhdGlvbkxhYmVsOiAnSXJ3aW4gRmFjaWxpdHknLFxuICAgICAgICBsb2NhdGlvbkxpbms6ICdodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvcGxhY2UvSXJ3aW4rSW5kb29yK0Zvb3RiYWxsK0ZhY2lsaXR5LCtVbml2ZXJzaXR5K29mK0lsbGlub2lzK2F0K1VyYmFuYS1DaGFtcGFpZ24sK0NoYW1wYWlnbiwrSUwrNjE4MjAvQDQwLjEwMDY0NzUsLTg4LjIzNDIyMDQsMTd6L2RhdGE9ITNtMSE0YjEhNG02ITFtMyEzbTIhMXMweDg4MGNkNzI0YTkyNjU1ZTk6MHhhNTNjMDUyNTA0NjgyNmZhITJzVW5pdmVyc2l0eStvZitJbGxpbm9pcythdCtVcmJhbmEtQ2hhbXBhaWduITNtMSExczB4ODgwY2Q3MjUyOTJjMDJiZDoweDE4ZjVhMDNkYWFkODY3N2EnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgIHdoYXQ6ICdOb3JtYWwgUHJhY3RpY2UnLFxuICAgICAgICB0aW1lOiAnOTozMFBNLTEyQU0nLFxuICAgICAgICB3aGVuOiAnTW9uZGF5cyAmIFdlZG5lc2RheXMnLFxuICAgICAgICBsb2NhdGlvbkxhYmVsOiAnQ29tcGxleCBGaWVsZHMnLFxuICAgICAgICBsb2NhdGlvbkxpbms6ICdodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvcGxhY2UvRmxvcmlkYSthbmQrTGluY29sbitQbGF5aW5nK0ZpZWxkL0A0MC4wOTY2OTY0LC04OC4yMjQyODA2LDE2ei9kYXRhPSE0bTUhMW0yITJtMSExc2NvbXBsZXgrZmllbGRzITNtMSExczB4MDAwMDAwMDAwMDAwMDAwMDoweDEzNjMzODQwODk2ZTI1YmYnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgIHdoYXQ6ICdBLVRlYW0gUHJhY3RpY2UnLFxuICAgICAgICB0aW1lOiAnVEJEJyxcbiAgICAgICAgd2hlbjogJ1dlZWtlbmRzJyxcbiAgICAgICAgbG9jYXRpb25MYWJlbDogJ0NvbXBsZXggRmllbGRzJyxcbiAgICAgICAgbG9jYXRpb25MaW5rOiAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL3BsYWNlL0Zsb3JpZGErYW5kK0xpbmNvbG4rUGxheWluZytGaWVsZC9ANDAuMDk2Njk2NCwtODguMjI0MjgwNiwxNnovZGF0YT0hNG01ITFtMiEybTEhMXNjb21wbGV4K2ZpZWxkcyEzbTEhMXMweDAwMDAwMDAwMDAwMDAwMDA6MHgxMzYzMzg0MDg5NmUyNWJmJ1xuICAgIH1cbl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3RlYW0vcHJhY3RpY2UvZGF0YS9wcmFjdGljZS5kYXRhLnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxoMSBjbGFzcz1cXFwidWkgaGVhZGVyXFxcIj5QcmFjdGljZTwvaDE+XFxuPHRhYmxlIGNsYXNzPVxcXCJ1aSBjZWxsZWQgdGFibGVcXFwiPlxcbiAgICA8dGhlYWQ+XFxuICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRoPlNlYXNvbjwvdGg+XFxuICAgICAgICAgICAgPHRoPldoYXQ8L3RoPlxcbiAgICAgICAgICAgIDx0aD5UaW1lPC90aD5cXG4gICAgICAgICAgICA8dGg+V2hlbjwvdGg+XFxuICAgICAgICAgICAgPHRoPkxvY2F0aW9uPC90aD5cXG4gICAgICAgIDwvdHI+XFxuICAgIDwvdGhlYWQ+XFxuICAgIDx0Ym9keT5cXG4gICAgICAgIDx0ciAqbmdGb3I9XFxcImxldCBwcmFjdGljZVJvdyBvZiBwcmFjdGljZURhdGFcXFwiPlxcbiAgICAgICAgICAgIDx0ZD57e3ByYWN0aWNlUm93LnNlYXNvbn19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+e3twcmFjdGljZVJvdy53aGF0fX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e3ByYWN0aWNlUm93LnRpbWV9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7cHJhY3RpY2VSb3cud2hlbn19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+PGEgaHJlZj1cXFwie3twcmFjdGljZVJvdy5sb2NhdGlvbkxpbmt9fVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPnt7cHJhY3RpY2VSb3cubG9jYXRpb25MYWJlbH19PC9hPjwvdGQ+XFxuICAgICAgICA8L3RyPlxcbiAgICA8L3Rib2R5PlxcbjwvdGFibGU+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vcHJhY3RpY2UvcHJhY3RpY2UuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJhY3RpY2UuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vcHJhY3RpY2UvcHJhY3RpY2UuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcInRyIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWN0aXZhdGVkUm91dGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG5pbXBvcnQgeyBUT1VSTkFNRU5UU19EQVRBIH0gZnJvbSBcIi4vZGF0YS90b3VybmFtZW50cy5kYXRhXCI7XG5pbXBvcnQgeyBUb3VybmFtZW50WWVhciB9IGZyb20gXCIuL21vZGVsL3RvdXJuYW1lbnQteWVhci5tb2RlbFwiO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3RvdXJuYW1lbnRzJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi90b3VybmFtZW50cy5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vdG91cm5hbWVudHMuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBUb3VybmFtZW50c0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvLyBUb3VybmFtZW50IGRhdGEgdG8gaW5qZWN0IGludG8gb3VyIHRlbXBsYXRlXG4gICAgcHJpdmF0ZSB0b3VybmFtZW50RGF0YTogVG91cm5hbWVudFllYXJbXSA9IFRPVVJOQU1FTlRTX0RBVEE7XG4gICAgLy8gU3Vic2NyaXB0aW9uIHRvIG91ciByb3V0ZSBwYXJhbWV0ZXJzICh0b3VybmFtZW50IHllYXIpXG4gICAgcHJpdmF0ZSByb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbjogYW55O1xuICAgIC8vIEN1cnJlbnQgdG91cm5hbWVudCB5ZWFyXG4gICAgcHJpdmF0ZSB5ZWFyOiBudW1iZXI7XG5cbiAgICAvLyBJbmplY3QgdGhlIEFjdGl2YXRlZFJvdXRlIGludG8gb3VyIGNvbXBvbmVudFxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcm91dGU6IEFjdGl2YXRlZFJvdXRlKSB7fVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIG91ciByb3V0ZSBwYXJhbWV0ZXJzICh0b3VybmFtZW50IHllYXIpLlxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJvdXRlUGFyYW1zU3Vic2NyaXB0aW9uID0gdGhpcy5yb3V0ZS5wYXJhbXMuc3Vic2NyaWJlKHBhcmFtcyA9PiB7XG4gICAgICAgICAgICAvLyAoKykgY29udmVydHMgc3RyaW5nICd5ZWFyJyB0byBhIG51bWJlclxuICAgICAgICAgICAgdGhpcy55ZWFyID0gK3BhcmFtc1sneWVhciddO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZSB0byBvdXIgcm91dGUgcGFyYW1ldGVycyAodG91cm5hbWVudCB5ZWFyKS5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3RvdXJuYW1lbnRzL3RvdXJuYW1lbnRzLmNvbXBvbmVudC50cyIsImltcG9ydCB7IFRvdXJuYW1lbnRZZWFyIH0gZnJvbSBcIi4uL21vZGVsL3RvdXJuYW1lbnQteWVhci5tb2RlbFwiO1xuXG5leHBvcnQgY29uc3QgVE9VUk5BTUVOVFNfREFUQTogVG91cm5hbWVudFllYXJbXSA9IFtcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTcsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdCb2lsZXIgQnJlYWthd2F5JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cHM6Ly9ib2lsZXJsaW5rLnB1cmR1ZS5lZHUvb3JnYW5pemF0aW9uL21lbnN1bHRpbWF0ZS9jYWxlbmRhci9kZXRhaWxzLzk3MjkyMCcsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ1NlcHQuIDE3dGgtMTh0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1dlc3QgTGFmYXlldHRlLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnTm8gV2lzY29uc2VxdWVuY2VzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL25vd2lzY29uc2VxdWVuY2VzLnVsdGltYXRlY2VudHJhbC5jb20nLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdPY3QuIDh0aC05dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdIYXJ0bGFuZCwgV0knLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ01pc3NvdXJpIExvdmVzIENvbXBhbnknLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vdWx0aW1hdGUubWlzc291cmkuZWR1L21sYy8yMDE2JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnTm92LiA1dGgtNnRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgYFByZXNpZGVudCdzIERheSBJbnZpdGVgLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL1ByZXNpZGVudHMtRGF5LVRvdXJuYW1lbnQtMjAxNycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0ZlYi4gMTd0aC0yMHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnU2FuIERpZWdvLCBDQScsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzV0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0NlbnRleCcsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvQ2VudGV4LTIwMTctT3BlbicsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ01hcmNoIDEwdGgtMTN0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ0F1c3RpbiwgVFgnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICc3dGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdIdWNrIEZpbm4nLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0h1Y2stRmlubi0yMDE3JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnQXByaWwgMXN0LTJuZCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1N0LiBMb3VpcywgTU8nLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxMXRoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnSWxsaW5vaXMgQ29uZmVyZW5jZXMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0lsbGlub2lzLUQtSS1Db2xsZWdlLU1lbnMtQ0MtMjAxNycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0FwcmlsIDIybmQtMjNyZCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1JhbnRvdWwsIElMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMm5kJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnR3JlYXQgTGFrZXMgUmVnaW9uYWxzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9HcmVhdC1MYWtlcy1ELUktQ29sbGVnZS1NZW5zLVJlZ2lvbmFscy0yMDE3JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnTWF5IDZ0aC03dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdGYWlyIE9ha3MsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnNnRoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdCb2lsZXIgQnJlYWthd2F5JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL3VsdGltYXRlL2NvbW1lbnRzLzM4Z3k3Mi9uZXdfZmllbGRzX2JvaWxlcl9icmVha2F3YXlfMjAxNV9ob3N0ZWRfYnlfdW5kdWUnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdTZXB0LiAxOXRoLTIwdGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdXZXN0ZmllbGQsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdIdWNrIG9mIHRoZSBJcmlzaCcsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHBzOi8vbmR1bHRpbWF0ZS53b3JkcHJlc3MuY29tL2hvdGknLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdPY3QuIDNyZC00dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdTb3V0aCBCZW5kLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnQ2hpY2FnbyBJbnZpdGUnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vd3d3LmNoaWNhZ29pbnZpdGUuY29tJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnT2N0LiAxN3RoLTE4dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSb2NrZm9yZCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ01pc3NvdXJpIExvdmVzIENvbXBhbnknLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vdWx0aXdvcmxkLmNvbS8yMDE1LzExLzEyL21pc3NvdXJpLWxvdmVzLWNvbXBhbnktMjAxNS10b3VybmFtZW50LXJlY2FwLW1lbnMnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdOb3YuIDd0aC04dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdDb2x1bWJpYSwgTU8nLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxMHRoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnRmxvcmlkYSBXYXJtdXAnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL1dhcm0tdXAtQS1GbG9yaWRhLUFmZmFpci0yMDE2JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnRmViLiAxMXRoLTE0dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdUYW1wYSwgRkwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxNXRoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnRWFzdGVybnMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0NvbGxlZ2UtRWFzdGVybnMtMjAxNicsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ01hcmNoIDE4dGgtMjB0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ05vcnRoIE15cnRsZSBCZWFjaCwgU0MnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxOXRoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnSHVjayBGaW5uJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9IdWNrLUZpbm4tWFgtMjAxNicsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0ZlYi4gMTF0aC0xNHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnU3QuIExvdWlzLCBNTycsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzExdGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdJbGxpbm9pcyBDb25mZXJlbmNlcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvSWxsaW5vaXMtRC1JLUNvbGxlZ2UtTWVucy1DQy0yMDE2JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnQXByaWwgMTZ0aC0xN3RoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnUmFudG91bCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICczcmQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdHcmVhdCBMYWtlcyBSZWdpb25hbHMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0dyZWF0LUxha2VzLUQtSS1Db2xsZWdlLU1lbnMtUmVnaW9uYWxzLTIwMTYnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdBcHJpbCAzMHRoLU1heSAxc3QnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdGYWlyIE9ha3MsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnM3JkJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTUsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdIdWNrIG9mIHRoZSBJcmlzaCcsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHBzOi8vbmR1bHRpbWF0ZS53b3JkcHJlc3MuY29tL3doaXRlc21va2UnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdTZXB0LiAyN3RoLTI4dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdTb3V0aCBCZW5kLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnR2xvcnkgRGF5cycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly93d3cuc3VuLXVsdGltYXRlLm9yZy9nbG9yeS1kYXlzLmh0bWwnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdPY3QuIDR0aC01dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSb2NrZm9yZCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0lsbGlub2lzIEludml0ZScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHBzOi8vaWxsaW5vaXMuY29sbGVnaWF0ZWxpbmsubmV0L29yZ2FuaXphdGlvbi9pbGxpbm9pc21lbnN1bHRpbWF0ZWZyaXNiZWV0ZWFtL2NhbGVuZGFyL2RldGFpbHMvNTA0MjA0JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnT2N0LiAxOHRoLTE5dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSYW50b3VsLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnTWlzc291cmkgTG92ZXMgQ29tcGFueScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly91bHRpd29ybGQuY29tLzIwMTQvMTEvMDYvbWlzc291cmktbG92ZXMtY29tcGFueS0yMDE0LXRvdXJuYW1lbnQtcHJldmlldy1tZW5zJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnTm92LiA4dGgtOXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0Zsb3JpZGEgV2FybXVwJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9XYXJtLVVwLUEtRmxvcmlkYS1BZmZhaXItMjAxNScsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0ZlYi4gMTN0aC0xNXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnVGFtcGEsIEZMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMTN0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0NlbnRleCBJbnZpdGUnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0NlbnRleC1JbnZpdGUtMjAxNScsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ01hcmNoIDE0dGgtMTV0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ0F1c3RpbiwgVFgnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxN3RoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnRWFzdGVybnMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0Vhc3Rlcm5zLTIwMTUnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdNYXJjaCAyN3RoLTI5dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdOb3J0aCBNeXJ0bGUgQmVhY2gsIFNDJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMTd0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0lsbGlub2lzIENvbmZlcmVuY2VzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9JbGxpbm9pcy1ELUktQ29sbGVnZS1NZW5zLUNDLTIwMTUnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdBcHJpbCAxMXRoLTEydGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSYW50b3VsLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzJuZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0dyZWF0IExha2VzIFJlZ2lvbmFscycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvR3JlYXQtTGFrZXMtRC1JLUNvbGxlZ2UtTWVucy1SZWdpb25hbHMtMjAxNScsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0FwcmlsIDI1dGgtMjZ0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1JvY2tmb3JkLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzFzdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0QtSSBOYXRpb25hbCBDaGFtcGlvbnNoaXBzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9VU0EtVWx0aW1hdGUtRC1JLUNvbGxlZ2UtQ2hhbXBpb25zaGlwcy0yMDE1JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnTWF5IDIybmQtMjV0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ01pbHdhdWtlZSwgV0knLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxM3RoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTQsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdCb2lsZXIgQnJlYWthd2F5JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMzQyMicsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ09jdC4gNXRoLTZ0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1dlc3QgTGFmYXlldHRlLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnSWxsaW5vaXMgSW52aXRlJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMzM1MCcsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ09jdC4gMTJ0aC0xM3RoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnUmFudG91bCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ01pY2hpZ2FuIFJvdW5kIFJvYmluJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnT2N0LiAyMHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnQW5uIEFyYm9yLCBNSScsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnR2xvcnkgRGF5cycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTM0OTknLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdPY3QuIDI2dGgtMjd0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1JvY2tmb3JkLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnTWlzc291cmkgTG92ZXMgQ29tcGFueScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTQwMTcnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdOb3YuIDl0aC0xMHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMTN0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0NhdCBGaWdodCcsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvQ2F0LUZpZ2h0JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnRmViLiAyMm5kLTIzcmQnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdMZXhpbmd0b24sIEtZJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMXN0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnRWFzdGVybnMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0Vhc3Rlcm5zLWFuZC1ESUlJLUVhc3Rlcm5zJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnTWFyY2ggMjJuZC0yM3JkJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnTGl0dGxlIFJpdmVyLCBTQycsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzEzdGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdJbGxpbm9pcyBDb25mZXJlbmNlcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvSWxsaW5vaXMtRC1JLUNvbGxlZ2UtTWVucy1DQycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0FwcmlsIDEydGgtMTN0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1JhbnRvdWwsIElMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMXN0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnR3JlYXQgTGFrZXMgUmVnaW9uYWxzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9HcmVhdC1MYWtlcy1ELUktQ29sbGVnZS1NZW5zLVJlZ2lvbmFscycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0FwcmlsIDI2dGgtMjd0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1JvY2tmb3JkLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzV0aCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEzLFxuICAgICAgICB0b3VybmFtZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnQm9pbGVyIEJyZWFrYXdheScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3JlczIwMTIvI2NvbGxlZ2Utb3Blbi90b3VybmFtZW50LzExNDMyJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnU2VwdC4gMjJuZC0yM3JkJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnV2VzdCBMYWZheWV0dGUsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdJbGxpbm9pcyBJbnZpdGUnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMyMDEyLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMTQ3NicsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ09jdC4gMTN0aC0xNHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnUmFudG91bCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ01pc3NvdXJpIExvdmVzIENvbXBhbnknLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMyMDEyLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMTY1NycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ05vdi4gMTB0aC0xMXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0h1Y2sgRmlubicsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTIxMTUnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdNYXJjaCA5dGgtMTB0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ0NoZXN0ZXJmaWVsZCwgTU8nLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxM3RoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnQ2VudGV4JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMjcwNycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ01hcmNoIDE2dGgtMTd0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ0F1c3RpbiwgVFgnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICc0dGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdJbGxpbm9pcyBDb25mZXJlbmNlcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTI2MDQnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdBcHJpbCAxM3RoLTE0dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSYW50b3VsLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzFzdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0dyZWF0IExha2VzIFJlZ2lvbmFscycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTI2NjcnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdBcHJpbCAyN3RoLTI4dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSb2NrZm9yZCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxc3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdELUkgTmF0aW9uYWwgQ2hhbXBpb25zaGlwcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTI2ODYnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdNYXkgMjR0aC0yN3RoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnTWFkaXNvbiwgV0knLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxN3RoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxuXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy9kYXRhL3RvdXJuYW1lbnRzLmRhdGEudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGgxIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPlRvdXJuYW1lbnRzPC9oMT5cXG48ZGl2IGNsYXNzPVxcXCJ1aSBzZWNvbmRhcnkgcG9pbnRpbmcgbWVudVxcXCI+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvdG91cm5hbWVudHMvMjAxM1xcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTN9XFxcIj4yMDEzPC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiaXRlbVxcXCIgcm91dGVyTGluaz1cXFwiL3RvdXJuYW1lbnRzLzIwMTRcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDE0fVxcXCI+MjAxNDwvYT5cXG4gICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIHJvdXRlckxpbms9XFxcIi90b3VybmFtZW50cy8yMDE1XFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogeWVhciA9PT0gMjAxNX1cXFwiPjIwMTU8L2E+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvdG91cm5hbWVudHMvMjAxNlxcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTZ9XFxcIj4yMDE2PC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiaXRlbVxcXCIgcm91dGVyTGluaz1cXFwiL3RvdXJuYW1lbnRzLzIwMTdcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDE3fVxcXCI+MjAxNzwvYT5cXG48L2Rpdj5cXG48bmctY29udGFpbmVyICpuZ0Zvcj1cXFwibGV0IHRvdXJuYW1lbnRZZWFyIG9mIHRvdXJuYW1lbnREYXRhXFxcIj5cXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cXFwidG91cm5hbWVudFllYXIueWVhciA9PT0geWVhclxcXCI+XFxuICAgICAgICA8dGFibGUgY2xhc3M9XFxcInVpIGNlbGxlZCB0YWJsZVxcXCIgKm5nSWY9XFxcInRvdXJuYW1lbnREYXRhXFxcIj5cXG4gICAgICAgICAgICA8dGhlYWQ+XFxuICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgIDx0aD5TZWFzb248L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPk5hbWU8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPldoZW48L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPkxvY2F0aW9uPC90aD5cXG4gICAgICAgICAgICAgICAgICAgIDx0aD5SZXN1bHQ8L3RoPlxcbiAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgdG91cm5hbWVudCBvZiB0b3VybmFtZW50WWVhci50b3VybmFtZW50c1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3t0b3VybmFtZW50LnNlYXNvbn19PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgIDx0ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tT25seSByZW5kZXIgYSBsaW5rIGlmIHRoZXJlIGlzIG9uZSBwcm92aWRlZCBpbiB0aGUgZGF0YSwgb3RoZXJ3aXNlIGp1c3QgcmVuZGVyIHRoZSB0ZXh0LS0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgKm5nSWY9XFxcInRvdXJuYW1lbnQubmFtZUxpbmtcXFwiIGhyZWY9XFxcInt7dG91cm5hbWVudC5uYW1lTGlua319XFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+e3t0b3VybmFtZW50Lm5hbWVMYWJlbH19PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XFxcIiF0b3VybmFtZW50Lm5hbWVMaW5rXFxcIj57e3RvdXJuYW1lbnQubmFtZUxhYmVsfX08L25nLWNvbnRhaW5lcj5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3t0b3VybmFtZW50LndoZW59fTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3t0b3VybmFtZW50LmxvY2F0aW9ufX08L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7dG91cm5hbWVudC5yZXN1bHR9fTwvdGQ+XFxuICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgIDwvdGFibGU+XFxuICAgIDwvbmctY29udGFpbmVyPlxcbjwvbmctY29udGFpbmVyPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC90ZWFtL3RvdXJuYW1lbnRzL3RvdXJuYW1lbnRzLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi90b3VybmFtZW50cy5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSB9IGZyb20gXCJAYW5ndWxhci9yb3V0ZXJcIjtcblxuaW1wb3J0IHsgUm9zdGVyWWVhciB9IGZyb20gXCIuL21vZGVsL3Jvc3Rlci15ZWFyLm1vZGVsXCI7XG5pbXBvcnQgeyBST1NURVJfREFUQSB9IGZyb20gXCIuL2RhdGEvcm9zdGVycy5kYXRhXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncm9zdGVyJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9yb3N0ZXIuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL3Jvc3Rlci5jb21wb25lbnQubGVzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIFJvc3RlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvLyBSb3N0ZXIgZGF0YSB0byBpbmplY3QgaW50byBvdXIgdGVtcGxhdGVcbiAgICBwcml2YXRlIHJvc3RlckRhdGE6IFJvc3RlclllYXJbXSA9IFJPU1RFUl9EQVRBO1xuICAgIC8vIFN1YnNjcmlwdGlvbiB0byBvdXIgcm91dGUgcGFyYW1ldGVycyAocm9zdGVyIHllYXIpXG4gICAgcHJpdmF0ZSByb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbjogYW55O1xuICAgIC8vIEN1cnJlbnQgcm9zdGVyIHllYXJcbiAgICBwcml2YXRlIHllYXI6IG51bWJlcjtcblxuICAgIC8vIEluamVjdCB0aGUgQWN0aXZhdGVkUm91dGUgaW50byBvdXIgY29tcG9uZW50XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZTogQWN0aXZhdGVkUm91dGUpIHt9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHJvc3RlciB5ZWFyKS5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5yb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbiA9IHRoaXMucm91dGUucGFyYW1zLnN1YnNjcmliZShwYXJhbXMgPT4ge1xuICAgICAgICAgICAgLy8gKCspIGNvbnZlcnRzIHN0cmluZyAneWVhcicgdG8gYSBudW1iZXJcbiAgICAgICAgICAgIHRoaXMueWVhciA9ICtwYXJhbXNbJ3llYXInXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHJvc3RlciB5ZWFyKS5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9yb3N0ZXIuY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgUm9zdGVyWWVhciB9IGZyb20gXCIuLi9tb2RlbC9yb3N0ZXIteWVhci5tb2RlbFwiO1xuXG5leHBvcnQgY29uc3QgUk9TVEVSX0RBVEE6IFJvc3RlclllYXJbXSA9IFtcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTcsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAxNy5qcGcnLFxuICAgICAgICBwbGF5ZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6IGBCZW4gJ0JlZWYnIFNhYm91cmluYCxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAxNi5qcGcnLFxuICAgICAgICBwbGF5ZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdOaWNrIFByb3pvcm92c2t5KicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE1LFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTUuanBnJyxcbiAgICAgICAgcGxheWVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTmljayBQcm96b3JvdnNreSonLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9XG5dO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9kYXRhL3Jvc3RlcnMuZGF0YS50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+Um9zdGVyPC9oMT5cXG48ZGl2IGNsYXNzPVxcXCJ1aSBzZWNvbmRhcnkgcG9pbnRpbmcgbWVudVxcXCI+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvcm9zdGVyLzIwMTVcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDE1fVxcXCI+MjAxNTwvYT5cXG4gICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIHJvdXRlckxpbms9XFxcIi9yb3N0ZXIvMjAxNlxcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTZ9XFxcIj4yMDE2PC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiaXRlbVxcXCIgcm91dGVyTGluaz1cXFwiL3Jvc3Rlci8yMDE3XFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogeWVhciA9PT0gMjAxN31cXFwiPjIwMTc8L2E+XFxuPC9kaXY+XFxuPG5nLWNvbnRhaW5lciAqbmdGb3I9XFxcImxldCByb3N0ZXJZZWFyIG9mIHJvc3RlckRhdGFcXFwiPlxcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVxcXCJyb3N0ZXJZZWFyLnllYXIgPT09IHllYXJcXFwiPlxcbiAgICAgICAgPGltZyBzcmM9XFxcInt7cm9zdGVyWWVhci5pbWFnZVBhdGh9fVxcXCIvPlxcbiAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJ1aSBjZWxsZWQgdGFibGVcXFwiPlxcbiAgICAgICAgICAgIDx0aGVhZD5cXG4gICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPiM8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPk5hbWU8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPlllYXI8L3RoPlxcbiAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgcGxheWVyIG9mIHJvc3RlclllYXIucGxheWVyc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3twbGF5ZXIubnVtYmVyfX08L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7cGxheWVyLm5hbWV9fTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3twbGF5ZXIueWVhcn19PC90ZD5cXG4gICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgPC90YWJsZT5cXG4gICAgICAgIDxwPigqKSBpbmRpY2F0ZXMgY2FwdGFpbiBmb3IgdGhhdCB5ZWFyPC9wPlxcbiAgICA8L25nLWNvbnRhaW5lcj5cXG48L25nLWNvbnRhaW5lcj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvdGVhbS9yb3N0ZXIvcm9zdGVyLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9yb3N0ZXIuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImltZyB7XFxuICB3aWR0aDogNzUlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzAwMDA0RDtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjllbTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9yb3N0ZXIuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIFZpZXdDaGlsZCwgRWxlbWVudFJlZiwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBTcHJlYWRzaGVldFNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vc2VydmljZS9nb29nbGUtc3ByZWFkc2hlZXQuc2VydmljZVwiO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2Fic2VudCcsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYWJzZW50LmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9hYnNlbnQuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBBYnNlbnRDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIC8vIEFQSSB1cmwgZm9yIG91ciBwZXJzb25hbCBzZXJ2ZXJcbiAgICBwcml2YXRlIGdvb2dsZVNoZWV0c0FwaVVybCA9ICdodHRwczovL25pY2stcHJvei1nb29nbGUtc2hlZXQtYXBpLmhlcm9rdWFwcC5jb20vc2hlZXRzLzExaWpySG95c2lJd3NGZkVnZ2JTTk05WThWdnpVNjVqZXVoUTN2a1Y1Rkd3L3NoZWV0SW5kZXgvMS9yb3dzLyc7XG4gICAgLy8gQVBJIHVybCBmb3Igb3VyIGJhY2t1cCBzZXJ2ZXIgKHNoZWV0c3UgQVBJKVxuICAgIC8vIHByaXZhdGUgZ29vZ2xlU2hlZXRzQmFja3VwQXBpVXJsID0gJ2h0dHBzOi8vc2hlZXRzdS5jb20vYXBpcy92MS4wLzdhMDMwYWU2MGI3ZCc7XG4gICAgcHJpdmF0ZSBnb29nbGVTaGVldHNCYWNrdXBBcGlVcmwgPSAnJztcblxuICAgIC8vIEVycm9yIG1lc3NhZ2VzXG4gICAgcHJpdmF0ZSB2YWxpZGF0aW9uRXJyb3JzOiBzdHJpbmcgPSAnUGxlYXNlIGRvIG5vdCBsZWF2ZSBhbnkgcmVxdWlyZWQgZmllbGRzIGJsYW5rLic7XG4gICAgcHJpdmF0ZSBzdWJtaXNzaW9uRXJyb3I6IHN0cmluZyA9ICdDb3VsZCBub3Qgc3VibWl0IHRoZSBmb3JtICBkdWUgdG8gYSBzZXJ2ZXIgZXJyb3IuIFBsZWFzZSB0cnkgYWdhaW4gc29vbiBvciBjb250YWN0IHRoZSB3ZWIgYWRtaW5zLic7XG5cbiAgICAvLyBGaXJzdCBuYW1lIGlucHV0XG4gICAgcHJpdmF0ZSBmaXJzdE5hbWU6IHN0cmluZztcbiAgICAvLyBMYXN0IG5hbWUgaW5wdXRcbiAgICBwcml2YXRlIGxhc3ROYW1lOiBzdHJpbmc7XG4gICAgLy8gUmVhc29uIGlucHV0XG4gICAgcHJpdmF0ZSByZWFzb246IHN0cmluZztcbiAgICAvLyBUaW1lIGlucHV0XG4gICAgcHJpdmF0ZSB0aW1lOiBzdHJpbmc7XG4gICAgLy8gRGF5IGlucHV0XG4gICAgcHJpdmF0ZSBkYXk6IG51bWJlcjtcbiAgICAvLyBNb250aCBpbnB1dFxuICAgIHByaXZhdGUgbW9udGg6IG51bWJlcjtcbiAgICAvLyBCb29sZWFuIGluZGljYXRpbmcgaWYgb3VyIGZvcm0gaXMgaW4gdGhlIHByb2Nlc3Mgb2Ygc3VibWl0dGluZyAodG8gc2hvdyBvdXIgbG9hZGluZyBpY29uKVxuICAgIHByaXZhdGUgZm9ybUlzU3VibWl0dGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIC8vIEJvb2xlYW4gaW5kaWNhdGluZyBpZiBvdXIgZm9ybSB3YXMgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZCAodG8gc2hvdyBvdXIgc3VjY2VzcyBtZXNzYWdlKVxuICAgIHByaXZhdGUgc3VibWl0U3VjY2VzczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIC8vIEZvcm0gZXJyb3JzIG91dHB1dFxuICAgIHByaXZhdGUgZm9ybUVycm9yczogc3RyaW5nO1xuXG4gICAgLy8gTW9udGggZHJvcGRvd25cbiAgICBAVmlld0NoaWxkKCdtb250aERyb3Bkb3duJylcbiAgICBwcml2YXRlIG1vbnRoRHJvcGRvd246IEVsZW1lbnRSZWY7XG5cbiAgICAvLyBDb25zdHJ1Y3RvciB3aXRoIG91ciBodHRwIHNlcnZpY2UgaW5qZWN0ZWRcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNwcmVhZHNoZWV0U2VydmljZTogU3ByZWFkc2hlZXRTZXJ2aWNlKSB7fVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICAkKHRoaXMubW9udGhEcm9wZG93bi5uYXRpdmVFbGVtZW50KS5kcm9wZG93bigpO1xuICAgIH1cblxuICAgIGhhbmRsZVN1Ym1pdChldmVudDogYW55LCBtb250aElucHV0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5tb250aCA9IG1vbnRoSW5wdXQ7XG4gICAgICAgIHRoaXMuc3VibWl0U3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCF0aGlzLmZvcm1Jc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUVycm9ycyA9IHRoaXMudmFsaWRhdGlvbkVycm9ycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUlzU3VibWl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1FcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgXCJUaW1lc3RhbXBcIjogZGF0ZS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgIFwiRmlyc3QgTmFtZVwiOiB0aGlzLmZpcnN0TmFtZSxcbiAgICAgICAgICAgICAgICBcIkxhc3QgTmFtZVwiOiB0aGlzLmxhc3ROYW1lLFxuICAgICAgICAgICAgICAgIFwiVGltZVwiOiB0aGlzLnRpbWUsXG4gICAgICAgICAgICAgICAgXCJEYXRlXCI6IGAke3RoaXMubW9udGh9LyR7dGhpcy5kYXl9YCxcbiAgICAgICAgICAgICAgICBcIlJlYXNvblwiOiB0aGlzLnJlYXNvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3VibWl0QWJzZW50Rm9ybShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1Ym1pdHMgb3VyIGZvcm0gdG8gdGhlIHNwcmVhZHNoZWV0IGJ5IGNhbGxpbmcgb3VyIHNlcnZpY2UgbWV0aG9kLlxuICAgICAqIE9uIHN1Y2Nlc3MsIHdlIHNob3cgb3VyIGNvbmZpcm1hdGlvbiBtb2RhbCBhbmQgcmVzZXQgb3VyIHJzdnAgbW9kYWwuXG4gICAgICogT24gZmFpbHVyZSwgd2UgaGlkZSBvdXIgc3VibWl0dGluZyBkaWFsb2cgYW5kIHNob3cgb3VyIHN1Ym1pc3Npb24gZXJyb3IgdG8gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAtIGRhdGEgdG8gc3VibWl0IHRvIG91ciBzcHJlYWRzaGVldFxuICAgICAqL1xuICAgIHByaXZhdGUgc3VibWl0QWJzZW50Rm9ybShkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zcHJlYWRzaGVldFNlcnZpY2UucG9zdFJvd1RvU3ByZWFkc2hlZXQodGhpcy5nb29nbGVTaGVldHNBcGlVcmwsIHRoaXMuZ29vZ2xlU2hlZXRzQmFja3VwQXBpVXJsLCBkYXRhKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGb3JtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJtaXRTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUlzU3VibWl0dGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUVycm9ycyA9IHRoaXMuc3VibWlzc2lvbkVycm9yO1xuICAgICAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgb3VyIGlucHV0IGZpZWxkcywgZXJyb3JzLCBhbmQgcmVzZXRzIG91ciBmb3JtIGlzIHN1Ym1pdHRpbmcgZmxhZy5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlc2V0Rm9ybSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5maXJzdE5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3ROYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFzb24gPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmRheSA9IG51bGw7XG4gICAgICAgIHRoaXMubW9udGggPSBudWxsO1xuICAgICAgICB0aGlzLmZvcm1FcnJvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcm1Jc1N1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGcm9udC1lbmQgdmFsaWRhdGlvbiBmb3Igb3VyIGZvcm0uXG4gICAgICogT3VyIGZvcm0gaXMgdmFsaWQgb25seSBpZiBhbGwgZmllbGRzIGFyZSBwb3B1bGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBmb3JtIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGZvcm1Jc1ZhbGlkKCk6IGJvb2xlYW4ge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0TmFtZSAhPSBudWxsICAgJiYgdGhpcy5maXJzdE5hbWUgIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMubGFzdE5hbWUgIT0gbnVsbCAgICAmJiB0aGlzLmxhc3ROYW1lICE9ICcnXG4gICAgICAgICAgICAmJiB0aGlzLnJlYXNvbiAhPSBudWxsICAgICAgJiYgdGhpcy5yZWFzb24gIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMudGltZSAhPSBudWxsICAgICAgICAmJiB0aGlzLnRpbWUgIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMubW9udGggIT0gbnVsbCAgICAgICAmJiB0aGlzLm1vbnRoID4gMFxuICAgICAgICAgICAgJiYgdGhpcy5kYXkgIT0gbnVsbDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+UHJhY3RpY2UgQWJzZW5jZSBGb3JtPC9oMT5cXG48ZGl2ICpuZ0lmPVxcXCJmb3JtSXNTdWJtaXR0aW5nXFxcIiBjbGFzcz1cXFwidWkgYWN0aXZlIGludmVydGVkIGRpbW1lclxcXCI+PGRpdiBjbGFzcz1cXFwidWkgdGV4dCBsb2FkZXJcXFwiPlN1Ym1pdHRpbmc8L2Rpdj48L2Rpdj5cXG48Zm9ybSBjbGFzcz1cXFwidWkgZm9ybVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInR3byBmaWVsZHNcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgIDxsYWJlbD5GaXJzdCBOYW1lIDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwiZmlyc3ROYW1lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJmaXJzdC1uYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiRmlyc3QgTmFtZVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICA8bGFiZWw+TGFzdCBOYW1lIDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwibGFzdE5hbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcImxhc3QtbmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIkxhc3QgTmFtZVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgIDxsYWJlbD5SZWFzb24gZm9yIG1pc3Npbmcgb3IgYmVpbmcgbGF0ZSB0byBwcmFjdGljZSA8c3BhbiBjbGFzcz1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwicmVhc29uXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJyZWFzb25cXFwiIHBsYWNlaG9sZGVyPVxcXCJCZXR0ZXIgYmUgZ29vZC4uLlxcXCI+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICA8bGFiZWw+RnJvbSB3aGF0IHRpbWUgdG8gd2hhdCB0aW1lIGlzIHlvdXIgY29uZmxpY3Q/IDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJ0aW1lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJ0aW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiVGltZVxcXCI+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0d28gZmllbGRzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD5QcmFjdGljZSBkYXRlIDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcImRheVxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJkYXlcXFwiIHBsYWNlaG9sZGVyPVxcXCJEYXkgKDAtMzEpXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD4mbmJzcDs8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8ZGl2ICNtb250aERyb3Bkb3duIGNsYXNzPVxcXCJ1aSBzZWFyY2ggc2VsZWN0aW9uIGRyb3Bkb3duXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCAjbW9udGhJbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcIm1vbnRoXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkZWZhdWx0IHRleHRcXFwiPk1vbnRoPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBkYXRhLXZhbHVlPVxcXCIwMVxcXCI+SmFudWFyeTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjAyXFxcIj5GZWJydWFyeTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjAzXFxcIj5NYXJjaDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjA0XFxcIj5BcHJpbDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjA1XFxcIj5NYXk8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBkYXRhLXZhbHVlPVxcXCIwNlxcXCI+SnVuZTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjA3XFxcIj5KdWx5PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgZGF0YS12YWx1ZT1cXFwiMDhcXFwiPkF1Z3VzdDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjA5XFxcIj5TZXB0ZW1iZXI8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBkYXRhLXZhbHVlPVxcXCIxMFxcXCI+T2N0b2JlcjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjExXFxcIj5Ob3ZlbWJlcjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjEyXFxcIj5EZWNlbWJlcjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8YnV0dG9uIChjbGljayk9XFxcImhhbmRsZVN1Ym1pdCgkZXZlbnQsIG1vbnRoSW5wdXQudmFsdWUpXFxcIiBjbGFzcz1cXFwidWkgYnV0dG9uXFxcIiB0eXBlPVxcXCJzdWJtaXRcXFwiPlN1Ym1pdDwvYnV0dG9uPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aSBlcnJvciBtZXNzYWdlXFxcIiAqbmdJZj1cXFwiZm9ybUVycm9yc1xcXCI+XFxuICAgICAgICA8cD57e2Zvcm1FcnJvcnN9fTwvcD5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpIHN1Y2Nlc3MgbWVzc2FnZVxcXCIgKm5nSWY9XFxcInN1Ym1pdFN1Y2Nlc3NcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5Gb3JtIFN1Ym1pdHRlZDwvZGl2PlxcbiAgICAgICAgPHA+VGhlIGZvcm0gd2FzIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQuIFN0b3AgbWlzc2luZyBwcmFjdGljZS48L3A+XFxuICAgIDwvZGl2PlxcbjwvZm9ybT5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9hYnNlbnQuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImxhYmVsIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbi51aS5mb3JtIHtcXG4gIHdpZHRoOiA4MCU7XFxuICBtYXJnaW46IDAgYXV0bztcXG59XFxuLnVpLmZvcm0gLnVpLmVycm9yLm1lc3NhZ2UsXFxuLnVpLmZvcm0gLnVpLnN1Y2Nlc3MubWVzc2FnZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLnVpLmZvcm0gLnVpLmVycm9yLm1lc3NhZ2UgcCxcXG4udWkuZm9ybSAudWkuc3VjY2Vzcy5tZXNzYWdlIHAge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG4udWkuc2VsZWN0aW9uLmFjdGl2ZS5kcm9wZG93biAubWVudSxcXG4udWkuc2VhcmNoLnNlbGVjdGlvbi5kcm9wZG93bi5hY3RpdmUudmlzaWJsZSxcXG4udWkuc2VsZWN0aW9uLmFjdGl2ZS5kcm9wZG93bjpob3ZlciB7XFxuICBib3JkZXItY29sb3I6ICNmZjYyMjY7XFxufVxcbi51aS5kcm9wZG93biB7XFxuICBtaW4td2lkdGg6IGluaGVyaXQ7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gUm91dGUgQ29uZmlndXJhdGlvblxuaW1wb3J0IHsgUm91dGVzIH0gZnJvbSBcIkBhbmd1bGFyL3JvdXRlclwiO1xuaW1wb3J0IHsgSG9tZUNvbXBvbmVudCB9IGZyb20gXCIuL2hvbWUvaG9tZS5jb21wb25lbnRcIjtcbmltcG9ydCB7IEFib3V0Q29tcG9uZW50IH0gZnJvbSBcIi4vYWJvdXQvYWJvdXQuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBQcm9zcGVjdGl2ZVBsYXllcnNDb21wb25lbnQgfSBmcm9tIFwiLi9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBDb250YWN0Q29tcG9uZW50IH0gZnJvbSBcIi4vY29udGFjdC9jb250YWN0LmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUHJhY3RpY2VDb21wb25lbnQgfSBmcm9tIFwiLi90ZWFtL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgVG91cm5hbWVudHNDb21wb25lbnQgfSBmcm9tIFwiLi90ZWFtL3RvdXJuYW1lbnRzL3RvdXJuYW1lbnRzLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUm9zdGVyQ29tcG9uZW50IH0gZnJvbSBcIi4vdGVhbS9yb3N0ZXIvcm9zdGVyLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgQWJzZW50Q29tcG9uZW50IH0gZnJvbSBcIi4vdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgVGVhbUhpc3RvcnlDb21wb25lbnQgfSBmcm9tIFwiLi9oaXN0b3J5L3RlYW0taGlzdG9yeS90ZWFtLWhpc3RvcnkuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBBd2FyZHNDb21wb25lbnQgfSBmcm9tIFwiLi9oaXN0b3J5L2F3YXJkcy9hd2FyZHMuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBSZXN1bHRzQ29tcG9uZW50IH0gZnJvbSBcIi4vaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50XCI7XG5cbmV4cG9ydCBjb25zdCBST1VURVM6IFJvdXRlcyA9IFtcbiAgICB7cGF0aDogJycsICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBIb21lQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJ3ByYWN0aWNlJywgICAgICAgICAgY29tcG9uZW50OiBQcmFjdGljZUNvbXBvbmVudH0sXG4gICAge3BhdGg6ICdhYnNlbnQnLCAgICAgICAgICAgIGNvbXBvbmVudDogQWJzZW50Q29tcG9uZW50fSxcbiAgICB7cGF0aDogJ2NvbnRhY3QnLCAgICAgICAgICAgY29tcG9uZW50OiBDb250YWN0Q29tcG9uZW50fSxcbiAgICB7cGF0aDogJ2hvbWUnLCAgICAgICAgICAgICAgY29tcG9uZW50OiBIb21lQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJ2Fib3V0JywgICAgICAgICAgICAgY29tcG9uZW50OiBBYm91dENvbXBvbmVudH0sXG4gICAge3BhdGg6ICdwcm9zcGVjdHMnLCAgICAgICAgIGNvbXBvbmVudDogUHJvc3BlY3RpdmVQbGF5ZXJzQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJ3RvdXJuYW1lbnRzLzp5ZWFyJywgY29tcG9uZW50OiBUb3VybmFtZW50c0NvbXBvbmVudH0sXG4gICAge3BhdGg6ICdyb3N0ZXIvOnllYXInLCAgICAgIGNvbXBvbmVudDogUm9zdGVyQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJ2hpc3RvcnkvOnllYXInLCAgICAgY29tcG9uZW50OiBUZWFtSGlzdG9yeUNvbXBvbmVudH0sXG4gICAge3BhdGg6ICdhd2FyZHMnLCAgICAgICAgICAgIGNvbXBvbmVudDogQXdhcmRzQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJ3Jlc3VsdHMnLCAgICAgICAgICAgY29tcG9uZW50OiBSZXN1bHRzQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJyoqJywgICAgICAgICAgICAgICAgY29tcG9uZW50OiBIb21lQ29tcG9uZW50fSxcbl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2FwcC5yb3V0ZXMudHMiLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIE9uSW5pdCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEhpc3RvcnlZZWFyIH0gZnJvbSBcIi4vbW9kZWwvaGlzdG9yeS15ZWFyLm1vZGVsXCI7XG5pbXBvcnQgeyBISVNUT1JZX0RBVEEgfSBmcm9tIFwiLi9kYXRhL2hpc3RvcnkteWVhci5kYXRhXCI7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSB9IGZyb20gXCJAYW5ndWxhci9yb3V0ZXJcIjtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd0ZWFtLWhpc3RvcnknLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3RlYW0taGlzdG9yeS5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5sZXNzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgVGVhbUhpc3RvcnlDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuXG4gICAgLy8gUmVzdWx0cyBkYXRhIHRvIGluamVjdCBpbnRvIG91ciB0ZW1wbGF0ZVxuICAgIHByaXZhdGUgaGlzdG9yeURhdGE6IEhpc3RvcnlZZWFyW10gPSBISVNUT1JZX0RBVEE7XG4gICAgLy8gU3Vic2NyaXB0aW9uIHRvIG91ciByb3V0ZSBwYXJhbWV0ZXJzICh0b3VybmFtZW50IHllYXIpXG4gICAgcHJpdmF0ZSByb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbjogYW55O1xuICAgIC8vIEN1cnJlbnQgdG91cm5hbWVudCB5ZWFyXG4gICAgcHJpdmF0ZSB5ZWFyOiBudW1iZXI7XG5cbiAgICAvLyBZZWFyIGRyb3Bkb3duc1xuICAgIEBWaWV3Q2hpbGQoJzE5OTRkcm9wZG93bicpXG4gICAgcHJpdmF0ZSBmaXJzdERyb3Bkb3duOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJzIwMDBkcm9wZG93bicpXG4gICAgcHJpdmF0ZSBzZWNvbmREcm9wZG93bjogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCcyMDEwZHJvcGRvd24nKVxuICAgIHByaXZhdGUgdGhpcmREcm9wZG93bjogRWxlbWVudFJlZjtcblxuICAgIC8vIEluamVjdCB0aGUgQWN0aXZhdGVkUm91dGUgaW50byBvdXIgY29tcG9uZW50XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZTogQWN0aXZhdGVkUm91dGUpIHt9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgICQodGhpcy5maXJzdERyb3Bkb3duLm5hdGl2ZUVsZW1lbnQpLmRyb3Bkb3duKHt9KTtcbiAgICAgICAgJCh0aGlzLnNlY29uZERyb3Bkb3duLm5hdGl2ZUVsZW1lbnQpLmRyb3Bkb3duKHt9KTtcbiAgICAgICAgJCh0aGlzLnRoaXJkRHJvcGRvd24ubmF0aXZlRWxlbWVudCkuZHJvcGRvd24oe30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBvdXIgcm91dGUgcGFyYW1ldGVycyAodG91cm5hbWVudCB5ZWFyKS5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5yb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbiA9IHRoaXMucm91dGUucGFyYW1zLnN1YnNjcmliZShwYXJhbXMgPT4ge1xuICAgICAgICAgICAgLy8gKCspIGNvbnZlcnRzIHN0cmluZyAneWVhcicgdG8gYSBudW1iZXJcbiAgICAgICAgICAgIHRoaXMueWVhciA9ICtwYXJhbXNbJ3llYXInXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHRvdXJuYW1lbnQgeWVhcikuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucm91dGVQYXJhbXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC50cyIsImltcG9ydCB7IEhpc3RvcnlZZWFyIH0gZnJvbSBcIi4uL21vZGVsL2hpc3RvcnkteWVhci5tb2RlbFwiO1xuXG5leHBvcnQgY29uc3QgSElTVE9SWV9EQVRBOiBIaXN0b3J5WWVhcltdID0gW1xuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNixcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDE2LmpwZycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPklsbGlub2lzIFVsdGltYXRlIGNhbWUgaW50byB0aGUgMjAxNiBzZWFzb24gd2l0aCBhIHRhc3RlIG9mIHN1Y2Nlc3MgYW5kIGJpZyBzaG9lcyB0byBmaWxsLiBSZXR1cm5pbmcgY2FwdGFpbiBOaWNrIFByb3pvcm92c2t5IGFuZCBuZXcgY2FwdGFpbnMgUHJheWFnIFBhdGVsIGFuZCBDaHJpcyBCdWNodGEgd2VyZSB0YXNrZWQgd2l0aCB0aGUgZGlmZmljdWx0IHByb3NwZWN0IG9mIHJlcGxhY2luZyB0aGUgMTIgZ3JhZHVhdGluZyBwbGF5ZXJzIGFzIHdlbGwgYXMgY29hY2ggTWF0dCBTdHVwY2EuIEJvb21sYW5kIGNvYWNoIEVyaWsgSHVlbWlsbGVyIGFuZCByZWNlbnQgYWx1bSBNYXR0IFdlc3Qgd2VyZSBhYmxlIHRvIGZpbGwgdGhlIGxlYWRlcnNoaXAgdm9pZCBhcyB0aGUgdGVhbSBsb29rZWQgdG8gcmVsb2FkIGZvciBhbm90aGVyIHJ1biBhdCBOYXRpb25hbHMuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIHRyeW91dHMgZm9yIHRoZSB0ZWFtIHdlcmUgdmVyeSBjb21wZXRpdGl2ZSwgd2l0aCB0aGUgYmlnZ2VzdCBpbmNvbWluZyBjbGFzcyBpbiByZWNlbnQgbWVtb3J5LiBUaGUgZmluYWwgcm9zdGVyIGluY2x1ZGVkIDcgcm9va2llcywgMSBncmFkIHN0dWRlbnQsIDUgZm9ybWVyIEJvb21sYW5kIHBsYXllcnMsIGFuZCAxMiByZXR1cm5lcnMuIFRoZSBuZXdlc3QgaXRlcmF0aW9uIG9mIElsbGlub2lzIFVsdGltYXRlIHRlc3RlZCB0aGVtc2VsdmVzIGF0IE1pc3NvdXJpIExvdmVzIENvbXBhbnksIGJ1dCByZXR1cm5lZCB3aXRoIHNob3VsZGVyIGluanVyaWVzIHRvIHNlbmlvcnMgTmljayBQcm96b3JvdnNreSBhbmQgQWxleCBHdXkgdGhhdCB3b3VsZCBoYW1wZXIgdGhlbSBmb3IgdGhlIHJlc3Qgb2YgdGhlIHNlYXNvbi48L3A+XG4gICAgICAgICAgICA8cD5UaGlzIHNwcmluZyBzZWFzb24gaGFkIHRoZSB0ZWFtIGhlYWRpbmcgdG8gRmxvcmlkYSwgU291dGggQ2Fyb2xpbmEsIGFuZCBNaXNzb3VyaSBpbiBzZWFyY2ggb2YgZWxpdGUgY29tcGV0aXRpb24uPC9wPlxuICAgICAgICAgICAgPHA+TWlkIEZlYnJ1YXJ5IGhhZCB0aGUgdGVhbSBmbHlpbmcgc291dGggdG8gY29tcGV0ZSBhdCBXYXJtIFVwLiBVbmZvcnR1bmF0ZWx5LCB0aGUgd2VlayBwcmlvciBoYWQgZ3JhZCBzdHVkZW50IENvZHkgR3JheSBicmVha2luZyBoaXMgaGFuZCBpbiBJcndpbiBhbmQgc2VuaW9yIFdpbHNvbiBXYW5nIHB1bGxpbmcgaGlzIGhhbXN0cmluZyBpbiB0aGUgQXJtb3J5LCBib3RoIGJpZyBoYW5kbGVyIGxvc3Nlcy4gT24gU2F0dXJkYXksIHRoZSB0ZWFtIHN0YXJ0ZWQgd2l0aCAxMC0xMyBhbmQgMTEtMTMgbG9zc2VzIHRvIFRleGFzIGFuZCBGbG9yaWRhIFN0YXRlLiBUaGUgdGhpcmQgZ2FtZSBvZiB0aGUgZGF5IHdhcyBhZ2FpbnN0IHBlcmVubmlhbCBwb3dlcmhvdXNlIFBpdHRzYnVyZ2guIElsbGlub2lzIGNhbWUgb3V0IHNsb3BweSBhbmQgd2FzIHByZXNzdXJlZCBpbnRvIG1ha2luZyBtYW55IGVycm9ycywgcmVzdWx0aW5nIGluIGEgMS03IHNjb3JlIGF0IGhhbGYgYW5kIGFuIGVtYmFycmFzc2luZyAyLTEyIGxvc3MsIGZpbmlzaGluZyAwLTQgb24gdGhlIGRheSBhZnRlciBhbm90aGVyIGxvc3MgdG8gQllVLiBTYXR1cmRheSBzdGFydGVkIG9mZiBiZXR0ZXIgd2l0aCBhIDEzLTUgd2luIG92ZXIgaG9zdCBTb3V0aCBGbG9yaWRhLCBidXQgd2FzIGZvbGxvd2VkIGJ5IGJpZyBsb3NzZXMgdG8gVmlyZ2luaWEgVGVjaCBhbmQgQXVidXJuLiBJbGxpbm9pcyBmaW5pc2hlZCB0aGUgdG91cm5hbWVudCAyLTcsIHdpdGggYSB1bml2ZXJzZSBsb3NzIHRvIGluIHJlZ2lvbiByaXZhbCBOb3J0aHdlc3Rlcm4gYW5kIG9ubHkgd2lucyBjb21pbmcgYWdhaW5zdCBTb3V0aCBGbG9yaWRhLjwvcD5cbiAgICAgICAgICAgIDxwPldpdGggbW9zdCBvZiB0aGUgdGVhbSBmaW5hbGx5IGhlYWx0aHksIHRoZSB0ZWFtIG1hZGUgdGhlIHRyaXAgdG8gRWFzdGVybnMgZm9yIHRoZSBzZWNvbmQgdG91cm5hbWVudCBvZiB0aGUgc2Vhc29uLiBUaGUgZmlyc3QgZ2FtZSBvZiB0aGUgdG91cm5hbWVudCB3YXMgYSByZW1hdGNoIGFnYWluc3QgUGl0dHNidXJnaC4gVGhpcyB0aW1lLCBJbGxpbm9pcyB3YXMgcHJlcGFyZWQgZm9yIHRoZSBpbnRlbnNpdHkgYW5kIHdhcyBhYmxlIHRvIG1ha2UgaXQgYSBjbG9zZXIgZ2FtZSwgYnV0IHN0aWxsIGxvc3QgMTItMTUuIEFub3RoZXIgcmVtYXRjaCBhZ2FpbnN0IFZpcmdpbmlhIFRlY2ggZW5kZWQgc2ltaWxhcmx5LCBsb3NpbmcgMTEtMTQsIGFuZCB0aGUgdGVhbSBlbmRlZCBTYXR1cmRheSAwLTQsIHdpdGggYSAxMC0xNSBsb3NzIHRvIFVOQyBEYXJrc2lkZSBhbmQgYW4gMTEtMTMgbG9zcyB0byByZWdpb25hbCByaXZhbCBNaWNoaWdhbi4gT24gYSB3ZXQsIGNvbGQsIGFuZCB3aW5keSBTdW5kYXksIElsbGlub2lzIHdhcyBub3QgYWJsZSB0byBjb21lIG91dCB3aXRoIGFueSBmaXJlIGFuZCBsb3N0IGJhZGx5IHRvIEphbWVzIE1hZGlzb24gYW5kIENvbm5lY3RpY3V0LCBnb2luZyAwLTYgb24gdGhlIHdlZWtlbmQuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIGZpbmFsIHJlZ3VsYXIgc2Vhc29uIHRvdXJuYW1lbnQgb2YgdGhlIHllYXIgd2FzIEh1Y2sgRmlubiBhbmQgdGhlIGJveXMgZnJvbSBJbGxpbm9pcyBsb29rZWQgdG8gYm91bmNlIGJhY2sgZnJvbSBhIHNvIGZhciB1bnN1Y2Nlc3NmdWwgcmVndWxhciBzZWFzb24uIFdpdGggYSBtaW5kc2V0IG9mIGltcHJvdmluZyBmb3IgdGhlIHNlcmllcyB0aGUgSWxsaW5pIGNhbWUgb3V0IHdpdGggYSA3LTAgbGVhZCBhdCBoYWxmIG9uIEluZGlhbmEgYW5kIGNsb3NlZCBpdCBvdXQgd2l0aCBhbiAxMS00IHdpbi4gRGF5dG9uIHdhcyB0aGUgbmV4dCBnYW1lLCB3aGljaCB3YXMgYSAxMy00IHdpbiBmb3IgdGhlIElsbGluaSB3aGljaCBtZWFudCB0aGF0IHRoZXkgd291bGQgcGxheSBNYXJ5bGFuZCBmb3IgdGhlIHBvb2wuIEFua2xlIGluanVyaWVzIHRvIFByYXlhZyBQYXRlbCBhbmQgQmVuIEZvc3RlciBtZWFudCB0aGF0IHRoZSBPIGxpbmUgd2FzIHBsYXlpbmcgd2l0aG91dCB0d28ga2V5IGNvbnRyaWJ1dG9ycywgYnV0IHRoZSB0ZWFtIHdhcyBhYmxlIHRvIHRvdWdoIG91dCBhIDE0LTExIHdpbiwgc2V0dGluZyB1cCBhIGNyb3Nzb3ZlciBnYW1lIGFnYWluc3QgSWxsaW5vaXMgU3RhdGUuIEluIGEgdmVyeSB3aW5keSBnYW1lLCBJbGxpbm9pcyB0cml1bXBoZWQgb3ZlciB0aGVpciBpbiBzdGF0ZSBjb21wZXRpdG9ycyBpbiBhIDEwLTYgdmljdG9yeSwgc2VjdXJpbmcgYSBxdWFydGVyZmluYWxzIGJlcnRoLiBUaGUgdGVhbSBjbG9zZWQgb3V0IHRoZSB0b3VybmFtZW50IHdpdGggbG9zc2VzIHRvIEFya2Fuc2FzIGFuZCBQdXJkdWUsIGFuZCBwcmVwYXJlZCB0aGVtc2VsdmVzIGZvciBDb25mZXJlbmNlcy48L3A+XG4gICAgICAgICAgICA8cD5PbmNlIGFnYWluLCBSYW50b3VsIHdhcyBob3N0IHRvIENvbmZlcmVuY2VzLCBidXQgdGhpcyB0aW1lIHRoZXJlIGNvdWxkIGJlIG5vIGNvbXBsYWludHMgYWJvdXQgdGhlIHdlYXRoZXIuIElsbGlub2lzIHN0YXJ0ZWQgb3V0IHN0cm9uZyB3aXRoIGNvbWZvcnRhYmxlIHdpbnMgb3ZlciB0aGUgcmVzdCBvZiB0aGUgcG9vbCwgaW5jbHVkaW5nIGFuIDExLTQgdmljdG9yeSBvdmVyIFVDaGljYWdvLiBXaW5uaW5nIHRoZSBwb29sIGxpbmVkIHVwIGEgc2VtaWZpbmFsIGdhbWUgYWdhaW5zdCBJbGxpbm9pcyBTdGF0ZSwgd2hpY2ggd2FzIHdvbiBoYW5kaWx5IDEzLTcgYW5kIHNldCB1cCBhIGNsYXNzaWMgSWxsaW5vaXMgLSBOb3J0aHdlc3Rlcm4gcmVtYXRjaC4gVW5mb3J0dW5hdGVseSwgdGhlIHRlYW0gc3RydWdnbGVkIHRvIGZpbmQgdGhlIGVuZHpvbmUgYW5kIGZvciB0aGUgc2Vjb25kIHllYXIgaW4gYSByb3csIGxvc3QgdG8gTm9ydGh3ZXN0ZXJuIGF0IENvbmZlcmVuY2VzLiBJbiB0aGUgMm5kIHBsYWNlIG1hdGNoIGFnYWluc3QgVUNoaWNhZ28sIElsbGlub2lzIHdhcyB1bmFibGUgdG8gZmluZCBhIGdyb292ZSBhbmQgbG9zdCA5LTExLiBXaXRoIFJlZ2lvbmFscyBpbiB0d28gd2Vla3MgYW5kIG9ubHkgb25lIGJpZCBmb3IgdGhlIHJlZ2lvbiwgSWxsaW5vaXMgaGFkIGEgbG90IG9mIHdvcmsgdG8gZG8uPC9wPlxuICAgICAgICAgICAgPHA+SW4gYSBjaGFuZ2Ugb2YgcGFjZSwgUmVnaW9uYWxzIHdhcyBub3QgaG9zdGVkIGluIFJvY2tmb3JkLCBidXQgaW4gRmFpciBPYWtzLCBJbmRpYW5hLiBUaGUgY29uZGl0aW9ucyB3ZXJlIHRlcnJpYmxlLCBsb3cgdGVtcGVyYXR1cmVzIGNvdXBsZWQgd2l0aCBoZWF2eSB3aW5kIGFuZCByYWluIG1lYW50IHRoYXQgaXQgd291bGQgYmUgZGlmZmljdWx0IGdldHRpbmcgYSBnb29kIGdyaXAuIEluIHRoZSBmaXJzdCBnYW1lIGFnYWluc3QgS2VudHVja3ksIGJvdGggTyBhbmQgRCBsaW5lIHdlcmUgYWJsZSB0byBwZXJmb3JtIHdlbGwsIGdpdmluZyB1cCBubyBicmVha3MgYW5kIGhhbmRpbmcgb3V0IGEgZmV3IG9mIHRoZWlyIG93biBhbmQgZmluaXNoaW5nIHdpdGggYSBzY29yZSBvZiAxMi02LiBUaGUgdHJlbmQgY29udGludWVkIGFnYWluc3QgSW5kaWFuYSwgd2l0aCBJbGxpbm9pcyB3aW5uaW5nIDEzLTYuIE5leHQgdXAgd2FzIE5vdHJlIERhbWUsIGEgcmVtYXRjaCBvZiBsYXN0IHllYXLigJlzIGZpbmFscywgd2lubmVyIHRha2VzIHRoZSBwb29sIGFuZCBxdWFydGVyZmluYWxzIGJlcnRoLiBBIGNvbXBsZXRlbHkgdXB3aW5kL2Rvd253aW5kIGdhbWUgZm91bmQgdGhlIGQgbGluZSB3aXRoIG9wcG9ydHVuaXRpZXMgdG8gYnJlYWssIGJ1dCBuZXZlciBhYmxlIHRvIGZpbmlzaCB0aGUgam9iLiBXaXRoIG5laXRoZXIgdGVhbSBiZWluZyBicm9rZW4sIE5vdHJlIERhbWUgd29uIHRoZSBmbGlwIGFuZCB0aGUgZ2FtZSwgOS0xMC4gSWxsaW5vaXMgZmluaXNoZWQgdXAgdGhlIGRheSB3aXRoIGEgMTMtNSB3aW4gb3ZlciBNaWNoaWdhbiBTdGF0ZSB0byBzZXQgdXAgYSBxdWFydGVyZmluYWxzIG1hdGNodXAgYWdhaW5zdCBOb3J0aHdlc3Rlcm4uPC9wPlxuICAgICAgICAgICAgPHA+Q29uZGl0aW9ucyBvbiBTdW5kYXkgd2VyZSBiZXR0ZXIgYW5kIHdpdGggYSBsaXR0bGUgc3VwcG9ydCBmcm9tIFdhbGRlbiBOZWxzb24sIHRoZSB0ZWFtIHdhcyByZWFkeSB0byBhdmVuZ2UgdGhlaXIgcmVjZW50IGxvc3Nlcy4gSWxsaW5vaXMgc3RhcnRlZCBvbiBEIGFuZCBOb3J0aHdlc3Rlcm4gY2FtZSBvdXQgd2l0aCBhbiBicmVhayBlYXJseSBpbiB0aGUgZ2FtZSwgYnV0IHRoZSB0ZWFtIGZvdWdodCBiYWNrIGFuZCBicmVha3Mgd2VyZSB0cmFkZWQgdG8gaGF2ZSBpdCBiZSBvbiBzZXJ2ZSBhdCBoYWxmLiBUaGUgc2Vjb25kIGhhbGYgY29tbWVuY2VkIHdpdGggbW9yZSBvZiBhIGNsZWFuZXIgZ2FtZSwgd2l0aCBib3RoIHRlYW1zIHRyYWRpbmcgb2ZmZW5zaXZlIGhvbGRzLiBBIGNoYW5jZSBhdCBhIGJyZWFrIGR1ZSB0byBhIE5pY2sgUHJvIHNreSB3YXMgY2FsbGVkIGJhY2sgb24gYSBjb250cm92ZXJzaWFsIG9ic2VydmVyIHJ1bGluZyBhbmQgdGhlIGdhbWUgcmVhY2hlZCBzb2Z0Y2FwIHdpdGggdGhlIHNjb3JlIDEwLTExLiBDaHJpcyBCdWNodGEgdGllZCB1cCB0aGUgc2NvcmUgd2l0aCBhIGh1Y2sgZnJvbSBLZXZpbiBMaW4gYW5kIHRoZSBkIGxpbmUgd2VudCBvdXQgdG8gdHJ5IGFuZCBicmVhayB3aXRoIHRoZSBzZWFzb24gb24gdGhlIGxpbmUuIEFmdGVyIGEgdHVybiBmcm9tIE5vcnRod2VzdGVybiwgSWxsaW5vaXMgd29ya2VkIHRoZSBkaXNjIGRvd24gdGhlIGZpZWxkIGFuZCByb29raWUgSmFjb2IgQ3V0aGJlcnQgdG9vayBhIHRpbWVvdXQgb3V0c2lkZSBvZiB0aGUgZW5kem9uZS4gT25lIGVuZHpvbmUgc2V0IGxhdGVyLCBQcmF5YWcgZm91bmQgQ3V0aGJlcnQgZm9yIHRoZSB3aW4sIHNlbmRpbmcgSWxsaW5vaXMgdG8gdGhlIHNlbWlmaW5hbHMuPC9wPlxuICAgICAgICAgICAgPHA+RHVlIHRvIHRoZSBsb3NzIGluIHBvb2wgcGxheSwgSWxsaW5vaXPigJlzIG1hdGNodXAgaW4gdGhlIHNlbWlmaW5hbHMgd2FzIE1pY2hpZ2FuLiBEZXNwaXRlIHRoZSB0b3VnaCBnYW1lIGJlZm9yZSwgSWxsaW5vaXMgaGFkIHRvIGNvbWUgb3V0IGhvdCBpZiB0aGV5IHdhbnRlZCB0byB3aW4gdGhlIGdhbWUuIE1pY2hpZ2FuIGNhbWUgb3V0IG9mIHRoZSBnYXRlIGZhc3QsIHNjb3Jpbmcgb24gYSBodWNrLiBJbGxpbm9pcyBmb2xsb3dlZCBzdWl0LCBhbmQgdGhlIHR3byB0ZWFtcyB0cmFkZWQgb2ZmZW5zaXZlIGhvbGRzIHVudGlsIE1pY2hpZ2FuIGJyb2tlIGZvciAzLTUuIEFzIHRoZSBnYW1lIHdlbnQgb24sIHRoZSBkZWZlbnNpdmUgcHJlc3N1cmUgZnJvbSBNaWNoaWdhbiBpbnRlbnNpZmllZCBhbmQgSWxsaW5vaXPigJkgbyBsaW5lIHdhcyBub3QgYWJsZSB0byBtYXRjaCB0aGUgZ29hbHMgdGhhdCBNaWNoaWdhbuKAmXMgbyBsaW5lIHdhcyBwdXR0aW5nIG91dC4gQ29taW5nIG91dCBvZiBoYWxmIGF0IDUtOCwgSWxsaW5vaXMgdHVybmVkIGFuZCB3YXMgYnJva2VuIGFnYWluLiBBIGxhdGUgaW5qdXJ5IHRvIFByYXlhZyBwdXNoZWQgdGhlIGhvcGUgb2YgYSBjb21lYmFjayBhIGxpdHRsZSBmdXJ0aGVyIG91dCBvZiByZWFjaCBhbmQgYSBzZW5pb3IgZCBsaW5lIHdhcyB1bmFibGUgdG8ga2VlcCBNaWNoaWdhbiBmcm9tIHNlaXppbmcgdGhlIHZpY3RvcnkgMTAtMTUuIE1pY2hpZ2FuIHdlbnQgb24gdG8gZGVmZWF0IE5vdHJlIERhbWUgMTUtOSB0byB0YWtlIHRoZSBiaWQgdG8gTmF0aW9uYWxzLiBJbGxpbm9pcyBmaW5pc2hlZCB0aGUgc2Vhc29uIHdpdGggYSAxMS0xMCB2aWN0b3J5IG92ZXIgUHVyZHVlIGZvciAzcmQgaW4gdGhlIHJlZ2lvbi48L3A+XG4gICAgICAgICAgICA8cD5DYXB0YWluIE5pY2sgUHJvem9yb3Zza3kgYW5kIEpvaG4gU2FuaWF0IHJlY2VpdmVkIDFzdCB0ZWFtIEFsbC1SZWdpb24gaG9ub3JzIGFuZCBDYXB0YWluIFByYXlhZyBQYXRlbCByZWNlaXZlZCAybmQgdGVhbSBBbGwtUmVnaW9uLiBCZW4gU2Fib3VyaW4gYW5kIEphY29iIEN1dGhiZXJ0IHdlcmUgdm90ZWQgQWxsLUZyZXNobWVuIGZvciB0aGUgcmVnaW9uLCB3aXRoIEJlbiB3aW5uaW5nIEZyZXNobWFuIG9mIHRoZSBZZWFyLjwvcD5cbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE1LFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTUuanBnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgSGVsbG9cbiAgICAgICAgYFxuICAgIH0sXG5dO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9oaXN0b3J5L3RlYW0taGlzdG9yeS9kYXRhL2hpc3RvcnkteWVhci5kYXRhLnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxoMSBjbGFzcz1cXFwidWkgaGVhZGVyXFxcIj5UZWFtIEhpc3Rvcnk8L2gxPlxcbjxkaXYgY2xhc3M9XFxcInVpIHNlY29uZGFyeSBwb2ludGluZyBtZW51XFxcIj5cXG4gICAgPGRpdiAjMTk5NGRyb3Bkb3duIGNsYXNzPVxcXCJ1aSBkcm9wZG93biBpdGVtXFxcIj5cXG4gICAgICAgIDE5OTQtMTk5OTxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OTRcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTQ8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OTVcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTU8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OTZcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTY8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OTdcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTc8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OThcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTg8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OTlcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTk8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiAjMjAwMGRyb3Bkb3duIGNsYXNzPVxcXCJ1aSBkcm9wZG93biBpdGVtXFxcIj5cXG4gICAgICAgIDIwMDAtMjAwOTxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDFcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDE8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDJcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDI8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDNcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDM8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDRcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDQ8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDVcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDU8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDZcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDY8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDdcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDc8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDhcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDg8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDlcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDk8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiAjMjAxMGRyb3Bkb3duIGNsYXNzPVxcXCJ1aSBkcm9wZG93biBpdGVtXFxcIj5cXG4gICAgICAgIDIwMTAtMjAxNzxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTBcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTFcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTE8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTJcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTI8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTNcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTM8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTRcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTQ8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTVcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTU8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTZcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTY8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTdcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTc8L2Rpdj5cXG5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG48aDIgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+e3t5ZWFyfX08L2gyPlxcbjxuZy1jb250YWluZXIgKm5nRm9yPVxcXCJsZXQgaGlzdG9yeVllYXIgb2YgaGlzdG9yeURhdGFcXFwiPlxcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVxcXCJoaXN0b3J5WWVhci55ZWFyID09PSB5ZWFyXFxcIj5cXG4gICAgICAgIDxpbWcgc3JjPVxcXCJ7e2hpc3RvcnlZZWFyLmltYWdlUGF0aH19XFxcIi8+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzdW1tYXJ5XFxcIiBbaW5uZXJIVE1MXT1cXFwiaGlzdG9yeVllYXIuc3VtbWFyeU1hcmt1cFxcXCI+PC9kaXY+XFxuICAgIDwvbmctY29udGFpbmVyPlxcbjwvbmctY29udGFpbmVyPlxcbjwhLS1Pbmx5IHNob3cgdGhlIHByZXZpb3VzIGFuZCBuZXh0IGJ1dHRvbiBpZiB0aGV5IGFyZSB3aXRoaW4gdGhlIGJvdW5kcyBvZiBvdXIgaGlzdG9yeSBzdW1tYXJpZXMtLT5cXG48YSAqbmdJZj1cXFwieWVhciA+IDE5OTRcXFwiIHJvdXRlckxpbms9XFxcIi9oaXN0b3J5L3t7eWVhciAtIDF9fVxcXCI+PGkgY2xhc3M9XFxcImFuZ2xlIGRvdWJsZSBsZWZ0IGljb25cXFwiPjwvaT48L2E+XFxuPGEgKm5nSWY9XFxcInllYXIgPCAyMDE3XFxcIiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS97e3llYXIgKyAxfX1cXFwiPjxpIGNsYXNzPVxcXCJhbmdsZSBkb3VibGUgcmlnaHQgaWNvblxcXCI+PC9pPjwvYT5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi90ZWFtLWhpc3RvcnkuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hpc3RvcnkvdGVhbS1oaXN0b3J5L3RlYW0taGlzdG9yeS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImltZyB7XFxuICB3aWR0aDogNzUlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzAwMDA0RDtcXG4gIG1hcmdpbi1ib3R0b206IDE1cHg7XFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5ZW07XFxufVxcbmkge1xcbiAgZm9udC1zaXplOiAyZW07XFxufVxcbmkucmlnaHQge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG5pLmxlZnQge1xcbiAgZmxvYXQ6IGxlZnQ7XFxufVxcbi5zdW1tYXJ5IHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcbn1cXG4uaXRlbS5hY3RpdmUge1xcbiAgYm9yZGVyOiAwICFpbXBvcnRhbnQ7XFxufVxcbi51aS5kcm9wZG93bi5pdGVtIHtcXG4gIGhlaWdodDogNDBweDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9oaXN0b3J5L3RlYW0taGlzdG9yeS90ZWFtLWhpc3RvcnkuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQVdBUkRTX0RBVEEgfSBmcm9tIFwiLi9kYXRhL2F3YXJkcy5kYXRhXCI7XG5pbXBvcnQgeyBBd2FyZCB9IGZyb20gXCIuL21vZGVsL2F3YXJkLm1vZGVsXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXdhcmRzJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9hd2FyZHMuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2F3YXJkcy5jb21wb25lbnQubGVzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIEF3YXJkc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvLyBBd2FyZHMgZGF0YSB0byBpbmplY3QgaW50byBvdXIgdGVtcGxhdGVcbiAgICBwcml2YXRlIGF3YXJkRGF0YTogQXdhcmRbXSA9IEFXQVJEU19EQVRBO1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBBd2FyZCB9IGZyb20gXCIuLi9tb2RlbC9hd2FyZC5tb2RlbFwiO1xuXG5leHBvcnQgY29uc3QgQVdBUkRTX0RBVEE6IEF3YXJkIFtdID0gW1xuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNixcbiAgICAgICAgbmFtZTogJ05pY2sgUHJvem9yb3Zza3knLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE2LFxuICAgICAgICBuYW1lOiAnSm9obm55IFNhbmlhdCcsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIG5hbWU6ICdQcmF5YWcgUGF0ZWwnLFxuICAgICAgICBhd2FyZDogJzJuZCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE2LFxuICAgICAgICBuYW1lOiAnQmVuIFNhYm91cmluJyxcbiAgICAgICAgYXdhcmQ6ICdBbGwtRnJlc2htYW4vRk9UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNixcbiAgICAgICAgbmFtZTogJ0phY29iIEN1dGhiZXJ0JyxcbiAgICAgICAgYXdhcmQ6ICdBbGwtRnJlc2htYW4nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTUsXG4gICAgICAgIG5hbWU6ICdNYXR0IFN0dXBjYScsXG4gICAgICAgIGF3YXJkOiAnQ09UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNSxcbiAgICAgICAgbmFtZTogJ05pY2sgUHJvem9yb3Zza3knLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE1LFxuICAgICAgICBuYW1lOiAnTWF0dCBXZXN0JyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNSxcbiAgICAgICAgbmFtZTogJ0tldmluIExpbicsXG4gICAgICAgIGF3YXJkOiAnQWxsLUZyZXNobWFuL0ZPVFknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTQsXG4gICAgICAgIG5hbWU6ICdOZWFsIFBoZWxwcycsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTQsXG4gICAgICAgIG5hbWU6ICdOaWNrIFByb3pvcm92c2t5JyxcbiAgICAgICAgYXdhcmQ6ICcybmQgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgbmFtZTogJ05hdGhhbiBHaWJib25zJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgbmFtZTogJ05lYWwgUGhlbHBzJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgbmFtZTogJ1J5YW4gU21pdGgnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtL1BPVFknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTMsXG4gICAgICAgIG5hbWU6ICdCcmFkIEJvbGxpbmdlcicsXG4gICAgICAgIGF3YXJkOiAnMm5kIFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTMsXG4gICAgICAgIG5hbWU6ICdOaWNrIFByb3pvcm92c2t5JyxcbiAgICAgICAgYXdhcmQ6ICdBbGwgRnJlc2htYW4nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTMsXG4gICAgICAgIG5hbWU6ICdKb2hubnkgU2FuaWF0JyxcbiAgICAgICAgYXdhcmQ6ICdBbGwgRnJlc2htYW4nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTMsXG4gICAgICAgIG5hbWU6ICdEZXJlayBZYW4nLFxuICAgICAgICBhd2FyZDogJ0FsbCBGcmVzaG1hbidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMixcbiAgICAgICAgbmFtZTogJ1J5YW4gU21pdGgnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEyLFxuICAgICAgICBuYW1lOiAnRGFuZSBKb3JnZW5zZW4nLFxuICAgICAgICBhd2FyZDogJzJuZCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDExLFxuICAgICAgICBuYW1lOiAnUnlhbiBTbWl0aCcsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTAsXG4gICAgICAgIG5hbWU6ICdXYWxkZW4gTmVsc29uJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMCxcbiAgICAgICAgbmFtZTogJ0JyaWFuIFBoZWxhbicsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTAsXG4gICAgICAgIG5hbWU6ICdSeWFuIFNtaXRoJyxcbiAgICAgICAgYXdhcmQ6ICcybmQgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwOSxcbiAgICAgICAgbmFtZTogJ01hdHQgU3R1cGNhJyxcbiAgICAgICAgYXdhcmQ6ICdDT1RZJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA5LFxuICAgICAgICBuYW1lOiAnRGVuaXMgQWduaWVsJyxcbiAgICAgICAgYXdhcmQ6ICcybmQgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwOSxcbiAgICAgICAgbmFtZTogJ1dhbGRlbiBOZWxzb24nLFxuICAgICAgICBhd2FyZDogJzJuZCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA5LFxuICAgICAgICBuYW1lOiAnUGF2YW4gU2FyZ3VydScsXG4gICAgICAgIGF3YXJkOiAnMm5kIFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDksXG4gICAgICAgIG5hbWU6ICdSeWFuIFNtaXRoJyxcbiAgICAgICAgYXdhcmQ6ICdGT1RZJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA4LFxuICAgICAgICBuYW1lOiAnSm9lbCBLb2VobmVtYW4nLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA4LFxuICAgICAgICBuYW1lOiAnUGF0IFN0ZXBoZW5zJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNyxcbiAgICAgICAgbmFtZTogJ0pvZWwgS29laG5lbWFuJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNyxcbiAgICAgICAgbmFtZTogJ0JyaWFuIEtvcmJlc21leWVyJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNixcbiAgICAgICAgbmFtZTogJ0JyaWFuIFBoZWxhbicsXG4gICAgICAgIGF3YXJkOiAnRk9UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNSxcbiAgICAgICAgbmFtZTogJ05pY2sgTWNEdWZmZWUnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA1LFxuICAgICAgICBuYW1lOiAnTWlrZSBDbGFyaycsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDUsXG4gICAgICAgIG5hbWU6ICdEYXZpZCBBYnJhbScsXG4gICAgICAgIGF3YXJkOiAnRk9UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNCxcbiAgICAgICAgbmFtZTogJ01hdHQgV2Vsc2gnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA0LFxuICAgICAgICBuYW1lOiAnTmljayBNY0R1ZmZlZScsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDQsXG4gICAgICAgIG5hbWU6ICdQYXQgU3RlcGhlbnMnLFxuICAgICAgICBhd2FyZDogJ0ZPVFknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDMsXG4gICAgICAgIG5hbWU6ICdOYXRlIEJvc3NjaGVyJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwMixcbiAgICAgICAgbmFtZTogJ1hpIFhpYScsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDIsXG4gICAgICAgIG5hbWU6ICdEYW5lIE9sc2VuJyxcbiAgICAgICAgYXdhcmQ6ICdGT1RZJ1xuICAgIH1cbl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2RhdGEvYXdhcmRzLmRhdGEudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGgxIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPkF3YXJkczwvaDE+XFxuPHRhYmxlIGNsYXNzPVxcXCJ1aSBjZWxsZWQgdGFibGVcXFwiPlxcbiAgICA8dGhlYWQ+XFxuICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRoPlllYXI8L3RoPlxcbiAgICAgICAgICAgIDx0aD5OYW1lPC90aD5cXG4gICAgICAgICAgICA8dGg+QXdhcmQ8L3RoPlxcbiAgICAgICAgPC90cj5cXG4gICAgPC90aGVhZD5cXG4gICAgPHRib2R5PlxcbiAgICAgICAgPHRyICpuZ0Zvcj1cXFwibGV0IGF3YXJkIG9mIGF3YXJkRGF0YVxcXCI+XFxuICAgICAgICAgICAgPHRkPnt7YXdhcmQueWVhcn19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+e3thd2FyZC5uYW1lfX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e2F3YXJkLmF3YXJkfX08L3RkPlxcbiAgICAgICAgPC90cj5cXG4gICAgPC90Ym9keT5cXG48L3RhYmxlPlxcbjxwPipBbGwtRnJlc2htYW4gdGVhbSBhZGRlZCBpbiAyMDEzLCBGT1RZIChGcmVzaG1hbiBvZiB0aGUgWWVhcikgZ2l2ZW4gdG8gdGhlIEFsbC1GcmVzaG1hbiBtZW1iZXIgd2l0aCB0aGUgbW9zdCAxc3QgcGxhY2Ugdm90ZXM8L3A+XFxuPHA+KlBsYXllciBvZiB0aGUgeWVhciBhd2FyZCBhZGRlZCBpbiAyMDEzLCBQT1RZIChQbGF5ZXIgb2YgdGhlIFllYXIpIGdpdmVuIHRvIHRoZSBBbGwtUmVnaW9uIG1lbWJlciB3aXRoIHRoZSBtb3N0IDFzdCBwbGFjZSB2b3RlczwvcD5cXG48cD4qQ09UWSAoQ29hY2ggb2YgdGhlIFllYXIpIGFkZGVkIGluIDIwMDk8L3A+XFxuPHA+KjJuZC1UZWFtIEFsbCBSZWdpb24gYWRkZWQgaW4gMjAwOTwvcD5cXG48cD4qQXdhcmRzIGZpcnN0IGdpdmVuIG91dCBpbiAyMDAyPC9wPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9oaXN0b3J5L2F3YXJkcy9hd2FyZHMuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL2F3YXJkcy5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvYXdhcmRzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwicCB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgdGV4dC1pbmRlbnQ6IDA7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvYXdhcmRzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJFU1VMVFNfREFUQSB9IGZyb20gXCIuL2RhdGEvcmVzdWx0cy5kYXRhXCI7XG5pbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiLi9tb2RlbC9yZXN1bHQubW9kZWxcIjtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdyZXN1bHRzJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9yZXN1bHRzLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9yZXN1bHRzLmNvbXBvbmVudC5sZXNzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgUmVzdWx0c0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvLyBSZXN1bHRzIGRhdGEgdG8gaW5qZWN0IGludG8gb3VyIHRlbXBsYXRlXG4gICAgcHJpdmF0ZSByZXN1bHREYXRhOiBSZXN1bHRbXSA9IFJFU1VMVFNfREFUQTtcblxuICAgIG5nT25Jbml0KCk6IHZvaWQge31cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9oaXN0b3J5L3Jlc3VsdHMvcmVzdWx0cy5jb21wb25lbnQudHMiLCJpbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiLi4vbW9kZWwvcmVzdWx0Lm1vZGVsXCI7XG5cbmV4cG9ydCBjb25zdCBSRVNVTFRTX0RBVEE6IFJlc3VsdFtdID0gW1xuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNixcbiAgICAgICAgc2VjdGlvbmFsczogJzNyZCcsXG4gICAgICAgIHJlZ2lvbmFsczogJzNyZCcsXG4gICAgICAgIG5hdGlvbmFsczogJy0nLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy90ZWFtcy9ldmVudHMvRXZlbnR0ZWFtLz9UZWFtSWQ9blF6c0NPMGZLYlVVRUZaZktKJTJmT1VvdGQlMmYxUE02d28zNUhQYVhKRU1VQzglM2QnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTUsXG4gICAgICAgIHNlY3Rpb25hbHM6ICcybmQnLFxuICAgICAgICByZWdpb25hbHM6ICcxc3QnLFxuICAgICAgICBuYXRpb25hbHM6ICcxM3RoJyxcbiAgICAgICAgdGVhbVBhZ2VMYWJlbDogJ1VTQVUnLFxuICAgICAgICB0ZWFtUGFnZUxpbms6ICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvdGVhbXMvZXZlbnRzL0V2ZW50dGVhbS8/VGVhbUlkPVQlMmJWNkQyWHlMVGxrTEElMmZYMldwYWlQR25ZeTZTM0RuJTJmbWNibGZvMDhETm8lM2QnXG4gICAgfVxuXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL2RhdGEvcmVzdWx0cy5kYXRhLnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxoMSBjbGFzcz1cXFwidWkgaGVhZGVyXFxcIj5SZXN1bHRzPC9oMT5cXG48dGFibGUgY2xhc3M9XFxcInVpIGNlbGxlZCB0YWJsZVxcXCI+XFxuICAgIDx0aGVhZD5cXG4gICAgPHRyPlxcbiAgICAgICAgPHRoPlllYXI8L3RoPlxcbiAgICAgICAgPHRoPlNlY3Rpb25hbHM8L3RoPlxcbiAgICAgICAgPHRoPlJlZ2lvbmFsczwvdGg+XFxuICAgICAgICA8dGg+TmF0aW9uYWxzPC90aD5cXG4gICAgICAgIDx0aD5UZWFtIFBhZ2U8L3RoPlxcbiAgICA8L3RyPlxcbiAgICA8L3RoZWFkPlxcbiAgICA8dGJvZHk+XFxuICAgIDx0ciAqbmdGb3I9XFxcImxldCByZXN1bHQgb2YgcmVzdWx0RGF0YVxcXCI+XFxuICAgICAgICA8dGQ+e3tyZXN1bHQueWVhcn19PC90ZD5cXG4gICAgICAgIDx0ZD57e3Jlc3VsdC5zZWN0aW9uYWxzfX08L3RkPlxcbiAgICAgICAgPHRkPnt7cmVzdWx0LnJlZ2lvbmFsc319PC90ZD5cXG4gICAgICAgIDx0ZD57e3Jlc3VsdC5uYXRpb25hbHN9fTwvdGQ+XFxuICAgICAgICA8dGQ+PGEgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGhyZWY9XFxcInt7cmVzdWx0LnRlYW1QYWdlTGlua319XFxcIj57e3Jlc3VsdC50ZWFtUGFnZUxhYmVsfX08L2E+PC90ZD5cXG4gICAgPC90cj5cXG4gICAgPC90Ym9keT5cXG48L3RhYmxlPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9oaXN0b3J5L3Jlc3VsdHMvcmVzdWx0cy5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vcmVzdWx0cy5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvcmVzdWx0cy9yZXN1bHRzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tIFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiO1xuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL3JvdXRlclwiO1xuXG5pbXBvcnQgeyBUZWFtSGlzdG9yeUNvbXBvbmVudCB9IGZyb20gXCIuL3RlYW0taGlzdG9yeS90ZWFtLWhpc3RvcnkuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBBd2FyZHNDb21wb25lbnQgfSBmcm9tIFwiLi9hd2FyZHMvYXdhcmRzLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUmVzdWx0c0NvbXBvbmVudCB9IGZyb20gXCIuL3Jlc3VsdHMvcmVzdWx0cy5jb21wb25lbnRcIjtcbmltcG9ydCB7IFJPVVRFUyB9IGZyb20gXCIuLi9hcHAucm91dGVzXCI7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBCcm93c2VyTW9kdWxlLFxuICAgICAgICBSb3V0ZXJNb2R1bGUuZm9yUm9vdChST1VURVMpXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgVGVhbUhpc3RvcnlDb21wb25lbnQsXG4gICAgICAgIEF3YXJkc0NvbXBvbmVudCxcbiAgICAgICAgUmVzdWx0c0NvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgSGlzdG9yeU1vZHVsZSB7fVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvaGlzdG9yeS5tb2R1bGUudHMiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL3JvdXRlclwiO1xuXG5pbXBvcnQgeyBNZW51RGVza3RvcENvbXBvbmVudCB9IGZyb20gXCIuL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBNZW51TW9iaWxlQ29tcG9uZW50IH0gZnJvbSBcIi4vbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBMZWZ0U2lkZWJhckNvbXBvbmVudCB9IGZyb20gXCIuL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBSaWdodFNpZGViYXJDb21wb25lbnQgfSBmcm9tIFwiLi9yaWdodC1zaWRlYmFyL3JpZ2h0LXNpZGViYXIuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBQYWdlRnJhbWVDb21wb25lbnQgfSBmcm9tIFwiLi9wYWdlLWZyYW1lLmNvbXBvbmVudFwiO1xuXG5pbXBvcnQgeyBST1VURVMgfSBmcm9tIFwiLi4vYXBwLnJvdXRlc1wiO1xuaW1wb3J0IHsgRm9vdGVyQ29tcG9uZW50IH0gZnJvbSBcIi4vZm9vdGVyL2Zvb3Rlci5jb21wb25lbnRcIjtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIFJvdXRlck1vZHVsZS5mb3JSb290KFJPVVRFUylcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBQYWdlRnJhbWVDb21wb25lbnQsXG4gICAgICAgIE1lbnVEZXNrdG9wQ29tcG9uZW50LFxuICAgICAgICBNZW51TW9iaWxlQ29tcG9uZW50LFxuICAgICAgICBMZWZ0U2lkZWJhckNvbXBvbmVudCxcbiAgICAgICAgUmlnaHRTaWRlYmFyQ29tcG9uZW50LFxuICAgICAgICBGb290ZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUGFnZUZyYW1lQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlRnJhbWVNb2R1bGUge31cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUubW9kdWxlLnRzIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdtZW51LWRlc2t0b3AnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL21lbnUtZGVza3RvcC5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vbWVudS1kZXNrdG9wLmNvbXBvbmVudC5sZXNzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgTWVudURlc2t0b3BDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIC8vIE1lbnUgZHJvcGRvd25zXG4gICAgQFZpZXdDaGlsZCgndGVhbURyb3Bkb3duJylcbiAgICBwcml2YXRlIHRlYW1Ecm9wZG93bjogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCdoaXN0b3J5RHJvcGRvd24nKVxuICAgIHByaXZhdGUgaGlzdG9yeURyb3Bkb3duOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBvdXIgbW9iaWxlIG1lbnUgZHJvcGRvd24uXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICAkKHRoaXMudGVhbURyb3Bkb3duLm5hdGl2ZUVsZW1lbnQpLmRyb3Bkb3duKHt9KTtcbiAgICAgICAgJCh0aGlzLmhpc3RvcnlEcm9wZG93bi5uYXRpdmVFbGVtZW50KS5kcm9wZG93bih7fSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1kZXNrdG9wL21lbnUtZGVza3RvcC5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL2hvbWVcXFwiPjxpbWcgY2xhc3M9XFxcImNyZXN0XFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbWVudS9jcmVzdC5wbmdcIikgKyBcIlxcXCIvPjwvYT5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL2hvbWVcXFwiPjxoMSBjbGFzcz1cXFwiaGVhZGVyLXRleHRcXFwiPklsbGlub2lzIFVsdGltYXRlPC9oMT48L2E+XFxuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwidWkgcG9pbnRpbmcgc3RhY2thYmxlIG1lbnVcXFwiPlxcbiAgICA8YSByb3V0ZXJMaW5rPVxcXCIvaG9tZVxcXCIgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbSBhY3RpdmVcXFwiPjxpIGNsYXNzPVxcXCJob21lIGljb25cXFwiPjwvaT5Ib21lPC9hPlxcbiAgICA8YSByb3V0ZXJMaW5rPVxcXCIvYWJvdXRcXFwiICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImluZm8gaWNvblxcXCI+PC9pPkFib3V0IFVzPC9hPlxcbiAgICA8YSByb3V0ZXJMaW5rPVxcXCIvcHJvc3BlY3RzXFxcIiAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImNoaWxkIGljb25cXFwiPjwvaT5Qcm9zcGVjdGl2ZSBQbGF5ZXJzPC9hPlxcbiAgICA8ZGl2ICN0ZWFtRHJvcGRvd24gY2xhc3M9XFxcInVpIGRyb3Bkb3duIGl0ZW1cXFwiPlxcbiAgICAgICAgPGkgY2xhc3M9XFxcInVzZXIgaWNvblxcXCI+PC9pPlRlYW08aSBjbGFzcz1cXFwiZHJvcGRvd24gaWNvblxcXCI+PC9pPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVudVxcXCI+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvcHJhY3RpY2VcXFwiICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJzb2NjZXIgaWNvblxcXCI+PC9pPlByYWN0aWNlPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvdG91cm5hbWVudHMvMjAxN1xcXCIgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJjYWxlbmRhciBpY29uXFxcIj48L2k+VG91cm5hbWVudHM8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9yb3N0ZXIvMjAxN1xcXCIgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcIm9yZGVyZWQgbGlzdCBpY29uXFxcIj48L2k+Um9zdGVyPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvYWJzZW50XFxcIiAgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJyZW1vdmUgaWNvblxcXCI+PC9pPkFic2VudCBGb3JtPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgI2hpc3RvcnlEcm9wZG93biBjbGFzcz1cXFwidWkgZHJvcGRvd24gaXRlbVxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiZmFzdCBiYWNrd2FyZCBpY29uXFxcIj48L2k+SGlzdG9yeTxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTZcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJ1bmRvIGljb25cXFwiPjwvaT5UZWFtIEhpc3Rvcnk8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9hd2FyZHNcXFwiICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJ0cm9waHkgaWNvblxcXCI+PC9pPkF3YXJkczwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgcm91dGVyTGluaz1cXFwiL3Jlc3VsdHNcXFwiICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImFyY2hpdmUgaWNvblxcXCI+PC9pPlBhc3QgUmVzdWx0czwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8YSBocmVmPVxcXCJodHRwOi8vd3d3LmlsbGluaXVsdGkuYmxvZ3Nwb3QuY29tL1xcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiY29tbWVudCBpY29uXFxcIj48L2k+QmxvZzwvYT5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL2NvbnRhY3RcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJtYWlsIGljb25cXFwiPjwvaT5Db250YWN0IFVzPC9hPlxcbjwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvY3Jlc3QucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9tZW51L2NyZXN0LnBuZ1xuLy8gbW9kdWxlIGlkID0gMTU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vbWVudS1kZXNrdG9wLmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuaGVhZGVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgcmVxdWlyZShcIi4uLy4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbWVudS9oZWFkZXItYmFja2dyb3VuZC5qcGdcIikgKyBcIik7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG4uaGVhZGVyIC5oZWFkZXItdGV4dCB7XFxuICBmb250LXNpemU6IDcycHg7XFxuICBmb250LWZhbWlseTogJ09zd2FsZCcsIHNhbnMtc2VyaWY7XFxuICBjb2xvcjogI2ZmNjIyNjtcXG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICBwYWRkaW5nOiAyNXB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgbGV0dGVyLXNwYWNpbmc6IDJweDtcXG4gIHRleHQtc2hhZG93OiAtMXB4IC0xcHggMCB3aGl0ZSwgMXB4IC0xcHggMCB3aGl0ZSwgLTFweCAxcHggMCB3aGl0ZSwgMXB4IDFweCAwIHdoaXRlO1xcbn1cXG4uaGVhZGVyIC5jcmVzdCB7XFxuICBtYXgtaGVpZ2h0OiA4MHB4O1xcbiAgbWF4LXdpZHRoOiA1MHB4O1xcbn1cXG4udWkubWVudSB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1kZXNrdG9wL21lbnUtZGVza3RvcC5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9oZWFkZXItYmFja2dyb3VuZC5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL21lbnUvaGVhZGVyLWJhY2tncm91bmQuanBnXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3Q2hpbGQsIEVsZW1lbnRSZWYsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdtZW51LW1vYmlsZScsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vbWVudS1tb2JpbGUuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL21lbnUtbW9iaWxlLmNvbXBvbmVudC5sZXNzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgTWVudU1vYmlsZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gICAgLy8gTWVudSBkcm9wZG93bnNcbiAgICBAVmlld0NoaWxkKCd0ZWFtRHJvcGRvd24nKVxuICAgIHByaXZhdGUgdGVhbURyb3Bkb3duOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ2hpc3RvcnlEcm9wZG93bicpXG4gICAgcHJpdmF0ZSBoaXN0b3J5RHJvcGRvd246IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgnbW9iaWxlRHJvcGRvd24nKVxuICAgIHByaXZhdGUgbW9iaWxlRHJvcGRvd246IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIG91ciBtb2JpbGUgbWVudSBkcm9wZG93bi5cbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vICQodGhpcy50ZWFtRHJvcGRvd24ubmF0aXZlRWxlbWVudCkuZHJvcGRvd24oe30pO1xuICAgICAgICAvLyAkKHRoaXMuaGlzdG9yeURyb3Bkb3duLm5hdGl2ZUVsZW1lbnQpLmRyb3Bkb3duKHt9KTtcbiAgICAgICAgJCh0aGlzLm1vYmlsZURyb3Bkb3duLm5hdGl2ZUVsZW1lbnQpLmRyb3Bkb3duKHt9KTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9tZW51LW1vYmlsZS9tZW51LW1vYmlsZS5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5cXG4gICAgPGRpdiAjbW9iaWxlRHJvcGRvd24gY2xhc3M9XFxcInVpIGlubGluZSBkcm9wZG93blxcXCI+XFxuICAgICAgICA8aDEgY2xhc3M9XFxcImhlYWRlci10ZXh0XFxcIj5JbGxpbm9pcyBVbHRpbWF0ZTwvaDE+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiZHJvcGRvd24gaWNvblxcXCI+PC9pPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVudVxcXCI+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL2hvbWVcXFwiICAgICAgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImhvbWUgaWNvblxcXCI+PC9pPkhvbWU8L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL2Fib3V0XFxcIiAgICAgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImluZm8gaWNvblxcXCI+PC9pPkFib3V0IFVzPC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9wcm9zcGVjdHNcXFwiICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJjaGlsZCBpY29uXFxcIj48L2k+UHJvc3BlY3RpdmUgUGxheWVyczwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvcHJhY3RpY2VcXFwiICAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwic29jY2VyIGljb25cXFwiPjwvaT5QcmFjdGljZTwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvdG91cm5hbWVudHMvMjAxN1xcXCIgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiY2FsZW5kYXIgaWNvblxcXCI+PC9pPlRvdXJuYW1lbnRzPC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9yb3N0ZXIvMjAxN1xcXCIgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJvcmRlcmVkIGxpc3QgaWNvblxcXCI+PC9pPlJvc3RlcjwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvYWJzZW50XFxcIiAgICAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwicmVtb3ZlIGljb25cXFwiPjwvaT5BYnNlbnQgRm9ybTwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDE2XFxcIiAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwidW5kbyBpY29uXFxcIj48L2k+VGVhbSBIaXN0b3J5PC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9hd2FyZHNcXFwiICAgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJ0cm9waHkgaWNvblxcXCI+PC9pPkF3YXJkczwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvcmVzdWx0c1xcXCIgICAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiYXJjaGl2ZSBpY29uXFxcIj48L2k+UGFzdCBSZXN1bHRzPC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9ibG9nXFxcIiAgICAgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJjb21tZW50IGljb25cXFwiPjwvaT5CbG9nPC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9jb250YWN0XFxcIiAgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJtYWlsIGljb25cXFwiPjwvaT5Db250YWN0IFVzPC9hPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtbW9iaWxlL21lbnUtbW9iaWxlLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9tZW51LW1vYmlsZS5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9tZW51LW1vYmlsZS9tZW51LW1vYmlsZS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5oZWFkZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9tZW51L2hlYWRlci1iYWNrZ3JvdW5kLmpwZ1wiKSArIFwiKTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcbn1cXG4uaGVhZGVyIC51aS5kcm9wZG93biB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi5oZWFkZXIgLmhlYWRlci10ZXh0IHtcXG4gIGZvbnQtc2l6ZTogNzJweDtcXG4gIGZvbnQtZmFtaWx5OiAnT3N3YWxkJywgc2Fucy1zZXJpZjtcXG4gIGNvbG9yOiAjZmY2MjI2O1xcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBtYXJnaW46IDA7XFxuICBsZXR0ZXItc3BhY2luZzogMnB4O1xcbiAgdGV4dC1zaGFkb3c6IC0xcHggLTFweCAwIHdoaXRlLCAxcHggLTFweCAwIHdoaXRlLCAtMXB4IDFweCAwIHdoaXRlLCAxcHggMXB4IDAgd2hpdGU7XFxufVxcbi5oZWFkZXIgLmRyb3Bkb3duLmljb24ge1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgY29sb3I6IHdoaXRlO1xcbn1cXG4uaGVhZGVyIC5tZW51IHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdsZWZ0LXNpZGViYXInLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2xlZnQtc2lkZWJhci5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgTGVmdFNpZGViYXJDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplVHdpdHRlcldpZGdldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFR3aXR0ZXIgc2NyaXB0IGZvciBpbml0aWFsaXppbmcgb3VyIFR3aXR0ZXIgVGltZWxpbmUgd2lkZ2V0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZVR3aXR0ZXJXaWRnZXQoKTogdm9pZCB7XG4gICAgICAgICFmdW5jdGlvbihkLHMsaWQpe1xuICAgICAgICAgICAgbGV0IGpzOiBhbnksXG4gICAgICAgICAgICAgICAgZmpzPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUocylbMF0sXG4gICAgICAgICAgICAgICAgcD0naHR0cHMnO1xuICAgICAgICAgICAgaWYoIWQuZ2V0RWxlbWVudEJ5SWQoaWQpKXtcbiAgICAgICAgICAgICAgICBqcz1kLmNyZWF0ZUVsZW1lbnQocyk7XG4gICAgICAgICAgICAgICAganMuaWQ9aWQ7XG4gICAgICAgICAgICAgICAganMuc3JjPXArXCI6Ly9wbGF0Zm9ybS50d2l0dGVyLmNvbS93aWRnZXRzLmpzXCI7XG4gICAgICAgICAgICAgICAgZmpzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGpzLGZqcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0oZG9jdW1lbnQsXCJzY3JpcHRcIixcInR3aXR0ZXItd2pzXCIpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInVpIHNlZ21lbnQgdHdpdHRlci1zaWRlYmFyXFxcIj5cXG4gICAgPGEgY2xhc3M9XFxcInR3aXR0ZXItdGltZWxpbmVcXFwiIGhlaWdodD1cXFwiNTAwcHhcXFwiIGhyZWY9XFxcImh0dHBzOi8vdHdpdHRlci5jb20vSWxsaW5pVWx0aVxcXCIgZGF0YS13aWRnZXQtaWQ9XFxcIjYwNTQxNDgzNjM2OTg4MzEzNlxcXCI+VHdlZXRzIGJ5IEBJbGxpbmlVbHRpPC9hPlxcbjwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL2xlZnQtc2lkZWJhci5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnR3aXR0ZXItc2lkZWJhciB7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWF4LXdpZHRoOiAyMDBweDtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL2xlZnQtc2lkZWJhci5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncmlnaHQtc2lkZWJhcicsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vcmlnaHQtc2lkZWJhci5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vcmlnaHQtc2lkZWJhci5jb21wb25lbnQubGVzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIFJpZ2h0U2lkZWJhckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9yaWdodC1zaWRlYmFyL3JpZ2h0LXNpZGViYXIuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInVpIHNlZ21lbnQgcGF5cGFsLXNpZGViYXJcXFwiPlxcbiAgICA8aDIgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+SGVscCBPdXQgSWxsaW5vaXMgVWx0aW1hdGUhPC9oMj5cXG5cXG4gICAgPHA+SWxsaW5vaXMgVWx0aW1hdGUgaXMgbW9zdGx5IHN0dWRlbnQtZnVuZGVkLCBoZWxwIHVzIG91dCBieSBkb25hdGluZyE8L3A+XFxuICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LnBheXBhbC5tZS9pbGxpbm9pc1VsdGltYXRlXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+XFxuICAgICAgICA8aW1nIGNsYXNzPVxcXCJwYXlwYWwtZG9uYXRlXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL3BheXBhbC1kb25hdGUucG5nXCIpICsgXCJcXFwiLz5cXG4gICAgPC9hPlxcbjwvZGl2PlxcbjxhIGhyZWY9XFxcImh0dHBzOi8vd3d3LmZhY2Vib29rLmNvbS9JbGxpbm9pc1VsdGltYXRlXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+XFxuICAgIDxpbWcgY2xhc3M9XFxcInNvY2lhbC1tZWRpYS1idXR0b24gaHZyLXNpbmtcXFwiIHNyYz1cXFwiXCIgKyByZXF1aXJlKFwiLi4vLi4vLi4vcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvZmFjZWJvb2stYnV0dG9uLnBuZ1wiKSArIFwiXFxcIi8+XFxuPC9hPlxcbjxhIGhyZWY9XFxcImh0dHBzOi8vdHdpdHRlci5jb20vaWxsaW5pdWx0aVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICA8aW1nIGNsYXNzPVxcXCJzb2NpYWwtbWVkaWEtYnV0dG9uIGh2ci1zaW5rXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL3R3aXR0ZXItYnV0dG9uLnBuZ1wiKSArIFwiXFxcIi8+XFxuPC9hPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9wYXlwYWwtZG9uYXRlLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL3BheXBhbC1kb25hdGUucG5nXG4vLyBtb2R1bGUgaWQgPSAxNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXNzZXRzL2ZhY2Vib29rLWJ1dHRvbi5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9mYWNlYm9vay1idXR0b24ucG5nXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXNzZXRzL3R3aXR0ZXItYnV0dG9uLnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL3R3aXR0ZXItYnV0dG9uLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vcmlnaHQtc2lkZWJhci5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9yaWdodC1zaWRlYmFyL3JpZ2h0LXNpZGViYXIuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIucGF5cGFsLXNpZGViYXIge1xcbiAgbWF4LXdpZHRoOiAyMDBweDtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbn1cXG4ucGF5cGFsLXNpZGViYXIgcCB7XFxuICB0ZXh0LWluZGVudDogMDtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxuICBwYWRkaW5nLXRvcDogMTVweDtcXG4gIHBhZGRpbmctYm90dG9tOiAxNXB4O1xcbn1cXG4ucGF5cGFsLWRvbmF0ZSB7XFxuICB3aWR0aDogMTAwcHg7XFxufVxcbi51aS5oZWFkZXIge1xcbiAgbWFyZ2luLWJvdHRvbTogMDtcXG59XFxuLnNvY2lhbC1tZWRpYS1idXR0b24ge1xcbiAgd2lkdGg6IDQwJTtcXG4gIG1heC13aWR0aDogNzBweDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbjogM3B4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzAwMDA0RDtcXG4gIGJveC1zaGFkb3c6IDBweCAxcHggMnB4IDAgcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjllbTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncGFnZS1mcmFtZScsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vcGFnZS1mcmFtZS5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vcGFnZS1mcmFtZS5jb21wb25lbnQubGVzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIFBhZ2VGcmFtZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9wYWdlLWZyYW1lLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8IS0tSGVhZGVyLS0+XFxuPG1lbnUtZGVza3RvcCBjbGFzcz1cXFwibWVudS1kZXNrdG9wXFxcIj48L21lbnUtZGVza3RvcD5cXG48bWVudS1tb2JpbGUgY2xhc3M9XFxcIm1lbnUtbW9iaWxlXFxcIj48L21lbnUtbW9iaWxlPlxcblxcbjwhLS1Db250ZW50LS0+XFxuPGRpdiBjbGFzcz1cXFwibWFpbi1jb250YWluZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsZWZ0LXNpZGViYXJcXFwiPlxcbiAgICAgICAgPGxlZnQtc2lkZWJhcj48L2xlZnQtc2lkZWJhcj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1haW4tY29udGVudFxcXCI+XFxuICAgICAgICA8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyaWdodC1zaWRlYmFyXFxcIj5cXG4gICAgICAgIDxyaWdodC1zaWRlYmFyPjwvcmlnaHQtc2lkZWJhcj5cXG4gICAgPC9kaXY+XFxuICAgIDxmb290ZXI+PC9mb290ZXI+XFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vcGFnZS1mcmFtZS5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9wYWdlLWZyYW1lLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLm1lbnUtZGVza3RvcCxcXG4ubGVmdC1zaWRlYmFyLFxcbi5yaWdodC1zaWRlYmFyIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5tYWluLWNvbnRhaW5lciB7XFxuICBtYXJnaW4tYm90dG9tOiA1MHB4O1xcbn1cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkge1xcbiAgLm1haW4tY29udGFpbmVyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gIH1cXG4gIC5tZW51LW1vYmlsZSB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxuICAubWVudS1kZXNrdG9wLFxcbiAgLmxlZnQtc2lkZWJhcixcXG4gIC5yaWdodC1zaWRlYmFyIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICB9XFxuICAubWFpbi1jb250ZW50IHtcXG4gICAgcGFkZGluZzogMCAxMHB4O1xcbiAgICB3aWR0aDogMTAwJTtcXG4gIH1cXG4gIC5sZWZ0LXNpZGViYXIge1xcbiAgICBtYXJnaW4tbGVmdDogMTBweDtcXG4gICAgZmxleDogMCAwIDIwMHB4O1xcbiAgfVxcbiAgLnJpZ2h0LXNpZGViYXIge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgICBmbGV4OiAwIDAgMTUwcHg7XFxuICB9XFxufVxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDEwMjRweCkge1xcbiAgLm1haW4tY29udGVudCB7XFxuICAgIHBhZGRpbmc6IDAgMzBweDtcXG4gIH1cXG4gIC5sZWZ0LXNpZGViYXIge1xcbiAgICBtYXJnaW4tbGVmdDogNTBweDtcXG4gIH1cXG4gIC5yaWdodC1zaWRlYmFyIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA1MHB4O1xcbiAgICBmbGV4OiAwIDAgMjAwcHg7XFxuICB9XFxufVxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDEyODBweCkge1xcbiAgLm1haW4tY29udGVudCB7XFxuICAgIHBhZGRpbmc6IDAgNTBweDtcXG4gIH1cXG4gIC5sZWZ0LXNpZGViYXIge1xcbiAgICBtYXJnaW4tbGVmdDogODBweDtcXG4gIH1cXG4gIC5yaWdodC1zaWRlYmFyIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA4MHB4O1xcbiAgfVxcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2Zvb3RlcicsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZm9vdGVyLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9mb290ZXIuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBGb290ZXJDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9mb290ZXIvZm9vdGVyLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJ1aSBtZW51XFxcIj5cXG4gICAgPHA+Rm9yIHN1cHBvcnQgb3IgdG8gcmVwb3J0IHdlYnNpdGUgaXNzdWVzLCBlbWFpbCB0aGUgYWRtaW4gYXQgd2NqcGhvZW5peEBnbWFpbC5jb20gb3IgdGhlIGNyZWF0b3IgYXQgbmljay5wcm96b3JvdnNreUBnbWFpbC5jb208L3A+XFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3BhZ2UtZnJhbWUvZm9vdGVyL2Zvb3Rlci5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vZm9vdGVyLmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudWkubWVudSB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGxlZnQ6IDA7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxucCB7XFxuICBtYXJnaW46IDAgYXV0bztcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG59XFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIHtcXG4gIHAge1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICB9XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9mb290ZXIvZm9vdGVyLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==