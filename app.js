webpackJsonp([0],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	var platform_browser_dynamic_1 = __webpack_require__(5);
	var core_1 = __webpack_require__(7);
	var app_module_1 = __webpack_require__(27);
	/*
	 Our application code
	*/
	// Turns off assertions and other checks within the framework if we are in production
	if (process.env.ENV === 'prod') {
	    core_1.enableProdMode();
	}
	// Bootstrap
	platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var common_1 = __webpack_require__(26);
	var platform_browser_1 = __webpack_require__(25);
	var http_1 = __webpack_require__(28);
	var forms_1 = __webpack_require__(29);
	var home_component_1 = __webpack_require__(33);
	var about_component_1 = __webpack_require__(39);
	var prospective_players_component_1 = __webpack_require__(43);
	var contact_component_1 = __webpack_require__(48);
	var app_component_1 = __webpack_require__(52);
	var team_module_1 = __webpack_require__(60);
	var history_module_1 = __webpack_require__(150);
	var page_frame_module_1 = __webpack_require__(151);
	var AppModule = (function () {
	    function AppModule() {
	    }
	    return AppModule;
	}());
	AppModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            platform_browser_1.BrowserModule,
	            http_1.HttpModule,
	            forms_1.FormsModule,
	            // AgmCoreModule.forRoot({
	            //     apiKey: 'AIzaSyBRIXAk5xdvn3ezypsSe55f8dZhcHheAZ8'
	            // }),
	            page_frame_module_1.PageFrameModule,
	            team_module_1.TeamModule,
	            history_module_1.HistoryModule
	        ],
	        declarations: [
	            app_component_1.AppComponent,
	            home_component_1.HomeComponent,
	            about_component_1.AboutComponent,
	            prospective_players_component_1.ProspectivePlayersComponent,
	            contact_component_1.ContactComponent
	        ],
	        // Use hash strategy so page refreshes on Github pages route correctly
	        providers: [{ provide: common_1.LocationStrategy, useClass: common_1.HashLocationStrategy }],
	        bootstrap: [app_component_1.AppComponent]
	    }),
	    __metadata("design:paramtypes", [])
	], AppModule);
	exports.AppModule = AppModule;


/***/ }),
/* 28 */,
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v2.2.4
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(7), __webpack_require__(30), __webpack_require__(8), __webpack_require__(9), __webpack_require__(31)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/operator/toPromise', 'rxjs/Subject', 'rxjs/Observable', 'rxjs/observable/fromPromise'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.forms = global.ng.forms || {}),global.ng.core,global.Rx.Observable.prototype,global.Rx,global.Rx,global.Rx.Observable));
	}(this, function (exports,_angular_core,rxjs_operator_toPromise,rxjs_Subject,rxjs_Observable,rxjs_observable_fromPromise) { 'use strict';
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Base class for control directives.
	     *
	     * Only used internally in the forms module.
	     *
	     * @stable
	     */
	    var AbstractControlDirective = (function () {
	        function AbstractControlDirective() {
	        }
	        Object.defineProperty(AbstractControlDirective.prototype, "control", {
	            get: function () { throw new Error('unimplemented'); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "value", {
	            get: function () { return this.control ? this.control.value : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "valid", {
	            get: function () { return this.control ? this.control.valid : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "invalid", {
	            get: function () { return this.control ? this.control.invalid : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "pending", {
	            get: function () { return this.control ? this.control.pending : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "errors", {
	            get: function () { return this.control ? this.control.errors : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
	            get: function () { return this.control ? this.control.pristine : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
	            get: function () { return this.control ? this.control.dirty : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "touched", {
	            get: function () { return this.control ? this.control.touched : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
	            get: function () { return this.control ? this.control.untouched : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "disabled", {
	            get: function () { return this.control ? this.control.disabled : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "enabled", {
	            get: function () { return this.control ? this.control.enabled : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "statusChanges", {
	            get: function () { return this.control ? this.control.statusChanges : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "valueChanges", {
	            get: function () { return this.control ? this.control.valueChanges : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "path", {
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        AbstractControlDirective.prototype.reset = function (value) {
	            if (value === void 0) { value = undefined; }
	            if (this.control)
	                this.control.reset(value);
	        };
	        AbstractControlDirective.prototype.hasError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return this.control ? this.control.hasError(errorCode, path) : false;
	        };
	        AbstractControlDirective.prototype.getError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return this.control ? this.control.getError(errorCode, path) : null;
	        };
	        return AbstractControlDirective;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * A directive that contains multiple {@link NgControl}s.
	     *
	     * Only used by the forms module.
	     *
	     * @stable
	     */
	    var ControlContainer = (function (_super) {
	        __extends$1(ControlContainer, _super);
	        function ControlContainer() {
	            _super.apply(this, arguments);
	        }
	        Object.defineProperty(ControlContainer.prototype, "formDirective", {
	            /**
	             * Get the form to which this container belongs.
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ControlContainer.prototype, "path", {
	            /**
	             * Get the path to this container.
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        return ControlContainer;
	    }(AbstractControlDirective));
	
	    function isPresent(obj) {
	        return obj != null;
	    }
	    function isBlank(obj) {
	        return obj == null;
	    }
	    // JS has NaN !== NaN
	    function looseIdentical(a, b) {
	        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	    }
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    function isPrimitive(obj) {
	        return !isJsObject(obj);
	    }
	
	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        StringMapWrapper.merge = function (m1, m2) {
	            var m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        StringMapWrapper.equals = function (m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var i = 0; i < k1.length; i++) {
	                var key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        ListWrapper.removeAll = function (list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                if (index > -1) {
	                    list.splice(index, 1);
	                }
	            }
	        };
	        ListWrapper.remove = function (list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        ListWrapper.flatten = function (list) {
	            return list.reduce(function (flat, item) {
	                var flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;
	                return flat.concat(flatItem);
	            }, []);
	        };
	        return ListWrapper;
	    }());
	
	    var isPromise = _angular_core.__core_private__.isPromise;
	
	    function isEmptyInputValue(value) {
	        return value == null || typeof value === 'string' && value.length === 0;
	    }
	    /**
	     * Providers for validators to be used for {@link FormControl}s in a form.
	     *
	     * Provide this using `multi: true` to add validators.
	     *
	     * ### Example
	     *
	     * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
	     * @stable
	     */
	    var NG_VALIDATORS = new _angular_core.OpaqueToken('NgValidators');
	    /**
	     * Providers for asynchronous validators to be used for {@link FormControl}s
	     * in a form.
	     *
	     * Provide this using `multi: true` to add validators.
	     *
	     * See {@link NG_VALIDATORS} for more details.
	     *
	     * @stable
	     */
	    var NG_ASYNC_VALIDATORS = new _angular_core.OpaqueToken('NgAsyncValidators');
	    /**
	     * Provides a set of validators used by form controls.
	     *
	     * A validator is a function that processes a {@link FormControl} or collection of
	     * controls and returns a map of errors. A null map means that validation has passed.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * var loginControl = new FormControl("", Validators.required)
	     * ```
	     *
	     * @stable
	     */
	    var Validators = (function () {
	        function Validators() {
	        }
	        /**
	         * Validator that requires controls to have a non-empty value.
	         */
	        Validators.required = function (control) {
	            return isEmptyInputValue(control.value) ? { 'required': true } : null;
	        };
	        /**
	         * Validator that requires controls to have a value of a minimum length.
	         */
	        Validators.minLength = function (minLength) {
	            return function (control) {
	                if (isEmptyInputValue(control.value)) {
	                    return null; // don't validate empty values to allow optional controls
	                }
	                var length = typeof control.value === 'string' ? control.value.length : 0;
	                return length < minLength ?
	                    { 'minlength': { 'requiredLength': minLength, 'actualLength': length } } :
	                    null;
	            };
	        };
	        /**
	         * Validator that requires controls to have a value of a maximum length.
	         */
	        Validators.maxLength = function (maxLength) {
	            return function (control) {
	                var length = typeof control.value === 'string' ? control.value.length : 0;
	                return length > maxLength ?
	                    { 'maxlength': { 'requiredLength': maxLength, 'actualLength': length } } :
	                    null;
	            };
	        };
	        /**
	         * Validator that requires a control to match a regex to its value.
	         */
	        Validators.pattern = function (pattern) {
	            if (!pattern)
	                return Validators.nullValidator;
	            var regex;
	            var regexStr;
	            if (typeof pattern === 'string') {
	                regexStr = "^" + pattern + "$";
	                regex = new RegExp(regexStr);
	            }
	            else {
	                regexStr = pattern.toString();
	                regex = pattern;
	            }
	            return function (control) {
	                if (isEmptyInputValue(control.value)) {
	                    return null; // don't validate empty values to allow optional controls
	                }
	                var value = control.value;
	                return regex.test(value) ? null :
	                    { 'pattern': { 'requiredPattern': regexStr, 'actualValue': value } };
	            };
	        };
	        /**
	         * No-op validator.
	         */
	        Validators.nullValidator = function (c) { return null; };
	        /**
	         * Compose multiple validators into a single function that returns the union
	         * of the individual error maps.
	         */
	        Validators.compose = function (validators) {
	            if (!validators)
	                return null;
	            var presentValidators = validators.filter(isPresent);
	            if (presentValidators.length == 0)
	                return null;
	            return function (control) {
	                return _mergeErrors(_executeValidators(control, presentValidators));
	            };
	        };
	        Validators.composeAsync = function (validators) {
	            if (!validators)
	                return null;
	            var presentValidators = validators.filter(isPresent);
	            if (presentValidators.length == 0)
	                return null;
	            return function (control) {
	                var promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
	                return Promise.all(promises).then(_mergeErrors);
	            };
	        };
	        return Validators;
	    }());
	    function _convertToPromise(obj) {
	        return isPromise(obj) ? obj : rxjs_operator_toPromise.toPromise.call(obj);
	    }
	    function _executeValidators(control, validators) {
	        return validators.map(function (v) { return v(control); });
	    }
	    function _executeAsyncValidators(control, validators) {
	        return validators.map(function (v) { return v(control); });
	    }
	    function _mergeErrors(arrayOfErrors) {
	        var res = arrayOfErrors.reduce(function (res, errors) {
	            return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
	        }, {});
	        return Object.keys(res).length === 0 ? null : res;
	    }
	
	    /**
	     * Used to provide a {@link ControlValueAccessor} for form controls.
	     *
	     * See {@link DefaultValueAccessor} for how to implement one.
	     * @stable
	     */
	    var NG_VALUE_ACCESSOR = new _angular_core.OpaqueToken('NgValueAccessor');
	
	    var CHECKBOX_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return CheckboxControlValueAccessor; }),
	        multi: true,
	    };
	    /**
	     * The accessor for writing a value and listening to changes on a checkbox input element.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="checkbox" name="rememberLogin" ngModel>
	     *  ```
	     *
	     *  @stable
	     */
	    var CheckboxControlValueAccessor = (function () {
	        function CheckboxControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        CheckboxControlValueAccessor.prototype.writeValue = function (value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
	        };
	        CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	        CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        CheckboxControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        CheckboxControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',
	                        host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
	                        providers: [CHECKBOX_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        CheckboxControlValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return CheckboxControlValueAccessor;
	    }());
	
	    var DEFAULT_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return DefaultValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The default accessor for writing a value and listening to changes that is used by the
	     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="text" name="searchQuery" ngModel>
	     *  ```
	     *
	     *  @stable
	     */
	    var DefaultValueAccessor = (function () {
	        function DefaultValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        DefaultValueAccessor.prototype.writeValue = function (value) {
	            var normalizedValue = value == null ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        };
	        DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	        DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        DefaultValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        DefaultValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
	                        // TODO: vsavkin replace the above selector with the one below it once
	                        // https://github.com/angular/angular/issues/3011 is implemented
	                        // selector: '[ngControl],[ngModel],[ngFormControl]',
	                        host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                        providers: [DEFAULT_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        DefaultValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return DefaultValueAccessor;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    function normalizeValidator(validator) {
	        if (validator.validate) {
	            return function (c) { return validator.validate(c); };
	        }
	        else {
	            return validator;
	        }
	    }
	    function normalizeAsyncValidator(validator) {
	        if (validator.validate) {
	            return function (c) { return validator.validate(c); };
	        }
	        else {
	            return validator;
	        }
	    }
	
	    var NUMBER_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return NumberValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The accessor for writing a number value and listening to changes that is used by the
	     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="number" [(ngModel)]="age">
	     *  ```
	     */
	    var NumberValueAccessor = (function () {
	        function NumberValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        NumberValueAccessor.prototype.writeValue = function (value) {
	            // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
	            var normalizedValue = value == null ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        };
	        NumberValueAccessor.prototype.registerOnChange = function (fn) {
	            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };
	        };
	        NumberValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        NumberValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        NumberValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',
	                        host: {
	                            '(change)': 'onChange($event.target.value)',
	                            '(input)': 'onChange($event.target.value)',
	                            '(blur)': 'onTouched()'
	                        },
	                        providers: [NUMBER_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        NumberValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return NumberValueAccessor;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    function unimplemented() {
	        throw new Error('unimplemented');
	    }
	    /**
	     * A base class that all control directive extend.
	     * It binds a {@link FormControl} object to a DOM element.
	     *
	     * Used internally by Angular forms.
	     *
	     * @stable
	     */
	    var NgControl = (function (_super) {
	        __extends$2(NgControl, _super);
	        function NgControl() {
	            _super.apply(this, arguments);
	            /** @internal */
	            this._parent = null;
	            this.name = null;
	            this.valueAccessor = null;
	            /** @internal */
	            this._rawValidators = [];
	            /** @internal */
	            this._rawAsyncValidators = [];
	        }
	        Object.defineProperty(NgControl.prototype, "validator", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgControl.prototype, "asyncValidator", {
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        return NgControl;
	    }(AbstractControlDirective));
	
	    var RADIO_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return RadioControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * Internal class used by Angular to uncheck radio buttons with the matching name.
	     */
	    var RadioControlRegistry = (function () {
	        function RadioControlRegistry() {
	            this._accessors = [];
	        }
	        RadioControlRegistry.prototype.add = function (control, accessor) {
	            this._accessors.push([control, accessor]);
	        };
	        RadioControlRegistry.prototype.remove = function (accessor) {
	            for (var i = this._accessors.length - 1; i >= 0; --i) {
	                if (this._accessors[i][1] === accessor) {
	                    this._accessors.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        RadioControlRegistry.prototype.select = function (accessor) {
	            var _this = this;
	            this._accessors.forEach(function (c) {
	                if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {
	                    c[1].fireUncheck(accessor.value);
	                }
	            });
	        };
	        RadioControlRegistry.prototype._isSameGroup = function (controlPair, accessor) {
	            if (!controlPair[0].control)
	                return false;
	            return controlPair[0]._parent === accessor._control._parent &&
	                controlPair[1].name === accessor.name;
	        };
	        RadioControlRegistry.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        RadioControlRegistry.ctorParameters = [];
	        return RadioControlRegistry;
	    }());
	    /**
	     * @whatItDoes  Writes radio control values and listens to radio control changes.
	     *
	     * Used by {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName}
	     * to keep the view synced with the {@link FormControl} model.
	     *
	     * @howToUse
	     *
	     * If you have imported the {@link FormsModule} or the {@link ReactiveFormsModule}, this
	     * value accessor will be active on any radio control that has a form directive. You do
	     * **not** need to add a special selector to activate it.
	     *
	     * ### How to use radio buttons with form directives
	     *
	     * To use radio buttons in a template-driven form, you'll want to ensure that radio buttons
	     * in the same group have the same `name` attribute.  Radio buttons with different `name`
	     * attributes do not affect each other.
	     *
	     * {@example forms/ts/radioButtons/radio_button_example.ts region='TemplateDriven'}
	     *
	     * When using radio buttons in a reactive form, radio buttons in the same group should have the
	     * same `formControlName`. You can also add a `name` attribute, but it's optional.
	     *
	     * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}
	     *
	     *  * **npm package**: `@angular/forms`
	     *
	     *  @stable
	     */
	    var RadioControlValueAccessor = (function () {
	        function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this._registry = _registry;
	            this._injector = _injector;
	            this.onChange = function () { };
	            this.onTouched = function () { };
	        }
	        RadioControlValueAccessor.prototype.ngOnInit = function () {
	            this._control = this._injector.get(NgControl);
	            this._checkName();
	            this._registry.add(this._control, this);
	        };
	        RadioControlValueAccessor.prototype.ngOnDestroy = function () { this._registry.remove(this); };
	        RadioControlValueAccessor.prototype.writeValue = function (value) {
	            this._state = value === this.value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', this._state);
	        };
	        RadioControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this._fn = fn;
	            this.onChange = function () {
	                fn(_this.value);
	                _this._registry.select(_this);
	            };
	        };
	        RadioControlValueAccessor.prototype.fireUncheck = function (value) { this.writeValue(value); };
	        RadioControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        RadioControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        RadioControlValueAccessor.prototype._checkName = function () {
	            if (this.name && this.formControlName && this.name !== this.formControlName) {
	                this._throwNameError();
	            }
	            if (!this.name && this.formControlName)
	                this.name = this.formControlName;
	        };
	        RadioControlValueAccessor.prototype._throwNameError = function () {
	            throw new Error("\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type=\"radio\" formControlName=\"food\" name=\"food\">\n    ");
	        };
	        RadioControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',
	                        host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
	                        providers: [RADIO_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        RadioControlValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	            { type: RadioControlRegistry, },
	            { type: _angular_core.Injector, },
	        ];
	        RadioControlValueAccessor.propDecorators = {
	            'name': [{ type: _angular_core.Input },],
	            'formControlName': [{ type: _angular_core.Input },],
	            'value': [{ type: _angular_core.Input },],
	        };
	        return RadioControlValueAccessor;
	    }());
	
	    var RANGE_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return RangeValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The accessor for writing a range value and listening to changes that is used by the
	     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="range" [(ngModel)]="age" >
	     *  ```
	     */
	    var RangeValueAccessor = (function () {
	        function RangeValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        RangeValueAccessor.prototype.writeValue = function (value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', parseFloat(value));
	        };
	        RangeValueAccessor.prototype.registerOnChange = function (fn) {
	            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };
	        };
	        RangeValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        RangeValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        RangeValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',
	                        host: {
	                            '(change)': 'onChange($event.target.value)',
	                            '(input)': 'onChange($event.target.value)',
	                            '(blur)': 'onTouched()'
	                        },
	                        providers: [RANGE_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        RangeValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return RangeValueAccessor;
	    }());
	
	    var SELECT_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return SelectControlValueAccessor; }),
	        multi: true
	    };
	    function _buildValueString(id, value) {
	        if (id == null)
	            return "" + value;
	        if (!isPrimitive(value))
	            value = 'Object';
	        return (id + ": " + value).slice(0, 50);
	    }
	    function _extractId(valueString) {
	        return valueString.split(':')[0];
	    }
	    /**
	     * @whatItDoes Writes values and listens to changes on a select element.
	     *
	     * Used by {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName}
	     * to keep the view synced with the {@link FormControl} model.
	     *
	     * @howToUse
	     *
	     * If you have imported the {@link FormsModule} or the {@link ReactiveFormsModule}, this
	     * value accessor will be active on any select control that has a form directive. You do
	     * **not** need to add a special selector to activate it.
	     *
	     * ### How to use select controls with form directives
	     *
	     * To use a select in a template-driven form, simply add an `ngModel` and a `name`
	     * attribute to the main `<select>` tag.
	     *
	     * If your option values are simple strings, you can bind to the normal `value` property
	     * on the option.  If your option values happen to be objects (and you'd like to save the
	     * selection in your form as an object), use `ngValue` instead:
	     *
	     * {@example forms/ts/selectControl/select_control_example.ts region='Component'}
	     *
	     * In reactive forms, you'll also want to add your form directive (`formControlName` or
	     * `formControl`) on the main `<select>` tag. Like in the former example, you have the
	     * choice of binding to the  `value` or `ngValue` property on the select's options.
	     *
	     * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}
	     *
	     * Note: We listen to the 'change' event because 'input' events aren't fired
	     * for selects in Firefox and IE:
	     * https://bugzilla.mozilla.org/show_bug.cgi?id=1024350
	     * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4660045/
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * @stable
	     */
	    var SelectControlValueAccessor = (function () {
	        function SelectControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            /** @internal */
	            this._optionMap = new Map();
	            /** @internal */
	            this._idCounter = 0;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        SelectControlValueAccessor.prototype.writeValue = function (value) {
	            this.value = value;
	            var valueString = _buildValueString(this._getOptionId(value), value);
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
	        };
	        SelectControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this.onChange = function (valueString) {
	                _this.value = valueString;
	                fn(_this._getOptionValue(valueString));
	            };
	        };
	        SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        SelectControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /** @internal */
	        SelectControlValueAccessor.prototype._registerOption = function () { return (this._idCounter++).toString(); };
	        /** @internal */
	        SelectControlValueAccessor.prototype._getOptionId = function (value) {
	            for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
	                var id = _a[_i];
	                if (looseIdentical(this._optionMap.get(id), value))
	                    return id;
	            }
	            return null;
	        };
	        /** @internal */
	        SelectControlValueAccessor.prototype._getOptionValue = function (valueString) {
	            var id = _extractId(valueString);
	            return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
	        };
	        SelectControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',
	                        host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                        providers: [SELECT_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        SelectControlValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return SelectControlValueAccessor;
	    }());
	    /**
	     * @whatItDoes Marks `<option>` as dynamic, so Angular can be notified when options change.
	     *
	     * @howToUse
	     *
	     * See docs for {@link SelectControlValueAccessor} for usage examples.
	     *
	     * @stable
	     */
	    var NgSelectOption = (function () {
	        function NgSelectOption(_element, _renderer, _select) {
	            this._element = _element;
	            this._renderer = _renderer;
	            this._select = _select;
	            if (this._select)
	                this.id = this._select._registerOption();
	        }
	        Object.defineProperty(NgSelectOption.prototype, "ngValue", {
	            set: function (value) {
	                if (this._select == null)
	                    return;
	                this._select._optionMap.set(this.id, value);
	                this._setElementValue(_buildValueString(this.id, value));
	                this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgSelectOption.prototype, "value", {
	            set: function (value) {
	                this._setElementValue(value);
	                if (this._select)
	                    this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        NgSelectOption.prototype._setElementValue = function (value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        };
	        NgSelectOption.prototype.ngOnDestroy = function () {
	            if (this._select) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        };
	        NgSelectOption.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'option' },] },
	        ];
	        /** @nocollapse */
	        NgSelectOption.ctorParameters = [
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: SelectControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	        ];
	        NgSelectOption.propDecorators = {
	            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],
	            'value': [{ type: _angular_core.Input, args: ['value',] },],
	        };
	        return NgSelectOption;
	    }());
	
	    var SELECT_MULTIPLE_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return SelectMultipleControlValueAccessor; }),
	        multi: true
	    };
	    function _buildValueString$1(id, value) {
	        if (id == null)
	            return "" + value;
	        if (typeof value === 'string')
	            value = "'" + value + "'";
	        if (!isPrimitive(value))
	            value = 'Object';
	        return (id + ": " + value).slice(0, 50);
	    }
	    function _extractId$1(valueString) {
	        return valueString.split(':')[0];
	    }
	    /**
	     * The accessor for writing a value and listening to changes on a select element.
	     *
	     * @stable
	     */
	    var SelectMultipleControlValueAccessor = (function () {
	        function SelectMultipleControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            /** @internal */
	            this._optionMap = new Map();
	            /** @internal */
	            this._idCounter = 0;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        SelectMultipleControlValueAccessor.prototype.writeValue = function (value) {
	            var _this = this;
	            this.value = value;
	            if (value == null)
	                return;
	            var values = value;
	            // convert values to ids
	            var ids = values.map(function (v) { return _this._getOptionId(v); });
	            this._optionMap.forEach(function (opt, o) { opt._setSelected(ids.indexOf(o.toString()) > -1); });
	        };
	        SelectMultipleControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this.onChange = function (_) {
	                var selected = [];
	                if (_.hasOwnProperty('selectedOptions')) {
	                    var options = _.selectedOptions;
	                    for (var i = 0; i < options.length; i++) {
	                        var opt = options.item(i);
	                        var val = _this._getOptionValue(opt.value);
	                        selected.push(val);
	                    }
	                }
	                else {
	                    var options = _.options;
	                    for (var i = 0; i < options.length; i++) {
	                        var opt = options.item(i);
	                        if (opt.selected) {
	                            var val = _this._getOptionValue(opt.value);
	                            selected.push(val);
	                        }
	                    }
	                }
	                fn(selected);
	            };
	        };
	        SelectMultipleControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        SelectMultipleControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /** @internal */
	        SelectMultipleControlValueAccessor.prototype._registerOption = function (value) {
	            var id = (this._idCounter++).toString();
	            this._optionMap.set(id, value);
	            return id;
	        };
	        /** @internal */
	        SelectMultipleControlValueAccessor.prototype._getOptionId = function (value) {
	            for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
	                var id = _a[_i];
	                if (looseIdentical(this._optionMap.get(id)._value, value))
	                    return id;
	            }
	            return null;
	        };
	        /** @internal */
	        SelectMultipleControlValueAccessor.prototype._getOptionValue = function (valueString) {
	            var id = _extractId$1(valueString);
	            return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
	        };
	        SelectMultipleControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
	                        host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },
	                        providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        SelectMultipleControlValueAccessor.ctorParameters = [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ];
	        return SelectMultipleControlValueAccessor;
	    }());
	    /**
	     * Marks `<option>` as dynamic, so Angular can be notified when options change.
	     *
	     * ### Example
	     *
	     * ```
	     * <select multiple name="city" ngModel>
	     *   <option *ngFor="let c of cities" [value]="c"></option>
	     * </select>
	     * ```
	     */
	    var NgSelectMultipleOption = (function () {
	        function NgSelectMultipleOption(_element, _renderer, _select) {
	            this._element = _element;
	            this._renderer = _renderer;
	            this._select = _select;
	            if (this._select) {
	                this.id = this._select._registerOption(this);
	            }
	        }
	        Object.defineProperty(NgSelectMultipleOption.prototype, "ngValue", {
	            set: function (value) {
	                if (this._select == null)
	                    return;
	                this._value = value;
	                this._setElementValue(_buildValueString$1(this.id, value));
	                this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgSelectMultipleOption.prototype, "value", {
	            set: function (value) {
	                if (this._select) {
	                    this._value = value;
	                    this._setElementValue(_buildValueString$1(this.id, value));
	                    this._select.writeValue(this._select.value);
	                }
	                else {
	                    this._setElementValue(value);
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        NgSelectMultipleOption.prototype._setElementValue = function (value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        };
	        /** @internal */
	        NgSelectMultipleOption.prototype._setSelected = function (selected) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);
	        };
	        NgSelectMultipleOption.prototype.ngOnDestroy = function () {
	            if (this._select) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        };
	        NgSelectMultipleOption.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'option' },] },
	        ];
	        /** @nocollapse */
	        NgSelectMultipleOption.ctorParameters = [
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: SelectMultipleControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	        ];
	        NgSelectMultipleOption.propDecorators = {
	            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],
	            'value': [{ type: _angular_core.Input, args: ['value',] },],
	        };
	        return NgSelectMultipleOption;
	    }());
	
	    function controlPath(name, parent) {
	        return parent.path.concat([name]);
	    }
	    function setUpControl(control, dir) {
	        if (!control)
	            _throwError(dir, 'Cannot find control with');
	        if (!dir.valueAccessor)
	            _throwError(dir, 'No value accessor for form control with');
	        control.validator = Validators.compose([control.validator, dir.validator]);
	        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	        dir.valueAccessor.writeValue(control.value);
	        // view -> model
	        dir.valueAccessor.registerOnChange(function (newValue) {
	            dir.viewToModelUpdate(newValue);
	            control.markAsDirty();
	            control.setValue(newValue, { emitModelToViewChange: false });
	        });
	        // touched
	        dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });
	        control.registerOnChange(function (newValue, emitModelEvent) {
	            // control -> view
	            dir.valueAccessor.writeValue(newValue);
	            // control -> ngModel
	            if (emitModelEvent)
	                dir.viewToModelUpdate(newValue);
	        });
	        if (dir.valueAccessor.setDisabledState) {
	            control.registerOnDisabledChange(function (isDisabled) { dir.valueAccessor.setDisabledState(isDisabled); });
	        }
	        // re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4
	        dir._rawValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange)
	                validator.registerOnValidatorChange(function () { return control.updateValueAndValidity(); });
	        });
	        dir._rawAsyncValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange)
	                validator.registerOnValidatorChange(function () { return control.updateValueAndValidity(); });
	        });
	    }
	    function cleanUpControl(control, dir) {
	        dir.valueAccessor.registerOnChange(function () { return _noControlError(dir); });
	        dir.valueAccessor.registerOnTouched(function () { return _noControlError(dir); });
	        dir._rawValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange) {
	                validator.registerOnValidatorChange(null);
	            }
	        });
	        dir._rawAsyncValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange) {
	                validator.registerOnValidatorChange(null);
	            }
	        });
	        if (control)
	            control._clearChangeFns();
	    }
	    function setUpFormContainer(control, dir) {
	        if (isBlank(control))
	            _throwError(dir, 'Cannot find control with');
	        control.validator = Validators.compose([control.validator, dir.validator]);
	        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	    }
	    function _noControlError(dir) {
	        return _throwError(dir, 'There is no FormControl instance attached to form control element with');
	    }
	    function _throwError(dir, message) {
	        var messageEnd;
	        if (dir.path.length > 1) {
	            messageEnd = "path: '" + dir.path.join(' -> ') + "'";
	        }
	        else if (dir.path[0]) {
	            messageEnd = "name: '" + dir.path + "'";
	        }
	        else {
	            messageEnd = 'unspecified name attribute';
	        }
	        throw new Error(message + " " + messageEnd);
	    }
	    function composeValidators(validators) {
	        return isPresent(validators) ? Validators.compose(validators.map(normalizeValidator)) : null;
	    }
	    function composeAsyncValidators(validators) {
	        return isPresent(validators) ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) :
	            null;
	    }
	    function isPropertyUpdated(changes, viewModel) {
	        if (!changes.hasOwnProperty('model'))
	            return false;
	        var change = changes['model'];
	        if (change.isFirstChange())
	            return true;
	        return !looseIdentical(viewModel, change.currentValue);
	    }
	    var BUILTIN_ACCESSORS = [
	        CheckboxControlValueAccessor,
	        RangeValueAccessor,
	        NumberValueAccessor,
	        SelectControlValueAccessor,
	        SelectMultipleControlValueAccessor,
	        RadioControlValueAccessor,
	    ];
	    function isBuiltInAccessor(valueAccessor) {
	        return BUILTIN_ACCESSORS.some(function (a) { return valueAccessor.constructor === a; });
	    }
	    // TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
	    function selectValueAccessor(dir, valueAccessors) {
	        if (!valueAccessors)
	            return null;
	        var defaultAccessor;
	        var builtinAccessor;
	        var customAccessor;
	        valueAccessors.forEach(function (v) {
	            if (v.constructor === DefaultValueAccessor) {
	                defaultAccessor = v;
	            }
	            else if (isBuiltInAccessor(v)) {
	                if (builtinAccessor)
	                    _throwError(dir, 'More than one built-in value accessor matches form control with');
	                builtinAccessor = v;
	            }
	            else {
	                if (customAccessor)
	                    _throwError(dir, 'More than one custom value accessor matches form control with');
	                customAccessor = v;
	            }
	        });
	        if (customAccessor)
	            return customAccessor;
	        if (builtinAccessor)
	            return builtinAccessor;
	        if (defaultAccessor)
	            return defaultAccessor;
	        _throwError(dir, 'No valid value accessor for form control with');
	        return null;
	    }
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * This is a base class for code shared between {@link NgModelGroup} and {@link FormGroupName}.
	     *
	     * @stable
	     */
	    var AbstractFormGroupDirective = (function (_super) {
	        __extends(AbstractFormGroupDirective, _super);
	        function AbstractFormGroupDirective() {
	            _super.apply(this, arguments);
	        }
	        AbstractFormGroupDirective.prototype.ngOnInit = function () {
	            this._checkParentType();
	            this.formDirective.addFormGroup(this);
	        };
	        AbstractFormGroupDirective.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeFormGroup(this);
	            }
	        };
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "control", {
	            /**
	             * Get the {@link FormGroup} backing this binding.
	             */
	            get: function () { return this.formDirective.getFormGroup(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "path", {
	            /**
	             * Get the path to this control group.
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "formDirective", {
	            /**
	             * Get the {@link Form} to which this group belongs.
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "validator", {
	            get: function () { return composeValidators(this._validators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "asyncValidator", {
	            get: function () { return composeAsyncValidators(this._asyncValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        AbstractFormGroupDirective.prototype._checkParentType = function () { };
	        return AbstractFormGroupDirective;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var AbstractControlStatus = (function () {
	        function AbstractControlStatus(cd) {
	            this._cd = cd;
	        }
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassUntouched", {
	            get: function () { return this._cd.control ? this._cd.control.untouched : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassTouched", {
	            get: function () { return this._cd.control ? this._cd.control.touched : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassPristine", {
	            get: function () { return this._cd.control ? this._cd.control.pristine : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassDirty", {
	            get: function () { return this._cd.control ? this._cd.control.dirty : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassValid", {
	            get: function () { return this._cd.control ? this._cd.control.valid : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassInvalid", {
	            get: function () { return this._cd.control ? this._cd.control.invalid : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassPending", {
	            get: function () { return this._cd.control ? this._cd.control.pending : false; },
	            enumerable: true,
	            configurable: true
	        });
	        return AbstractControlStatus;
	    }());
	    var ngControlStatusHost = {
	        '[class.ng-untouched]': 'ngClassUntouched',
	        '[class.ng-touched]': 'ngClassTouched',
	        '[class.ng-pristine]': 'ngClassPristine',
	        '[class.ng-dirty]': 'ngClassDirty',
	        '[class.ng-valid]': 'ngClassValid',
	        '[class.ng-invalid]': 'ngClassInvalid',
	        '[class.ng-pending]': 'ngClassPending',
	    };
	    /**
	     * Directive automatically applied to Angular form controls that sets CSS classes
	     * based on control status (valid/invalid/dirty/etc).
	     *
	     * @stable
	     */
	    var NgControlStatus = (function (_super) {
	        __extends$3(NgControlStatus, _super);
	        function NgControlStatus(cd) {
	            _super.call(this, cd);
	        }
	        NgControlStatus.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost },] },
	        ];
	        /** @nocollapse */
	        NgControlStatus.ctorParameters = [
	            { type: NgControl, decorators: [{ type: _angular_core.Self },] },
	        ];
	        return NgControlStatus;
	    }(AbstractControlStatus));
	    /**
	     * Directive automatically applied to Angular form groups that sets CSS classes
	     * based on control status (valid/invalid/dirty/etc).
	     *
	     * @stable
	     */
	    var NgControlStatusGroup = (function (_super) {
	        __extends$3(NgControlStatusGroup, _super);
	        function NgControlStatusGroup(cd) {
	            _super.call(this, cd);
	        }
	        NgControlStatusGroup.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',
	                        host: ngControlStatusHost
	                    },] },
	        ];
	        /** @nocollapse */
	        NgControlStatusGroup.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Self },] },
	        ];
	        return NgControlStatusGroup;
	    }(AbstractControlStatus));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Use by directives and components to emit custom Events.
	     *
	     * ### Examples
	     *
	     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	     * title gets clicked:
	     *
	     * ```
	     * @Component({
	     *   selector: 'zippy',
	     *   template: `
	     *   <div class="zippy">
	     *     <div (click)="toggle()">Toggle</div>
	     *     <div [hidden]="!visible">
	     *       <ng-content></ng-content>
	     *     </div>
	     *  </div>`})
	     * export class Zippy {
	     *   visible: boolean = true;
	     *   @Output() open: EventEmitter<any> = new EventEmitter();
	     *   @Output() close: EventEmitter<any> = new EventEmitter();
	     *
	     *   toggle() {
	     *     this.visible = !this.visible;
	     *     if (this.visible) {
	     *       this.open.emit(null);
	     *     } else {
	     *       this.close.emit(null);
	     *     }
	     *   }
	     * }
	     * ```
	     *
	     * The events payload can be accessed by the parameter `$event` on the components output event
	     * handler:
	     *
	     * ```
	     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	     * ```
	     *
	     * Uses Rx.Observable but provides an adapter to make it work as specified here:
	     * https://github.com/jhusain/observable-spec
	     *
	     * Once a reference implementation of the spec is available, switch to it.
	     * @stable
	     */
	    var EventEmitter = (function (_super) {
	        __extends$5(EventEmitter, _super);
	        /**
	         * Creates an instance of [EventEmitter], which depending on [isAsync],
	         * delivers events synchronously or asynchronously.
	         */
	        function EventEmitter(isAsync) {
	            if (isAsync === void 0) { isAsync = false; }
	            _super.call(this);
	            this.__isAsync = isAsync;
	        }
	        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	            var schedulerFn;
	            var errorFn = function (err) { return null; };
	            var completeFn = function () { return null; };
	            if (generatorOrNext && typeof generatorOrNext === 'object') {
	                schedulerFn = this.__isAsync ? function (value) {
	                    setTimeout(function () { return generatorOrNext.next(value); });
	                } : function (value) { generatorOrNext.next(value); };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                        function (err) { generatorOrNext.error(err); };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                        function () { generatorOrNext.complete(); };
	                }
	            }
	            else {
	                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
	                    function (value) { generatorOrNext(value); };
	                if (error) {
	                    errorFn =
	                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	                }
	                if (complete) {
	                    completeFn =
	                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	                }
	            }
	            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	        };
	        return EventEmitter;
	    }(rxjs_Subject.Subject));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.
	     */
	    var VALID = 'VALID';
	    /**
	     * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.
	     */
	    var INVALID = 'INVALID';
	    /**
	     * Indicates that a FormControl is pending, i.e. that async validation is occurring and
	     * errors are not yet available for the input value.
	     */
	    var PENDING = 'PENDING';
	    /**
	     * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor
	     * calculations of validity or value.
	     */
	    var DISABLED = 'DISABLED';
	    function _find(control, path, delimiter) {
	        if (path == null)
	            return null;
	        if (!(path instanceof Array)) {
	            path = path.split(delimiter);
	        }
	        if (path instanceof Array && (path.length === 0))
	            return null;
	        return path.reduce(function (v, name) {
	            if (v instanceof FormGroup) {
	                return v.controls[name] || null;
	            }
	            if (v instanceof FormArray) {
	                return v.at(name) || null;
	            }
	            return null;
	        }, control);
	    }
	    function toObservable(r) {
	        return isPromise(r) ? rxjs_observable_fromPromise.fromPromise(r) : r;
	    }
	    function coerceToValidator(validator) {
	        return Array.isArray(validator) ? composeValidators(validator) : validator;
	    }
	    function coerceToAsyncValidator(asyncValidator) {
	        return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator;
	    }
	    /**
	     * @whatItDoes This is the base class for {@link FormControl}, {@link FormGroup}, and
	     * {@link FormArray}.
	     *
	     * It provides some of the shared behavior that all controls and groups of controls have, like
	     * running validators, calculating status, and resetting state. It also defines the properties
	     * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
	     * instantiated directly.
	     *
	     * @stable
	     */
	    var AbstractControl = (function () {
	        function AbstractControl(validator, asyncValidator) {
	            this.validator = validator;
	            this.asyncValidator = asyncValidator;
	            /** @internal */
	            this._onCollectionChange = function () { };
	            this._pristine = true;
	            this._touched = false;
	            /** @internal */
	            this._onDisabledChange = [];
	        }
	        Object.defineProperty(AbstractControl.prototype, "value", {
	            /**
	             * The value of the control.
	             */
	            get: function () { return this._value; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "parent", {
	            /**
	             * The parent control.
	             */
	            get: function () { return this._parent; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "status", {
	            /**
	             * The validation status of the control. There are four possible
	             * validation statuses:
	             *
	             * * **VALID**:  control has passed all validation checks
	             * * **INVALID**: control has failed at least one validation check
	             * * **PENDING**: control is in the midst of conducting a validation check
	             * * **DISABLED**: control is exempt from validation checks
	             *
	             * These statuses are mutually exclusive, so a control cannot be
	             * both valid AND invalid or invalid AND disabled.
	             */
	            get: function () { return this._status; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "valid", {
	            /**
	             * A control is `valid` when its `status === VALID`.
	             *
	             * In order to have this status, the control must have passed all its
	             * validation checks.
	             */
	            get: function () { return this._status === VALID; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "invalid", {
	            /**
	             * A control is `invalid` when its `status === INVALID`.
	             *
	             * In order to have this status, the control must have failed
	             * at least one of its validation checks.
	             */
	            get: function () { return this._status === INVALID; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "pending", {
	            /**
	             * A control is `pending` when its `status === PENDING`.
	             *
	             * In order to have this status, the control must be in the
	             * middle of conducting a validation check.
	             */
	            get: function () { return this._status == PENDING; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "disabled", {
	            /**
	             * A control is `disabled` when its `status === DISABLED`.
	             *
	             * Disabled controls are exempt from validation checks and
	             * are not included in the aggregate value of their ancestor
	             * controls.
	             */
	            get: function () { return this._status === DISABLED; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "enabled", {
	            /**
	             * A control is `enabled` as long as its `status !== DISABLED`.
	             *
	             * In other words, it has a status of `VALID`, `INVALID`, or
	             * `PENDING`.
	             */
	            get: function () { return this._status !== DISABLED; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "errors", {
	            /**
	             * Returns any errors generated by failing validation. If there
	             * are no errors, it will return null.
	             */
	            get: function () { return this._errors; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "pristine", {
	            /**
	             * A control is `pristine` if the user has not yet changed
	             * the value in the UI.
	             *
	             * Note that programmatic changes to a control's value will
	             * *not* mark it dirty.
	             */
	            get: function () { return this._pristine; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "dirty", {
	            /**
	             * A control is `dirty` if the user has changed the value
	             * in the UI.
	             *
	             * Note that programmatic changes to a control's value will
	             * *not* mark it dirty.
	             */
	            get: function () { return !this.pristine; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "touched", {
	            /**
	            * A control is marked `touched` once the user has triggered
	            * a `blur` event on it.
	            */
	            get: function () { return this._touched; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "untouched", {
	            /**
	             * A control is `untouched` if the user has not yet triggered
	             * a `blur` event on it.
	             */
	            get: function () { return !this._touched; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "valueChanges", {
	            /**
	             * Emits an event every time the value of the control changes, in
	             * the UI or programmatically.
	             */
	            get: function () { return this._valueChanges; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "statusChanges", {
	            /**
	             * Emits an event every time the validation status of the control
	             * is re-calculated.
	             */
	            get: function () { return this._statusChanges; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Sets the synchronous validators that are active on this control.  Calling
	         * this will overwrite any existing sync validators.
	         */
	        AbstractControl.prototype.setValidators = function (newValidator) {
	            this.validator = coerceToValidator(newValidator);
	        };
	        /**
	         * Sets the async validators that are active on this control. Calling this
	         * will overwrite any existing async validators.
	         */
	        AbstractControl.prototype.setAsyncValidators = function (newValidator) {
	            this.asyncValidator = coerceToAsyncValidator(newValidator);
	        };
	        /**
	         * Empties out the sync validator list.
	         */
	        AbstractControl.prototype.clearValidators = function () { this.validator = null; };
	        /**
	         * Empties out the async validator list.
	         */
	        AbstractControl.prototype.clearAsyncValidators = function () { this.asyncValidator = null; };
	        /**
	         * Marks the control as `touched`.
	         *
	         * This will also mark all direct ancestors as `touched` to maintain
	         * the model.
	         */
	        AbstractControl.prototype.markAsTouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = true;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `untouched`.
	         *
	         * If the control has any children, it will also mark all children as `untouched`
	         * to maintain the model, and re-calculate the `touched` status of all parent
	         * controls.
	         */
	        AbstractControl.prototype.markAsUntouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = false;
	            this._forEachChild(function (control) { control.markAsUntouched({ onlySelf: true }); });
	            if (this._parent && !onlySelf) {
	                this._parent._updateTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `dirty`.
	         *
	         * This will also mark all direct ancestors as `dirty` to maintain
	         * the model.
	         */
	        AbstractControl.prototype.markAsDirty = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = false;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsDirty({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `pristine`.
	         *
	         * If the control has any children, it will also mark all children as `pristine`
	         * to maintain the model, and re-calculate the `pristine` status of all parent
	         * controls.
	         */
	        AbstractControl.prototype.markAsPristine = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = true;
	            this._forEachChild(function (control) { control.markAsPristine({ onlySelf: true }); });
	            if (this._parent && !onlySelf) {
	                this._parent._updatePristine({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `pending`.
	         */
	        AbstractControl.prototype.markAsPending = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._status = PENDING;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsPending({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Disables the control. This means the control will be exempt from validation checks and
	         * excluded from the aggregate value of any parent. Its status is `DISABLED`.
	         *
	         * If the control has children, all children will be disabled to maintain the model.
	         */
	        AbstractControl.prototype.disable = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._status = DISABLED;
	            this._errors = null;
	            this._forEachChild(function (control) { control.disable({ onlySelf: true }); });
	            this._updateValue();
	            if (emitEvent !== false) {
	                this._valueChanges.emit(this._value);
	                this._statusChanges.emit(this._status);
	            }
	            this._updateAncestors(onlySelf);
	            this._onDisabledChange.forEach(function (changeFn) { return changeFn(true); });
	        };
	        /**
	         * Enables the control. This means the control will be included in validation checks and
	         * the aggregate value of its parent. Its status is re-calculated based on its value and
	         * its validators.
	         *
	         * If the control has children, all children will be enabled.
	         */
	        AbstractControl.prototype.enable = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._status = VALID;
	            this._forEachChild(function (control) { control.enable({ onlySelf: true }); });
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
	            this._updateAncestors(onlySelf);
	            this._onDisabledChange.forEach(function (changeFn) { return changeFn(false); });
	        };
	        AbstractControl.prototype._updateAncestors = function (onlySelf) {
	            if (this._parent && !onlySelf) {
	                this._parent.updateValueAndValidity();
	                this._parent._updatePristine();
	                this._parent._updateTouched();
	            }
	        };
	        AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
	        /**
	         * Re-calculates the value and validation status of the control.
	         *
	         * By default, it will also update the value and validity of its ancestors.
	         */
	        AbstractControl.prototype.updateValueAndValidity = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._setInitialStatus();
	            this._updateValue();
	            if (this.enabled) {
	                this._errors = this._runValidator();
	                this._status = this._calculateStatus();
	                if (this._status === VALID || this._status === PENDING) {
	                    this._runAsyncValidator(emitEvent);
	                }
	            }
	            if (emitEvent !== false) {
	                this._valueChanges.emit(this._value);
	                this._statusChanges.emit(this._status);
	            }
	            if (this._parent && !onlySelf) {
	                this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            }
	        };
	        /** @internal */
	        AbstractControl.prototype._updateTreeValidity = function (_a) {
	            var emitEvent = (_a === void 0 ? { emitEvent: true } : _a).emitEvent;
	            this._forEachChild(function (ctrl) { return ctrl._updateTreeValidity({ emitEvent: emitEvent }); });
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
	        };
	        AbstractControl.prototype._setInitialStatus = function () { this._status = this._allControlsDisabled() ? DISABLED : VALID; };
	        AbstractControl.prototype._runValidator = function () {
	            return this.validator ? this.validator(this) : null;
	        };
	        AbstractControl.prototype._runAsyncValidator = function (emitEvent) {
	            var _this = this;
	            if (this.asyncValidator) {
	                this._status = PENDING;
	                this._cancelExistingSubscription();
	                var obs = toObservable(this.asyncValidator(this));
	                this._asyncValidationSubscription =
	                    obs.subscribe({ next: function (res) { return _this.setErrors(res, { emitEvent: emitEvent }); } });
	            }
	        };
	        AbstractControl.prototype._cancelExistingSubscription = function () {
	            if (this._asyncValidationSubscription) {
	                this._asyncValidationSubscription.unsubscribe();
	            }
	        };
	        /**
	         * Sets errors on a form control.
	         *
	         * This is used when validations are run manually by the user, rather than automatically.
	         *
	         * Calling `setErrors` will also update the validity of the parent control.
	         *
	         * ### Example
	         *
	         * ```
	         * const login = new FormControl("someLogin");
	         * login.setErrors({
	         *   "notUnique": true
	         * });
	         *
	         * expect(login.valid).toEqual(false);
	         * expect(login.errors).toEqual({"notUnique": true});
	         *
	         * login.setValue("someOtherLogin");
	         *
	         * expect(login.valid).toEqual(true);
	         * ```
	         */
	        AbstractControl.prototype.setErrors = function (errors, _a) {
	            var emitEvent = (_a === void 0 ? {} : _a).emitEvent;
	            this._errors = errors;
	            this._updateControlsErrors(emitEvent !== false);
	        };
	        /**
	         * Retrieves a child control given the control's name or path.
	         *
	         * Paths can be passed in as an array or a string delimited by a dot.
	         *
	         * To get a control nested within a `person` sub-group:
	         *
	         * * `this.form.get('person.name');`
	         *
	         * -OR-
	         *
	         * * `this.form.get(['person', 'name']);`
	         */
	        AbstractControl.prototype.get = function (path) { return _find(this, path, '.'); };
	        /**
	         * Returns true if the control with the given path has the error specified. Otherwise
	         * returns null or undefined.
	         *
	         * If no path is given, it checks for the error on the present control.
	         */
	        AbstractControl.prototype.getError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            var control = path ? this.get(path) : this;
	            return control && control._errors ? control._errors[errorCode] : null;
	        };
	        /**
	         * Returns true if the control with the given path has the error specified. Otherwise
	         * returns false.
	         *
	         * If no path is given, it checks for the error on the present control.
	         */
	        AbstractControl.prototype.hasError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return !!this.getError(errorCode, path);
	        };
	        Object.defineProperty(AbstractControl.prototype, "root", {
	            /**
	             * Retrieves the top-level ancestor of this control.
	             */
	            get: function () {
	                var x = this;
	                while (x._parent) {
	                    x = x._parent;
	                }
	                return x;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        AbstractControl.prototype._updateControlsErrors = function (emitEvent) {
	            this._status = this._calculateStatus();
	            if (emitEvent) {
	                this._statusChanges.emit(this._status);
	            }
	            if (this._parent) {
	                this._parent._updateControlsErrors(emitEvent);
	            }
	        };
	        /** @internal */
	        AbstractControl.prototype._initObservables = function () {
	            this._valueChanges = new EventEmitter();
	            this._statusChanges = new EventEmitter();
	        };
	        AbstractControl.prototype._calculateStatus = function () {
	            if (this._allControlsDisabled())
	                return DISABLED;
	            if (this._errors)
	                return INVALID;
	            if (this._anyControlsHaveStatus(PENDING))
	                return PENDING;
	            if (this._anyControlsHaveStatus(INVALID))
	                return INVALID;
	            return VALID;
	        };
	        /** @internal */
	        AbstractControl.prototype._anyControlsHaveStatus = function (status) {
	            return this._anyControls(function (control) { return control.status === status; });
	        };
	        /** @internal */
	        AbstractControl.prototype._anyControlsDirty = function () {
	            return this._anyControls(function (control) { return control.dirty; });
	        };
	        /** @internal */
	        AbstractControl.prototype._anyControlsTouched = function () {
	            return this._anyControls(function (control) { return control.touched; });
	        };
	        /** @internal */
	        AbstractControl.prototype._updatePristine = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = !this._anyControlsDirty();
	            if (this._parent && !onlySelf) {
	                this._parent._updatePristine({ onlySelf: onlySelf });
	            }
	        };
	        /** @internal */
	        AbstractControl.prototype._updateTouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = this._anyControlsTouched();
	            if (this._parent && !onlySelf) {
	                this._parent._updateTouched({ onlySelf: onlySelf });
	            }
	        };
	        /** @internal */
	        AbstractControl.prototype._isBoxedValue = function (formState) {
	            return typeof formState === 'object' && formState !== null &&
	                Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
	        };
	        /** @internal */
	        AbstractControl.prototype._registerOnCollectionChange = function (fn) { this._onCollectionChange = fn; };
	        return AbstractControl;
	    }());
	    /**
	     * @whatItDoes Tracks the value and validation status of an individual form control.
	     *
	     * It is one of the three fundamental building blocks of Angular forms, along with
	     * {@link FormGroup} and {@link FormArray}.
	     *
	     * @howToUse
	     *
	     * When instantiating a {@link FormControl}, you can pass in an initial value as the
	     * first argument. Example:
	     *
	     * ```ts
	     * const ctrl = new FormControl('some value');
	     * console.log(ctrl.value);     // 'some value'
	     *```
	     *
	     * You can also initialize the control with a form state object on instantiation,
	     * which includes both the value and whether or not the control is disabled.
	     * You can't use the value key without the disabled key; both are required
	     * to use this way of initialization.
	     *
	     * ```ts
	     * const ctrl = new FormControl({value: 'n/a', disabled: true});
	     * console.log(ctrl.value);     // 'n/a'
	     * console.log(ctrl.status);   // 'DISABLED'
	     * ```
	     *
	     * To include a sync validator (or an array of sync validators) with the control,
	     * pass it in as the second argument. Async validators are also supported, but
	     * have to be passed in separately as the third arg.
	     *
	     * ```ts
	     * const ctrl = new FormControl('', Validators.required);
	     * console.log(ctrl.value);     // ''
	     * console.log(ctrl.status);   // 'INVALID'
	     * ```
	     *
	     * See its superclass, {@link AbstractControl}, for more properties and methods.
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * @stable
	     */
	    var FormControl = (function (_super) {
	        __extends$6(FormControl, _super);
	        function FormControl(formState, validator, asyncValidator) {
	            if (formState === void 0) { formState = null; }
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator));
	            /** @internal */
	            this._onChange = [];
	            this._applyFormState(formState);
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	            this._initObservables();
	        }
	        /**
	         * Set the value of the form control to `value`.
	         *
	         * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`
	         * and not its parent component. This defaults to false.
	         *
	         * If `emitEvent` is `true`, this
	         * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults
	         * to true (as it falls through to `updateValueAndValidity`).
	         *
	         * If `emitModelToViewChange` is `true`, the view will be notified about the new value
	         * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
	         * specified.
	         *
	         * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the
	         * model.  This is the default behavior if `emitViewToModelChange` is not specified.
	         */
	        FormControl.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange, emitViewToModelChange = _b.emitViewToModelChange;
	            this._value = value;
	            if (this._onChange.length && emitModelToViewChange !== false) {
	                this._onChange.forEach(function (changeFn) { return changeFn(_this._value, emitViewToModelChange !== false); });
	            }
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Patches the value of a control.
	         *
	         * This function is functionally the same as {@link FormControl.setValue} at this level.
	         * It exists for symmetry with {@link FormGroup.patchValue} on `FormGroups` and `FormArrays`,
	         * where it does behave differently.
	         */
	        FormControl.prototype.patchValue = function (value, options) {
	            if (options === void 0) { options = {}; }
	            this.setValue(value, options);
	        };
	        /**
	         * Resets the form control. This means by default:
	         *
	         * * it is marked as `pristine`
	         * * it is marked as `untouched`
	         * * value is set to null
	         *
	         * You can also reset to a specific form state by passing through a standalone
	         * value or a form state object that contains both a value and a disabled state
	         * (these are the only two properties that cannot be calculated).
	         *
	         * Ex:
	         *
	         * ```ts
	         * this.control.reset('Nancy');
	         *
	         * console.log(this.control.value);  // 'Nancy'
	         * ```
	         *
	         * OR
	         *
	         * ```
	         * this.control.reset({value: 'Nancy', disabled: true});
	         *
	         * console.log(this.control.value);  // 'Nancy'
	         * console.log(this.control.status);  // 'DISABLED'
	         * ```
	         */
	        FormControl.prototype.reset = function (formState, _a) {
	            if (formState === void 0) { formState = null; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._applyFormState(formState);
	            this.markAsPristine({ onlySelf: onlySelf });
	            this.markAsUntouched({ onlySelf: onlySelf });
	            this.setValue(this._value, { onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * @internal
	         */
	        FormControl.prototype._updateValue = function () { };
	        /**
	         * @internal
	         */
	        FormControl.prototype._anyControls = function (condition) { return false; };
	        /**
	         * @internal
	         */
	        FormControl.prototype._allControlsDisabled = function () { return this.disabled; };
	        /**
	         * Register a listener for change events.
	         */
	        FormControl.prototype.registerOnChange = function (fn) { this._onChange.push(fn); };
	        /**
	         * @internal
	         */
	        FormControl.prototype._clearChangeFns = function () {
	            this._onChange = [];
	            this._onDisabledChange = [];
	            this._onCollectionChange = function () { };
	        };
	        /**
	         * Register a listener for disabled events.
	         */
	        FormControl.prototype.registerOnDisabledChange = function (fn) {
	            this._onDisabledChange.push(fn);
	        };
	        /**
	         * @internal
	         */
	        FormControl.prototype._forEachChild = function (cb) { };
	        FormControl.prototype._applyFormState = function (formState) {
	            if (this._isBoxedValue(formState)) {
	                this._value = formState.value;
	                formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :
	                    this.enable({ onlySelf: true, emitEvent: false });
	            }
	            else {
	                this._value = formState;
	            }
	        };
	        return FormControl;
	    }(AbstractControl));
	    /**
	     * @whatItDoes Tracks the value and validity state of a group of {@link FormControl}
	     * instances.
	     *
	     * A `FormGroup` aggregates the values of each child {@link FormControl} into one object,
	     * with each control name as the key.  It calculates its status by reducing the statuses
	     * of its children. For example, if one of the controls in a group is invalid, the entire
	     * group becomes invalid.
	     *
	     * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,
	     * along with {@link FormControl} and {@link FormArray}.
	     *
	     * @howToUse
	     *
	     * When instantiating a {@link FormGroup}, pass in a collection of child controls as the first
	     * argument. The key for each child will be the name under which it is registered.
	     *
	     * ### Example
	     *
	     * ```
	     * const form = new FormGroup({
	     *   first: new FormControl('Nancy', Validators.minLength(2)),
	     *   last: new FormControl('Drew'),
	     * });
	     *
	     * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
	     * console.log(form.status);  // 'VALID'
	     * ```
	     *
	     * You can also include group-level validators as the second arg, or group-level async
	     * validators as the third arg. These come in handy when you want to perform validation
	     * that considers the value of more than one child control.
	     *
	     * ### Example
	     *
	     * ```
	     * const form = new FormGroup({
	     *   password: new FormControl('', Validators.minLength(2)),
	     *   passwordConfirm: new FormControl('', Validators.minLength(2)),
	     * }, passwordMatchValidator);
	     *
	     *
	     * function passwordMatchValidator(g: FormGroup) {
	     *    return g.get('password').value === g.get('passwordConfirm').value
	     *       ? null : {'mismatch': true};
	     * }
	     * ```
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * @stable
	     */
	    var FormGroup = (function (_super) {
	        __extends$6(FormGroup, _super);
	        function FormGroup(controls, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, validator, asyncValidator);
	            this.controls = controls;
	            this._initObservables();
	            this._setUpControls();
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        /**
	         * Registers a control with the group's list of controls.
	         *
	         * This method does not update value or validity of the control, so for
	         * most cases you'll want to use {@link FormGroup.addControl} instead.
	         */
	        FormGroup.prototype.registerControl = function (name, control) {
	            if (this.controls[name])
	                return this.controls[name];
	            this.controls[name] = control;
	            control.setParent(this);
	            control._registerOnCollectionChange(this._onCollectionChange);
	            return control;
	        };
	        /**
	         * Add a control to this group.
	         */
	        FormGroup.prototype.addControl = function (name, control) {
	            this.registerControl(name, control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Remove a control from this group.
	         */
	        FormGroup.prototype.removeControl = function (name) {
	            if (this.controls[name])
	                this.controls[name]._registerOnCollectionChange(function () { });
	            delete (this.controls[name]);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Replace an existing control.
	         */
	        FormGroup.prototype.setControl = function (name, control) {
	            if (this.controls[name])
	                this.controls[name]._registerOnCollectionChange(function () { });
	            delete (this.controls[name]);
	            if (control)
	                this.registerControl(name, control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Check whether there is an enabled control with the given name in the group.
	         *
	         * It will return false for disabled controls. If you'd like to check for
	         * existence in the group only, use {@link AbstractControl.get} instead.
	         */
	        FormGroup.prototype.contains = function (controlName) {
	            return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
	        };
	        /**
	         *  Sets the value of the {@link FormGroup}. It accepts an object that matches
	         *  the structure of the group, with control names as keys.
	         *
	         * This method performs strict checks, so it will throw an error if you try
	         * to set the value of a control that doesn't exist or if you exclude the
	         * value of a control.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const form = new FormGroup({
	         *     first: new FormControl(),
	         *     last: new FormControl()
	         *  });
	         *  console.log(form.value);   // {first: null, last: null}
	         *
	         *  form.setValue({first: 'Nancy', last: 'Drew'});
	         *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
	         *
	         *  ```
	         */
	        FormGroup.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._checkAllValuesPresent(value);
	            Object.keys(value).forEach(function (name) {
	                _this._throwIfControlMissing(name);
	                _this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         *  Patches the value of the {@link FormGroup}. It accepts an object with control
	         *  names as keys, and will do its best to match the values to the correct controls
	         *  in the group.
	         *
	         *  It accepts both super-sets and sub-sets of the group without throwing an error.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const form = new FormGroup({
	         *     first: new FormControl(),
	         *     last: new FormControl()
	         *  });
	         *  console.log(form.value);   // {first: null, last: null}
	         *
	         *  form.patchValue({first: 'Nancy'});
	         *  console.log(form.value);   // {first: 'Nancy', last: null}
	         *
	         *  ```
	         */
	        FormGroup.prototype.patchValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            Object.keys(value).forEach(function (name) {
	                if (_this.controls[name]) {
	                    _this.controls[name].patchValue(value[name], { onlySelf: true, emitEvent: emitEvent });
	                }
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Resets the {@link FormGroup}. This means by default:
	         *
	         * * The group and all descendants are marked `pristine`
	         * * The group and all descendants are marked `untouched`
	         * * The value of all descendants will be null or null maps
	         *
	         * You can also reset to a specific form state by passing in a map of states
	         * that matches the structure of your form, with control names as keys. The state
	         * can be a standalone value or a form state object with both a value and a disabled
	         * status.
	         *
	         * ### Example
	         *
	         * ```ts
	         * this.form.reset({first: 'name', last: 'last name'});
	         *
	         * console.log(this.form.value);  // {first: 'name', last: 'last name'}
	         * ```
	         *
	         * - OR -
	         *
	         * ```
	         * this.form.reset({
	         *   first: {value: 'name', disabled: true},
	         *   last: 'last'
	         * });
	         *
	         * console.log(this.form.value);  // {first: 'name', last: 'last name'}
	         * console.log(this.form.get('first').status);  // 'DISABLED'
	         * ```
	         */
	        FormGroup.prototype.reset = function (value, _a) {
	            if (value === void 0) { value = {}; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._forEachChild(function (control, name) {
	                control.reset(value[name], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            this._updatePristine({ onlySelf: onlySelf });
	            this._updateTouched({ onlySelf: onlySelf });
	        };
	        /**
	         * The aggregate value of the {@link FormGroup}, including any disabled controls.
	         *
	         * If you'd like to include all values regardless of disabled status, use this method.
	         * Otherwise, the `value` property is the best way to get the value of the group.
	         */
	        FormGroup.prototype.getRawValue = function () {
	            return this._reduceChildren({}, function (acc, control, name) {
	                acc[name] = control.value;
	                return acc;
	            });
	        };
	        /** @internal */
	        FormGroup.prototype._throwIfControlMissing = function (name) {
	            if (!Object.keys(this.controls).length) {
	                throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
	            }
	            if (!this.controls[name]) {
	                throw new Error("Cannot find form control with name: " + name + ".");
	            }
	        };
	        /** @internal */
	        FormGroup.prototype._forEachChild = function (cb) {
	            var _this = this;
	            Object.keys(this.controls).forEach(function (k) { return cb(_this.controls[k], k); });
	        };
	        /** @internal */
	        FormGroup.prototype._setUpControls = function () {
	            var _this = this;
	            this._forEachChild(function (control) {
	                control.setParent(_this);
	                control._registerOnCollectionChange(_this._onCollectionChange);
	            });
	        };
	        /** @internal */
	        FormGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
	        /** @internal */
	        FormGroup.prototype._anyControls = function (condition) {
	            var _this = this;
	            var res = false;
	            this._forEachChild(function (control, name) {
	                res = res || (_this.contains(name) && condition(control));
	            });
	            return res;
	        };
	        /** @internal */
	        FormGroup.prototype._reduceValue = function () {
	            var _this = this;
	            return this._reduceChildren({}, function (acc, control, name) {
	                if (control.enabled || _this.disabled) {
	                    acc[name] = control.value;
	                }
	                return acc;
	            });
	        };
	        /** @internal */
	        FormGroup.prototype._reduceChildren = function (initValue, fn) {
	            var res = initValue;
	            this._forEachChild(function (control, name) { res = fn(res, control, name); });
	            return res;
	        };
	        /** @internal */
	        FormGroup.prototype._allControlsDisabled = function () {
	            for (var _i = 0, _a = Object.keys(this.controls); _i < _a.length; _i++) {
	                var controlName = _a[_i];
	                if (this.controls[controlName].enabled) {
	                    return false;
	                }
	            }
	            return Object.keys(this.controls).length > 0 || this.disabled;
	        };
	        /** @internal */
	        FormGroup.prototype._checkAllValuesPresent = function (value) {
	            this._forEachChild(function (control, name) {
	                if (value[name] === undefined) {
	                    throw new Error("Must supply a value for form control with name: '" + name + "'.");
	                }
	            });
	        };
	        return FormGroup;
	    }(AbstractControl));
	    /**
	     * @whatItDoes Tracks the value and validity state of an array of {@link FormControl}
	     * instances.
	     *
	     * A `FormArray` aggregates the values of each child {@link FormControl} into an array.
	     * It calculates its status by reducing the statuses of its children. For example, if one of
	     * the controls in a `FormArray` is invalid, the entire array becomes invalid.
	     *
	     * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,
	     * along with {@link FormControl} and {@link FormGroup}.
	     *
	     * @howToUse
	     *
	     * When instantiating a {@link FormArray}, pass in an array of child controls as the first
	     * argument.
	     *
	     * ### Example
	     *
	     * ```
	     * const arr = new FormArray([
	     *   new FormControl('Nancy', Validators.minLength(2)),
	     *   new FormControl('Drew'),
	     * ]);
	     *
	     * console.log(arr.value);   // ['Nancy', 'Drew']
	     * console.log(arr.status);  // 'VALID'
	     * ```
	     *
	     * You can also include array-level validators as the second arg, or array-level async
	     * validators as the third arg. These come in handy when you want to perform validation
	     * that considers the value of more than one child control.
	     *
	     * ### Adding or removing controls
	     *
	     * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
	     * in `FormArray` itself. These methods ensure the controls are properly tracked in the
	     * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
	     * the `FormArray` directly, as that will result in strange and unexpected behavior such
	     * as broken change detection.
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * @stable
	     */
	    var FormArray = (function (_super) {
	        __extends$6(FormArray, _super);
	        function FormArray(controls, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, validator, asyncValidator);
	            this.controls = controls;
	            this._initObservables();
	            this._setUpControls();
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        /**
	         * Get the {@link AbstractControl} at the given `index` in the array.
	         */
	        FormArray.prototype.at = function (index) { return this.controls[index]; };
	        /**
	         * Insert a new {@link AbstractControl} at the end of the array.
	         */
	        FormArray.prototype.push = function (control) {
	            this.controls.push(control);
	            this._registerControl(control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Insert a new {@link AbstractControl} at the given `index` in the array.
	         */
	        FormArray.prototype.insert = function (index, control) {
	            this.controls.splice(index, 0, control);
	            this._registerControl(control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Remove the control at the given `index` in the array.
	         */
	        FormArray.prototype.removeAt = function (index) {
	            if (this.controls[index])
	                this.controls[index]._registerOnCollectionChange(function () { });
	            this.controls.splice(index, 1);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Replace an existing control.
	         */
	        FormArray.prototype.setControl = function (index, control) {
	            if (this.controls[index])
	                this.controls[index]._registerOnCollectionChange(function () { });
	            this.controls.splice(index, 1);
	            if (control) {
	                this.controls.splice(index, 0, control);
	                this._registerControl(control);
	            }
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        Object.defineProperty(FormArray.prototype, "length", {
	            /**
	             * Length of the control array.
	             */
	            get: function () { return this.controls.length; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         *  Sets the value of the {@link FormArray}. It accepts an array that matches
	         *  the structure of the control.
	         *
	         * This method performs strict checks, so it will throw an error if you try
	         * to set the value of a control that doesn't exist or if you exclude the
	         * value of a control.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const arr = new FormArray([
	         *     new FormControl(),
	         *     new FormControl()
	         *  ]);
	         *  console.log(arr.value);   // [null, null]
	         *
	         *  arr.setValue(['Nancy', 'Drew']);
	         *  console.log(arr.value);   // ['Nancy', 'Drew']
	         *  ```
	         */
	        FormArray.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._checkAllValuesPresent(value);
	            value.forEach(function (newValue, index) {
	                _this._throwIfControlMissing(index);
	                _this.at(index).setValue(newValue, { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         *  Patches the value of the {@link FormArray}. It accepts an array that matches the
	         *  structure of the control, and will do its best to match the values to the correct
	         *  controls in the group.
	         *
	         *  It accepts both super-sets and sub-sets of the array without throwing an error.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const arr = new FormArray([
	         *     new FormControl(),
	         *     new FormControl()
	         *  ]);
	         *  console.log(arr.value);   // [null, null]
	         *
	         *  arr.patchValue(['Nancy']);
	         *  console.log(arr.value);   // ['Nancy', null]
	         *  ```
	         */
	        FormArray.prototype.patchValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            value.forEach(function (newValue, index) {
	                if (_this.at(index)) {
	                    _this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: emitEvent });
	                }
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Resets the {@link FormArray}. This means by default:
	         *
	         * * The array and all descendants are marked `pristine`
	         * * The array and all descendants are marked `untouched`
	         * * The value of all descendants will be null or null maps
	         *
	         * You can also reset to a specific form state by passing in an array of states
	         * that matches the structure of the control. The state can be a standalone value
	         * or a form state object with both a value and a disabled status.
	         *
	         * ### Example
	         *
	         * ```ts
	         * this.arr.reset(['name', 'last name']);
	         *
	         * console.log(this.arr.value);  // ['name', 'last name']
	         * ```
	         *
	         * - OR -
	         *
	         * ```
	         * this.arr.reset([
	         *   {value: 'name', disabled: true},
	         *   'last'
	         * ]);
	         *
	         * console.log(this.arr.value);  // ['name', 'last name']
	         * console.log(this.arr.get(0).status);  // 'DISABLED'
	         * ```
	         */
	        FormArray.prototype.reset = function (value, _a) {
	            if (value === void 0) { value = []; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._forEachChild(function (control, index) {
	                control.reset(value[index], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            this._updatePristine({ onlySelf: onlySelf });
	            this._updateTouched({ onlySelf: onlySelf });
	        };
	        /**
	         * The aggregate value of the array, including any disabled controls.
	         *
	         * If you'd like to include all values regardless of disabled status, use this method.
	         * Otherwise, the `value` property is the best way to get the value of the array.
	         */
	        FormArray.prototype.getRawValue = function () { return this.controls.map(function (control) { return control.value; }); };
	        /** @internal */
	        FormArray.prototype._throwIfControlMissing = function (index) {
	            if (!this.controls.length) {
	                throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
	            }
	            if (!this.at(index)) {
	                throw new Error("Cannot find form control at index " + index);
	            }
	        };
	        /** @internal */
	        FormArray.prototype._forEachChild = function (cb) {
	            this.controls.forEach(function (control, index) { cb(control, index); });
	        };
	        /** @internal */
	        FormArray.prototype._updateValue = function () {
	            var _this = this;
	            this._value = this.controls.filter(function (control) { return control.enabled || _this.disabled; })
	                .map(function (control) { return control.value; });
	        };
	        /** @internal */
	        FormArray.prototype._anyControls = function (condition) {
	            return this.controls.some(function (control) { return control.enabled && condition(control); });
	        };
	        /** @internal */
	        FormArray.prototype._setUpControls = function () {
	            var _this = this;
	            this._forEachChild(function (control) { return _this._registerControl(control); });
	        };
	        /** @internal */
	        FormArray.prototype._checkAllValuesPresent = function (value) {
	            this._forEachChild(function (control, i) {
	                if (value[i] === undefined) {
	                    throw new Error("Must supply a value for form control at index: " + i + ".");
	                }
	            });
	        };
	        /** @internal */
	        FormArray.prototype._allControlsDisabled = function () {
	            for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {
	                var control = _a[_i];
	                if (control.enabled)
	                    return false;
	            }
	            return this.controls.length > 0 || this.disabled;
	        };
	        FormArray.prototype._registerControl = function (control) {
	            control.setParent(this);
	            control._registerOnCollectionChange(this._onCollectionChange);
	        };
	        return FormArray;
	    }(AbstractControl));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var formDirectiveProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return NgForm; })
	    };
	    var resolvedPromise = Promise.resolve(null);
	    /**
	     * @whatItDoes Creates a top-level {@link FormGroup} instance and binds it to a form
	     * to track aggregate form value and validation status.
	     *
	     * @howToUse
	     *
	     * As soon as you import the `FormsModule`, this directive becomes active by default on
	     * all `<form>` tags.  You don't need to add a special selector.
	     *
	     * You can export the directive into a local template variable using `ngForm` as the key
	     * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
	     * {@link FormGroup} instance are duplicated on the directive itself, so a reference to it
	     * will give you access to the aggregate value and validity status of the form, as well as
	     * user interaction properties like `dirty` and `touched`.
	     *
	     * To register child controls with the form, you'll want to use {@link NgModel} with a
	     * `name` attribute.  You can also use {@link NgModelGroup} if you'd like to create
	     * sub-groups within the form.
	     *
	     * You can listen to the directive's `ngSubmit` event to be notified when the user has
	     * triggered a form submission. The `ngSubmit` event will be emitted with the original form
	     * submission event.
	     *
	     * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * * **NgModule**: `FormsModule`
	     *
	     *  @stable
	     */
	    var NgForm = (function (_super) {
	        __extends$4(NgForm, _super);
	        function NgForm(validators, asyncValidators) {
	            _super.call(this);
	            this._submitted = false;
	            this.ngSubmit = new EventEmitter();
	            this.form =
	                new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
	        }
	        Object.defineProperty(NgForm.prototype, "submitted", {
	            get: function () { return this._submitted; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "formDirective", {
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "control", {
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "path", {
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "controls", {
	            get: function () { return this.form.controls; },
	            enumerable: true,
	            configurable: true
	        });
	        NgForm.prototype.addControl = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var container = _this._findContainer(dir.path);
	                dir._control = container.registerControl(dir.name, dir.control);
	                setUpControl(dir.control, dir);
	                dir.control.updateValueAndValidity({ emitEvent: false });
	            });
	        };
	        NgForm.prototype.getControl = function (dir) { return this.form.get(dir.path); };
	        NgForm.prototype.removeControl = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var container = _this._findContainer(dir.path);
	                if (container) {
	                    container.removeControl(dir.name);
	                }
	            });
	        };
	        NgForm.prototype.addFormGroup = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var container = _this._findContainer(dir.path);
	                var group = new FormGroup({});
	                setUpFormContainer(group, dir);
	                container.registerControl(dir.name, group);
	                group.updateValueAndValidity({ emitEvent: false });
	            });
	        };
	        NgForm.prototype.removeFormGroup = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var container = _this._findContainer(dir.path);
	                if (container) {
	                    container.removeControl(dir.name);
	                }
	            });
	        };
	        NgForm.prototype.getFormGroup = function (dir) { return this.form.get(dir.path); };
	        NgForm.prototype.updateModel = function (dir, value) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var ctrl = _this.form.get(dir.path);
	                ctrl.setValue(value);
	            });
	        };
	        NgForm.prototype.setValue = function (value) { this.control.setValue(value); };
	        NgForm.prototype.onSubmit = function ($event) {
	            this._submitted = true;
	            this.ngSubmit.emit($event);
	            return false;
	        };
	        NgForm.prototype.onReset = function () { this.resetForm(); };
	        NgForm.prototype.resetForm = function (value) {
	            if (value === void 0) { value = undefined; }
	            this.form.reset(value);
	            this._submitted = false;
	        };
	        /** @internal */
	        NgForm.prototype._findContainer = function (path) {
	            path.pop();
	            return path.length ? this.form.get(path) : this.form;
	        };
	        NgForm.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',
	                        providers: [formDirectiveProvider],
	                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
	                        outputs: ['ngSubmit'],
	                        exportAs: 'ngForm'
	                    },] },
	        ];
	        /** @nocollapse */
	        NgForm.ctorParameters = [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ];
	        return NgForm;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var Examples = {
	        formControlName: "\n    <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });",
	        formGroupName: "\n    <div [formGroup]=\"myGroup\">\n       <div formGroupName=\"person\">\n          <input formControlName=\"firstName\">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });",
	        formArrayName: "\n    <div [formGroup]=\"myGroup\">\n      <div formArrayName=\"cities\">\n        <div *ngFor=\"let city of cityArray.controls; let i=index\">\n          <input [formControlName]=\"i\">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl('SF')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });",
	        ngModelGroup: "\n    <form>\n       <div ngModelGroup=\"person\">\n          <input [(ngModel)]=\"person.name\" name=\"firstName\">\n       </div>\n    </form>",
	        ngModelWithFormGroup: "\n    <div [formGroup]=\"myGroup\">\n       <input formControlName=\"firstName\">\n       <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n    </div>\n  "
	    };
	
	    var TemplateDrivenErrors = (function () {
	        function TemplateDrivenErrors() {
	        }
	        TemplateDrivenErrors.modelParentException = function () {
	            throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup's partner directive \"formControlName\" instead.  Example:\n\n      " + Examples.formControlName + "\n\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n      Example:\n\n      " + Examples.ngModelWithFormGroup);
	        };
	        TemplateDrivenErrors.formGroupNameException = function () {
	            throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      " + Examples.formGroupName + "\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      " + Examples.ngModelGroup);
	        };
	        TemplateDrivenErrors.missingNameException = function () {
	            throw new Error("If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as 'standalone' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]=\"person.firstName\" name=\"first\">\n      Example 2: <input [(ngModel)]=\"person.firstName\" [ngModelOptions]=\"{standalone: true}\">");
	        };
	        TemplateDrivenErrors.modelGroupParentException = function () {
	            throw new Error("\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      " + Examples.formGroupName + "\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      " + Examples.ngModelGroup);
	        };
	        return TemplateDrivenErrors;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var modelGroupProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return NgModelGroup; })
	    };
	    /**
	     * @whatItDoes Creates and binds a {@link FormGroup} instance to a DOM element.
	     *
	     * @howToUse
	     *
	     * This directive can only be used as a child of {@link NgForm} (or in other words,
	     * within `<form>` tags).
	     *
	     * Use this directive if you'd like to create a sub-group within a form. This can
	     * come in handy if you want to validate a sub-group of your form separately from
	     * the rest of your form, or if some values in your domain model make more sense to
	     * consume together in a nested object.
	     *
	     * Pass in the name you'd like this sub-group to have and it will become the key
	     * for the sub-group in the form's full value. You can also export the directive into
	     * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
	     *
	     * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * * **NgModule**: `FormsModule`
	     *
	     * @stable
	     */
	    var NgModelGroup = (function (_super) {
	        __extends$8(NgModelGroup, _super);
	        function NgModelGroup(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /** @internal */
	        NgModelGroup.prototype._checkParentType = function () {
	            if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
	                TemplateDrivenErrors.modelGroupParentException();
	            }
	        };
	        NgModelGroup.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' },] },
	        ];
	        /** @nocollapse */
	        NgModelGroup.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ];
	        NgModelGroup.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['ngModelGroup',] },],
	        };
	        return NgModelGroup;
	    }(AbstractFormGroupDirective));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var formControlBinding = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return NgModel; })
	    };
	    /**
	     * `ngModel` forces an additional change detection run when its inputs change:
	     * E.g.:
	     * ```
	     * <div>{{myModel.valid}}</div>
	     * <input [(ngModel)]="myValue" #myModel="ngModel">
	     * ```
	     * I.e. `ngModel` can export itself on the element and then be used in the template.
	     * Normally, this would result in expressions before the `input` that use the exported directive
	     * to have and old value as they have been
	     * dirty checked before. As this is a very common case for `ngModel`, we added this second change
	     * detection run.
	     *
	     * Notes:
	     * - this is just one extra run no matter how many `ngModel` have been changed.
	     * - this is a general problem when using `exportAs` for directives!
	     */
	    var resolvedPromise$1 = Promise.resolve(null);
	    /**
	     * @whatItDoes Creates a {@link FormControl} instance from a domain model and binds it
	     * to a form control element.
	     *
	     * The {@link FormControl} instance will track the value, user interaction, and
	     * validation status of the control and keep the view synced with the model. If used
	     * within a parent form, the directive will also register itself with the form as a child
	     * control.
	     *
	     * @howToUse
	     *
	     * This directive can be used by itself or as part of a larger form. All you need is the
	     * `ngModel` selector to activate it.
	     *
	     * It accepts a domain model as an optional {@link @Input}. If you have a one-way binding
	     * to `ngModel` with `[]` syntax, changing the value of the domain model in the component
	     * class will set the value in the view. If you have a two-way binding with `[()]` syntax
	     * (also known as 'banana-box syntax'), the value in the UI will always be synced back to
	     * the domain model in your class as well.
	     *
	     * If you wish to inspect the properties of the associated {@link FormControl} (like
	     * validity state), you can also export the directive into a local template variable using
	     * `ngModel` as the key (ex: `#myVar="ngModel"`). You can then access the control using the
	     * directive's `control` property, but most properties you'll need (like `valid` and `dirty`)
	     * will fall through to the control anyway, so you can access them directly. You can see a
	     * full list of properties directly available in {@link AbstractControlDirective}.
	     *
	     * The following is an example of a simple standalone control using `ngModel`:
	     *
	     * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
	     *
	     * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
	     * so that the control can be registered with the parent form under that name.
	     *
	     * It's worth noting that in the context of a parent form, you often can skip one-way or
	     * two-way binding because the parent form will sync the value for you. You can access
	     * its properties by exporting it into a local template variable using `ngForm` (ex:
	     * `#f="ngForm"`). Then you can pass it where it needs to go on submit.
	     *
	     * If you do need to populate initial values into your form, using a one-way binding for
	     * `ngModel` tends to be sufficient as long as you use the exported form's value rather
	     * than the domain model's value on submit.
	     *
	     * Take a look at an example of using `ngModel` within a form:
	     *
	     * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
	     *
	     * To see `ngModel` examples with different form control types, see:
	     *
	     * * Radio buttons: {@link RadioControlValueAccessor}
	     * * Selects: {@link SelectControlValueAccessor}
	     *
	     * **npm package**: `@angular/forms`
	     *
	     * **NgModule**: `FormsModule`
	     *
	     *  @stable
	     */
	    var NgModel = (function (_super) {
	        __extends$7(NgModel, _super);
	        function NgModel(parent, validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            /** @internal */
	            this._control = new FormControl();
	            /** @internal */
	            this._registered = false;
	            this.update = new EventEmitter();
	            this._parent = parent;
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        NgModel.prototype.ngOnChanges = function (changes) {
	            this._checkForErrors();
	            if (!this._registered)
	                this._setUpControl();
	            if ('isDisabled' in changes) {
	                this._updateDisabled(changes);
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this._updateValue(this.model);
	                this.viewModel = this.model;
	            }
	        };
	        NgModel.prototype.ngOnDestroy = function () { this.formDirective && this.formDirective.removeControl(this); };
	        Object.defineProperty(NgModel.prototype, "control", {
	            get: function () { return this._control; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "path", {
	            get: function () {
	                return this._parent ? controlPath(this.name, this._parent) : [this.name];
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "formDirective", {
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "validator", {
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "asyncValidator", {
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        NgModel.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        NgModel.prototype._setUpControl = function () {
	            this._isStandalone() ? this._setUpStandalone() :
	                this.formDirective.addControl(this);
	            this._registered = true;
	        };
	        NgModel.prototype._isStandalone = function () {
	            return !this._parent || (this.options && this.options.standalone);
	        };
	        NgModel.prototype._setUpStandalone = function () {
	            setUpControl(this._control, this);
	            this._control.updateValueAndValidity({ emitEvent: false });
	        };
	        NgModel.prototype._checkForErrors = function () {
	            if (!this._isStandalone()) {
	                this._checkParentType();
	            }
	            this._checkName();
	        };
	        NgModel.prototype._checkParentType = function () {
	            if (!(this._parent instanceof NgModelGroup) &&
	                this._parent instanceof AbstractFormGroupDirective) {
	                TemplateDrivenErrors.formGroupNameException();
	            }
	            else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
	                TemplateDrivenErrors.modelParentException();
	            }
	        };
	        NgModel.prototype._checkName = function () {
	            if (this.options && this.options.name)
	                this.name = this.options.name;
	            if (!this._isStandalone() && !this.name) {
	                TemplateDrivenErrors.missingNameException();
	            }
	        };
	        NgModel.prototype._updateValue = function (value) {
	            var _this = this;
	            resolvedPromise$1.then(function () { _this.control.setValue(value, { emitViewToModelChange: false }); });
	        };
	        NgModel.prototype._updateDisabled = function (changes) {
	            var _this = this;
	            var disabledValue = changes['isDisabled'].currentValue;
	            var isDisabled = disabledValue === '' || (disabledValue && disabledValue !== 'false');
	            resolvedPromise$1.then(function () {
	                if (isDisabled && !_this.control.disabled) {
	                    _this.control.disable();
	                }
	                else if (!isDisabled && _this.control.disabled) {
	                    _this.control.enable();
	                }
	            });
	        };
	        NgModel.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[ngModel]:not([formControlName]):not([formControl])',
	                        providers: [formControlBinding],
	                        exportAs: 'ngModel'
	                    },] },
	        ];
	        /** @nocollapse */
	        NgModel.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ];
	        NgModel.propDecorators = {
	            'name': [{ type: _angular_core.Input },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'options': [{ type: _angular_core.Input, args: ['ngModelOptions',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	        };
	        return NgModel;
	    }(NgControl));
	
	    var ReactiveErrors = (function () {
	        function ReactiveErrors() {
	        }
	        ReactiveErrors.controlParentException = function () {
	            throw new Error("formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + Examples.formControlName);
	        };
	        ReactiveErrors.ngModelGroupException = function () {
	            throw new Error("formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        " + Examples.formGroupName + "\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        " + Examples.ngModelGroup);
	        };
	        ReactiveErrors.missingFormException = function () {
	            throw new Error("formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       " + Examples.formControlName);
	        };
	        ReactiveErrors.groupParentException = function () {
	            throw new Error("formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + Examples.formGroupName);
	        };
	        ReactiveErrors.arrayParentException = function () {
	            throw new Error("formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        " + Examples.formArrayName);
	        };
	        ReactiveErrors.disabledAttrWarning = function () {
	            console.warn("\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    ");
	        };
	        return ReactiveErrors;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$9 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var formControlBinding$1 = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return FormControlDirective; })
	    };
	    /**
	     * @whatItDoes Syncs a standalone {@link FormControl} instance to a form control element.
	     *
	     * In other words, this directive ensures that any values written to the {@link FormControl}
	     * instance programmatically will be written to the DOM element (model -> view). Conversely,
	     * any values written to the DOM element through user input will be reflected in the
	     * {@link FormControl} instance (view -> model).
	     *
	     * @howToUse
	     *
	     * Use this directive if you'd like to create and manage a {@link FormControl} instance directly.
	     * Simply create a {@link FormControl}, save it to your component class, and pass it into the
	     * {@link FormControlDirective}.
	     *
	     * This directive is designed to be used as a standalone control.  Unlike {@link FormControlName},
	     * it does not require that your {@link FormControl} instance be part of any parent
	     * {@link FormGroup}, and it won't be registered to any {@link FormGroupDirective} that
	     * exists above it.
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {@link FormControl} instance. See a full list of available properties in
	     * {@link AbstractControl}.
	     *
	     * **Set the value**: You can pass in an initial value when instantiating the {@link FormControl},
	     * or you can set it programmatically later using {@link AbstractControl.setValue} or
	     * {@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the control, you can
	     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to
	     * {@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     *  @stable
	     */
	    var FormControlDirective = (function (_super) {
	        __extends$9(FormControlDirective, _super);
	        function FormControlDirective(validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            this.update = new EventEmitter();
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        Object.defineProperty(FormControlDirective.prototype, "isDisabled", {
	            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
	            enumerable: true,
	            configurable: true
	        });
	        FormControlDirective.prototype.ngOnChanges = function (changes) {
	            if (this._isControlChanged(changes)) {
	                setUpControl(this.form, this);
	                if (this.control.disabled && this.valueAccessor.setDisabledState) {
	                    this.valueAccessor.setDisabledState(true);
	                }
	                this.form.updateValueAndValidity({ emitEvent: false });
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.form.setValue(this.model);
	                this.viewModel = this.model;
	            }
	        };
	        Object.defineProperty(FormControlDirective.prototype, "path", {
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "validator", {
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "asyncValidator", {
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "control", {
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        FormControlDirective.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        FormControlDirective.prototype._isControlChanged = function (changes) {
	            return changes.hasOwnProperty('form');
	        };
	        FormControlDirective.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControl]', providers: [formControlBinding$1], exportAs: 'ngForm' },] },
	        ];
	        /** @nocollapse */
	        FormControlDirective.ctorParameters = [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ];
	        FormControlDirective.propDecorators = {
	            'form': [{ type: _angular_core.Input, args: ['formControl',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	        };
	        return FormControlDirective;
	    }(NgControl));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$11 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var formDirectiveProvider$1 = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormGroupDirective; })
	    };
	    /**
	     * @whatItDoes Binds an existing {@link FormGroup} to a DOM element.
	     *
	     * @howToUse
	     *
	     * This directive accepts an existing {@link FormGroup} instance. It will then use this
	     * {@link FormGroup} instance to match any child {@link FormControl}, {@link FormGroup},
	     * and {@link FormArray} instances to child {@link FormControlName}, {@link FormGroupName},
	     * and {@link FormArrayName} directives.
	     *
	     * **Set value**: You can set the form's initial value when instantiating the
	     * {@link FormGroup}, or you can set it programmatically later using the {@link FormGroup}'s
	     * {@link AbstractControl.setValue} or {@link AbstractControl.patchValue} methods.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the form, you can subscribe
	     * to the {@link FormGroup}'s {@link AbstractControl.valueChanges} event.  You can also listen to
	     * its {@link AbstractControl.statusChanges} event to be notified when the validation status is
	     * re-calculated.
	     *
	     * Furthermore, you can listen to the directive's `ngSubmit` event to be notified when the user has
	     * triggered a form submission. The `ngSubmit` event will be emitted with the original form
	     * submission event.
	     *
	     * ### Example
	     *
	     * In this example, we create form controls for first name and last name.
	     *
	     * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
	     *
	     * **npm package**: `@angular/forms`
	     *
	     * **NgModule**: {@link ReactiveFormsModule}
	     *
	     *  @stable
	     */
	    var FormGroupDirective = (function (_super) {
	        __extends$11(FormGroupDirective, _super);
	        function FormGroupDirective(_validators, _asyncValidators) {
	            _super.call(this);
	            this._validators = _validators;
	            this._asyncValidators = _asyncValidators;
	            this._submitted = false;
	            this.directives = [];
	            this.form = null;
	            this.ngSubmit = new EventEmitter();
	        }
	        FormGroupDirective.prototype.ngOnChanges = function (changes) {
	            this._checkFormPresent();
	            if (changes.hasOwnProperty('form')) {
	                this._updateValidators();
	                this._updateDomValue();
	                this._updateRegistrations();
	            }
	        };
	        Object.defineProperty(FormGroupDirective.prototype, "submitted", {
	            get: function () { return this._submitted; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "formDirective", {
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "control", {
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "path", {
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        FormGroupDirective.prototype.addControl = function (dir) {
	            var ctrl = this.form.get(dir.path);
	            setUpControl(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	            this.directives.push(dir);
	            return ctrl;
	        };
	        FormGroupDirective.prototype.getControl = function (dir) { return this.form.get(dir.path); };
	        FormGroupDirective.prototype.removeControl = function (dir) { ListWrapper.remove(this.directives, dir); };
	        FormGroupDirective.prototype.addFormGroup = function (dir) {
	            var ctrl = this.form.get(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        };
	        FormGroupDirective.prototype.removeFormGroup = function (dir) { };
	        FormGroupDirective.prototype.getFormGroup = function (dir) { return this.form.get(dir.path); };
	        FormGroupDirective.prototype.addFormArray = function (dir) {
	            var ctrl = this.form.get(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        };
	        FormGroupDirective.prototype.removeFormArray = function (dir) { };
	        FormGroupDirective.prototype.getFormArray = function (dir) { return this.form.get(dir.path); };
	        FormGroupDirective.prototype.updateModel = function (dir, value) {
	            var ctrl = this.form.get(dir.path);
	            ctrl.setValue(value);
	        };
	        FormGroupDirective.prototype.onSubmit = function ($event) {
	            this._submitted = true;
	            this.ngSubmit.emit($event);
	            return false;
	        };
	        FormGroupDirective.prototype.onReset = function () { this.resetForm(); };
	        FormGroupDirective.prototype.resetForm = function (value) {
	            if (value === void 0) { value = undefined; }
	            this.form.reset(value);
	            this._submitted = false;
	        };
	        /** @internal */
	        FormGroupDirective.prototype._updateDomValue = function () {
	            var _this = this;
	            this.directives.forEach(function (dir) {
	                var newCtrl = _this.form.get(dir.path);
	                if (dir._control !== newCtrl) {
	                    cleanUpControl(dir._control, dir);
	                    if (newCtrl)
	                        setUpControl(newCtrl, dir);
	                    dir._control = newCtrl;
	                }
	            });
	            this.form._updateTreeValidity({ emitEvent: false });
	        };
	        FormGroupDirective.prototype._updateRegistrations = function () {
	            var _this = this;
	            this.form._registerOnCollectionChange(function () { return _this._updateDomValue(); });
	            if (this._oldForm)
	                this._oldForm._registerOnCollectionChange(function () { });
	            this._oldForm = this.form;
	        };
	        FormGroupDirective.prototype._updateValidators = function () {
	            var sync = composeValidators(this._validators);
	            this.form.validator = Validators.compose([this.form.validator, sync]);
	            var async = composeAsyncValidators(this._asyncValidators);
	            this.form.asyncValidator = Validators.composeAsync([this.form.asyncValidator, async]);
	        };
	        FormGroupDirective.prototype._checkFormPresent = function () {
	            if (!this.form) {
	                ReactiveErrors.missingFormException();
	            }
	        };
	        FormGroupDirective.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[formGroup]',
	                        providers: [formDirectiveProvider$1],
	                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
	                        exportAs: 'ngForm'
	                    },] },
	        ];
	        /** @nocollapse */
	        FormGroupDirective.ctorParameters = [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ];
	        FormGroupDirective.propDecorators = {
	            'form': [{ type: _angular_core.Input, args: ['formGroup',] },],
	            'ngSubmit': [{ type: _angular_core.Output },],
	        };
	        return FormGroupDirective;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$12 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var formGroupNameProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormGroupName; })
	    };
	    /**
	     * @whatItDoes Syncs a nested {@link FormGroup} to a DOM element.
	     *
	     * @howToUse
	     *
	     * This directive can only be used with a parent {@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the nested {@link FormGroup} you want to link, and
	     * will look for a {@link FormGroup} registered with that name in the parent
	     * {@link FormGroup} instance you passed into {@link FormGroupDirective}.
	     *
	     * Nested form groups can come in handy when you want to validate a sub-group of a
	     * form separately from the rest or when you'd like to group the values of certain
	     * controls into their own nested object.
	     *
	     * **Access the group**: You can access the associated {@link FormGroup} using the
	     * {@link AbstractControl.get} method. Ex: `this.form.get('name')`.
	     *
	     * You can also access individual controls within the group using dot syntax.
	     * Ex: `this.form.get('name.first')`
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {@link FormGroup}. See a full list of available properties in {@link AbstractControl}.
	     *
	     * **Set the value**: You can set an initial value for each child control when instantiating
	     * the {@link FormGroup}, or you can set it programmatically later using
	     * {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the group, you can
	     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to
	     * {@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     * @stable
	     */
	    var FormGroupName = (function (_super) {
	        __extends$12(FormGroupName, _super);
	        function FormGroupName(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /** @internal */
	        FormGroupName.prototype._checkParentType = function () {
	            if (_hasInvalidParent(this._parent)) {
	                ReactiveErrors.groupParentException();
	            }
	        };
	        FormGroupName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] },] },
	        ];
	        /** @nocollapse */
	        FormGroupName.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ];
	        FormGroupName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formGroupName',] },],
	        };
	        return FormGroupName;
	    }(AbstractFormGroupDirective));
	    var formArrayNameProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormArrayName; })
	    };
	    /**
	     * @whatItDoes Syncs a nested {@link FormArray} to a DOM element.
	     *
	     * @howToUse
	     *
	     * This directive is designed to be used with a parent {@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the nested {@link FormArray} you want to link, and
	     * will look for a {@link FormArray} registered with that name in the parent
	     * {@link FormGroup} instance you passed into {@link FormGroupDirective}.
	     *
	     * Nested form arrays can come in handy when you have a group of form controls but
	     * you're not sure how many there will be. Form arrays allow you to create new
	     * form controls dynamically.
	     *
	     * **Access the array**: You can access the associated {@link FormArray} using the
	     * {@link AbstractControl.get} method on the parent {@link FormGroup}.
	     * Ex: `this.form.get('cities')`.
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {@link FormArray}. See a full list of available properties in {@link AbstractControl}.
	     *
	     * **Set the value**: You can set an initial value for each child control when instantiating
	     * the {@link FormArray}, or you can set the value programmatically later using the
	     * {@link FormArray}'s {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}
	     * methods.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the array, you can
	     * subscribe to the {@link FormArray}'s {@link AbstractControl.valueChanges} event.  You can also
	     * listen to its {@link AbstractControl.statusChanges} event to be notified when the validation
	     * status is re-calculated.
	     *
	     * **Add new controls**: You can add new controls to the {@link FormArray} dynamically by
	     * calling its {@link FormArray.push} method.
	     *  Ex: `this.form.get('cities').push(new FormControl());`
	     *
	     * ### Example
	     *
	     * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
	     *
	     * * **npm package**: `@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     * @stable
	     */
	    var FormArrayName = (function (_super) {
	        __extends$12(FormArrayName, _super);
	        function FormArrayName(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        FormArrayName.prototype.ngOnInit = function () {
	            this._checkParentType();
	            this.formDirective.addFormArray(this);
	        };
	        FormArrayName.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeFormArray(this);
	            }
	        };
	        Object.defineProperty(FormArrayName.prototype, "control", {
	            get: function () { return this.formDirective.getFormArray(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "formDirective", {
	            get: function () {
	                return this._parent ? this._parent.formDirective : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "path", {
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "validator", {
	            get: function () { return composeValidators(this._validators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "asyncValidator", {
	            get: function () { return composeAsyncValidators(this._asyncValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        FormArrayName.prototype._checkParentType = function () {
	            if (_hasInvalidParent(this._parent)) {
	                ReactiveErrors.arrayParentException();
	            }
	        };
	        FormArrayName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] },] },
	        ];
	        /** @nocollapse */
	        FormArrayName.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ];
	        FormArrayName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formArrayName',] },],
	        };
	        return FormArrayName;
	    }(ControlContainer));
	    function _hasInvalidParent(parent) {
	        return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&
	            !(parent instanceof FormArrayName);
	    }
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$10 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var controlNameBinding = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return FormControlName; })
	    };
	    /**
	     * @whatItDoes  Syncs a {@link FormControl} in an existing {@link FormGroup} to a form control
	     * element by name.
	     *
	     * In other words, this directive ensures that any values written to the {@link FormControl}
	     * instance programmatically will be written to the DOM element (model -> view). Conversely,
	     * any values written to the DOM element through user input will be reflected in the
	     * {@link FormControl} instance (view -> model).
	     *
	     * @howToUse
	     *
	     * This directive is designed to be used with a parent {@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the {@link FormControl} instance you want to
	     * link, and will look for a {@link FormControl} registered with that name in the
	     * closest {@link FormGroup} or {@link FormArray} above it.
	     *
	     * **Access the control**: You can access the {@link FormControl} associated with
	     * this directive by using the {@link AbstractControl.get} method.
	     * Ex: `this.form.get('first');`
	     *
	     * **Get value**: the `value` property is always synced and available on the {@link FormControl}.
	     * See a full list of available properties in {@link AbstractControl}.
	     *
	     *  **Set value**: You can set an initial value for the control when instantiating the
	     *  {@link FormControl}, or you can set it programmatically later using
	     *  {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the control, you can
	     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to
	     * {@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * In this example, we create form controls for first name and last name.
	     *
	     * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
	     *
	     * To see `formControlName` examples with different form control types, see:
	     *
	     * * Radio buttons: {@link RadioControlValueAccessor}
	     * * Selects: {@link SelectControlValueAccessor}
	     *
	     * **npm package**: `@angular/forms`
	     *
	     * **NgModule**: {@link ReactiveFormsModule}
	     *
	     *  @stable
	     */
	    var FormControlName = (function (_super) {
	        __extends$10(FormControlName, _super);
	        function FormControlName(parent, validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            this._added = false;
	            this.update = new EventEmitter();
	            this._parent = parent;
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        Object.defineProperty(FormControlName.prototype, "isDisabled", {
	            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
	            enumerable: true,
	            configurable: true
	        });
	        FormControlName.prototype.ngOnChanges = function (changes) {
	            if (!this._added)
	                this._setUpControl();
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.viewModel = this.model;
	                this.formDirective.updateModel(this, this.model);
	            }
	        };
	        FormControlName.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeControl(this);
	            }
	        };
	        FormControlName.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        Object.defineProperty(FormControlName.prototype, "path", {
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "formDirective", {
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "validator", {
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "asyncValidator", {
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "control", {
	            get: function () { return this._control; },
	            enumerable: true,
	            configurable: true
	        });
	        FormControlName.prototype._checkParentType = function () {
	            if (!(this._parent instanceof FormGroupName) &&
	                this._parent instanceof AbstractFormGroupDirective) {
	                ReactiveErrors.ngModelGroupException();
	            }
	            else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) &&
	                !(this._parent instanceof FormArrayName)) {
	                ReactiveErrors.controlParentException();
	            }
	        };
	        FormControlName.prototype._setUpControl = function () {
	            this._checkParentType();
	            this._control = this.formDirective.addControl(this);
	            if (this.control.disabled && this.valueAccessor.setDisabledState) {
	                this.valueAccessor.setDisabledState(true);
	            }
	            this._added = true;
	        };
	        FormControlName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControlName]', providers: [controlNameBinding] },] },
	        ];
	        /** @nocollapse */
	        FormControlName.ctorParameters = [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ];
	        FormControlName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formControlName',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	        };
	        return FormControlName;
	    }(NgControl));
	
	    var REQUIRED_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return RequiredValidator; }),
	        multi: true
	    };
	    /**
	     * A Directive that adds the `required` validator to any controls marked with the
	     * `required` attribute, via the {@link NG_VALIDATORS} binding.
	     *
	     * ### Example
	     *
	     * ```
	     * <input name="fullName" ngModel required>
	     * ```
	     *
	     * @stable
	     */
	    var RequiredValidator = (function () {
	        function RequiredValidator() {
	        }
	        Object.defineProperty(RequiredValidator.prototype, "required", {
	            get: function () { return this._required; },
	            set: function (value) {
	                this._required = value != null && value !== false && "" + value !== 'false';
	                if (this._onChange)
	                    this._onChange();
	            },
	            enumerable: true,
	            configurable: true
	        });
	        RequiredValidator.prototype.validate = function (c) {
	            return this.required ? Validators.required(c) : null;
	        };
	        RequiredValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        RequiredValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[required][formControlName],[required][formControl],[required][ngModel]',
	                        providers: [REQUIRED_VALIDATOR],
	                        host: { '[attr.required]': 'required ? "" : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        RequiredValidator.ctorParameters = [];
	        RequiredValidator.propDecorators = {
	            'required': [{ type: _angular_core.Input },],
	        };
	        return RequiredValidator;
	    }());
	    /**
	     * Provider which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.
	     *
	     * ## Example:
	     *
	     * {@example common/forms/ts/validators/validators.ts region='min'}
	     */
	    var MIN_LENGTH_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return MinLengthValidator; }),
	        multi: true
	    };
	    /**
	     * A directive which installs the {@link MinLengthValidator} for any `formControlName`,
	     * `formControl`, or control with `ngModel` that also has a `minlength` attribute.
	     *
	     * @stable
	     */
	    var MinLengthValidator = (function () {
	        function MinLengthValidator() {
	        }
	        MinLengthValidator.prototype.ngOnChanges = function (changes) {
	            if ('minlength' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        MinLengthValidator.prototype.validate = function (c) {
	            return this.minlength == null ? null : this._validator(c);
	        };
	        MinLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        MinLengthValidator.prototype._createValidator = function () {
	            this._validator = Validators.minLength(parseInt(this.minlength, 10));
	        };
	        MinLengthValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
	                        providers: [MIN_LENGTH_VALIDATOR],
	                        host: { '[attr.minlength]': 'minlength ? minlength : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        MinLengthValidator.ctorParameters = [];
	        MinLengthValidator.propDecorators = {
	            'minlength': [{ type: _angular_core.Input },],
	        };
	        return MinLengthValidator;
	    }());
	    /**
	     * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.
	     *
	     * ## Example:
	     *
	     * {@example common/forms/ts/validators/validators.ts region='max'}
	     */
	    var MAX_LENGTH_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return MaxLengthValidator; }),
	        multi: true
	    };
	    /**
	     * A directive which installs the {@link MaxLengthValidator} for any `formControlName,
	     * `formControl`,
	     * or control with `ngModel` that also has a `maxlength` attribute.
	     *
	     * @stable
	     */
	    var MaxLengthValidator = (function () {
	        function MaxLengthValidator() {
	        }
	        MaxLengthValidator.prototype.ngOnChanges = function (changes) {
	            if ('maxlength' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        MaxLengthValidator.prototype.validate = function (c) {
	            return this.maxlength != null ? this._validator(c) : null;
	        };
	        MaxLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        MaxLengthValidator.prototype._createValidator = function () {
	            this._validator = Validators.maxLength(parseInt(this.maxlength, 10));
	        };
	        MaxLengthValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
	                        providers: [MAX_LENGTH_VALIDATOR],
	                        host: { '[attr.maxlength]': 'maxlength ? maxlength : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        MaxLengthValidator.ctorParameters = [];
	        MaxLengthValidator.propDecorators = {
	            'maxlength': [{ type: _angular_core.Input },],
	        };
	        return MaxLengthValidator;
	    }());
	    var PATTERN_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return PatternValidator; }),
	        multi: true
	    };
	    /**
	     * A Directive that adds the `pattern` validator to any controls marked with the
	     * `pattern` attribute, via the {@link NG_VALIDATORS} binding. Uses attribute value
	     * as the regex to validate Control value against.  Follows pattern attribute
	     * semantics; i.e. regex must match entire Control value.
	     *
	     * ### Example
	     *
	     * ```
	     * <input [name]="fullName" pattern="[a-zA-Z ]*" ngModel>
	     * ```
	     * @stable
	     */
	    var PatternValidator = (function () {
	        function PatternValidator() {
	        }
	        PatternValidator.prototype.ngOnChanges = function (changes) {
	            if ('pattern' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        PatternValidator.prototype.validate = function (c) { return this._validator(c); };
	        PatternValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        PatternValidator.prototype._createValidator = function () { this._validator = Validators.pattern(this.pattern); };
	        PatternValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
	                        providers: [PATTERN_VALIDATOR],
	                        host: { '[attr.pattern]': 'pattern ? pattern : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        PatternValidator.ctorParameters = [];
	        PatternValidator.propDecorators = {
	            'pattern': [{ type: _angular_core.Input },],
	        };
	        return PatternValidator;
	    }());
	
	    /**
	     * @whatItDoes Creates an {@link AbstractControl} from a user-specified configuration.
	     *
	     * It is essentially syntactic sugar that shortens the `new FormGroup()`,
	     * `new FormControl()`, and `new FormArray()` boilerplate that can build up in larger
	     * forms.
	     *
	     * @howToUse
	     *
	     * To use, inject `FormBuilder` into your component class. You can then call its methods
	     * directly.
	     *
	     * {@example forms/ts/formBuilder/form_builder_example.ts region='Component'}
	     *
	     *  * **npm package**: `@angular/forms`
	     *
	     *  * **NgModule**: {@link ReactiveFormsModule}
	     *
	     * @stable
	     */
	    var FormBuilder = (function () {
	        function FormBuilder() {
	        }
	        /**
	         * Construct a new {@link FormGroup} with the given map of configuration.
	         * Valid keys for the `extra` parameter map are `validator` and `asyncValidator`.
	         *
	         * See the {@link FormGroup} constructor for more details.
	         */
	        FormBuilder.prototype.group = function (controlsConfig, extra) {
	            if (extra === void 0) { extra = null; }
	            var controls = this._reduceControls(controlsConfig);
	            var validator = isPresent(extra) ? extra['validator'] : null;
	            var asyncValidator = isPresent(extra) ? extra['asyncValidator'] : null;
	            return new FormGroup(controls, validator, asyncValidator);
	        };
	        /**
	         * Construct a new {@link FormControl} with the given `formState`,`validator`, and
	         * `asyncValidator`.
	         *
	         * `formState` can either be a standalone value for the form control or an object
	         * that contains both a value and a disabled status.
	         *
	         */
	        FormBuilder.prototype.control = function (formState, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            return new FormControl(formState, validator, asyncValidator);
	        };
	        /**
	         * Construct a {@link FormArray} from the given `controlsConfig` array of
	         * configuration, with the given optional `validator` and `asyncValidator`.
	         */
	        FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {
	            var _this = this;
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            var controls = controlsConfig.map(function (c) { return _this._createControl(c); });
	            return new FormArray(controls, validator, asyncValidator);
	        };
	        /** @internal */
	        FormBuilder.prototype._reduceControls = function (controlsConfig) {
	            var _this = this;
	            var controls = {};
	            Object.keys(controlsConfig).forEach(function (controlName) {
	                controls[controlName] = _this._createControl(controlsConfig[controlName]);
	            });
	            return controls;
	        };
	        /** @internal */
	        FormBuilder.prototype._createControl = function (controlConfig) {
	            if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup ||
	                controlConfig instanceof FormArray) {
	                return controlConfig;
	            }
	            else if (Array.isArray(controlConfig)) {
	                var value = controlConfig[0];
	                var validator = controlConfig.length > 1 ? controlConfig[1] : null;
	                var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
	                return this.control(value, validator, asyncValidator);
	            }
	            else {
	                return this.control(controlConfig);
	            }
	        };
	        FormBuilder.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        FormBuilder.ctorParameters = [];
	        return FormBuilder;
	    }());
	
	    var SHARED_FORM_DIRECTIVES = [
	        NgSelectOption, NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor,
	        RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor,
	        SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus,
	        NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator
	    ];
	    var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
	    var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
	    /**
	     * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
	     */
	    var InternalFormsSharedModule = (function () {
	        function InternalFormsSharedModule() {
	        }
	        InternalFormsSharedModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: SHARED_FORM_DIRECTIVES,
	                        exports: SHARED_FORM_DIRECTIVES,
	                    },] },
	        ];
	        /** @nocollapse */
	        InternalFormsSharedModule.ctorParameters = [];
	        return InternalFormsSharedModule;
	    }());
	
	    /**
	     * The ng module for forms.
	     * @stable
	     */
	    var FormsModule = (function () {
	        function FormsModule() {
	        }
	        FormsModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: TEMPLATE_DRIVEN_DIRECTIVES,
	                        providers: [RadioControlRegistry],
	                        exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
	                    },] },
	        ];
	        /** @nocollapse */
	        FormsModule.ctorParameters = [];
	        return FormsModule;
	    }());
	    /**
	     * The ng module for reactive forms.
	     * @stable
	     */
	    var ReactiveFormsModule = (function () {
	        function ReactiveFormsModule() {
	        }
	        ReactiveFormsModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: [REACTIVE_DRIVEN_DIRECTIVES],
	                        providers: [FormBuilder, RadioControlRegistry],
	                        exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
	                    },] },
	        ];
	        /** @nocollapse */
	        ReactiveFormsModule.ctorParameters = [];
	        return ReactiveFormsModule;
	    }());
	
	    exports.AbstractControlDirective = AbstractControlDirective;
	    exports.AbstractFormGroupDirective = AbstractFormGroupDirective;
	    exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;
	    exports.ControlContainer = ControlContainer;
	    exports.NG_VALUE_ACCESSOR = NG_VALUE_ACCESSOR;
	    exports.DefaultValueAccessor = DefaultValueAccessor;
	    exports.NgControl = NgControl;
	    exports.NgControlStatus = NgControlStatus;
	    exports.NgControlStatusGroup = NgControlStatusGroup;
	    exports.NgForm = NgForm;
	    exports.NgModel = NgModel;
	    exports.NgModelGroup = NgModelGroup;
	    exports.RadioControlValueAccessor = RadioControlValueAccessor;
	    exports.FormControlDirective = FormControlDirective;
	    exports.FormControlName = FormControlName;
	    exports.FormGroupDirective = FormGroupDirective;
	    exports.FormArrayName = FormArrayName;
	    exports.FormGroupName = FormGroupName;
	    exports.NgSelectOption = NgSelectOption;
	    exports.SelectControlValueAccessor = SelectControlValueAccessor;
	    exports.SelectMultipleControlValueAccessor = SelectMultipleControlValueAccessor;
	    exports.MaxLengthValidator = MaxLengthValidator;
	    exports.MinLengthValidator = MinLengthValidator;
	    exports.PatternValidator = PatternValidator;
	    exports.RequiredValidator = RequiredValidator;
	    exports.FormBuilder = FormBuilder;
	    exports.AbstractControl = AbstractControl;
	    exports.FormArray = FormArray;
	    exports.FormControl = FormControl;
	    exports.FormGroup = FormGroup;
	    exports.NG_ASYNC_VALIDATORS = NG_ASYNC_VALIDATORS;
	    exports.NG_VALIDATORS = NG_VALIDATORS;
	    exports.Validators = Validators;
	    exports.FormsModule = FormsModule;
	    exports.ReactiveFormsModule = ReactiveFormsModule;
	
	}));

/***/ }),
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var HomeComponent = (function () {
	    function HomeComponent() {
	    }
	    HomeComponent.prototype.ngOnInit = function () {
	        console.log('Home Component!');
	    };
	    return HomeComponent;
	}());
	HomeComponent = __decorate([
	    core_1.Component({
	        selector: 'home',
	        template: __webpack_require__(34),
	        styles: [__webpack_require__(36)],
	        encapsulation: core_1.ViewEncapsulation.None,
	    }),
	    __metadata("design:paramtypes", [])
	], HomeComponent);
	exports.HomeComponent = HomeComponent;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = "<img class=\"home-image\" src=\"" + __webpack_require__(35) + "\"/>";

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/home.jpg";

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(37);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".home-image {\n  width: 100%;\n  box-shadow: 0px 1px 2px 0 rgba(34, 36, 38, 0.15);\n  border: 1px solid #00004D;\n}\n", ""]);
	
	// exports


/***/ }),
/* 38 */,
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var AboutComponent = (function () {
	    function AboutComponent() {
	    }
	    AboutComponent.prototype.ngOnInit = function () {
	        console.log('About Component!');
	    };
	    return AboutComponent;
	}());
	AboutComponent = __decorate([
	    core_1.Component({
	        selector: 'about',
	        template: __webpack_require__(40),
	        styles: [__webpack_require__(41)]
	    }),
	    __metadata("design:paramtypes", [])
	], AboutComponent);
	exports.AboutComponent = AboutComponent;


/***/ }),
/* 40 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">About Us</h1>\n<p>Illinois Ultimate is one of the premier ultimate programs in the Midwest and frequently ranks in the National top 25. We strive to contend with the best programs in the country and have qualified to compete at Nationals 7 of the last 10 years. We are a program that prides itself on developing players who come to Illinois with no experience playing competitive ultimate. We teach all levels of ultimate, from the basics of throwing a forehand all the way to throwing bombs in the worst of weather.</p>\n<h2 class=\"ui header\">Mission Statement</h2>\n<p>We want to compete at the highest level possible in college ultimate while remaining respectful to our opponents.  We want to develop all our of players to become the best they can be at ultimate, as well as players who exemplify the true meaning of sportsmanship, which is pivotal to the progress of ultimate frisbee in its current state.</p>\n<h2 class=\"ui header\">Team Structure/Affiliation with University</h2>\n<p>Our team is a Registered Student Organization (RSO) at the University of Illinois and we are classified as a club sport. We receive some funding from the University that helps pay for our travel costs and hotels while we are at tournaments.</p>\n<p>We are a member of the USAU  College Series and compete in a series of tournaments that  culminate in the College Championships held every year during Memorial Day weekend. Most, if not all, state schools have established ultimate teams and many smaller schools have teams as well.  We compete in the Illinois conference which is as you can guess, the schools in the state of Illinois. The next largest division is the Great Lakes Region, which includes the states of Illinois, Indiana, Michigan, and Kentucky. The final step is the aforementioned National Championships.</p>\n<p>Our program is split up into two teams, A and B. Our A team is a group of individuals who are very dedicated to the team and who put in a large amount of time for practices as well as training outside of practices. Our B team is more oriented towards the development of younger or inexperienced players. B team provides a much more relaxed atmosphere but still remains competitive with all other B teams in the region, and even beats some smaller schools' A teams.</p>\n<p>A team has tryouts each year. This year's tryouts will consist of four fall tournaments. There will be a round of cuts made after the second tournament. The tryout roster will then be narrowed down to one team before the final tournament of the fall, via cuts on a rolling basis. Players may be moved between the A and B team rosters as necessary.</p>";

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(42);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "p {\n  text-align: left;\n}\n", ""]);
	
	// exports


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var google_spreadsheet_service_1 = __webpack_require__(44);
	var ProspectivePlayersComponent = (function () {
	    // Constructor with our http service injected
	    function ProspectivePlayersComponent(spreadsheetService) {
	        this.spreadsheetService = spreadsheetService;
	        // API url for our personal server
	        this.googleSheetsApiUrl = 'https://nick-proz-google-sheet-api.herokuapp.com/sheets/11ijrHoysiIwsFfEggbSNM9Y8VvzU65jeuhQ3vkV5FGw/sheetIndex/2/rows/';
	        // API url for our backup server (sheetsu API)
	        // private googleSheetsBackupApiUrl = 'https://sheetsu.com/apis/v1.0/7a030ae60b7d';
	        this.googleSheetsBackupApiUrl = '';
	        // Error messages
	        this.validationErrors = 'Please do not leave any required fields blank.';
	        this.submissionError = 'Could not submit the form  due to a server error. Please try again soon or contact the web admins.';
	        // Contact input
	        this.contact = 'Yes';
	        // Boolean indicating if our form is in the process of submitting (to show our loading icon)
	        this.formIsSubmitting = false;
	        // Boolean indicating if our form was successfully submitted (to show our success message)
	        this.submitSuccess = false;
	    }
	    ProspectivePlayersComponent.prototype.ngOnInit = function () { };
	    ProspectivePlayersComponent.prototype.handleSubmit = function (event) {
	        event.preventDefault();
	        this.submitSuccess = false;
	        if (!this.formIsValid()) {
	            this.formErrors = this.validationErrors;
	        }
	        else {
	            this.formIsSubmitting = true;
	            this.formErrors = null;
	            var date = new Date();
	            var data = {
	                "Timestamp": date.toLocaleString(),
	                "First Name": this.firstName,
	                "Last Name": this.lastName,
	                "Email Address": this.emailAddress,
	                "Hometown": this.hometown,
	                "Highschool": this.highschool,
	                "Major": this.major,
	                "Experience": this.experience,
	                "Other Clubs": this.otherClubs,
	                "Contact Me": this.contact
	            };
	            this.submitAbsentForm(data);
	        }
	    };
	    /**
	     * Submits our form to the spreadsheet by calling our service method.
	     * On success, we show our confirmation modal and reset our rsvp modal.
	     * On failure, we hide our submitting dialog and show our submission error to the user.
	     *
	     * @param data - data to submit to our spreadsheet
	     */
	    ProspectivePlayersComponent.prototype.submitAbsentForm = function (data) {
	        var _this = this;
	        this.spreadsheetService.postRowToSpreadsheet(this.googleSheetsApiUrl, this.googleSheetsBackupApiUrl, data)
	            .then(function () {
	            _this.resetForm();
	            _this.submitSuccess = true;
	        })
	            .catch(function () {
	            _this.formIsSubmitting = false;
	            _this.formErrors = _this.submissionError;
	        });
	    };
	    /**
	     * Clears our input fields, errors, and resets our form is submitting flag.
	     */
	    ProspectivePlayersComponent.prototype.resetForm = function () {
	        this.firstName = null;
	        this.lastName = null;
	        this.emailAddress = null;
	        this.hometown = null;
	        this.highschool = null;
	        this.major = null;
	        this.experience = null;
	        this.otherClubs = null;
	        this.formErrors = null;
	        this.formIsSubmitting = false;
	    };
	    /**
	     * Front-end validation for our form.
	     * Our form is valid only if all fields are populated.
	     *
	     * @returns {boolean} - true if the form is valid, false otherwise
	     */
	    ProspectivePlayersComponent.prototype.formIsValid = function () {
	        return this.firstName != null && this.firstName != ''
	            && this.lastName != null && this.lastName != ''
	            && this.emailAddress != null && this.emailAddress != ''
	            && this.hometown != null && this.hometown != ''
	            && this.highschool != null && this.highschool != ''
	            && this.major != null && this.major != ''
	            && this.experience != null && this.experience != ''
	            && this.otherClubs != null && this.otherClubs != ''
	            && this.contact != null && this.contact != '';
	    };
	    return ProspectivePlayersComponent;
	}());
	ProspectivePlayersComponent = __decorate([
	    core_1.Component({
	        selector: 'prospective-players',
	        template: __webpack_require__(45),
	        styles: [__webpack_require__(46)]
	    }),
	    __metadata("design:paramtypes", [typeof (_a = typeof google_spreadsheet_service_1.SpreadsheetService !== "undefined" && google_spreadsheet_service_1.SpreadsheetService) === "function" && _a || Object])
	], ProspectivePlayersComponent);
	exports.ProspectivePlayersComponent = ProspectivePlayersComponent;
	var _a;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var http_1 = __webpack_require__(28);
	/**
	 * Service to interact with our Google spreadsheet.
	 */
	var SpreadsheetService = (function () {
	    // Constructor with our http service injected
	    function SpreadsheetService(http) {
	        this.http = http;
	        // HTTP headers
	        this.headers = new http_1.Headers({ 'Content-Type': 'application/json' });
	    }
	    /**
	     * Attempts to post the data passed in to our spreadsheet.
	     * Rejects the promise if there is an error.
	     *
	     * @param apiUrl - url of the google sheets API
	     * @param backupApiUrl - url of hte google sheets backup API
	     * @param data - data to add to our spreadsheet
	     * @returns {Promise<JSON>} - Promise holding the successfully posted object, or a rejected promise with an error
	     */
	    SpreadsheetService.prototype.postRowToSpreadsheet = function (apiUrl, backupApiUrl, data) {
	        var _this = this;
	        return this.http
	            .post(apiUrl, data, { headers: this.headers })
	            .toPromise()
	            .then(function (response) { return response.json(); })
	            .catch(function () { return _this.postRowToSpreadsheetBackup(backupApiUrl, data); });
	    };
	    /**
	     * Attempts to post the data passed in to our backup spreadsheet.
	     * This is a backup post in case our personal server fails.
	     * Rejects the promise if there is an error.
	     *
	     * @param backupApiUrl - url of hte google sheets backup API
	     * @param data - data to add to our spreadsheet
	     * @returns {Promise<JSON>} - Promise holding the successfully posted object, or a rejected promise with an error
	     */
	    SpreadsheetService.prototype.postRowToSpreadsheetBackup = function (backupApiUrl, data) {
	        return this.http
	            .post(backupApiUrl, data, { headers: this.headers })
	            .toPromise()
	            .then(function (response) { return response.json(); })
	            .catch(SpreadsheetService.handleError);
	    };
	    /**
	     * Handles all rsvp service errors (after our backup call) when interfacing
	     * with the google spreadsheet api. We log the error and reject the promise.
	     *
	     * @param error - Error to log and reject
	     * @returns {Promise<any>} - A rejected promise
	     */
	    SpreadsheetService.handleError = function (error) {
	        console.error('An error occurred when attempting to send data to our spreadsheet: ', error);
	        return Promise.reject(error);
	    };
	    return SpreadsheetService;
	}());
	SpreadsheetService = __decorate([
	    core_1.Injectable(),
	    __metadata("design:paramtypes", [typeof (_a = typeof http_1.Http !== "undefined" && http_1.Http) === "function" && _a || Object])
	], SpreadsheetService);
	exports.SpreadsheetService = SpreadsheetService;
	var _a;


/***/ }),
/* 45 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Prospective Players</h1>\n<p>Illinois Ultimate has had a long history since its inception in the early 1990s and now consistently competes with best competition around the country. Illinois has qualified for national championships 6 out of the last 9 years behind our dedication, determination, and distinguished character on and off the field. Illinois alumni have gone on to play for nationals caliber club teams such as Chicago Machine, Minneapolis Drag 'n Thrust, Cincinnati Steamboat, Atlanta Chain Lightning, and San Francisco Blackbird. Alumni have played on professional AUDL teams such as the Chicago Wildfire, Minnesota Windchill, Cincinnati Revolution, and the San Jose Spiders. They have also created and captained club teams including Chicago Machine, Black Market Ultimate, and Beachfront Ultimate, and have gone on to coach college ultimate at the University of Illinois, the University of Chicago, Northwestern University, and the University of Kentucky. It's safe to say that once you play ultimate at Illinois you are opened up to a world of opportunity through our alumni network, who are more than willing to assist you on your journey though ultimate during and beyond your college years.</p>\n<p>While you are at Illinois you will enjoy a number of experiences. This ranges from team socials to study groups and from practices in Irwin Fieldhouse to playing games on the shores of San Diego. Your teammates won't only be your best friends, they will be family. You will learn the various ways ultimate is played, how to expand your throwing arsenal, how to improve your athleticism, and how to take your game to the next level. A majority of our team didn't play organized ultimate before coming to college, and are now some of the best players in the Great Lakes region (see our All-Regions honors page).</p>\n<p>We encourage prospective players to fill out our interest form and to reach out to the captains especially if you will be on campus. We are more than happy to meet up and discuss what Illinois can do for you, and to see what you can do to be ready for Illinois once you get on campus. Our contact information is below. Thank you for taking the time to visit our website, and we hope to hear from you soon.</p>\n\n<form class=\"ui form\">\n        <div class=\"two fields\">\n            <div class=\"field\">\n                <label>First Name <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"firstName\" type=\"text\" name=\"first-name\" placeholder=\"First Name\">\n            </div>\n            <div class=\"field\">\n                <label>Last Name <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"lastName\" type=\"text\" name=\"last-name\" placeholder=\"Last Name\">\n            </div>\n        </div>\n        <div class=\"two fields\">\n            <div class=\"field\">\n                <label>Email Address <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"emailAddress\" type=\"text\" name=\"email-address\" placeholder=\"Email Address\">\n            </div>\n            <div class=\"field\">\n                <label>What is your Hometown? <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"hometown\" type=\"text\" name=\"home-town\" placeholder=\"Hometown\">\n            </div>\n        </div>\n        <div class=\"two fields\">\n            <div class=\"field\">\n                <label>What high school did you attend? <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"highschool\" type=\"text\" name=\"highschool\" placeholder=\"High School\">\n            </div>\n            <div class=\"field\">\n                <label>What major are you planning on going into? <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"major\" type=\"text\" name=\"major\" placeholder=\"Major\">\n            </div>\n        </div>\n        <div class=\"field\">\n            <label>How long have you played ultimate/what kind of experience do you have? <span class=\"required\">*</span></label>\n            <textarea [(ngModel)]=\"experience\" name=\"experience\" rows=\"2\"></textarea>\n        </div>\n        <div class=\"field\">\n            <label>What other clubs/organizations are you planning on joining when you arrive on campus? <span class=\"required\">*</span></label>\n            <textarea [(ngModel)]=\"otherClubs\" name=\"other-clubs\" rows=\"2\"></textarea>\n        </div>\n        <div class=\"inline fields\">\n            <label>Would you be alright with a captain or coach reaching out to you? <span class=\"required\">*</span></label>\n            <div class=\"field\">\n                <div class=\"ui radio checkbox\">\n                    <input id=\"contact-yes\" [(ngModel)]=\"contact\" type=\"radio\" name=\"contact\" value=\"Yes\" checked=\"checked\" tabindex=\"0\" class=\"hidden\">\n                    <label for=\"contact-yes\">Yes</label>\n                </div>\n            </div>\n            <div class=\"field\">\n                <div class=\"ui radio checkbox\">\n                    <input id=\"contact-no\" [(ngModel)]=\"contact\" type=\"radio\" name=\"contact\" value=\"No\" tabindex=\"0\" class=\"hidden\">\n                    <label for=\"contact-no\">No</label>\n                </div>\n            </div>\n        </div>\n    <button (click)=\"handleSubmit($event)\" class=\"ui button\" type=\"submit\">Submit</button>\n    <div class=\"ui error message\" *ngIf=\"formErrors\">\n        <p>{{formErrors}}</p>\n    </div>\n    <div class=\"ui success message\" *ngIf=\"submitSuccess\">\n        <div class=\"header\">Form Submitted</div>\n        <p>The form was successfully submitted! Thanks for taking the time to fill it out.</p>\n    </div>\n    <div *ngIf=\"formIsSubmitting\" class=\"ui active inverted dimmer\"><div class=\"ui text loader\">Submitting</div></div>\n</form>";

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(47);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "p,\nlabel {\n  text-align: left;\n}\n.ui.form {\n  margin: 20px auto;\n}\n.ui.form .ui.error.message,\n.ui.form .ui.success.message {\n  display: block;\n}\n.ui.form .ui.error.message p,\n.ui.form .ui.success.message p {\n  text-align: center;\n}\n", ""]);
	
	// exports


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var ContactComponent = (function () {
	    function ContactComponent() {
	    }
	    ContactComponent.prototype.ngOnInit = function () {
	        console.log('Contact Component!');
	    };
	    return ContactComponent;
	}());
	ContactComponent = __decorate([
	    core_1.Component({
	        selector: 'contact',
	        template: __webpack_require__(49),
	        styles: [__webpack_require__(50)]
	    }),
	    __metadata("design:paramtypes", [])
	], ContactComponent);
	exports.ContactComponent = ContactComponent;


/***/ }),
/* 49 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Contact Us</h1>\n<p>For any questions regarding practice or club details, feel free to contact any of the current captains:</p>\n\n<p class=\"captain\">Chris Buchta -- cbuchta2@gmail.com</p>\n<p class=\"captain\">Ben Foster -- ben.foster234@gmail.com</p>\n<p class=\"captain\">Jacob Komenda -- jacob.komenda@gmail.com</p>";

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(51);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".captain {\n  margin-bottom: 0;\n}\n", ""]);
	
	// exports


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	__webpack_require__(53);
	var AppComponent = (function () {
	    function AppComponent() {
	    }
	    AppComponent.prototype.ngOnInit = function () { };
	    return AppComponent;
	}());
	AppComponent = __decorate([
	    core_1.Component({
	        selector: 'app',
	        template: __webpack_require__(57),
	        styles: [__webpack_require__(58)]
	    }),
	    __metadata("design:paramtypes", [])
	], AppComponent);
	exports.AppComponent = AppComponent;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(54);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(56)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/css-loader/index.js!./styles.css", function() {
				var newContent = require("!!../../../node_modules/css-loader/index.js!./styles.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "/* General Elements */\nbody {\n    background-image: url(" + __webpack_require__(55) + ");\n    font-family: 'Quattrocento', serif;\n    text-align: center;\n    overflow-y: scroll;\n}\np {\n    text-indent: 25px;\n    padding: 5px;\n}\na {\n    color: #ff6226;\n}\na:hover {\n    color: #00004D;\n}\ninput {\n    font-family: 'Quattrocento', serif !important;\n}\n\ninput:focus {\n     border-color: #ff6226 !important;\n}\n\n/* Headers */\n.ui.header {\n    font-family: 'Oswald', sans-serif;\n    color: #00004D;\n    letter-spacing: 1px;\n    /*text-transform: uppercase;*/\n}\n\n/* Tables */\n.ui.table tr, .ui.table td {\n    text-align: center;\n    border-top: 0;\n}\n\n/* Secondary Menus */\n.ui.secondary.pointing.menu {\n    justify-content: center;\n}\n.ui.secondary.pointing.menu .item.active {\n    border-color: #00004D;\n}\n\n/* Random */\n.button {\n    background-color: #ff6226 !important;\n    color: white !important;\n}\n.required {\n    color: #ff6226;\n}", ""]);
	
	// exports


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/background.jpg";

/***/ }),
/* 56 */,
/* 57 */
/***/ (function(module, exports) {

	module.exports = "<main class=\"main-container\">\n    <page-frame></page-frame>\n</main>\n";

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(59);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".main-container {\n  height: 100%;\n}\n", ""]);
	
	// exports


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var core_2 = __webpack_require__(61);
	var platform_browser_1 = __webpack_require__(25);
	var forms_1 = __webpack_require__(29);
	var practice_component_1 = __webpack_require__(84);
	var tournaments_component_1 = __webpack_require__(89);
	var roster_component_1 = __webpack_require__(124);
	var absent_component_1 = __webpack_require__(129);
	var router_1 = __webpack_require__(90);
	var app_routes_1 = __webpack_require__(134);
	var google_spreadsheet_service_1 = __webpack_require__(44);
	var TeamModule = (function () {
	    function TeamModule() {
	    }
	    return TeamModule;
	}());
	TeamModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            platform_browser_1.BrowserModule,
	            forms_1.FormsModule,
	            core_2.AgmCoreModule.forRoot({
	                apiKey: 'AIzaSyBRIXAk5xdvn3ezypsSe55f8dZhcHheAZ8'
	            }),
	            router_1.RouterModule.forRoot(app_routes_1.ROUTES)
	        ],
	        declarations: [
	            practice_component_1.PracticeComponent,
	            tournaments_component_1.TournamentsComponent,
	            roster_component_1.RosterComponent,
	            absent_component_1.AbsentComponent
	        ],
	        providers: [google_spreadsheet_service_1.SpreadsheetService]
	    }),
	    __metadata("design:paramtypes", [])
	], TeamModule);
	exports.TeamModule = TeamModule;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	// main modules
	__export(__webpack_require__(62));
	__export(__webpack_require__(79));
	// Google Maps types
	// core module
	// we explicitly export the module here to prevent this Ionic 2 bug:
	// http://stevemichelotti.com/integrate-angular-2-google-maps-into-ionic-2/
	var core_module_1 = __webpack_require__(83);
	exports.AgmCoreModule = core_module_1.AgmCoreModule;
	//# sourceMappingURL=index.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var google_map_1 = __webpack_require__(63);
	exports.SebmGoogleMap = google_map_1.SebmGoogleMap;
	var google_map_circle_1 = __webpack_require__(72);
	exports.SebmGoogleMapCircle = google_map_circle_1.SebmGoogleMapCircle;
	var google_map_info_window_1 = __webpack_require__(73);
	exports.SebmGoogleMapInfoWindow = google_map_info_window_1.SebmGoogleMapInfoWindow;
	var google_map_kml_layer_1 = __webpack_require__(74);
	exports.SebmGoogleMapKmlLayer = google_map_kml_layer_1.SebmGoogleMapKmlLayer;
	var google_map_marker_1 = __webpack_require__(75);
	exports.SebmGoogleMapMarker = google_map_marker_1.SebmGoogleMapMarker;
	var google_map_polygon_1 = __webpack_require__(76);
	exports.SebmGoogleMapPolygon = google_map_polygon_1.SebmGoogleMapPolygon;
	var google_map_polyline_1 = __webpack_require__(77);
	exports.SebmGoogleMapPolyline = google_map_polyline_1.SebmGoogleMapPolyline;
	var google_map_polyline_point_1 = __webpack_require__(78);
	exports.SebmGoogleMapPolylinePoint = google_map_polyline_point_1.SebmGoogleMapPolylinePoint;
	//# sourceMappingURL=directives.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var circle_manager_1 = __webpack_require__(66);
	var info_window_manager_1 = __webpack_require__(67);
	var marker_manager_1 = __webpack_require__(68);
	var polygon_manager_1 = __webpack_require__(69);
	var polyline_manager_1 = __webpack_require__(70);
	var kml_layer_manager_1 = __webpack_require__(71);
	/**
	 * SebMGoogleMap renders a Google Map.
	 * **Important note**: To be able see a map in the browser, you have to define a height for the CSS
	 * class `sebm-google-map-container`.
	 *
	 * ### Example
	 * ```typescript
	 * import { Component } from '@angular/core';
	 * import { SebmGoogleMap } from 'angular2-google-maps/core';
	 *
	 * @Component({
	 *  selector: 'my-map-cmp',
	 *  directives: [SebmGoogleMap],
	 *  styles: [`
	 *    .sebm-google-map-container {
	 *      height: 300px;
	 *    }
	 * `],
	 *  template: `
	 *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
	 *    </sebm-google-map>
	 *  `
	 * })
	 * ```
	 */
	var SebmGoogleMap = (function () {
	    function SebmGoogleMap(_elem, _mapsWrapper) {
	        this._elem = _elem;
	        this._mapsWrapper = _mapsWrapper;
	        /**
	         * The longitude that defines the center of the map.
	         */
	        this.longitude = 0;
	        /**
	         * The latitude that defines the center of the map.
	         */
	        this.latitude = 0;
	        /**
	         * The zoom level of the map. The default zoom level is 8.
	         */
	        this.zoom = 8;
	        /**
	         * Enables/disables if map is draggable.
	         */
	        this.draggable = true;
	        /**
	         * Enables/disables zoom and center on double click. Enabled by default.
	         */
	        this.disableDoubleClickZoom = false;
	        /**
	         * Enables/disables all default UI of the Google map. Please note: When the map is created, this
	         * value cannot get updated.
	         */
	        this.disableDefaultUI = false;
	        /**
	         * If false, disables scrollwheel zooming on the map. The scrollwheel is enabled by default.
	         */
	        this.scrollwheel = true;
	        /**
	         * If false, prevents the map from being controlled by the keyboard. Keyboard shortcuts are
	         * enabled by default.
	         */
	        this.keyboardShortcuts = true;
	        /**
	         * The enabled/disabled state of the Zoom control.
	         */
	        this.zoomControl = true;
	        /**
	         * Styles to apply to each of the default map types. Note that for Satellite/Hybrid and Terrain
	         * modes, these styles will only apply to labels and geometry.
	         */
	        this.styles = [];
	        /**
	         * When true and the latitude and/or longitude values changes, the Google Maps panTo method is
	         * used to
	         * center the map. See: https://developers.google.com/maps/documentation/javascript/reference#Map
	         */
	        this.usePanning = false;
	        /**
	         * The initial enabled/disabled state of the Street View Pegman control.
	         * This control is part of the default UI, and should be set to false when displaying a map type
	         * on which the Street View road overlay should not appear (e.g. a non-Earth map type).
	         */
	        this.streetViewControl = true;
	        /**
	         * Sets the viewport to contain the given bounds.
	         */
	        this.fitBounds = null;
	        /**
	         * The initial enabled/disabled state of the Scale control. This is disabled by default.
	         */
	        this.scaleControl = false;
	        /**
	         * The initial enabled/disabled state of the Map type control.
	         */
	        this.mapTypeControl = false;
	        this._observableSubscriptions = [];
	        /**
	         * This event emitter gets emitted when the user clicks on the map (but not when they click on a
	         * marker or infoWindow).
	         */
	        this.mapClick = new core_1.EventEmitter();
	        /**
	         * This event emitter gets emitted when the user right-clicks on the map (but not when they click
	         * on a marker or infoWindow).
	         */
	        this.mapRightClick = new core_1.EventEmitter();
	        /**
	         * This event emitter gets emitted when the user double-clicks on the map (but not when they click
	         * on a marker or infoWindow).
	         */
	        this.mapDblClick = new core_1.EventEmitter();
	        /**
	         * This event emitter is fired when the map center changes.
	         */
	        this.centerChange = new core_1.EventEmitter();
	        /**
	         * This event is fired when the viewport bounds have changed.
	         */
	        this.boundsChange = new core_1.EventEmitter();
	        /**
	         * This event is fired when the map becomes idle after panning or zooming.
	         */
	        this.idle = new core_1.EventEmitter();
	        /**
	         * This event is fired when the zoom level has changed.
	         */
	        this.zoomChange = new core_1.EventEmitter();
	    }
	    /** @internal */
	    SebmGoogleMap.prototype.ngOnInit = function () {
	        // todo: this should be solved with a new component and a viewChild decorator
	        var container = this._elem.nativeElement.querySelector('.sebm-google-map-container-inner');
	        this._initMapInstance(container);
	    };
	    SebmGoogleMap.prototype._initMapInstance = function (el) {
	        this._mapsWrapper.createMap(el, {
	            center: { lat: this.latitude || 0, lng: this.longitude || 0 },
	            zoom: this.zoom,
	            minZoom: this.minZoom,
	            maxZoom: this.maxZoom,
	            disableDefaultUI: this.disableDefaultUI,
	            backgroundColor: this.backgroundColor,
	            draggable: this.draggable,
	            draggableCursor: this.draggableCursor,
	            draggingCursor: this.draggingCursor,
	            keyboardShortcuts: this.keyboardShortcuts,
	            zoomControl: this.zoomControl,
	            styles: this.styles,
	            streetViewControl: this.streetViewControl,
	            scaleControl: this.scaleControl,
	            mapTypeControl: this.mapTypeControl
	        });
	        // register event listeners
	        this._handleMapCenterChange();
	        this._handleMapZoomChange();
	        this._handleMapMouseEvents();
	        this._handleBoundsChange();
	        this._handleIdleEvent();
	    };
	    /** @internal */
	    SebmGoogleMap.prototype.ngOnDestroy = function () {
	        // unsubscribe all registered observable subscriptions
	        this._observableSubscriptions.forEach(function (s) { return s.unsubscribe(); });
	    };
	    /* @internal */
	    SebmGoogleMap.prototype.ngOnChanges = function (changes) {
	        this._updateMapOptionsChanges(changes);
	        this._updatePosition(changes);
	    };
	    SebmGoogleMap.prototype._updateMapOptionsChanges = function (changes) {
	        var options = {};
	        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMap._mapOptionsAttributes.indexOf(k) !== -1; });
	        optionKeys.forEach(function (k) { options[k] = changes[k].currentValue; });
	        this._mapsWrapper.setMapOptions(options);
	    };
	    /**
	     * Triggers a resize event on the google map instance.
	     * Returns a promise that gets resolved after the event was triggered.
	     */
	    SebmGoogleMap.prototype.triggerResize = function () {
	        var _this = this;
	        // Note: When we would trigger the resize event and show the map in the same turn (which is a
	        // common case for triggering a resize event), then the resize event would not
	        // work (to show the map), so we trigger the event in a timeout.
	        return new Promise(function (resolve) {
	            setTimeout(function () { return _this._mapsWrapper.triggerMapEvent('resize').then(function () { return resolve(); }); });
	        });
	    };
	    SebmGoogleMap.prototype._updatePosition = function (changes) {
	        if (changes['latitude'] == null && changes['longitude'] == null &&
	            changes['fitBounds'] == null) {
	            // no position update needed
	            return;
	        }
	        // we prefer fitBounds in changes
	        if (changes['fitBounds'] && this.fitBounds != null) {
	            this._fitBounds();
	            return;
	        }
	        if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {
	            return;
	        }
	        var newCenter = {
	            lat: this.latitude,
	            lng: this.longitude,
	        };
	        if (this.usePanning) {
	            this._mapsWrapper.panTo(newCenter);
	        }
	        else {
	            this._mapsWrapper.setCenter(newCenter);
	        }
	    };
	    SebmGoogleMap.prototype._fitBounds = function () {
	        if (this.usePanning) {
	            this._mapsWrapper.panToBounds(this.fitBounds);
	            return;
	        }
	        this._mapsWrapper.fitBounds(this.fitBounds);
	    };
	    SebmGoogleMap.prototype._handleMapCenterChange = function () {
	        var _this = this;
	        var s = this._mapsWrapper.subscribeToMapEvent('center_changed').subscribe(function () {
	            _this._mapsWrapper.getCenter().then(function (center) {
	                _this.latitude = center.lat();
	                _this.longitude = center.lng();
	                _this.centerChange.emit({ lat: _this.latitude, lng: _this.longitude });
	            });
	        });
	        this._observableSubscriptions.push(s);
	    };
	    SebmGoogleMap.prototype._handleBoundsChange = function () {
	        var _this = this;
	        var s = this._mapsWrapper.subscribeToMapEvent('bounds_changed').subscribe(function () {
	            _this._mapsWrapper.getBounds().then(function (bounds) { _this.boundsChange.emit(bounds); });
	        });
	        this._observableSubscriptions.push(s);
	    };
	    SebmGoogleMap.prototype._handleMapZoomChange = function () {
	        var _this = this;
	        var s = this._mapsWrapper.subscribeToMapEvent('zoom_changed').subscribe(function () {
	            _this._mapsWrapper.getZoom().then(function (z) {
	                _this.zoom = z;
	                _this.zoomChange.emit(z);
	            });
	        });
	        this._observableSubscriptions.push(s);
	    };
	    SebmGoogleMap.prototype._handleIdleEvent = function () {
	        var _this = this;
	        var s = this._mapsWrapper.subscribeToMapEvent('idle').subscribe(function () { _this.idle.emit(void 0); });
	        this._observableSubscriptions.push(s);
	    };
	    SebmGoogleMap.prototype._handleMapMouseEvents = function () {
	        var _this = this;
	        var events = [
	            { name: 'click', emitter: this.mapClick },
	            { name: 'rightclick', emitter: this.mapRightClick },
	        ];
	        events.forEach(function (e) {
	            var s = _this._mapsWrapper.subscribeToMapEvent(e.name).subscribe(function (event) {
	                var value = { coords: { lat: event.latLng.lat(), lng: event.latLng.lng() } };
	                e.emitter.emit(value);
	            });
	            _this._observableSubscriptions.push(s);
	        });
	    };
	    /**
	     * Map option attributes that can change over time
	     */
	    SebmGoogleMap._mapOptionsAttributes = [
	        'disableDoubleClickZoom', 'scrollwheel', 'draggable', 'draggableCursor', 'draggingCursor',
	        'keyboardShortcuts', 'zoomControl', 'styles', 'streetViewControl', 'zoom', 'mapTypeControl',
	        'minZoom', 'maxZoom'
	    ];
	    SebmGoogleMap.decorators = [
	        { type: core_1.Component, args: [{
	                    selector: 'sebm-google-map',
	                    providers: [
	                        google_maps_api_wrapper_1.GoogleMapsAPIWrapper, marker_manager_1.MarkerManager, info_window_manager_1.InfoWindowManager, circle_manager_1.CircleManager, polyline_manager_1.PolylineManager,
	                        polygon_manager_1.PolygonManager, kml_layer_manager_1.KmlLayerManager
	                    ],
	                    inputs: [
	                        'longitude', 'latitude', 'zoom', 'minZoom', 'maxZoom', 'draggable: mapDraggable',
	                        'disableDoubleClickZoom', 'disableDefaultUI', 'scrollwheel', 'backgroundColor', 'draggableCursor',
	                        'draggingCursor', 'keyboardShortcuts', 'zoomControl', 'styles', 'usePanning', 'streetViewControl',
	                        'fitBounds', 'scaleControl', 'mapTypeControl'
	                    ],
	                    outputs: [
	                        'mapClick', 'mapRightClick', 'mapDblClick', 'centerChange', 'idle', 'boundsChange', 'zoomChange'
	                    ],
	                    host: { '[class.sebm-google-map-container]': 'true' },
	                    styles: ["\n    .sebm-google-map-container-inner {\n      width: inherit;\n      height: inherit;\n    }\n    .sebm-google-map-content {\n      display:none;\n    }\n  "],
	                    template: "\n    <div class='sebm-google-map-container-inner'></div>\n    <div class='sebm-google-map-content'>\n      <ng-content></ng-content>\n    </div>\n  "
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMap.ctorParameters = function () { return [
	        { type: core_1.ElementRef, },
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	    ]; };
	    return SebmGoogleMap;
	}());
	exports.SebmGoogleMap = SebmGoogleMap;
	//# sourceMappingURL=google-map.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var maps_api_loader_1 = __webpack_require__(65);
	/**
	 * Wrapper class that handles the communication with the Google Maps Javascript
	 * API v3
	 */
	var GoogleMapsAPIWrapper = (function () {
	    function GoogleMapsAPIWrapper(_loader, _zone) {
	        var _this = this;
	        this._loader = _loader;
	        this._zone = _zone;
	        this._map =
	            new Promise(function (resolve) { _this._mapResolver = resolve; });
	    }
	    GoogleMapsAPIWrapper.prototype.createMap = function (el, mapOptions) {
	        var _this = this;
	        return this._loader.load().then(function () {
	            var map = new google.maps.Map(el, mapOptions);
	            _this._mapResolver(map);
	            return;
	        });
	    };
	    GoogleMapsAPIWrapper.prototype.setMapOptions = function (options) {
	        this._map.then(function (m) { m.setOptions(options); });
	    };
	    /**
	     * Creates a google map marker with the map context
	     */
	    GoogleMapsAPIWrapper.prototype.createMarker = function (options) {
	        if (options === void 0) { options = {}; }
	        return this._map.then(function (map) {
	            options.map = map;
	            return new google.maps.Marker(options);
	        });
	    };
	    GoogleMapsAPIWrapper.prototype.createInfoWindow = function (options) {
	        return this._map.then(function () { return new google.maps.InfoWindow(options); });
	    };
	    /**
	     * Creates a google.map.Circle for the current map.
	     */
	    GoogleMapsAPIWrapper.prototype.createCircle = function (options) {
	        return this._map.then(function (map) {
	            options.map = map;
	            return new google.maps.Circle(options);
	        });
	    };
	    GoogleMapsAPIWrapper.prototype.createPolyline = function (options) {
	        return this.getNativeMap().then(function (map) {
	            var line = new google.maps.Polyline(options);
	            line.setMap(map);
	            return line;
	        });
	    };
	    GoogleMapsAPIWrapper.prototype.createPolygon = function (options) {
	        return this.getNativeMap().then(function (map) {
	            var polygon = new google.maps.Polygon(options);
	            polygon.setMap(map);
	            return polygon;
	        });
	    };
	    /**
	     * Determines if given coordinates are insite a Polygon path.
	     */
	    GoogleMapsAPIWrapper.prototype.containsLocation = function (latLng, polygon) {
	        return google.maps.geometry.poly.containsLocation(latLng, polygon);
	    };
	    GoogleMapsAPIWrapper.prototype.subscribeToMapEvent = function (eventName) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._map.then(function (m) {
	                m.addListener(eventName, function (arg) { _this._zone.run(function () { return observer.next(arg); }); });
	            });
	        });
	    };
	    GoogleMapsAPIWrapper.prototype.setCenter = function (latLng) {
	        return this._map.then(function (map) { return map.setCenter(latLng); });
	    };
	    GoogleMapsAPIWrapper.prototype.getZoom = function () { return this._map.then(function (map) { return map.getZoom(); }); };
	    GoogleMapsAPIWrapper.prototype.getBounds = function () {
	        return this._map.then(function (map) { return map.getBounds(); });
	    };
	    GoogleMapsAPIWrapper.prototype.setZoom = function (zoom) {
	        return this._map.then(function (map) { return map.setZoom(zoom); });
	    };
	    GoogleMapsAPIWrapper.prototype.getCenter = function () {
	        return this._map.then(function (map) { return map.getCenter(); });
	    };
	    GoogleMapsAPIWrapper.prototype.panTo = function (latLng) {
	        return this._map.then(function (map) { return map.panTo(latLng); });
	    };
	    GoogleMapsAPIWrapper.prototype.fitBounds = function (latLng) {
	        return this._map.then(function (map) { return map.fitBounds(latLng); });
	    };
	    GoogleMapsAPIWrapper.prototype.panToBounds = function (latLng) {
	        return this._map.then(function (map) { return map.panToBounds(latLng); });
	    };
	    /**
	     * Returns the native Google Maps Map instance. Be careful when using this instance directly.
	     */
	    GoogleMapsAPIWrapper.prototype.getNativeMap = function () { return this._map; };
	    /**
	     * Triggers the given event name on the map instance.
	     */
	    GoogleMapsAPIWrapper.prototype.triggerMapEvent = function (eventName) {
	        return this._map.then(function (m) { return google.maps.event.trigger(m, eventName); });
	    };
	    GoogleMapsAPIWrapper.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    GoogleMapsAPIWrapper.ctorParameters = function () { return [
	        { type: maps_api_loader_1.MapsAPILoader, },
	        { type: core_1.NgZone, },
	    ]; };
	    return GoogleMapsAPIWrapper;
	}());
	exports.GoogleMapsAPIWrapper = GoogleMapsAPIWrapper;
	//# sourceMappingURL=google-maps-api-wrapper.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var MapsAPILoader = (function () {
	    function MapsAPILoader() {
	    }
	    MapsAPILoader.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    MapsAPILoader.ctorParameters = function () { return []; };
	    return MapsAPILoader;
	}());
	exports.MapsAPILoader = MapsAPILoader;
	//# sourceMappingURL=maps-api-loader.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var CircleManager = (function () {
	    function CircleManager(_apiWrapper, _zone) {
	        this._apiWrapper = _apiWrapper;
	        this._zone = _zone;
	        this._circles = new Map();
	    }
	    CircleManager.prototype.addCircle = function (circle) {
	        this._circles.set(circle, this._apiWrapper.createCircle({
	            center: { lat: circle.latitude, lng: circle.longitude },
	            clickable: circle.clickable,
	            draggable: circle.draggable,
	            editable: circle.editable,
	            fillColor: circle.fillColor,
	            fillOpacity: circle.fillOpacity,
	            radius: circle.radius,
	            strokeColor: circle.strokeColor,
	            strokeOpacity: circle.strokeOpacity,
	            strokePosition: circle.strokePosition,
	            strokeWeight: circle.strokeWeight,
	            visible: circle.visible,
	            zIndex: circle.zIndex
	        }));
	    };
	    ;
	    /**
	     * Removes the given circle from the map.
	     */
	    CircleManager.prototype.removeCircle = function (circle) {
	        var _this = this;
	        return this._circles.get(circle).then(function (c) {
	            c.setMap(null);
	            _this._circles.delete(circle);
	        });
	    };
	    CircleManager.prototype.setOptions = function (circle, options) {
	        return this._circles.get(circle).then(function (c) { return c.setOptions(options); });
	    };
	    ;
	    CircleManager.prototype.getBounds = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.getBounds(); });
	    };
	    ;
	    CircleManager.prototype.getCenter = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.getCenter(); });
	    };
	    ;
	    CircleManager.prototype.getRadius = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.getRadius(); });
	    };
	    CircleManager.prototype.setCenter = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.setCenter({ lat: circle.latitude, lng: circle.longitude }); });
	    };
	    ;
	    CircleManager.prototype.setEditable = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.setEditable(circle.editable); });
	    };
	    ;
	    CircleManager.prototype.setDraggable = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.setDraggable(circle.draggable); });
	    };
	    ;
	    CircleManager.prototype.setVisible = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.setVisible(circle.visible); });
	    };
	    ;
	    CircleManager.prototype.setRadius = function (circle) {
	        return this._circles.get(circle).then(function (c) { return c.setRadius(circle.radius); });
	    };
	    ;
	    CircleManager.prototype.createEventObservable = function (eventName, circle) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            var listener = null;
	            _this._circles.get(circle).then(function (c) {
	                listener = c.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	            return function () {
	                if (listener !== null) {
	                    listener.remove();
	                }
	            };
	        });
	    };
	    CircleManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    CircleManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	    ]; };
	    return CircleManager;
	}());
	exports.CircleManager = CircleManager;
	//# sourceMappingURL=circle-manager.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(9);
	var core_1 = __webpack_require__(7);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var marker_manager_1 = __webpack_require__(68);
	var InfoWindowManager = (function () {
	    function InfoWindowManager(_mapsWrapper, _zone, _markerManager) {
	        this._mapsWrapper = _mapsWrapper;
	        this._zone = _zone;
	        this._markerManager = _markerManager;
	        this._infoWindows = new Map();
	    }
	    InfoWindowManager.prototype.deleteInfoWindow = function (infoWindow) {
	        var _this = this;
	        var iWindow = this._infoWindows.get(infoWindow);
	        if (iWindow == null) {
	            // info window already deleted
	            return Promise.resolve();
	        }
	        return iWindow.then(function (i) {
	            return _this._zone.run(function () {
	                i.close();
	                _this._infoWindows.delete(infoWindow);
	            });
	        });
	    };
	    InfoWindowManager.prototype.setPosition = function (infoWindow) {
	        return this._infoWindows.get(infoWindow).then(function (i) { return i.setPosition({
	            lat: infoWindow.latitude,
	            lng: infoWindow.longitude
	        }); });
	    };
	    InfoWindowManager.prototype.setZIndex = function (infoWindow) {
	        return this._infoWindows.get(infoWindow)
	            .then(function (i) { return i.setZIndex(infoWindow.zIndex); });
	    };
	    InfoWindowManager.prototype.open = function (infoWindow) {
	        var _this = this;
	        return this._infoWindows.get(infoWindow).then(function (w) {
	            if (infoWindow.hostMarker != null) {
	                return _this._markerManager.getNativeMarker(infoWindow.hostMarker).then(function (marker) {
	                    return _this._mapsWrapper.getNativeMap().then(function (map) { return w.open(map, marker); });
	                });
	            }
	            return _this._mapsWrapper.getNativeMap().then(function (map) { return w.open(map); });
	        });
	    };
	    InfoWindowManager.prototype.close = function (infoWindow) {
	        return this._infoWindows.get(infoWindow).then(function (w) { return w.close(); });
	    };
	    InfoWindowManager.prototype.setOptions = function (infoWindow, options) {
	        return this._infoWindows.get(infoWindow).then(function (i) { return i.setOptions(options); });
	    };
	    InfoWindowManager.prototype.addInfoWindow = function (infoWindow) {
	        var options = {
	            content: infoWindow.content,
	            maxWidth: infoWindow.maxWidth,
	            zIndex: infoWindow.zIndex,
	        };
	        if (typeof infoWindow.latitude === 'number' && typeof infoWindow.longitude === 'number') {
	            options.position = { lat: infoWindow.latitude, lng: infoWindow.longitude };
	        }
	        var infoWindowPromise = this._mapsWrapper.createInfoWindow(options);
	        this._infoWindows.set(infoWindow, infoWindowPromise);
	    };
	    /**
	     * Creates a Google Maps event listener for the given InfoWindow as an Observable
	     */
	    InfoWindowManager.prototype.createEventObservable = function (eventName, infoWindow) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._infoWindows.get(infoWindow).then(function (i) {
	                i.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	        });
	    };
	    InfoWindowManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    InfoWindowManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	        { type: marker_manager_1.MarkerManager, },
	    ]; };
	    return InfoWindowManager;
	}());
	exports.InfoWindowManager = InfoWindowManager;
	//# sourceMappingURL=info-window-manager.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var MarkerManager = (function () {
	    function MarkerManager(_mapsWrapper, _zone) {
	        this._mapsWrapper = _mapsWrapper;
	        this._zone = _zone;
	        this._markers = new Map();
	    }
	    MarkerManager.prototype.deleteMarker = function (marker) {
	        var _this = this;
	        var m = this._markers.get(marker);
	        if (m == null) {
	            // marker already deleted
	            return Promise.resolve();
	        }
	        return m.then(function (m) {
	            return _this._zone.run(function () {
	                m.setMap(null);
	                _this._markers.delete(marker);
	            });
	        });
	    };
	    MarkerManager.prototype.updateMarkerPosition = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setPosition({ lat: marker.latitude, lng: marker.longitude }); });
	    };
	    MarkerManager.prototype.updateTitle = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setTitle(marker.title); });
	    };
	    MarkerManager.prototype.updateLabel = function (marker) {
	        return this._markers.get(marker).then(function (m) { m.setLabel(marker.label); });
	    };
	    MarkerManager.prototype.updateDraggable = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setDraggable(marker.draggable); });
	    };
	    MarkerManager.prototype.updateIcon = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setIcon(marker.iconUrl); });
	    };
	    MarkerManager.prototype.updateOpacity = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setOpacity(marker.opacity); });
	    };
	    MarkerManager.prototype.updateVisible = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setVisible(marker.visible); });
	    };
	    MarkerManager.prototype.updateZIndex = function (marker) {
	        return this._markers.get(marker).then(function (m) { return m.setZIndex(marker.zIndex); });
	    };
	    MarkerManager.prototype.addMarker = function (marker) {
	        var markerPromise = this._mapsWrapper.createMarker({
	            position: { lat: marker.latitude, lng: marker.longitude },
	            label: marker.label,
	            draggable: marker.draggable,
	            icon: marker.iconUrl,
	            opacity: marker.opacity,
	            visible: marker.visible,
	            zIndex: marker.zIndex,
	            title: marker.title
	        });
	        this._markers.set(marker, markerPromise);
	    };
	    MarkerManager.prototype.getNativeMarker = function (marker) {
	        return this._markers.get(marker);
	    };
	    MarkerManager.prototype.createEventObservable = function (eventName, marker) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._markers.get(marker).then(function (m) {
	                m.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	        });
	    };
	    MarkerManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    MarkerManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	    ]; };
	    return MarkerManager;
	}());
	exports.MarkerManager = MarkerManager;
	//# sourceMappingURL=marker-manager.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var PolygonManager = (function () {
	    function PolygonManager(_mapsWrapper, _zone) {
	        this._mapsWrapper = _mapsWrapper;
	        this._zone = _zone;
	        this._polygons = new Map();
	    }
	    PolygonManager.prototype.addPolygon = function (path) {
	        var polygonPromise = this._mapsWrapper.createPolygon({
	            clickable: path.clickable,
	            draggable: path.draggable,
	            editable: path.editable,
	            fillColor: path.fillColor,
	            fillOpacity: path.fillOpacity,
	            geodesic: path.geodesic,
	            paths: path.paths,
	            strokeColor: path.strokeColor,
	            strokeOpacity: path.strokeOpacity,
	            strokeWeight: path.strokeWeight,
	            visible: path.visible,
	            zIndex: path.zIndex,
	        });
	        this._polygons.set(path, polygonPromise);
	    };
	    PolygonManager.prototype.updatePolygon = function (polygon) {
	        var _this = this;
	        var m = this._polygons.get(polygon);
	        if (m == null) {
	            return Promise.resolve();
	        }
	        return m.then(function (l) { return _this._zone.run(function () { l.setPaths(polygon.paths); }); });
	    };
	    PolygonManager.prototype.setPolygonOptions = function (path, options) {
	        return this._polygons.get(path).then(function (l) { l.setOptions(options); });
	    };
	    PolygonManager.prototype.deletePolygon = function (paths) {
	        var _this = this;
	        var m = this._polygons.get(paths);
	        if (m == null) {
	            return Promise.resolve();
	        }
	        return m.then(function (l) {
	            return _this._zone.run(function () {
	                l.setMap(null);
	                _this._polygons.delete(paths);
	            });
	        });
	    };
	    PolygonManager.prototype.createEventObservable = function (eventName, path) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._polygons.get(path).then(function (l) {
	                l.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	        });
	    };
	    PolygonManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    PolygonManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	    ]; };
	    return PolygonManager;
	}());
	exports.PolygonManager = PolygonManager;
	//# sourceMappingURL=polygon-manager.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	var PolylineManager = (function () {
	    function PolylineManager(_mapsWrapper, _zone) {
	        this._mapsWrapper = _mapsWrapper;
	        this._zone = _zone;
	        this._polylines = new Map();
	    }
	    PolylineManager._convertPoints = function (line) {
	        var path = line._getPoints().map(function (point) {
	            return { lat: point.latitude, lng: point.longitude };
	        });
	        return path;
	    };
	    PolylineManager.prototype.addPolyline = function (line) {
	        var path = PolylineManager._convertPoints(line);
	        var polylinePromise = this._mapsWrapper.createPolyline({
	            clickable: line.clickable,
	            draggable: line.draggable,
	            editable: line.editable,
	            geodesic: line.geodesic,
	            strokeColor: line.strokeColor,
	            strokeOpacity: line.strokeOpacity,
	            strokeWeight: line.strokeWeight,
	            visible: line.visible,
	            zIndex: line.zIndex,
	            path: path
	        });
	        this._polylines.set(line, polylinePromise);
	    };
	    PolylineManager.prototype.updatePolylinePoints = function (line) {
	        var _this = this;
	        var path = PolylineManager._convertPoints(line);
	        var m = this._polylines.get(line);
	        if (m == null) {
	            return Promise.resolve();
	        }
	        return m.then(function (l) { return _this._zone.run(function () { l.setPath(path); }); });
	    };
	    PolylineManager.prototype.setPolylineOptions = function (line, options) {
	        return this._polylines.get(line).then(function (l) { l.setOptions(options); });
	    };
	    PolylineManager.prototype.deletePolyline = function (line) {
	        var _this = this;
	        var m = this._polylines.get(line);
	        if (m == null) {
	            return Promise.resolve();
	        }
	        return m.then(function (l) {
	            return _this._zone.run(function () {
	                l.setMap(null);
	                _this._polylines.delete(line);
	            });
	        });
	    };
	    PolylineManager.prototype.createEventObservable = function (eventName, line) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._polylines.get(line).then(function (l) {
	                l.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	        });
	    };
	    PolylineManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    PolylineManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	    ]; };
	    return PolylineManager;
	}());
	exports.PolylineManager = PolylineManager;
	//# sourceMappingURL=polyline-manager.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(9);
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	/**
	 * Manages all KML Layers for a Google Map instance.
	 */
	var KmlLayerManager = (function () {
	    function KmlLayerManager(_wrapper, _zone) {
	        this._wrapper = _wrapper;
	        this._zone = _zone;
	        this._layers = new Map();
	    }
	    /**
	     * Adds a new KML Layer to the map.
	     */
	    KmlLayerManager.prototype.addKmlLayer = function (layer) {
	        var newLayer = this._wrapper.getNativeMap().then(function (m) {
	            return new google.maps.KmlLayer({
	                clickable: layer.clickable,
	                map: m,
	                preserveViewport: layer.preserveViewport,
	                screenOverlays: layer.screenOverlays,
	                suppressInfoWindows: layer.suppressInfoWindows,
	                url: layer.url,
	                zIndex: layer.zIndex
	            });
	        });
	        this._layers.set(layer, newLayer);
	    };
	    KmlLayerManager.prototype.setOptions = function (layer, options) {
	        this._layers.get(layer).then(function (l) { return l.setOptions(options); });
	    };
	    KmlLayerManager.prototype.deleteKmlLayer = function (layer) {
	        var _this = this;
	        this._layers.get(layer).then(function (l) {
	            l.setMap(null);
	            _this._layers.delete(layer);
	        });
	    };
	    /**
	     * Creates a Google Maps event listener for the given KmlLayer as an Observable
	     */
	    KmlLayerManager.prototype.createEventObservable = function (eventName, layer) {
	        var _this = this;
	        return Observable_1.Observable.create(function (observer) {
	            _this._layers.get(layer).then(function (m) {
	                m.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
	            });
	        });
	    };
	    KmlLayerManager.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    KmlLayerManager.ctorParameters = function () { return [
	        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },
	        { type: core_1.NgZone, },
	    ]; };
	    return KmlLayerManager;
	}());
	exports.KmlLayerManager = KmlLayerManager;
	//# sourceMappingURL=kml-layer-manager.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var circle_manager_1 = __webpack_require__(66);
	var SebmGoogleMapCircle = (function () {
	    function SebmGoogleMapCircle(_manager) {
	        this._manager = _manager;
	        /**
	         * Indicates whether this Circle handles mouse events. Defaults to true.
	         */
	        this.clickable = true;
	        /**
	         * If set to true, the user can drag this circle over the map. Defaults to false.
	         */
	        this.draggable = false;
	        /**
	         * If set to true, the user can edit this circle by dragging the control points shown at
	         * the center and around the circumference of the circle. Defaults to false.
	         */
	        this.editable = false;
	        /**
	         * The radius in meters on the Earth's surface.
	         */
	        this.radius = 0;
	        /**
	         * The stroke position. Defaults to CENTER.
	         * This property is not supported on Internet Explorer 8 and earlier.
	         */
	        this.strokePosition = 'CENTER';
	        /**
	         * The stroke width in pixels.
	         */
	        this.strokeWeight = 0;
	        /**
	         * Whether this circle is visible on the map. Defaults to true.
	         */
	        this.visible = true;
	        /**
	         * This event is fired when the circle's center is changed.
	         */
	        this.centerChange = new core_1.EventEmitter();
	        /**
	         * This event emitter gets emitted when the user clicks on the circle.
	         */
	        this.circleClick = new core_1.EventEmitter();
	        /**
	         * This event emitter gets emitted when the user clicks on the circle.
	         */
	        this.circleDblClick = new core_1.EventEmitter();
	        /**
	         * This event is repeatedly fired while the user drags the circle.
	         */
	        this.drag = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user stops dragging the circle.
	         */
	        this.dragEnd = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user starts dragging the circle.
	         */
	        this.dragStart = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousedown event is fired on the circle.
	         */
	        this.mouseDown = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousemove event is fired on the circle.
	         */
	        this.mouseMove = new core_1.EventEmitter();
	        /**
	         * This event is fired on circle mouseout.
	         */
	        this.mouseOut = new core_1.EventEmitter();
	        /**
	         * This event is fired on circle mouseover.
	         */
	        this.mouseOver = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mouseup event is fired on the circle.
	         */
	        this.mouseUp = new core_1.EventEmitter();
	        /**
	         * This event is fired when the circle's radius is changed.
	         */
	        this.radiusChange = new core_1.EventEmitter();
	        /**
	         * This event is fired when the circle is right-clicked on.
	         */
	        this.rightClick = new core_1.EventEmitter();
	        this._circleAddedToManager = false;
	        this._eventSubscriptions = [];
	    }
	    /** @internal */
	    SebmGoogleMapCircle.prototype.ngOnInit = function () {
	        this._manager.addCircle(this);
	        this._circleAddedToManager = true;
	        this._registerEventListeners();
	    };
	    /** @internal */
	    SebmGoogleMapCircle.prototype.ngOnChanges = function (changes) {
	        if (!this._circleAddedToManager) {
	            return;
	        }
	        if (changes['latitude'] || changes['longitude']) {
	            this._manager.setCenter(this);
	        }
	        if (changes['editable']) {
	            this._manager.setEditable(this);
	        }
	        if (changes['draggable']) {
	            this._manager.setDraggable(this);
	        }
	        if (changes['visible']) {
	            this._manager.setVisible(this);
	        }
	        if (changes['radius']) {
	            this._manager.setRadius(this);
	        }
	        this._updateCircleOptionsChanges(changes);
	    };
	    SebmGoogleMapCircle.prototype._updateCircleOptionsChanges = function (changes) {
	        var options = {};
	        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMapCircle._mapOptions.indexOf(k) !== -1; });
	        optionKeys.forEach(function (k) { options[k] = changes[k].currentValue; });
	        if (optionKeys.length > 0) {
	            this._manager.setOptions(this, options);
	        }
	    };
	    SebmGoogleMapCircle.prototype._registerEventListeners = function () {
	        var _this = this;
	        var events = new Map();
	        events.set('center_changed', this.centerChange);
	        events.set('click', this.circleClick);
	        events.set('dblclick', this.circleDblClick);
	        events.set('drag', this.drag);
	        events.set('dragend', this.dragEnd);
	        events.set('dragStart', this.dragStart);
	        events.set('mousedown', this.mouseDown);
	        events.set('mousemove', this.mouseMove);
	        events.set('mouseout', this.mouseOut);
	        events.set('mouseover', this.mouseOver);
	        events.set('mouseup', this.mouseUp);
	        events.set('radius_changed', this.radiusChange);
	        events.set('rightclick', this.rightClick);
	        events.forEach(function (eventEmitter, eventName) {
	            _this._eventSubscriptions.push(_this._manager.createEventObservable(eventName, _this).subscribe(function (value) {
	                switch (eventName) {
	                    case 'radius_changed':
	                        _this._manager.getRadius(_this).then(function (radius) { return eventEmitter.emit(radius); });
	                        break;
	                    case 'center_changed':
	                        _this._manager.getCenter(_this).then(function (center) {
	                            return eventEmitter.emit({ lat: center.lat(), lng: center.lng() });
	                        });
	                        break;
	                    default:
	                        eventEmitter.emit({ coords: { lat: value.latLng.lat(), lng: value.latLng.lng() } });
	                }
	            }));
	        });
	    };
	    /** @internal */
	    SebmGoogleMapCircle.prototype.ngOnDestroy = function () {
	        this._eventSubscriptions.forEach(function (s) { s.unsubscribe(); });
	        this._eventSubscriptions = null;
	        this._manager.removeCircle(this);
	    };
	    /**
	     * Gets the LatLngBounds of this Circle.
	     */
	    SebmGoogleMapCircle.prototype.getBounds = function () { return this._manager.getBounds(this); };
	    SebmGoogleMapCircle.prototype.getCenter = function () { return this._manager.getCenter(this); };
	    SebmGoogleMapCircle._mapOptions = [
	        'fillColor', 'fillOpacity', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight',
	        'visible', 'zIndex'
	    ];
	    SebmGoogleMapCircle.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'sebm-google-map-circle',
	                    inputs: [
	                        'latitude', 'longitude', 'clickable', 'draggable: circleDraggable', 'editable', 'fillColor',
	                        'fillOpacity', 'radius', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight',
	                        'visible', 'zIndex'
	                    ],
	                    outputs: [
	                        'centerChange', 'circleClick', 'circleDblClick', 'drag', 'dragEnd', 'dragStart', 'mouseDown',
	                        'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'radiusChange', 'rightClick'
	                    ]
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapCircle.ctorParameters = function () { return [
	        { type: circle_manager_1.CircleManager, },
	    ]; };
	    return SebmGoogleMapCircle;
	}());
	exports.SebmGoogleMapCircle = SebmGoogleMapCircle;
	//# sourceMappingURL=google-map-circle.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var info_window_manager_1 = __webpack_require__(67);
	var infoWindowId = 0;
	/**
	 * SebmGoogleMapInfoWindow renders a info window inside a {@link SebmGoogleMapMarker} or standalone.
	 *
	 * ### Example
	 * ```typescript
	 * import { Component } from 'angular2/core';
	 * import { SebmGoogleMap, SebmGoogleMapMarker, SebmGoogleMapInfoWindow } from
	 * 'angular2-google-maps/core';
	 *
	 * @Component({
	 *  selector: 'my-map-cmp',
	 *  directives: [SebmGoogleMap, SebmGoogleMapMarker, SebmGoogleMapInfoWindow],
	 *  styles: [`
	 *    .sebm-google-map-container {
	 *      height: 300px;
	 *    }
	 * `],
	 *  template: `
	 *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
	 *      <sebm-google-map-marker [latitude]="lat" [longitude]="lng" [label]="'M'">
	 *        <sebm-google-map-info-window [disableAutoPan]="true">
	 *          Hi, this is the content of the <strong>info window</strong>
	 *        </sebm-google-map-info-window>
	 *      </sebm-google-map-marker>
	 *    </sebm-google-map>
	 *  `
	 * })
	 * ```
	 */
	var SebmGoogleMapInfoWindow = (function () {
	    function SebmGoogleMapInfoWindow(_infoWindowManager, _el) {
	        this._infoWindowManager = _infoWindowManager;
	        this._el = _el;
	        /**
	         * Sets the open state for the InfoWindow. You can also call the open() and close() methods.
	         */
	        this.isOpen = false;
	        /**
	         * Emits an event when the info window is closed.
	         */
	        this.infoWindowClose = new core_1.EventEmitter();
	        this._infoWindowAddedToManager = false;
	        this._id = (infoWindowId++).toString();
	    }
	    SebmGoogleMapInfoWindow.prototype.ngOnInit = function () {
	        this.content = this._el.nativeElement.querySelector('.sebm-google-map-info-window-content');
	        this._infoWindowManager.addInfoWindow(this);
	        this._infoWindowAddedToManager = true;
	        this._updateOpenState();
	        this._registerEventListeners();
	    };
	    /** @internal */
	    SebmGoogleMapInfoWindow.prototype.ngOnChanges = function (changes) {
	        if (!this._infoWindowAddedToManager) {
	            return;
	        }
	        if ((changes['latitude'] || changes['longitude']) && typeof this.latitude === 'number' &&
	            typeof this.longitude === 'number') {
	            this._infoWindowManager.setPosition(this);
	        }
	        if (changes['zIndex']) {
	            this._infoWindowManager.setZIndex(this);
	        }
	        if (changes['isOpen']) {
	            this._updateOpenState();
	        }
	        this._setInfoWindowOptions(changes);
	    };
	    SebmGoogleMapInfoWindow.prototype._registerEventListeners = function () {
	        var _this = this;
	        this._infoWindowManager.createEventObservable('closeclick', this).subscribe(function () {
	            _this.isOpen = false;
	            _this.infoWindowClose.emit();
	        });
	    };
	    SebmGoogleMapInfoWindow.prototype._updateOpenState = function () {
	        this.isOpen ? this.open() : this.close();
	    };
	    SebmGoogleMapInfoWindow.prototype._setInfoWindowOptions = function (changes) {
	        var options = {};
	        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMapInfoWindow._infoWindowOptionsInputs.indexOf(k) !== -1; });
	        optionKeys.forEach(function (k) { options[k] = changes[k].currentValue; });
	        this._infoWindowManager.setOptions(this, options);
	    };
	    /**
	     * Opens the info window.
	     */
	    SebmGoogleMapInfoWindow.prototype.open = function () { return this._infoWindowManager.open(this); };
	    /**
	     * Closes the info window.
	     */
	    SebmGoogleMapInfoWindow.prototype.close = function () {
	        var _this = this;
	        return this._infoWindowManager.close(this).then(function () { _this.infoWindowClose.emit(); });
	    };
	    /** @internal */
	    SebmGoogleMapInfoWindow.prototype.id = function () { return this._id; };
	    /** @internal */
	    SebmGoogleMapInfoWindow.prototype.toString = function () { return 'SebmGoogleMapInfoWindow-' + this._id.toString(); };
	    /** @internal */
	    SebmGoogleMapInfoWindow.prototype.ngOnDestroy = function () { this._infoWindowManager.deleteInfoWindow(this); };
	    SebmGoogleMapInfoWindow._infoWindowOptionsInputs = ['disableAutoPan', 'maxWidth'];
	    SebmGoogleMapInfoWindow.decorators = [
	        { type: core_1.Component, args: [{
	                    selector: 'sebm-google-map-info-window',
	                    inputs: ['latitude', 'longitude', 'disableAutoPan', 'isOpen', 'zIndex', 'maxWidth'],
	                    outputs: ['infoWindowClose'],
	                    template: "<div class='sebm-google-map-info-window-content'>\n      <ng-content></ng-content>\n    </div>\n  "
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapInfoWindow.ctorParameters = function () { return [
	        { type: info_window_manager_1.InfoWindowManager, },
	        { type: core_1.ElementRef, },
	    ]; };
	    return SebmGoogleMapInfoWindow;
	}());
	exports.SebmGoogleMapInfoWindow = SebmGoogleMapInfoWindow;
	//# sourceMappingURL=google-map-info-window.js.map

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var kml_layer_manager_1 = __webpack_require__(71);
	var layerId = 0;
	var SebmGoogleMapKmlLayer = (function () {
	    function SebmGoogleMapKmlLayer(_manager) {
	        this._manager = _manager;
	        this._addedToManager = false;
	        this._id = (layerId++).toString();
	        this._subscriptions = [];
	        /**
	         * If true, the layer receives mouse events. Default value is true.
	         */
	        this.clickable = true;
	        /**
	         * By default, the input map is centered and zoomed to the bounding box of the contents of the
	         * layer.
	         * If this option is set to true, the viewport is left unchanged, unless the map's center and zoom
	         * were never set.
	         */
	        this.preserveViewport = false;
	        /**
	         * Whether to render the screen overlays. Default true.
	         */
	        this.screenOverlays = true;
	        /**
	         * Suppress the rendering of info windows when layer features are clicked.
	         */
	        this.suppressInfoWindows = false;
	        /**
	         * The URL of the KML document to display.
	         */
	        this.url = null;
	        /**
	         * The z-index of the layer.
	         */
	        this.zIndex = null;
	        /**
	         * This event is fired when a feature in the layer is clicked.
	         */
	        this.layerClick = new core_1.EventEmitter();
	        /**
	         * This event is fired when the KML layers default viewport has changed.
	         */
	        this.defaultViewportChange = new core_1.EventEmitter();
	        /**
	         * This event is fired when the KML layer has finished loading.
	         * At this point it is safe to read the status property to determine if the layer loaded
	         * successfully.
	         */
	        this.statusChange = new core_1.EventEmitter();
	    }
	    SebmGoogleMapKmlLayer.prototype.ngOnInit = function () {
	        if (this._addedToManager) {
	            return;
	        }
	        this._manager.addKmlLayer(this);
	        this._addedToManager = true;
	        this._addEventListeners();
	    };
	    SebmGoogleMapKmlLayer.prototype.ngOnChanges = function (changes) {
	        if (!this._addedToManager) {
	            return;
	        }
	        this._updatePolygonOptions(changes);
	    };
	    SebmGoogleMapKmlLayer.prototype._updatePolygonOptions = function (changes) {
	        var options = Object.keys(changes)
	            .filter(function (k) { return SebmGoogleMapKmlLayer._kmlLayerOptions.indexOf(k) !== -1; })
	            .reduce(function (obj, k) {
	            obj[k] = changes[k].currentValue;
	            return obj;
	        }, {});
	        if (Object.keys(options).length > 0) {
	            this._manager.setOptions(this, options);
	        }
	    };
	    SebmGoogleMapKmlLayer.prototype._addEventListeners = function () {
	        var _this = this;
	        var listeners = [
	            { name: 'click', handler: function (ev) { return _this.layerClick.emit(ev); } },
	            { name: 'defaultviewport_changed', handler: function () { return _this.defaultViewportChange.emit(); } },
	            { name: 'status_changed', handler: function () { return _this.statusChange.emit(); } },
	        ];
	        listeners.forEach(function (obj) {
	            var os = _this._manager.createEventObservable(obj.name, _this).subscribe(obj.handler);
	            _this._subscriptions.push(os);
	        });
	    };
	    /** @internal */
	    SebmGoogleMapKmlLayer.prototype.id = function () { return this._id; };
	    /** @internal */
	    SebmGoogleMapKmlLayer.prototype.toString = function () { return "SebmGoogleMapKmlLayer-" + this._id.toString(); };
	    /** @internal */
	    SebmGoogleMapKmlLayer.prototype.ngOnDestroy = function () {
	        this._manager.deleteKmlLayer(this);
	        // unsubscribe all registered observable subscriptions
	        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });
	    };
	    SebmGoogleMapKmlLayer._kmlLayerOptions = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'];
	    SebmGoogleMapKmlLayer.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'sebm-google-map-kml-layer',
	                    inputs: ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'],
	                    outputs: ['layerClick', 'defaultViewportChange', 'statusChange']
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapKmlLayer.ctorParameters = function () { return [
	        { type: kml_layer_manager_1.KmlLayerManager, },
	    ]; };
	    return SebmGoogleMapKmlLayer;
	}());
	exports.SebmGoogleMapKmlLayer = SebmGoogleMapKmlLayer;
	//# sourceMappingURL=google-map-kml-layer.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var marker_manager_1 = __webpack_require__(68);
	var google_map_info_window_1 = __webpack_require__(73);
	var markerId = 0;
	/**
	 * SebmGoogleMapMarker renders a map marker inside a {@link SebmGoogleMap}.
	 *
	 * ### Example
	 * ```typescript
	 * import { Component } from 'angular2/core';
	 * import { SebmGoogleMap, SebmGoogleMapMarker } from 'angular2-google-maps/core';
	 *
	 * @Component({
	 *  selector: 'my-map-cmp',
	 *  directives: [SebmGoogleMap, SebmGoogleMapMarker],
	 *  styles: [`
	 *    .sebm-google-map-container {
	 *      height: 300px;
	 *    }
	 * `],
	 *  template: `
	 *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
	 *      <sebm-google-map-marker [latitude]="lat" [longitude]="lng" [label]="'M'">
	 *      </sebm-google-map-marker>
	 *    </sebm-google-map>
	 *  `
	 * })
	 * ```
	 */
	var SebmGoogleMapMarker = (function () {
	    function SebmGoogleMapMarker(_markerManager) {
	        this._markerManager = _markerManager;
	        /**
	         * If true, the marker can be dragged. Default value is false.
	         */
	        this.draggable = false;
	        /**
	         * If true, the marker is visible
	         */
	        this.visible = true;
	        /**
	         * Whether to automatically open the child info window when the marker is clicked.
	         */
	        this.openInfoWindow = true;
	        /**
	         * The marker's opacity between 0.0 and 1.0.
	         */
	        this.opacity = 1;
	        /**
	         * All markers are displayed on the map in order of their zIndex, with higher values displaying in
	         * front of markers with lower values. By default, markers are displayed according to their
	         * vertical position on screen, with lower markers appearing in front of markers further up the
	         * screen.
	         */
	        this.zIndex = 1;
	        /**
	         * This event emitter gets emitted when the user clicks on the marker.
	         */
	        this.markerClick = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user stops dragging the marker.
	         */
	        this.dragEnd = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user mouses over the marker.
	         */
	        this.mouseOver = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user mouses outside the marker.
	         */
	        this.mouseOut = new core_1.EventEmitter();
	        this._markerAddedToManger = false;
	        this._observableSubscriptions = [];
	        this._id = (markerId++).toString();
	    }
	    /* @internal */
	    SebmGoogleMapMarker.prototype.ngAfterContentInit = function () {
	        if (this.infoWindow != null) {
	            this.infoWindow.hostMarker = this;
	        }
	    };
	    /** @internal */
	    SebmGoogleMapMarker.prototype.ngOnChanges = function (changes) {
	        if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {
	            return;
	        }
	        if (!this._markerAddedToManger) {
	            this._markerManager.addMarker(this);
	            this._markerAddedToManger = true;
	            this._addEventListeners();
	            return;
	        }
	        if (changes['latitude'] || changes['longitude']) {
	            this._markerManager.updateMarkerPosition(this);
	        }
	        if (changes['title']) {
	            this._markerManager.updateTitle(this);
	        }
	        if (changes['label']) {
	            this._markerManager.updateLabel(this);
	        }
	        if (changes['draggable']) {
	            this._markerManager.updateDraggable(this);
	        }
	        if (changes['iconUrl']) {
	            this._markerManager.updateIcon(this);
	        }
	        if (changes['opacity']) {
	            this._markerManager.updateOpacity(this);
	        }
	        if (changes['visible']) {
	            this._markerManager.updateVisible(this);
	        }
	        if (changes['zIndex']) {
	            this._markerManager.updateZIndex(this);
	        }
	    };
	    SebmGoogleMapMarker.prototype._addEventListeners = function () {
	        var _this = this;
	        var cs = this._markerManager.createEventObservable('click', this).subscribe(function () {
	            if (_this.openInfoWindow && _this.infoWindow != null) {
	                _this.infoWindow.open();
	            }
	            _this.markerClick.emit(null);
	        });
	        this._observableSubscriptions.push(cs);
	        var ds = this._markerManager.createEventObservable('dragend', this)
	            .subscribe(function (e) {
	            _this.dragEnd.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
	        });
	        this._observableSubscriptions.push(ds);
	        var mover = this._markerManager.createEventObservable('mouseover', this)
	            .subscribe(function (e) {
	            _this.mouseOver.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
	        });
	        this._observableSubscriptions.push(mover);
	        var mout = this._markerManager.createEventObservable('mouseout', this)
	            .subscribe(function (e) {
	            _this.mouseOut.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });
	        });
	        this._observableSubscriptions.push(mout);
	    };
	    /** @internal */
	    SebmGoogleMapMarker.prototype.id = function () { return this._id; };
	    /** @internal */
	    SebmGoogleMapMarker.prototype.toString = function () { return 'SebmGoogleMapMarker-' + this._id.toString(); };
	    /** @internal */
	    SebmGoogleMapMarker.prototype.ngOnDestroy = function () {
	        this._markerManager.deleteMarker(this);
	        // unsubscribe all registered observable subscriptions
	        this._observableSubscriptions.forEach(function (s) { return s.unsubscribe(); });
	    };
	    SebmGoogleMapMarker.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'sebm-google-map-marker',
	                    inputs: [
	                        'latitude', 'longitude', 'title', 'label', 'draggable: markerDraggable', 'iconUrl',
	                        'openInfoWindow', 'opacity', 'visible', 'zIndex'
	                    ],
	                    outputs: ['markerClick', 'dragEnd', 'mouseOver', 'mouseOut']
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapMarker.ctorParameters = function () { return [
	        { type: marker_manager_1.MarkerManager, },
	    ]; };
	    SebmGoogleMapMarker.propDecorators = {
	        'infoWindow': [{ type: core_1.ContentChild, args: [google_map_info_window_1.SebmGoogleMapInfoWindow,] },],
	    };
	    return SebmGoogleMapMarker;
	}());
	exports.SebmGoogleMapMarker = SebmGoogleMapMarker;
	//# sourceMappingURL=google-map-marker.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var polygon_manager_1 = __webpack_require__(69);
	/**
	 * SebmGoogleMapPolygon renders a polygon on a {@link SebmGoogleMap}
	 *
	 * ### Example
	 * ```typescript
	 * import { Component } from '@angular/core';
	 * import { SebmGoogleMap, SebmGooglePolygon, LatLngLiteral } from 'angular2-maps/core';
	 *
	 * @Component({
	 *  selector: 'my-map-cmp',
	 *  styles: [`
	 *    .semb-map-container {
	 *      height: 300px;
	 *    }
	 * `],
	 *  template: `
	 *    <semb-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
	 *      <semb-map-polygon [paths]="paths">
	 *      </semb-map-polygon>
	 *    </semb-map>
	 *  `
	 * })
	 * export class MyMapCmp {
	 *   lat: number = 0;
	 *   lng: number = 0;
	 *   zoom: number = 10;
	 *   paths: Array<LatLngLiteral> = [
	 *     { lat: 0,  lng: 10 },
	 *     { lat: 0,  lng: 20 },
	 *     { lat: 10, lng: 20 },
	 *     { lat: 10, lng: 10 },
	 *     { lat: 0,  lng: 10 }
	 *   ]
	 *   // Nesting paths will create a hole where they overlap;
	 *   nestedPaths: Array<Array<LatLngLiteral>> = [[
	 *     { lat: 0,  lng: 10 },
	 *     { lat: 0,  lng: 20 },
	 *     { lat: 10, lng: 20 },
	 *     { lat: 10, lng: 10 },
	 *     { lat: 0,  lng: 10 }
	 *   ], [
	 *     { lat: 0, lng: 15 },
	 *     { lat: 0, lng: 20 },
	 *     { lat: 5, lng: 20 },
	 *     { lat: 5, lng: 15 },
	 *     { lat: 0, lng: 15 }
	 *   ]]
	 * }
	 * ```
	 */
	var SebmGoogleMapPolygon = (function () {
	    function SebmGoogleMapPolygon(_polygonManager) {
	        this._polygonManager = _polygonManager;
	        /**
	         * Indicates whether this Polygon handles mouse events. Defaults to true.
	         */
	        this.clickable = true;
	        /**
	         * If set to true, the user can drag this shape over the map. The geodesic
	         * property defines the mode of dragging. Defaults to false.
	         */
	        this.draggable = false;
	        /**
	         * If set to true, the user can edit this shape by dragging the control
	         * points shown at the vertices and on each segment. Defaults to false.
	         */
	        this.editable = false;
	        /**
	         * When true, edges of the polygon are interpreted as geodesic and will
	         * follow the curvature of the Earth. When false, edges of the polygon are
	         * rendered as straight lines in screen space. Note that the shape of a
	         * geodesic polygon may appear to change when dragged, as the dimensions
	         * are maintained relative to the surface of the earth. Defaults to false.
	         */
	        this.geodesic = false;
	        /**
	         * The ordered sequence of coordinates that designates a closed loop.
	         * Unlike polylines, a polygon may consist of one or more paths.
	         *  As a result, the paths property may specify one or more arrays of
	         * LatLng coordinates. Paths are closed automatically; do not repeat the
	         * first vertex of the path as the last vertex. Simple polygons may be
	         * defined using a single array of LatLngs. More complex polygons may
	         * specify an array of arrays. Any simple arrays are converted into Arrays.
	         * Inserting or removing LatLngs from the Array will automatically update
	         * the polygon on the map.
	         */
	        this.paths = [];
	        /**
	         * This event is fired when the DOM click event is fired on the Polygon.
	         */
	        this.polyClick = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM dblclick event is fired on the Polygon.
	         */
	        this.polyDblClick = new core_1.EventEmitter();
	        /**
	         * This event is repeatedly fired while the user drags the polygon.
	         */
	        this.polyDrag = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user stops dragging the polygon.
	         */
	        this.polyDragEnd = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user starts dragging the polygon.
	         */
	        this.polyDragStart = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousedown event is fired on the Polygon.
	         */
	        this.polyMouseDown = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousemove event is fired on the Polygon.
	         */
	        this.polyMouseMove = new core_1.EventEmitter();
	        /**
	         * This event is fired on Polygon mouseout.
	         */
	        this.polyMouseOut = new core_1.EventEmitter();
	        /**
	         * This event is fired on Polygon mouseover.
	         */
	        this.polyMouseOver = new core_1.EventEmitter();
	        /**
	         * This event is fired whe the DOM mouseup event is fired on the Polygon
	         */
	        this.polyMouseUp = new core_1.EventEmitter();
	        /**
	         * This even is fired when the Polygon is right-clicked on.
	         */
	        this.polyRightClick = new core_1.EventEmitter();
	        this._polygonAddedToManager = false;
	        this._subscriptions = [];
	    }
	    /** @internal */
	    SebmGoogleMapPolygon.prototype.ngAfterContentInit = function () {
	        if (!this._polygonAddedToManager) {
	            this._init();
	        }
	    };
	    SebmGoogleMapPolygon.prototype.ngOnChanges = function (changes) {
	        if (!this._polygonAddedToManager) {
	            this._init();
	            return;
	        }
	        this._polygonManager.setPolygonOptions(this, this._updatePolygonOptions(changes));
	    };
	    SebmGoogleMapPolygon.prototype._init = function () {
	        this._polygonManager.addPolygon(this);
	        this._polygonAddedToManager = true;
	        this._addEventListeners();
	    };
	    SebmGoogleMapPolygon.prototype._addEventListeners = function () {
	        var _this = this;
	        var handlers = [
	            { name: 'click', handler: function (ev) { return _this.polyClick.emit(ev); } },
	            { name: 'dbclick', handler: function (ev) { return _this.polyDblClick.emit(ev); } },
	            { name: 'drag', handler: function (ev) { return _this.polyDrag.emit(ev); } },
	            { name: 'dragend', handler: function (ev) { return _this.polyDragEnd.emit(ev); } },
	            { name: 'dragstart', handler: function (ev) { return _this.polyDragStart.emit(ev); } },
	            { name: 'mousedown', handler: function (ev) { return _this.polyMouseDown.emit(ev); } },
	            { name: 'mousemove', handler: function (ev) { return _this.polyMouseMove.emit(ev); } },
	            { name: 'mouseout', handler: function (ev) { return _this.polyMouseOut.emit(ev); } },
	            { name: 'mouseover', handler: function (ev) { return _this.polyMouseOver.emit(ev); } },
	            { name: 'mouseup', handler: function (ev) { return _this.polyMouseUp.emit(ev); } },
	            { name: 'rightclick', handler: function (ev) { return _this.polyRightClick.emit(ev); } },
	        ];
	        handlers.forEach(function (obj) {
	            var os = _this._polygonManager.createEventObservable(obj.name, _this).subscribe(obj.handler);
	            _this._subscriptions.push(os);
	        });
	    };
	    SebmGoogleMapPolygon.prototype._updatePolygonOptions = function (changes) {
	        return Object.keys(changes)
	            .filter(function (k) { return SebmGoogleMapPolygon._polygonOptionsAttributes.indexOf(k) !== -1; })
	            .reduce(function (obj, k) {
	            obj[k] = changes[k].currentValue;
	            return obj;
	        }, {});
	    };
	    /** @internal */
	    SebmGoogleMapPolygon.prototype.id = function () { return this._id; };
	    /** @internal */
	    SebmGoogleMapPolygon.prototype.ngOnDestroy = function () {
	        this._polygonManager.deletePolygon(this);
	        // unsubscribe all registered observable subscriptions
	        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });
	    };
	    SebmGoogleMapPolygon._polygonOptionsAttributes = [
	        'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'icon', 'map',
	        'paths', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'draggable',
	        'editable', 'visible'
	    ];
	    SebmGoogleMapPolygon.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'sebm-map-polygon',
	                    inputs: [
	                        'clickable',
	                        'draggable: polyDraggable',
	                        'editable',
	                        'fillColor',
	                        'fillOpacity',
	                        'geodesic',
	                        'paths',
	                        'strokeColor',
	                        'strokeOpacity',
	                        'strokeWeight',
	                        'visible',
	                        'zIndex',
	                    ],
	                    outputs: [
	                        'polyClick', 'polyDblClick', 'polyDrag', 'polyDragEnd', 'polyMouseDown', 'polyMouseMove',
	                        'polyMouseOut', 'polyMouseOver', 'polyMouseUp', 'polyRightClick'
	                    ]
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapPolygon.ctorParameters = function () { return [
	        { type: polygon_manager_1.PolygonManager, },
	    ]; };
	    return SebmGoogleMapPolygon;
	}());
	exports.SebmGoogleMapPolygon = SebmGoogleMapPolygon;
	//# sourceMappingURL=google-map-polygon.js.map

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var polyline_manager_1 = __webpack_require__(70);
	var google_map_polyline_point_1 = __webpack_require__(78);
	var polylineId = 0;
	/**
	 * SebmGoogleMapPolyline renders a polyline on a {@link SebmGoogleMap}
	 *
	 * ### Example
	 * ```typescript
	 * import { Component } from 'angular2/core';
	 * import { SebmGoogleMap, SebmGooglePolyline, SebmGooglePolylinePoint } from
	 * 'angular2-google-maps/core';
	 *
	 * @Component({
	 *  selector: 'my-map-cmp',
	 *  directives: [SebmGoogleMap, SebmGooglePolyline, SebmGooglePolylinePoint],
	 *  styles: [`
	 *    .sebm-google-map-container {
	 *      height: 300px;
	 *    }
	 * `],
	 *  template: `
	 *    <sebm-google-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
	 *      <sebm-google-map-polyline>
	 *          <sebm-google-map-polyline-point [latitude]="latA" [longitude]="lngA">
	 *          </sebm-google-map-polyline-point>
	 *          <sebm-google-map-polyline-point [latitude]="latB" [longitude]="lngB">
	 *          </sebm-google-map-polyline-point>
	 *      </sebm-google-map-polyline>
	 *    </sebm-google-map>
	 *  `
	 * })
	 * ```
	 */
	var SebmGoogleMapPolyline = (function () {
	    function SebmGoogleMapPolyline(_polylineManager) {
	        this._polylineManager = _polylineManager;
	        /**
	         * Indicates whether this Polyline handles mouse events. Defaults to true.
	         */
	        this.clickable = true;
	        /**
	         * If set to true, the user can drag this shape over the map. The geodesic property defines the
	         * mode of dragging. Defaults to false.
	         */
	        this.draggable = false;
	        /**
	         * If set to true, the user can edit this shape by dragging the control points shown at the
	         * vertices and on each segment. Defaults to false.
	         */
	        this.editable = false;
	        /**
	         * When true, edges of the polygon are interpreted as geodesic and will follow the curvature of
	         * the Earth. When false, edges of the polygon are rendered as straight lines in screen space.
	         * Note that the shape of a geodesic polygon may appear to change when dragged, as the dimensions
	         * are maintained relative to the surface of the earth. Defaults to false.
	         */
	        this.geodesic = false;
	        /**
	         * Whether this polyline is visible on the map. Defaults to true.
	         */
	        this.visible = true;
	        /**
	         * This event is fired when the DOM click event is fired on the Polyline.
	         */
	        this.lineClick = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM dblclick event is fired on the Polyline.
	         */
	        this.lineDblClick = new core_1.EventEmitter();
	        /**
	         * This event is repeatedly fired while the user drags the polyline.
	         */
	        this.lineDrag = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user stops dragging the polyline.
	         */
	        this.lineDragEnd = new core_1.EventEmitter();
	        /**
	         * This event is fired when the user starts dragging the polyline.
	         */
	        this.lineDragStart = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousedown event is fired on the Polyline.
	         */
	        this.lineMouseDown = new core_1.EventEmitter();
	        /**
	         * This event is fired when the DOM mousemove event is fired on the Polyline.
	         */
	        this.lineMouseMove = new core_1.EventEmitter();
	        /**
	         * This event is fired on Polyline mouseout.
	         */
	        this.lineMouseOut = new core_1.EventEmitter();
	        /**
	         * This event is fired on Polyline mouseover.
	         */
	        this.lineMouseOver = new core_1.EventEmitter();
	        /**
	         * This event is fired whe the DOM mouseup event is fired on the Polyline
	         */
	        this.lineMouseUp = new core_1.EventEmitter();
	        /**
	         * This even is fired when the Polyline is right-clicked on.
	         */
	        this.lineRightClick = new core_1.EventEmitter();
	        this._polylineAddedToManager = false;
	        this._subscriptions = [];
	        this._id = (polylineId++).toString();
	    }
	    /** @internal */
	    SebmGoogleMapPolyline.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        if (this.points.length) {
	            this.points.forEach(function (point) {
	                var s = point.positionChanged.subscribe(function () { _this._polylineManager.updatePolylinePoints(_this); });
	                _this._subscriptions.push(s);
	            });
	        }
	        if (!this._polylineAddedToManager) {
	            this._init();
	        }
	        var s = this.points.changes.subscribe(function () { return _this._polylineManager.updatePolylinePoints(_this); });
	        this._subscriptions.push(s);
	        this._polylineManager.updatePolylinePoints(this);
	    };
	    SebmGoogleMapPolyline.prototype.ngOnChanges = function (changes) {
	        if (!this._polylineAddedToManager) {
	            this._init();
	            return;
	        }
	        var options = {};
	        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMapPolyline._polylineOptionsAttributes.indexOf(k) !== -1; });
	        optionKeys.forEach(function (k) { return options[k] = changes[k].currentValue; });
	        this._polylineManager.setPolylineOptions(this, options);
	    };
	    SebmGoogleMapPolyline.prototype._init = function () {
	        this._polylineManager.addPolyline(this);
	        this._polylineAddedToManager = true;
	        this._addEventListeners();
	    };
	    SebmGoogleMapPolyline.prototype._addEventListeners = function () {
	        var _this = this;
	        var handlers = [
	            { name: 'click', handler: function (ev) { return _this.lineClick.emit(ev); } },
	            { name: 'dbclick', handler: function (ev) { return _this.lineDblClick.emit(ev); } },
	            { name: 'drag', handler: function (ev) { return _this.lineDrag.emit(ev); } },
	            { name: 'dragend', handler: function (ev) { return _this.lineDragEnd.emit(ev); } },
	            { name: 'dragstart', handler: function (ev) { return _this.lineDragStart.emit(ev); } },
	            { name: 'mousedown', handler: function (ev) { return _this.lineMouseDown.emit(ev); } },
	            { name: 'mousemove', handler: function (ev) { return _this.lineMouseMove.emit(ev); } },
	            { name: 'mouseout', handler: function (ev) { return _this.lineMouseOut.emit(ev); } },
	            { name: 'mouseover', handler: function (ev) { return _this.lineMouseOver.emit(ev); } },
	            { name: 'mouseup', handler: function (ev) { return _this.lineMouseUp.emit(ev); } },
	            { name: 'rightclick', handler: function (ev) { return _this.lineRightClick.emit(ev); } },
	        ];
	        handlers.forEach(function (obj) {
	            var os = _this._polylineManager.createEventObservable(obj.name, _this).subscribe(obj.handler);
	            _this._subscriptions.push(os);
	        });
	    };
	    /** @internal */
	    SebmGoogleMapPolyline.prototype._getPoints = function () {
	        if (this.points) {
	            return this.points.toArray();
	        }
	        return [];
	    };
	    /** @internal */
	    SebmGoogleMapPolyline.prototype.id = function () { return this._id; };
	    /** @internal */
	    SebmGoogleMapPolyline.prototype.ngOnDestroy = function () {
	        this._polylineManager.deletePolyline(this);
	        // unsubscribe all registered observable subscriptions
	        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });
	    };
	    SebmGoogleMapPolyline._polylineOptionsAttributes = [
	        'draggable', 'editable', 'visible', 'geodesic', 'strokeColor', 'strokeOpacity', 'strokeWeight',
	        'zIndex'
	    ];
	    SebmGoogleMapPolyline.decorators = [
	        { type: core_1.Directive, args: [{
	                    selector: 'sebm-google-map-polyline',
	                    inputs: [
	                        'clickable', 'draggable: polylineDraggable', 'editable', 'geodesic', 'strokeColor',
	                        'strokeWeight', 'strokeOpacity', 'visible', 'zIndex'
	                    ],
	                    outputs: [
	                        'lineClick', 'lineDblClick', 'lineDrag', 'lineDragEnd', 'lineMouseDown', 'lineMouseMove',
	                        'lineMouseOut', 'lineMouseOver', 'lineMouseUp', 'lineRightClick'
	                    ]
	                },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapPolyline.ctorParameters = function () { return [
	        { type: polyline_manager_1.PolylineManager, },
	    ]; };
	    SebmGoogleMapPolyline.propDecorators = {
	        'points': [{ type: core_1.ContentChildren, args: [google_map_polyline_point_1.SebmGoogleMapPolylinePoint,] },],
	    };
	    return SebmGoogleMapPolyline;
	}());
	exports.SebmGoogleMapPolyline = SebmGoogleMapPolyline;
	//# sourceMappingURL=google-map-polyline.js.map

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	/**
	 * SebmGoogleMapPolylinePoint represents one element of a polyline within a  {@link
	 * SembGoogleMapPolyline}
	 */
	var SebmGoogleMapPolylinePoint = (function () {
	    function SebmGoogleMapPolylinePoint() {
	        /**
	         * This event emitter gets emitted when the position of the point changed.
	         */
	        this.positionChanged = new core_1.EventEmitter();
	    }
	    SebmGoogleMapPolylinePoint.prototype.ngOnChanges = function (changes) {
	        if (changes['latitude'] || changes['longitude']) {
	            var position = {
	                lat: changes['latitude'].currentValue,
	                lng: changes['longitude'].currentValue
	            };
	            this.positionChanged.emit(position);
	        }
	    };
	    SebmGoogleMapPolylinePoint.decorators = [
	        { type: core_1.Directive, args: [{ selector: 'sebm-google-map-polyline-point' },] },
	    ];
	    /** @nocollapse */
	    SebmGoogleMapPolylinePoint.ctorParameters = function () { return []; };
	    SebmGoogleMapPolylinePoint.propDecorators = {
	        'latitude': [{ type: core_1.Input },],
	        'longitude': [{ type: core_1.Input },],
	        'positionChanged': [{ type: core_1.Output },],
	    };
	    return SebmGoogleMapPolylinePoint;
	}());
	exports.SebmGoogleMapPolylinePoint = SebmGoogleMapPolylinePoint;
	//# sourceMappingURL=google-map-polyline-point.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var google_maps_api_wrapper_1 = __webpack_require__(64);
	exports.GoogleMapsAPIWrapper = google_maps_api_wrapper_1.GoogleMapsAPIWrapper;
	var circle_manager_1 = __webpack_require__(66);
	exports.CircleManager = circle_manager_1.CircleManager;
	var info_window_manager_1 = __webpack_require__(67);
	exports.InfoWindowManager = info_window_manager_1.InfoWindowManager;
	var marker_manager_1 = __webpack_require__(68);
	exports.MarkerManager = marker_manager_1.MarkerManager;
	var polygon_manager_1 = __webpack_require__(69);
	exports.PolygonManager = polygon_manager_1.PolygonManager;
	var polyline_manager_1 = __webpack_require__(70);
	exports.PolylineManager = polyline_manager_1.PolylineManager;
	var kml_layer_manager_1 = __webpack_require__(71);
	exports.KmlLayerManager = kml_layer_manager_1.KmlLayerManager;
	var lazy_maps_api_loader_1 = __webpack_require__(80);
	exports.GoogleMapsScriptProtocol = lazy_maps_api_loader_1.GoogleMapsScriptProtocol;
	exports.LAZY_MAPS_API_CONFIG = lazy_maps_api_loader_1.LAZY_MAPS_API_CONFIG;
	exports.LazyMapsAPILoader = lazy_maps_api_loader_1.LazyMapsAPILoader;
	var maps_api_loader_1 = __webpack_require__(65);
	exports.MapsAPILoader = maps_api_loader_1.MapsAPILoader;
	var noop_maps_api_loader_1 = __webpack_require__(82);
	exports.NoOpMapsAPILoader = noop_maps_api_loader_1.NoOpMapsAPILoader;
	//# sourceMappingURL=services.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var core_1 = __webpack_require__(7);
	var browser_globals_1 = __webpack_require__(81);
	var maps_api_loader_1 = __webpack_require__(65);
	(function (GoogleMapsScriptProtocol) {
	    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTP"] = 1] = "HTTP";
	    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTPS"] = 2] = "HTTPS";
	    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["AUTO"] = 3] = "AUTO";
	})(exports.GoogleMapsScriptProtocol || (exports.GoogleMapsScriptProtocol = {}));
	var GoogleMapsScriptProtocol = exports.GoogleMapsScriptProtocol;
	/**
	 * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link
	 * LazyMapsAPILoaderConfig}.
	 */
	exports.LAZY_MAPS_API_CONFIG = new core_1.OpaqueToken('angular2-google-maps LAZY_MAPS_API_CONFIG');
	var LazyMapsAPILoader = (function (_super) {
	    __extends(LazyMapsAPILoader, _super);
	    function LazyMapsAPILoader(config, w, d) {
	        _super.call(this);
	        this._config = config || {};
	        this._windowRef = w;
	        this._documentRef = d;
	    }
	    LazyMapsAPILoader.prototype.load = function () {
	        var _this = this;
	        if (this._scriptLoadingPromise) {
	            return this._scriptLoadingPromise;
	        }
	        var script = this._documentRef.getNativeDocument().createElement('script');
	        script.type = 'text/javascript';
	        script.async = true;
	        script.defer = true;
	        var callbackName = "angular2GoogleMapsLazyMapsAPILoader";
	        script.src = this._getScriptSrc(callbackName);
	        this._scriptLoadingPromise = new Promise(function (resolve, reject) {
	            _this._windowRef.getNativeWindow()[callbackName] = function () { resolve(); };
	            script.onerror = function (error) { reject(error); };
	        });
	        this._documentRef.getNativeDocument().body.appendChild(script);
	        return this._scriptLoadingPromise;
	    };
	    LazyMapsAPILoader.prototype._getScriptSrc = function (callbackName) {
	        var protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;
	        var protocol;
	        switch (protocolType) {
	            case GoogleMapsScriptProtocol.AUTO:
	                protocol = '';
	                break;
	            case GoogleMapsScriptProtocol.HTTP:
	                protocol = 'http:';
	                break;
	            case GoogleMapsScriptProtocol.HTTPS:
	                protocol = 'https:';
	                break;
	        }
	        var hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
	        var queryParams = {
	            v: this._config.apiVersion || '3',
	            callback: callbackName,
	            key: this._config.apiKey,
	            client: this._config.clientId,
	            channel: this._config.channel,
	            libraries: this._config.libraries,
	            region: this._config.region,
	            language: this._config.language
	        };
	        var params = Object.keys(queryParams)
	            .filter(function (k) { return queryParams[k] != null; })
	            .filter(function (k) {
	            // remove empty arrays
	            return !Array.isArray(queryParams[k]) ||
	                (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
	        })
	            .map(function (k) {
	            // join arrays as comma seperated strings
	            var i = queryParams[k];
	            if (Array.isArray(i)) {
	                return { key: k, value: i.join(',') };
	            }
	            return { key: k, value: queryParams[k] };
	        })
	            .map(function (entry) { return entry.key + "=" + entry.value; })
	            .join('&');
	        return protocol + "//" + hostAndPath + "?" + params;
	    };
	    LazyMapsAPILoader.decorators = [
	        { type: core_1.Injectable },
	    ];
	    /** @nocollapse */
	    LazyMapsAPILoader.ctorParameters = function () { return [
	        { type: undefined, decorators: [{ type: core_1.Inject, args: [exports.LAZY_MAPS_API_CONFIG,] },] },
	        { type: browser_globals_1.WindowRef, },
	        { type: browser_globals_1.DocumentRef, },
	    ]; };
	    return LazyMapsAPILoader;
	}(maps_api_loader_1.MapsAPILoader));
	exports.LazyMapsAPILoader = LazyMapsAPILoader;
	//# sourceMappingURL=lazy-maps-api-loader.js.map

/***/ }),
/* 81 */
/***/ (function(module, exports) {

	"use strict";
	var WindowRef = (function () {
	    function WindowRef() {
	    }
	    WindowRef.prototype.getNativeWindow = function () { return window; };
	    return WindowRef;
	}());
	exports.WindowRef = WindowRef;
	var DocumentRef = (function () {
	    function DocumentRef() {
	    }
	    DocumentRef.prototype.getNativeDocument = function () { return document; };
	    return DocumentRef;
	}());
	exports.DocumentRef = DocumentRef;
	exports.BROWSER_GLOBALS_PROVIDERS = [WindowRef, DocumentRef];
	//# sourceMappingURL=browser-globals.js.map

/***/ }),
/* 82 */
/***/ (function(module, exports) {

	"use strict";
	/**
	 * When using the NoOpMapsAPILoader, the Google Maps API must be added to the page via a `<script>`
	 * Tag.
	 * It's important that the Google Maps API script gets loaded first on the page.
	 */
	var NoOpMapsAPILoader = (function () {
	    function NoOpMapsAPILoader() {
	    }
	    NoOpMapsAPILoader.prototype.load = function () {
	        if (!window.google || !window.google.maps) {
	            throw new Error('Google Maps API not loaded on page. Make sure window.google.maps is available!');
	        }
	        return Promise.resolve();
	    };
	    ;
	    return NoOpMapsAPILoader;
	}());
	exports.NoOpMapsAPILoader = NoOpMapsAPILoader;
	//# sourceMappingURL=noop-maps-api-loader.js.map

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var core_1 = __webpack_require__(7);
	var google_map_kml_layer_1 = __webpack_require__(74);
	var google_map_1 = __webpack_require__(63);
	var google_map_circle_1 = __webpack_require__(72);
	var google_map_info_window_1 = __webpack_require__(73);
	var google_map_marker_1 = __webpack_require__(75);
	var google_map_polygon_1 = __webpack_require__(76);
	var google_map_polyline_1 = __webpack_require__(77);
	var google_map_polyline_point_1 = __webpack_require__(78);
	var lazy_maps_api_loader_1 = __webpack_require__(80);
	var lazy_maps_api_loader_2 = __webpack_require__(80);
	var maps_api_loader_1 = __webpack_require__(65);
	var browser_globals_1 = __webpack_require__(81);
	/**
	 * @internal
	 */
	function coreDirectives() {
	    return [
	        google_map_1.SebmGoogleMap, google_map_marker_1.SebmGoogleMapMarker, google_map_info_window_1.SebmGoogleMapInfoWindow, google_map_circle_1.SebmGoogleMapCircle,
	        google_map_polygon_1.SebmGoogleMapPolygon, google_map_polyline_1.SebmGoogleMapPolyline, google_map_polyline_point_1.SebmGoogleMapPolylinePoint, google_map_kml_layer_1.SebmGoogleMapKmlLayer
	    ];
	}
	exports.coreDirectives = coreDirectives;
	;
	/**
	 * The angular2-google-maps core module. Contains all Directives/Services/Pipes
	 * of the core module. Please use `AgmCoreModule.forRoot()` in your app module.
	 */
	var AgmCoreModule = (function () {
	    function AgmCoreModule() {
	    }
	    /**
	     * Please use this method when you register the module at the root level.
	     */
	    AgmCoreModule.forRoot = function (lazyMapsAPILoaderConfig) {
	        return {
	            ngModule: AgmCoreModule,
	            providers: browser_globals_1.BROWSER_GLOBALS_PROVIDERS.concat([
	                { provide: maps_api_loader_1.MapsAPILoader, useClass: lazy_maps_api_loader_1.LazyMapsAPILoader },
	                { provide: lazy_maps_api_loader_2.LAZY_MAPS_API_CONFIG, useValue: lazyMapsAPILoaderConfig }
	            ]),
	        };
	    };
	    AgmCoreModule.decorators = [
	        { type: core_1.NgModule, args: [{ declarations: coreDirectives(), exports: coreDirectives() },] },
	    ];
	    /** @nocollapse */
	    AgmCoreModule.ctorParameters = function () { return []; };
	    return AgmCoreModule;
	}());
	exports.AgmCoreModule = AgmCoreModule;
	//# sourceMappingURL=core-module.js.map

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var practice_data_1 = __webpack_require__(85);
	var PracticeComponent = (function () {
	    function PracticeComponent() {
	        // Practice data to inject into our template
	        this.practiceData = practice_data_1.PRACTICE_DATA;
	    }
	    PracticeComponent.prototype.ngOnInit = function () { };
	    return PracticeComponent;
	}());
	PracticeComponent = __decorate([
	    core_1.Component({
	        selector: 'practice',
	        template: __webpack_require__(86),
	        styles: [__webpack_require__(87)]
	    }),
	    __metadata("design:paramtypes", [])
	], PracticeComponent);
	exports.PracticeComponent = PracticeComponent;


/***/ }),
/* 85 */
/***/ (function(module, exports) {

	"use strict";
	exports.PRACTICE_DATA = [
	    {
	        season: 'Fall',
	        what: 'Normal Practice',
	        time: '4:30PM-7PM',
	        when: 'Mondays & Wednesdays',
	        locationLabel: 'Complex Fields',
	        locationLink: 'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
	    },
	    {
	        season: 'Fall',
	        what: 'Weekend Invite Practice',
	        time: 'TBD',
	        when: 'Weekends',
	        locationLabel: 'Complex Fields',
	        locationLink: 'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
	    },
	    {
	        season: 'Winter',
	        what: 'Normal Practice',
	        time: '9:30PM-12AM',
	        when: 'Mondays & Wednesdays',
	        locationLabel: 'Armory',
	        locationLink: 'https://www.google.com/maps/place/Armory/@40.105402,-88.235534,17z/data=!3m1!5s0x880cd73b8c4fbb7d:0xa84890110afd0990!4m7!1m4!3m3!1s0x880cd73a16c1d78f:0xe1bb009225fc1225!2sE+Armory+Ave,+Champaign,+IL+61820!3b1!3m1!1s0x0000000000000000:0x0b21d56f2b951978'
	    },
	    {
	        season: 'Winter',
	        what: 'Indoor Field Practice',
	        time: '11PM-12AM',
	        when: 'Thursdays',
	        locationLabel: 'Irwin Facility',
	        locationLink: 'https://www.google.com/maps/place/Irwin+Indoor+Football+Facility,+University+of+Illinois+at+Urbana-Champaign,+Champaign,+IL+61820/@40.1006475,-88.2342204,17z/data=!3m1!4b1!4m6!1m3!3m2!1s0x880cd724a92655e9:0xa53c0525046826fa!2sUniversity+of+Illinois+at+Urbana-Champaign!3m1!1s0x880cd725292c02bd:0x18f5a03daad8677a'
	    },
	    {
	        season: 'Spring',
	        what: 'Normal Practice',
	        time: '9:30PM-12AM',
	        when: 'Mondays & Wednesdays',
	        locationLabel: 'Complex Fields',
	        locationLink: 'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
	    },
	    {
	        season: 'Spring',
	        what: 'A-Team Practice',
	        time: 'TBD',
	        when: 'Weekends',
	        locationLabel: 'Complex Fields',
	        locationLink: 'https://www.google.com/maps/place/Florida+and+Lincoln+Playing+Field/@40.0966964,-88.2242806,16z/data=!4m5!1m2!2m1!1scomplex+fields!3m1!1s0x0000000000000000:0x13633840896e25bf'
	    }
	];


/***/ }),
/* 86 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Practice</h1>\n<table class=\"ui celled table\">\n    <thead>\n        <tr>\n            <th>Season</th>\n            <th>What</th>\n            <th>Time</th>\n            <th>When</th>\n            <th>Location</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr *ngFor=\"let practiceRow of practiceData\">\n            <td>{{practiceRow.season}}</td>\n            <td>{{practiceRow.what}}</td>\n            <td>{{practiceRow.time}}</td>\n            <td>{{practiceRow.when}}</td>\n            <td><a href=\"{{practiceRow.locationLink}}\" target=\"_blank\">{{practiceRow.locationLabel}}</a></td>\n        </tr>\n    </tbody>\n</table>";

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(88);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "tr {\n  text-align: center;\n}\n", ""]);
	
	// exports


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var router_1 = __webpack_require__(90);
	var tournaments_data_1 = __webpack_require__(120);
	var TournamentsComponent = (function () {
	    // Inject the ActivatedRoute into our component
	    function TournamentsComponent(route) {
	        this.route = route;
	        // Tournament data to inject into our template
	        this.tournamentData = tournaments_data_1.TOURNAMENTS_DATA;
	    }
	    /**
	     * Subscribe to our route parameters (tournament year).
	     */
	    TournamentsComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.routeParamsSubscription = this.route.params.subscribe(function (params) {
	            // (+) converts string 'year' to a number
	            _this.year = +params['year'];
	        });
	    };
	    /**
	     * Unsubscribe to our route parameters (tournament year).
	     */
	    TournamentsComponent.prototype.ngOnDestroy = function () {
	        this.routeParamsSubscription.unsubscribe();
	    };
	    return TournamentsComponent;
	}());
	TournamentsComponent = __decorate([
	    core_1.Component({
	        selector: 'tournaments',
	        template: __webpack_require__(121),
	        styles: [__webpack_require__(122)]
	    }),
	    __metadata("design:paramtypes", [typeof (_a = typeof router_1.ActivatedRoute !== "undefined" && router_1.ActivatedRoute) === "function" && _a || Object])
	], TournamentsComponent);
	exports.TournamentsComponent = TournamentsComponent;
	var _a;


/***/ }),
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */
/***/ (function(module, exports) {

	"use strict";
	exports.TOURNAMENTS_DATA = [
	    {
	        year: 2017,
	        tournaments: [
	            {
	                season: 'Fall',
	                nameLabel: 'Boiler Breakaway',
	                nameLink: 'https://boilerlink.purdue.edu/organization/mensultimate/calendar/details/972920',
	                when: 'Sept. 17th-18th',
	                location: 'West Lafayette, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'No Wisconsequences',
	                nameLink: 'http://nowisconsequences.ultimatecentral.com',
	                when: 'Oct. 8th-9th',
	                location: 'Hartland, WI',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Missouri Loves Company',
	                nameLink: 'http://ultimate.missouri.edu/mlc/2016',
	                when: 'Nov. 5th-6th',
	                location: 'Columbia, MO',
	                result: '-'
	            },
	            {
	                season: 'Spring',
	                nameLabel: "President's Day Invite",
	                nameLink: 'http://play.usaultimate.org/events/Presidents-Day-Tournament-2017',
	                when: 'Feb. 17th-20th',
	                location: 'San Diego, CA',
	                result: '5th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Centex',
	                nameLink: 'http://play.usaultimate.org/events/Centex-2017-Open',
	                when: 'March 10th-13th',
	                location: 'Austin, TX',
	                result: '7th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Huck Finn',
	                nameLink: 'http://play.usaultimate.org/events/Huck-Finn-2017',
	                when: 'April 1st-2nd',
	                location: 'St. Louis, MO',
	                result: '11th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Illinois Conferences',
	                nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2017',
	                when: 'April 22nd-23rd',
	                location: 'Rantoul, IL',
	                result: '2nd'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Great Lakes Regionals',
	                nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2017',
	                when: 'May 6th-7th',
	                location: 'Fair Oaks, IN',
	                result: '6th'
	            }
	        ]
	    },
	    {
	        year: 2016,
	        tournaments: [
	            {
	                season: 'Fall',
	                nameLabel: 'Boiler Breakaway',
	                nameLink: 'https://www.reddit.com/r/ultimate/comments/38gy72/new_fields_boiler_breakaway_2015_hosted_by_undue',
	                when: 'Sept. 19th-20th',
	                location: 'Westfield, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Huck of the Irish',
	                nameLink: 'https://ndultimate.wordpress.com/hoti',
	                when: 'Oct. 3rd-4th',
	                location: 'South Bend, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Chicago Invite',
	                nameLink: 'http://www.chicagoinvite.com',
	                when: 'Oct. 17th-18th',
	                location: 'Rockford, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Missouri Loves Company',
	                nameLink: 'http://ultiworld.com/2015/11/12/missouri-loves-company-2015-tournament-recap-mens',
	                when: 'Nov. 7th-8th',
	                location: 'Columbia, MO',
	                result: '10th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Florida Warmup',
	                nameLink: 'http://play.usaultimate.org/events/Warm-up-A-Florida-Affair-2016',
	                when: 'Feb. 11th-14th',
	                location: 'Tampa, FL',
	                result: '15th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Easterns',
	                nameLink: 'http://play.usaultimate.org/events/College-Easterns-2016',
	                when: 'March 18th-20th',
	                location: 'North Myrtle Beach, SC',
	                result: '19th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Huck Finn',
	                nameLink: 'http://play.usaultimate.org/events/Huck-Finn-XX-2016',
	                when: 'Feb. 11th-14th',
	                location: 'St. Louis, MO',
	                result: '11th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Illinois Conferences',
	                nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2016',
	                when: 'April 16th-17th',
	                location: 'Rantoul, IL',
	                result: '3rd'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Great Lakes Regionals',
	                nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2016',
	                when: 'April 30th-May 1st',
	                location: 'Fair Oaks, IN',
	                result: '3rd'
	            }
	        ]
	    },
	    {
	        year: 2015,
	        tournaments: [
	            {
	                season: 'Fall',
	                nameLabel: 'Huck of the Irish',
	                nameLink: 'https://ndultimate.wordpress.com/whitesmoke',
	                when: 'Sept. 27th-28th',
	                location: 'South Bend, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Glory Days',
	                nameLink: 'http://www.sun-ultimate.org/glory-days.html',
	                when: 'Oct. 4th-5th',
	                location: 'Rockford, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Illinois Invite',
	                nameLink: 'https://illinois.collegiatelink.net/organization/illinoismensultimatefrisbeeteam/calendar/details/504204',
	                when: 'Oct. 18th-19th',
	                location: 'Rantoul, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Missouri Loves Company',
	                nameLink: 'http://ultiworld.com/2014/11/06/missouri-loves-company-2014-tournament-preview-mens',
	                when: 'Nov. 8th-9th',
	                location: 'Columbia, MO',
	                result: '-'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Florida Warmup',
	                nameLink: 'http://play.usaultimate.org/events/Warm-Up-A-Florida-Affair-2015',
	                when: 'Feb. 13th-15th',
	                location: 'Tampa, FL',
	                result: '13th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Centex Invite',
	                nameLink: 'http://play.usaultimate.org/events/Centex-Invite-2015',
	                when: 'March 14th-15th',
	                location: 'Austin, TX',
	                result: '17th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Easterns',
	                nameLink: 'http://play.usaultimate.org/events/Easterns-2015',
	                when: 'March 27th-29th',
	                location: 'North Myrtle Beach, SC',
	                result: '17th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Illinois Conferences',
	                nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC-2015',
	                when: 'April 11th-12th',
	                location: 'Rantoul, IL',
	                result: '2nd'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Great Lakes Regionals',
	                nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals-2015',
	                when: 'April 25th-26th',
	                location: 'Rockford, IL',
	                result: '1st'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'D-I National Championships',
	                nameLink: 'http://play.usaultimate.org/events/USA-Ultimate-D-I-College-Championships-2015',
	                when: 'May 22nd-25th',
	                location: 'Milwaukee, WI',
	                result: '13th'
	            }
	        ]
	    },
	    {
	        year: 2014,
	        tournaments: [
	            {
	                season: 'Fall',
	                nameLabel: 'Boiler Breakaway',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/13422',
	                when: 'Oct. 5th-6th',
	                location: 'West Lafayette, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Illinois Invite',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/13350',
	                when: 'Oct. 12th-13th',
	                location: 'Rantoul, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Michigan Round Robin',
	                nameLink: '',
	                when: 'Oct. 20th',
	                location: 'Ann Arbor, MI',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Glory Days',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/13499',
	                when: 'Oct. 26th-27th',
	                location: 'Rockford, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Missouri Loves Company',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/14017',
	                when: 'Nov. 9th-10th',
	                location: 'Columbia, MO',
	                result: '13th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Cat Fight',
	                nameLink: 'http://play.usaultimate.org/events/Cat-Fight',
	                when: 'Feb. 22nd-23rd',
	                location: 'Lexington, KY',
	                result: '1st'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Easterns',
	                nameLink: 'http://play.usaultimate.org/events/Easterns-and-DIII-Easterns',
	                when: 'March 22nd-23rd',
	                location: 'Little River, SC',
	                result: '13th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Illinois Conferences',
	                nameLink: 'http://play.usaultimate.org/events/Illinois-D-I-College-Mens-CC',
	                when: 'April 12th-13th',
	                location: 'Rantoul, IL',
	                result: '1st'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Great Lakes Regionals',
	                nameLink: 'http://play.usaultimate.org/events/Great-Lakes-D-I-College-Mens-Regionals',
	                when: 'April 26th-27th',
	                location: 'Rockford, IL',
	                result: '5th'
	            }
	        ]
	    },
	    {
	        year: 2013,
	        tournaments: [
	            {
	                season: 'Fall',
	                nameLabel: 'Boiler Breakaway',
	                nameLink: 'http://scores.usaultimate.org/scores2012/#college-open/tournament/11432',
	                when: 'Sept. 22nd-23rd',
	                location: 'West Lafayette, IN',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Illinois Invite',
	                nameLink: 'http://scores.usaultimate.org/scores2012/#college-open/tournament/11476',
	                when: 'Oct. 13th-14th',
	                location: 'Rantoul, IL',
	                result: '-'
	            },
	            {
	                season: 'Fall',
	                nameLabel: 'Missouri Loves Company',
	                nameLink: 'http://scores.usaultimate.org/scores2012/#college-open/tournament/11657',
	                when: 'Nov. 10th-11th',
	                location: 'Columbia, MO',
	                result: '-'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Huck Finn',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12115',
	                when: 'March 9th-10th',
	                location: 'Chesterfield, MO',
	                result: '13th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Centex',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12707',
	                when: 'March 16th-17th',
	                location: 'Austin, TX',
	                result: '4th'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Illinois Conferences',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12604',
	                when: 'April 13th-14th',
	                location: 'Rantoul, IL',
	                result: '1st'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'Great Lakes Regionals',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12667',
	                when: 'April 27th-28th',
	                location: 'Rockford, IL',
	                result: '1st'
	            },
	            {
	                season: 'Spring',
	                nameLabel: 'D-I National Championships',
	                nameLink: 'http://scores.usaultimate.org/scores/#college-open/tournament/12686',
	                when: 'May 24th-27th',
	                location: 'Madison, WI',
	                result: '17th'
	            }
	        ]
	    }
	];


/***/ }),
/* 121 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Tournaments</h1>\n<div class=\"ui secondary pointing menu\">\n    <a class=\"item\" routerLink=\"/tournaments/2013\" [ngClass]=\"{'active': year === 2013}\">2013</a>\n    <a class=\"item\" routerLink=\"/tournaments/2014\" [ngClass]=\"{'active': year === 2014}\">2014</a>\n    <a class=\"item\" routerLink=\"/tournaments/2015\" [ngClass]=\"{'active': year === 2015}\">2015</a>\n    <a class=\"item\" routerLink=\"/tournaments/2016\" [ngClass]=\"{'active': year === 2016}\">2016</a>\n    <a class=\"item\" routerLink=\"/tournaments/2017\" [ngClass]=\"{'active': year === 2017}\">2017</a>\n</div>\n<ng-container *ngFor=\"let tournamentYear of tournamentData\">\n    <ng-container *ngIf=\"tournamentYear.year === year\">\n        <table class=\"ui celled table\" *ngIf=\"tournamentData\">\n            <thead>\n                <tr>\n                    <th>Season</th>\n                    <th>Name</th>\n                    <th>When</th>\n                    <th>Location</th>\n                    <th>Result</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr *ngFor=\"let tournament of tournamentYear.tournaments\">\n                    <td>{{tournament.season}}</td>\n                    <td>\n                        <!--Only render a link if there is one provided in the data, otherwise just render the text-->\n                        <a *ngIf=\"tournament.nameLink\" href=\"{{tournament.nameLink}}\" target=\"_blank\">{{tournament.nameLabel}}</a>\n                        <ng-container *ngIf=\"!tournament.nameLink\">{{tournament.nameLabel}}</ng-container>\n                    </td>\n                    <td>{{tournament.when}}</td>\n                    <td>{{tournament.location}}</td>\n                    <td>{{tournament.result}}</td>\n                </tr>\n            </tbody>\n        </table>\n    </ng-container>\n</ng-container>";

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(123);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "", ""]);
	
	// exports


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var router_1 = __webpack_require__(90);
	var rosters_data_1 = __webpack_require__(125);
	var RosterComponent = (function () {
	    // Inject the ActivatedRoute into our component
	    function RosterComponent(route) {
	        this.route = route;
	        // Roster data to inject into our template
	        this.rosterData = rosters_data_1.ROSTER_DATA;
	    }
	    /**
	     * Subscribe to our route parameters (roster year).
	     */
	    RosterComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.routeParamsSubscription = this.route.params.subscribe(function (params) {
	            // (+) converts string 'year' to a number
	            _this.year = +params['year'];
	        });
	    };
	    /**
	     * Unsubscribe to our route parameters (roster year).
	     */
	    RosterComponent.prototype.ngOnDestroy = function () {
	        this.routeParamsSubscription.unsubscribe();
	    };
	    return RosterComponent;
	}());
	RosterComponent = __decorate([
	    core_1.Component({
	        selector: 'roster',
	        template: __webpack_require__(126),
	        styles: [__webpack_require__(127)]
	    }),
	    __metadata("design:paramtypes", [typeof (_a = typeof router_1.ActivatedRoute !== "undefined" && router_1.ActivatedRoute) === "function" && _a || Object])
	], RosterComponent);
	exports.RosterComponent = RosterComponent;
	var _a;


/***/ }),
/* 125 */
/***/ (function(module, exports) {

	"use strict";
	exports.ROSTER_DATA = [
	    {
	        year: 2017,
	        imagePath: './assets/team-photo-2017.jpg',
	        players: [
	            {
	                number: 2,
	                name: "Ben 'Beef' Sabourin",
	                year: 'Sophomore'
	            }
	        ]
	    },
	    {
	        year: 2016,
	        imagePath: './assets/team-photo-2016.jpg',
	        players: [
	            {
	                number: 1,
	                name: 'Nick Prozorovsky*',
	                year: 'Senior'
	            }
	        ]
	    },
	    {
	        year: 2015,
	        imagePath: './assets/team-photo-2015.jpg',
	        players: [
	            {
	                number: 1,
	                name: 'Nick Prozorovsky*',
	                year: 'Junior'
	            }
	        ]
	    }
	];


/***/ }),
/* 126 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Roster</h1>\n<div class=\"ui secondary pointing menu\">\n    <a class=\"item\" routerLink=\"/roster/2015\" [ngClass]=\"{'active': year === 2015}\">2015</a>\n    <a class=\"item\" routerLink=\"/roster/2016\" [ngClass]=\"{'active': year === 2016}\">2016</a>\n    <a class=\"item\" routerLink=\"/roster/2017\" [ngClass]=\"{'active': year === 2017}\">2017</a>\n</div>\n<ng-container *ngFor=\"let rosterYear of rosterData\">\n    <ng-container *ngIf=\"rosterYear.year === year\">\n        <img src=\"{{rosterYear.imagePath}}\"/>\n        <table class=\"ui celled table\">\n            <thead>\n                <tr>\n                    <th>#</th>\n                    <th>Name</th>\n                    <th>Year</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr *ngFor=\"let player of rosterYear.players\">\n                    <td>{{player.number}}</td>\n                    <td>{{player.name}}</td>\n                    <td>{{player.year}}</td>\n                </tr>\n            </tbody>\n        </table>\n        <p>(*) indicates captain for that year</p>\n    </ng-container>\n</ng-container>";

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(128);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "img {\n  width: 75%;\n  border: 1px solid #00004D;\n  border-radius: 0.28571429em;\n}\n", ""]);
	
	// exports


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var google_spreadsheet_service_1 = __webpack_require__(44);
	var AbsentComponent = (function () {
	    // Constructor with our http service injected
	    function AbsentComponent(spreadsheetService) {
	        this.spreadsheetService = spreadsheetService;
	        // API url for our personal server
	        this.googleSheetsApiUrl = 'https://nick-proz-google-sheet-api.herokuapp.com/sheets/11ijrHoysiIwsFfEggbSNM9Y8VvzU65jeuhQ3vkV5FGw/sheetIndex/1/rows/';
	        // API url for our backup server (sheetsu API)
	        // private googleSheetsBackupApiUrl = 'https://sheetsu.com/apis/v1.0/7a030ae60b7d';
	        this.googleSheetsBackupApiUrl = '';
	        // Error messages
	        this.validationErrors = 'Please do not leave any required fields blank.';
	        this.submissionError = 'Could not submit the form  due to a server error. Please try again soon or contact the web admins.';
	        // Boolean indicating if our form is in the process of submitting (to show our loading icon)
	        this.formIsSubmitting = false;
	        // Boolean indicating if our form was successfully submitted (to show our success message)
	        this.submitSuccess = false;
	    }
	    AbsentComponent.prototype.ngAfterViewInit = function () {
	        $(this.monthDropdown.nativeElement).dropdown();
	    };
	    AbsentComponent.prototype.handleSubmit = function (event, monthInput) {
	        event.preventDefault();
	        this.month = monthInput;
	        this.submitSuccess = false;
	        if (!this.formIsValid()) {
	            this.formErrors = this.validationErrors;
	        }
	        else {
	            this.formIsSubmitting = true;
	            this.formErrors = null;
	            var date = new Date();
	            var data = {
	                "Timestamp": date.toLocaleString(),
	                "First Name": this.firstName,
	                "Last Name": this.lastName,
	                "Time": this.time,
	                "Date": this.month + "/" + this.day,
	                "Reason": this.reason
	            };
	            this.submitAbsentForm(data);
	        }
	    };
	    /**
	     * Submits our form to the spreadsheet by calling our service method.
	     * On success, we show our confirmation modal and reset our rsvp modal.
	     * On failure, we hide our submitting dialog and show our submission error to the user.
	     *
	     * @param data - data to submit to our spreadsheet
	     */
	    AbsentComponent.prototype.submitAbsentForm = function (data) {
	        var _this = this;
	        this.spreadsheetService.postRowToSpreadsheet(this.googleSheetsApiUrl, this.googleSheetsBackupApiUrl, data)
	            .then(function () {
	            _this.resetForm();
	            _this.submitSuccess = true;
	        })
	            .catch(function () {
	            _this.formIsSubmitting = false;
	            _this.formErrors = _this.submissionError;
	        });
	    };
	    /**
	     * Clears our input fields, errors, and resets our form is submitting flag.
	     */
	    AbsentComponent.prototype.resetForm = function () {
	        this.firstName = null;
	        this.lastName = null;
	        this.reason = null;
	        this.time = null;
	        this.day = null;
	        this.month = null;
	        this.formErrors = null;
	        this.formIsSubmitting = false;
	    };
	    /**
	     * Front-end validation for our form.
	     * Our form is valid only if all fields are populated.
	     *
	     * @returns {boolean} - true if the form is valid, false otherwise
	     */
	    AbsentComponent.prototype.formIsValid = function () {
	        return this.firstName != null && this.firstName != ''
	            && this.lastName != null && this.lastName != ''
	            && this.reason != null && this.reason != ''
	            && this.time != null && this.time != ''
	            && this.month != null && this.month > 0
	            && this.day != null;
	    };
	    return AbsentComponent;
	}());
	__decorate([
	    core_1.ViewChild('monthDropdown'),
	    __metadata("design:type", typeof (_a = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _a || Object)
	], AbsentComponent.prototype, "monthDropdown", void 0);
	AbsentComponent = __decorate([
	    core_1.Component({
	        selector: 'absent',
	        template: __webpack_require__(131),
	        styles: [__webpack_require__(132)]
	    }),
	    __metadata("design:paramtypes", [typeof (_b = typeof google_spreadsheet_service_1.SpreadsheetService !== "undefined" && google_spreadsheet_service_1.SpreadsheetService) === "function" && _b || Object])
	], AbsentComponent);
	exports.AbsentComponent = AbsentComponent;
	var _a, _b;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(130)))

/***/ }),
/* 130 */,
/* 131 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Practice Absence Form</h1>\n<div *ngIf=\"formIsSubmitting\" class=\"ui active inverted dimmer\"><div class=\"ui text loader\">Submitting</div></div>\n<form class=\"ui form\">\n    <div class=\"two fields\">\n        <div class=\"field\">\n            <label>First Name <span class=\"required\">*</span></label>\n            <input [(ngModel)]=\"firstName\" type=\"text\" name=\"first-name\" placeholder=\"First Name\">\n        </div>\n        <div class=\"field\">\n            <label>Last Name <span class=\"required\">*</span></label>\n            <input [(ngModel)]=\"lastName\" type=\"text\" name=\"last-name\" placeholder=\"Last Name\">\n        </div>\n    </div>\n    <div class=\"field\">\n        <label>Reason for missing or being late to practice <span class=\"required\">*</span></label>\n        <input [(ngModel)]=\"reason\" type=\"text\" name=\"reason\" placeholder=\"Better be good...\">\n    </div>\n    <div class=\"field\">\n        <label>From what time to what time is your conflict? <span class=\"required\">*</span></label>\n        <input [(ngModel)]=\"time\" type=\"text\" name=\"time\" placeholder=\"Time\">\n    </div>\n    <div class=\"field\">\n        <div class=\"two fields\">\n            <div class=\"field\">\n                <label>Practice date <span class=\"required\">*</span></label>\n                <input [(ngModel)]=\"day\" maxlength=\"2\" type=\"text\" name=\"day\" placeholder=\"Day (0-31)\">\n            </div>\n            <div class=\"field\">\n                <label>&nbsp;</label>\n                <div #monthDropdown class=\"ui search selection dropdown\">\n                    <input #monthInput type=\"hidden\" name=\"month\">\n                    <i class=\"dropdown icon\"></i>\n                    <div class=\"default text\">Month</div>\n                    <div class=\"menu\">\n                        <div class=\"item\" data-value=\"01\">January</div>\n                        <div class=\"item\" data-value=\"02\">February</div>\n                        <div class=\"item\" data-value=\"03\">March</div>\n                        <div class=\"item\" data-value=\"04\">April</div>\n                        <div class=\"item\" data-value=\"05\">May</div>\n                        <div class=\"item\" data-value=\"06\">June</div>\n                        <div class=\"item\" data-value=\"07\">July</div>\n                        <div class=\"item\" data-value=\"08\">August</div>\n                        <div class=\"item\" data-value=\"09\">September</div>\n                        <div class=\"item\" data-value=\"10\">October</div>\n                        <div class=\"item\" data-value=\"11\">November</div>\n                        <div class=\"item\" data-value=\"12\">December</div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n    <button (click)=\"handleSubmit($event, monthInput.value)\" class=\"ui button\" type=\"submit\">Submit</button>\n    <div class=\"ui error message\" *ngIf=\"formErrors\">\n        <p>{{formErrors}}</p>\n    </div>\n    <div class=\"ui success message\" *ngIf=\"submitSuccess\">\n        <div class=\"header\">Form Submitted</div>\n        <p>The form was successfully submitted. Stop missing practice.</p>\n    </div>\n</form>";

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(133);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "label {\n  text-align: left;\n}\n.ui.form {\n  width: 80%;\n  margin: 0 auto;\n}\n.ui.form .ui.error.message,\n.ui.form .ui.success.message {\n  display: block;\n}\n.ui.form .ui.error.message p,\n.ui.form .ui.success.message p {\n  text-align: center;\n}\n.ui.selection.active.dropdown .menu,\n.ui.search.selection.dropdown.active.visible,\n.ui.selection.active.dropdown:hover {\n  border-color: #ff6226;\n}\n.ui.dropdown {\n  min-width: inherit;\n}\n", ""]);
	
	// exports


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var home_component_1 = __webpack_require__(33);
	var about_component_1 = __webpack_require__(39);
	var prospective_players_component_1 = __webpack_require__(43);
	var contact_component_1 = __webpack_require__(48);
	var practice_component_1 = __webpack_require__(84);
	var tournaments_component_1 = __webpack_require__(89);
	var roster_component_1 = __webpack_require__(124);
	var absent_component_1 = __webpack_require__(129);
	var team_history_component_1 = __webpack_require__(135);
	var awards_component_1 = __webpack_require__(140);
	var results_component_1 = __webpack_require__(145);
	exports.ROUTES = [
	    { path: '', component: home_component_1.HomeComponent },
	    { path: 'practice', component: practice_component_1.PracticeComponent },
	    { path: 'absent', component: absent_component_1.AbsentComponent },
	    { path: 'contact', component: contact_component_1.ContactComponent },
	    { path: 'home', component: home_component_1.HomeComponent },
	    { path: 'about', component: about_component_1.AboutComponent },
	    { path: 'prospects', component: prospective_players_component_1.ProspectivePlayersComponent },
	    { path: 'tournaments/:year', component: tournaments_component_1.TournamentsComponent },
	    { path: 'roster/:year', component: roster_component_1.RosterComponent },
	    { path: 'history/:year', component: team_history_component_1.TeamHistoryComponent },
	    { path: 'awards', component: awards_component_1.AwardsComponent },
	    { path: 'results', component: results_component_1.ResultsComponent },
	    { path: '**', component: home_component_1.HomeComponent },
	];


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var history_year_data_1 = __webpack_require__(136);
	var router_1 = __webpack_require__(90);
	var TeamHistoryComponent = (function () {
	    // Inject the ActivatedRoute into our component
	    function TeamHistoryComponent(route) {
	        this.route = route;
	        // Results data to inject into our template
	        this.historyData = history_year_data_1.HISTORY_DATA;
	    }
	    TeamHistoryComponent.prototype.ngAfterViewInit = function () {
	        $(this.firstDropdown.nativeElement).dropdown({});
	        $(this.secondDropdown.nativeElement).dropdown({});
	        $(this.thirdDropdown.nativeElement).dropdown({});
	    };
	    /**
	     * Subscribe to our route parameters (tournament year).
	     */
	    TeamHistoryComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.routeParamsSubscription = this.route.params.subscribe(function (params) {
	            // (+) converts string 'year' to a number
	            _this.year = +params['year'];
	        });
	    };
	    /**
	     * Unsubscribe to our route parameters (tournament year).
	     */
	    TeamHistoryComponent.prototype.ngOnDestroy = function () {
	        this.routeParamsSubscription.unsubscribe();
	    };
	    return TeamHistoryComponent;
	}());
	__decorate([
	    core_1.ViewChild('1994dropdown'),
	    __metadata("design:type", typeof (_a = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _a || Object)
	], TeamHistoryComponent.prototype, "firstDropdown", void 0);
	__decorate([
	    core_1.ViewChild('2000dropdown'),
	    __metadata("design:type", typeof (_b = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _b || Object)
	], TeamHistoryComponent.prototype, "secondDropdown", void 0);
	__decorate([
	    core_1.ViewChild('2010dropdown'),
	    __metadata("design:type", typeof (_c = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _c || Object)
	], TeamHistoryComponent.prototype, "thirdDropdown", void 0);
	TeamHistoryComponent = __decorate([
	    core_1.Component({
	        selector: 'team-history',
	        template: __webpack_require__(137),
	        styles: [__webpack_require__(138)]
	    }),
	    __metadata("design:paramtypes", [typeof (_d = typeof router_1.ActivatedRoute !== "undefined" && router_1.ActivatedRoute) === "function" && _d || Object])
	], TeamHistoryComponent);
	exports.TeamHistoryComponent = TeamHistoryComponent;
	var _a, _b, _c, _d;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(130)))

/***/ }),
/* 136 */
/***/ (function(module, exports) {

	"use strict";
	exports.HISTORY_DATA = [
	    {
	        year: 2017,
	        imagePath: './assets/team-photo-2017.jpg',
	        summaryMarkup: "\n            <p></p>\n        "
	    },
	    {
	        year: 2016,
	        imagePath: './assets/team-photo-2016.jpg',
	        summaryMarkup: "\n            <p>Illinois Ultimate came into the 2016 season with a taste of success and big shoes to fill. Returning captain Nick Prozorovsky and new captains Prayag Patel and Chris Buchta were tasked with the difficult prospect of replacing the 12 graduating players as well as coach Matt Stupca. Boomland coach Erik Huemiller and recent alum Matt West were able to fill the leadership void as the team looked to reload for another run at Nationals.</p>\n            <p>The tryouts for the team were very competitive, with the biggest incoming class in recent memory. The final roster included 7 rookies, 1 grad student, 5 former Boomland players, and 12 returners. The newest iteration of Illinois Ultimate tested themselves at Missouri Loves Company, but returned with shoulder injuries to seniors Nick Prozorovsky and Alex Guy that would hamper them for the rest of the season.</p>\n            <p>This spring season had the team heading to Florida, South Carolina, and Missouri in search of elite competition.</p>\n            <p>Mid February had the team flying south to compete at Warm Up. Unfortunately, the week prior had grad student Cody Gray breaking his hand in Irwin and senior Wilson Wang pulling his hamstring in the Armory, both big handler losses. On Saturday, the team started with 10-13 and 11-13 losses to Texas and Florida State. The third game of the day was against perennial powerhouse Pittsburgh. Illinois came out sloppy and was pressured into making many errors, resulting in a 1-7 score at half and an embarrassing 2-12 loss, finishing 0-4 on the day after another loss to BYU. Saturday started off better with a 13-5 win over host South Florida, but was followed by big losses to Virginia Tech and Auburn. Illinois finished the tournament 2-7, with a universe loss to in region rival Northwestern and only wins coming against South Florida.</p>\n            <p>With most of the team finally healthy, the team made the trip to Easterns for the second tournament of the season. The first game of the tournament was a rematch against Pittsburgh. This time, Illinois was prepared for the intensity and was able to make it a closer game, but still lost 12-15. Another rematch against Virginia Tech ended similarly, losing 11-14, and the team ended Saturday 0-4, with a 10-15 loss to UNC Darkside and an 11-13 loss to regional rival Michigan. On a wet, cold, and windy Sunday, Illinois was not able to come out with any fire and lost badly to James Madison and Connecticut, going 0-6 on the weekend.</p>\n            <p>The final regular season tournament of the year was Huck Finn and the boys from Illinois looked to bounce back from a so far unsuccessful regular season. With a mindset of improving for the series the Illini came out with a 7-0 lead at half on Indiana and closed it out with an 11-4 win. Dayton was the next game, which was a 13-4 win for the Illini which meant that they would play Maryland for the pool. Ankle injuries to Prayag Patel and Ben Foster meant that the O line was playing without two key contributors, but the team was able to tough out a 14-11 win, setting up a crossover game against Illinois State. In a very windy game, Illinois triumphed over their in state competitors in a 10-6 victory, securing a quarterfinals berth. The team closed out the tournament with losses to Arkansas and Purdue, and prepared themselves for Conferences.</p>\n            <p>Once again, Rantoul was host to Conferences, but this time there could be no complaints about the weather. Illinois started out strong with comfortable wins over the rest of the pool, including an 11-4 victory over UChicago. Winning the pool lined up a semifinal game against Illinois State, which was won handily 13-7 and set up a classic Illinois - Northwestern rematch. Unfortunately, the team struggled to find the endzone and for the second year in a row, lost to Northwestern at Conferences. In the 2nd place match against UChicago, Illinois was unable to find a groove and lost 9-11. With Regionals in two weeks and only one bid for the region, Illinois had a lot of work to do.</p>\n            <p>In a change of pace, Regionals was not hosted in Rockford, but in Fair Oaks, Indiana. The conditions were terrible, low temperatures coupled with heavy wind and rain meant that it would be difficult getting a good grip. In the first game against Kentucky, both O and D line were able to perform well, giving up no breaks and handing out a few of their own and finishing with a score of 12-6. The trend continued against Indiana, with Illinois winning 13-6. Next up was Notre Dame, a rematch of last year\u2019s finals, winner takes the pool and quarterfinals berth. A completely upwind/downwind game found the d line with opportunities to break, but never able to finish the job. With neither team being broken, Notre Dame won the flip and the game, 9-10. Illinois finished up the day with a 13-5 win over Michigan State to set up a quarterfinals matchup against Northwestern.</p>\n            <p>Conditions on Sunday were better and with a little support from Walden Nelson, the team was ready to avenge their recent losses. Illinois started on D and Northwestern came out with an break early in the game, but the team fought back and breaks were traded to have it be on serve at half. The second half commenced with more of a cleaner game, with both teams trading offensive holds. A chance at a break due to a Nick Pro sky was called back on a controversial observer ruling and the game reached softcap with the score 10-11. Chris Buchta tied up the score with a huck from Kevin Lin and the d line went out to try and break with the season on the line. After a turn from Northwestern, Illinois worked the disc down the field and rookie Jacob Cuthbert took a timeout outside of the endzone. One endzone set later, Prayag found Cuthbert for the win, sending Illinois to the semifinals.</p>\n            <p>Due to the loss in pool play, Illinois\u2019s matchup in the semifinals was Michigan. Despite the tough game before, Illinois had to come out hot if they wanted to win the game. Michigan came out of the gate fast, scoring on a huck. Illinois followed suit, and the two teams traded offensive holds until Michigan broke for 3-5. As the game went on, the defensive pressure from Michigan intensified and Illinois\u2019 o line was not able to match the goals that Michigan\u2019s o line was putting out. Coming out of half at 5-8, Illinois turned and was broken again. A late injury to Prayag pushed the hope of a comeback a little further out of reach and a senior d line was unable to keep Michigan from seizing the victory 10-15. Michigan went on to defeat Notre Dame 15-9 to take the bid to Nationals. Illinois finished the season with a 11-10 victory over Purdue for 3rd in the region.</p>\n            <p>Captain Nick Prozorovsky and John Saniat received 1st team All-Region honors and Captain Prayag Patel received 2nd team All-Region. Ben Sabourin and Jacob Cuthbert were voted All-Freshmen for the region, with Ben winning Freshman of the Year.</p>\n        "
	    },
	    {
	        year: 2015,
	        imagePath: './assets/team-photo-2015.jpg',
	        summaryMarkup: "\n            <p>After the worst regionals performance since 2006, Illinois entered the 2015 season with a new looking team and a new mindset. Major losses included long time coach Walden Nelson, as well as O-line stars Neal Phelps, Brian Rathunde, and Sean Hill. Marty Markenson returned as captain and was joined by first-timers Johnny Saniat and Nick Prozorovsky.</p>\n            <p>The major change to the team came in the form of returning coach, Matt Stupca. Matt coached the team from 2006-2009 and brought them to Nationals twice, finishing in 5th place in 2008. The experienced coach gave the team the necessary leadership needed to rebuild the club for a possible Nationals run again.</p>\n            <p>As always, the fall tryouts were competitive and exciting, with another strong rookie class and many B-teamers and outsiders joining the scene. When it was all said and done, the final roster consisted of 23 people. The roster included 2 rookies, 5 B-teamers, 15 returners, and 1 transfer student. New additions included Valparaiso stud, Matt West, basketball crossover Jarred Elliot, lovable spirit leader Eric Badger, and rookies Kevin Lin and Jacob Komenda.</p>\n            <p>Come end of fall, Illinois was re-armed and ready for another run for Nationals in the spring season.</p>\n            <p>The spring season schedule was perhaps one of Illinois' most busy. The team was scheduled to attend 3 of the highest level tournaments around the country, including tournaments in Texas, Florida, and South Carolina.</p>\n            <p>When February came around, it was time to head south to Tampa for the first spring tournament, Florida Warm-Up. For the first time, the team traveled by air to a tournament. Warm-Up, a three day tournament, proved to be a useful lesson to the team. On day one, the Illini went 1-3 with only one win in a night game vs. Cornell. It was a disappointing performance, but day two spelt different stories for Illinois. Saturday morning, The Illini would play the revered Nationals team UCF in a game that was recorded by Ultiworld. The Illini were no doubt underdogs, but fought hard to take a lead on the Dogs of War. Major plays included a Callahan by handler Prayag Patel and a huck break-score by Max Willis to rookie Jacob Komenda. The Dogs of War fought, but the Illini pulled through, winning the game 13-9 and claiming one of the biggest upsets of the tournament. Illinois would cruise to two more wins that day, finishing 3-0 for Saturday. With emotions high but legs tired, the Illini finished off the long weekend with a tough loss against Georgetown and a win against Wisconsin-Milwaukee on Sunday to end Florida Warm up. They finished 5-4 on the weekend.</p>\n            <p>The next big tournament was the famous Centex invite in Austin, Texas. The team was seeded 9th overall out of 20 after their impressive win against Central Florida back at Warm-Up. With high expectations, the Illini would jump right into it, playing one of the best teams of 2015, North-Carolina Wilmington. The first point of the game would prove to be somewhat of a theme for the Illini that weekend, as top cutter Nick Prozorovsky would go down with a knee injury. The Illini could not upset the big dog this time though, as Wilmington won comfortably at 11-3.</p>\n            <p>As the day went on, the injuries continued. Nearly half of the Illini squad would go down that day. The pain also showed in the scores, as the Illini would lose to Texas 12-5 and fall to two lower-seeded teams Arkansas and Iowa. They finished 0-4 on Saturday. </p>\n            <p>In the loser's bracket on Sunday, Illinois would go 3-0 with wins over California, Iowa State, and Wisconsin-Milwaukee. </p>\n            <p>The finale of the spring tournaments was the very competitive Easterns in North Myrtle Beach, South Carolina, which a year earlier was won by Great Lakes region rival Michigan. The Illini went into the tournament with a bit of a different look, as Boomland coach Erik Huemiller would fill in for coach Matt Stupca as well as numerous injured and absent players returning to the squad. They were seeded as the 20 seed, with nowhere to go but up.</p>\n            <p>In a highly competitive pool, the Illini would start off against the 2012-2013 national champions, Pittsburgh. Pitt had won every tournament up to this point. The Illini took advantage of Pitts many sloppy mistakes, but could not come away with another upset, falling 15-10. The troubles continued, with losses to Carleton College, UMass, and Georgia. This put the Illini's first day record at a troubling 1-12 on the season.</p>\n            <p>Sunday would prove to be an important day for the Illini. Despite the troubles on Day 1s, the Illini had played well the second day of tournaments all season, with a 6-0 record. As the last ranked seed at the tournament, they would fight to break seed against NC State, Colorado State, and 10-seeded Auburn.</p>\n            <p>With many different position changes, the Illini came out with a new fire, going 3-0 again on Sunday and taking out the competition handily. With this, the Illini spring regular season would come to an end. They would finish with a 10-12 record, with only one of those wins coming on day one of a tournament. This issue would be in the back of everyone's head going into the postseason.</p>\n            <p>Sectionals, as always, was held in Rantoul, IL. The Illini came in as the favorite, with Northwestern and UChicago sitting close behind. The Illini would rough out wins against Eastern Illinois and Southern Illinois before taking on UChicago, who had ended their 2014 season dramatically last year at regionals.</p>\n            <p>The game was up and down but eventually ended in another crushing loss for the Illini on universe point. This sent the Illini into Sunday with a first round match against other rival Northwestern, who the team hadn't played since last year. The game was close early on, but the upstate rivals pulled ahead and eventually took the game 15-9. It was the second very alarming loss in a row for the Illini, and for the first time in years, would eliminate them from winning sectionals.</p>\n            <p>Despite this news, the Illini took down Illinois State in the next game to ensure another game against UChicago for second place in the section. In the game that had a game to go atmosphere, the Illini finally were able to hit on all cylinders, blowing out their recent rivals 15-6 and taking second place at sectionals. It would prove to be somewhat of a weight lifted off everyone's back going into regionals, but there was still much work to be done.</p>\n            <p>Regionals was back at Rockford, a place of many emotions for most Illinois players. Illinois came in as the 3 seed; in a pool with Purdue, Grand Valley, and again, UChicago. The recent ups and downs of the Illinois season, as well as inspiring messages by coach Stupca and some of the players, had the team focused as ever.</p>\n            <p>The first game against Purdue saw the O-Line in cruise control with a level of consistency not seen before in the season. With a few breaks mixed in, the Illini took the first game of the day 11-8. With an easier 13-6 win against Grand Valley State, Illinois would play their final game of the day against UChicago. The game was played just a few fields away from where Chicago ended Illinois season one year prior. Emotions ran high again, but the Illini finally put UChicago to rest in an 11-5 victory. It was a big statement for Illinois and sent them into Sunday's championship bracket riding high.</p>\n            <p>Illinois went into Sunday still not having been broken yet, a true testament to their O-line's improved focus. The first game of the day was against last year's second Nationals team from the region, Eastern Michigan. The game was tight throughout with both O-lines trading, but the Illini pulled through to win the game 15-12. The game saw the Illini let up one break, which was the first break allowed all weekend.</p>\n            <p>This sent the team into semis against their athletic, Big 10 counterparts, Indiana. Indiana, for the most part, was completely unfamiliar to the Illini's play style going into the matchup. With the 'game to go' in the back of everyone's heads, the Illini poured on the points and won 15-5, claiming their biggest victory of the tournament. The D-Line shined this game, giving the O-line a much needed rest heading into the biggest game of the season.</p>\n            <p>The 'game to go' saw the Illini face up against a team they never would have expected. In surprising fashion, the scrappy and energized Notre Dame would stand as their last test of the season. The other side of the bracket would prove to be one to remember, as Notre Dame had beaten rival Michigan after Michigan had beaten Northwestern on double game point the game before. It was win or go home for the Illini.</p>\n            <p>The game was a spectacle, with many of the program's alumni and half the region watching. And with expectations set on Nationals, the Illini delivered, winning the game 15-7 and punching their ticket to Milwaukee for Nationals.</p>\n            <p>The victory was a huge one for the program and it proved to be a huge swing in the eventual Coach of the Year award won by Illinois coach, Matt Stupca. Illinois ended the weekend 6-0, and unbelievably, only allowed 1 break all weekend.</p>\n            <p>The Illini were headed to Nationals!!!</p>\n            <p>After failing to reach Nationals the year earlier, Illinois returned and were seeded 19th among the competition. The Illini, having struggled against top competition earlier in the season, were highly focused going into Nationals.</p>\n            <p>Unusual circumstances at other regionals put the Illini in what was considered one of the best Nationals pools ever, Pool C. Their pool included Maryland, Oregon, Florida State, and UNC. Illinois had not played any of those teams during the regular season.</p>\n            <p>The first game was against Maryland, whose star player and Callahan nominee, was brothers with one of Illinois' rookies. The game was heated though, with highlights including a wild sky by Tyler 'Dutch' DeNooyer and a handblock of Maryland's star by Prayag Patel.</p>\n            <p>The game came down to the wire, but saw the Illini as the slim victors 15-13, with former Nationals scoring top-lister Nick Prozorovsky catching the final point to put the Illini 1-0 on the weekend. It was a win for the Illini that spoke volumes to the idea that they truly belonged there.</p>\n            <p>The next matchup was under the lights on the big field against UNC. Illinois faced another top level player, the eventual Callahan winner, Jon Nethercutt. Nethercutt and his UNC Darkside squad had been one of the highest ranked teams going into the tournament and looked even stronger with the return of the mighty cutter, Ben Snell. </p>\n            <p>Considered the underdogs by far, Illinois jumped out to a quick 2-0 lead, breaking the seemingly unstoppable UNC O-line. The early start proved to be important as Darkside fought back and took the half by only one point. The game was closer than anyone could have predicted.</p>\n            <p>But it was not enough to take down the Atlantic Coast champs, as Darkside took the game 15-12. Nethercutt proved to be hyped correctly, but the Illini still played strong regardless.</p>\n            <p>Day 2 saw the Illini in a huge spotlight, facing Oregon Ego to start the day. The road to Nationals had been shaky for Ego, as their struggles at regionals were the sole reason they had even been placed into Pool C as the shocking 15 seed. They sat 0-2 on the weekend, and were in a do-or-die situation for their season. Fittingly, the Illini matched up against them with a chance to end their season, and a chance to end the college career of one of the games' most well-known players, Dylan Freechild.</p>\n            <p>Freechild and the amped up Ego squad came out strong, taking an early and commanding lead. There were some glimmers of hope for Illinois, but none proved strong enough to get them close, as Ego won the game handily 15-7. This put the Illini at 1-2, and kept the season alive for Oregon.</p>\n            <p>The final game of pool play came against Chris Laroque and Florida State. A year earlier, Illinois had lost a tough game on double game point against FSU at Easterns. Illinois yet again was a heavy underdog. They managed to keep it close for most the game, but FSU's star-studded team proved too strong as FSU took the game 15-11. It was another game very close at half for Illinois, which was promising. The loss would put Illinois out of contention to move into the next round of play.</p>\n            <p>In the final game of the season, Illinois would play Cincinnati. With a win, they would claim a tie for 13th place. With a loss, they would finish 17th at Nationals for the 5th time in a row, perhaps proving the 'curse of Illinois-th place' to be true.</p>\n            <p>But the Illini had no plans to settle for that, as they took the game 15-12 with a bit of a late surge. The game proved to be an Illini classic, with a goal line D by Mark Peterson and a bookends point from Kanzy. The win was topped off with Nick Prozorovsky catching the game winning catch, sending the fans home happy and ending an excellent Illinois season.</p>\n            <p>Illinois broke the 'curse' and finished 13th, their best Nationals performance since 2008.</p>\n            <p>Not surprisingly, three of the final four teams were from Pool C, and the championship saw UNC match up against Oregon. UNC would win again, blowing out Oregon 15-6. In the end, it was actually Illinois who had put the most points up on the eventual champions, with 12 points. Nick Prozorovsky finished pool play tied for the lead in goals scored at 24. Most importantly, Illinois broke seed, gaining the respect deserved and achieving their goals. The 13 seniors leaving were sent home happy.</p>\n            <p>Matt West and Nick Prozorovsky won 1st team all region honors. Kevin Lin won Freshman of the Region. The Matt Stupca deservedly won Coach of the year.</p>\n        "
	    }, {
	        year: 2014,
	        imagePath: './assets/team-photo-2014.jpg',
	        summaryMarkup: "\n            <p>Illinois entered the season hoping to return to Nationals. The team lost 3 time captain and Player of the Region, Ryan 'Kennedy' Smith. Returning captain and Machine star Neal Phelps was joined by first time junior captains Marty Markenson and Eric Bultman. The captaining team was young and inexperienced but Walden Nelson returned giving the team hope.</p>\n            <p>At MLC the team was able to exceed expectations by finishing in 2nd place, losing to the eventual National Champions Colorado Mamabird in the finals. This win in addition to the previous year's nationals birth gave the team a cockiness they were unable to shed.</p>\n            <p>The spring schedule was a weak one compared to years' past. The team only attended two tournaments, Huck Finn and Easterns. The team was able to easily win Kat Fight which further boosted the team's ego. At Easterns they fell short in Pool play losing to Pitt, Florida State, Luther, and Central Florida. But won 13th place with wins against Massachusetts and Luther.</p>\n            <p>Illinois was able to comfortable win the Illinois Conference Championships with a win in the finals over Northwestern. The Great Lakes earned two bids to nationals thanks to Northwestern and Michigan. Illinois won their pool and set themselves up for a shot at Nationals. Northwestern learned from their Conference loss and was able to adapt to slow down the Illinois offense forcing Illinois to fight through the backdoor. They next played Chicago in a windy game in which both teams attempted to score with 50/50 shots. These conditions stopped Illinois' high speed offense and gave Chicago a chance to have many opportunities on defense. Chicago finally finished the game with a stall 9 jump ball in the endzone finishing Illinois' season.</p>\n        "
	    }, {
	        year: 2013,
	        imagePath: './assets/team-photo-2013.jpg',
	        summaryMarkup: "\n            <p>After the disappointing and heartbreaking finish in 2012, Illinois lost a huge chunk of veteran talent and had to reload for 2013. Ryan Smith was captain for the 3rd year in a row and was joined by three first year captains in Neal Phelps, Colin Reid and Nathan Gibbons. The captains and the seniors on the team used the previous year's finish as motivation and set the tone at practices throughout the whole year.</p>    \n            <p>Tryouts were completed shockingly early for the 2nd year in a row. With so many open spots, Illinois was fortunate to receive a very deep and talented freshman class. Five freshman made the A-team, with three of them all coming from the same high school. A large chunk of the team were stepping into new roles or were new to college ultimate altogether. They would be forced to acclimate and adjust quickly if Illinois were to meet it's goals for the year.</p>    \n            <p>At Huck Finn, Illinois came in very over confident and were punished by the frisbee gods for their hubris. They thought they could walk into the tournament and do well. They got a huge wake up call on Saturday with three losses including a potential candidate for worst loss of the program. Another blemish on Coach Walden Nelson's coaching record. Illinois used their performance on Saturday of Huck Finn as cause for penance and toughed out an undefeated Sunday through atrocious weather conditions.</p>    \n            <p>The next weekend at Centex, Illinois came out with a renewed focus and sense of urgency. They gritted out a semifinals finish including splitting two universe point games against Harvard. This tournament gave people on the team reason to believe and showed what the team was capable of.</p>    \n            <p>Sectionals was held in Chicago. There were some tough games, but Illinois won their third consecutive conference championship. After winning the tournament, Illinois did hill sprints to help get mentally prepared for the bloodbath of a 1 bid region.</p>    \n            <p>Illinois came into Regionals as the #2 seed and knew what they had to do. Just like 2011, the format was pool play on Saturday with bracket play on Sunday. The first two games were comfortable victories. The third pool play game against Indiana was a back and forth affair. Indiana led late in the game, but on long turn-filled universe point, Illinois ground out a tough win.</p>    \n            <p>Sunday morning, Illinois came out very hot and played extremely well in a good win over up and coming Northwestern. In the first half of the Regional semi-final against MSU, Illinois could not continue their good play. The Oline struggled mightily with execution errors from the younger players on the line. The first half score was 5-8 MSU. Early in the second half, this worrying trend continued and the score went to 6-10 MSU. When things were looking dire, the soon to be graduating players refused to go down without a fight. Big plays from Preston Goulson and Tyler Anderson fueled a furious Illinois comeback highlighted by a big sky from Brian Rathunde. Illinois pulled out a stunning 14-11 win over MSU. This set up the classic Great Lake Regionals matchup between Illinois and Michigan. For the first time since 2008, this matchup would be for the Regional title and the sole bid to Nationals. Illinois maintained a very slim lead throughout the game. The Oline played very calmly even with increased pressure from Michigan. Late in the game, Illinois pulled out a couple breaks and ended the game on a d and subsequent score by Jon McKoy. Illinois returned to Nationals as the sole representative of the Great Lakes. Ryan Smith won Player of the Region honors, Neal Phelps, Nathan Gibbons earned First Team All-Region awards, Brad Bolliger earned a Second Team and Nick Prozorovsky, Johnny Saniat and Derek Yan earned Freshman team awards.</p>    \n            <p>Unfortunately at Nationals, Illinois could not break the 17th place curse. Some key players were unable to play. Illinois gamely tried to fight on but just could not overcome their depleted personnel. In a unsurprising turn of events, Illinois finished 17th at Nationals.</p>    \n        "
	    }, {
	        year: 2012,
	        imagePath: './assets/team-photo-2012.jpg',
	        summaryMarkup: "\n            <p>For the first time since 2008, Illinois returned a majority of the team and had high expectations going into the season. Major personnel losses included 2-time captain Austin Lien and 3-year O-line starter Chris Hidaka. Zach Frantz and Ryan Smith returned as captains and were joined by Kevin Bruns. With such a large number of returning A-teamers, tryouts were as competitive as ever and there were many people fighting for the few remaining spots. After following the Illinois tradition of making final cuts really late, 3 freshmen had made the A-team, which hadn't happened since 2009.</p>    \n            <p>For such a veteran team, focus and urgency was lacking during the season. There were many times where people would be going through the motions and not getting the most of the practice. Unlike past years, when the senior class would set the tone for all their younger teammates, this year saw a rift open up between the seniors and the younger members of the team. This rift manifested itself in many ways throughout the season, but it came to a head at Centex where a team meeting was held Saturday night after pool play and two juniors spoke to all the seniors and told them to get their act together.</p>    \n            <p>With high expectations going into the season, Illinois scheduled a more competitive tournament schedule than in 2011 and went to Easterns and Centex two tournaments with several Nationals contenders in addition to the early season tournament Free State Classic. With all the drama going on behind closed doors, Illinois had an up and down tournament performance with some uncharacteristic big losses. At Free State, Illinois struggled to play in the wind against Iowa and lost to them twice, once on Saturday and again in the Final. At Centex, Illinois played Iowa again and came out hot and took a 3-0 lead, but that quickly disappeared and Iowa won again in dominating fashion. This bled into the most dispiriting performance by Illinois in many years, as they proceeded to be blanked in the first half by Tufts. After play ended, the aforementioned team meeting was held. Sunday of Centex, Illinois came out reinvigorated and played a close game with Luther but eventually lost on universe. The following weekend at Easterns, Illinois played much more consistently and lost twice, once to eventual champions Pittsburgh and again on universe to Tufts. Buoyed by their Easterns results, Illinois looked ahead to the series and a return to Nationals.</p>    \n            <p>The third annual alumni game was held, and the alumni extended their winning streak to two games after a dismal performance by the college kids. After taking half 8-5, the college team seemed to think the game was over and did not try as hard as the older, more out of shape alumni. Unfortunately, the lessons from the alumni game would not be remembered later in the season.</p>    \n            <p>Sectionals once again were held in Rantoul and like every other tournament that has ever been held there, the weather was terrible. Saturday was cold, windy, and wet and Illinois took care of business winning every game handily. Sunday was sunny and very windy and after going up by a lot on Northwestern, Illinois lost their focus and let them back into the game. Illinois eventually closed it out and won by a few points.</p>    \n            <p>Like the past three years, Illinois was counting on being able to flip the switch and play their best ultimate of the season at Regionals. With two bids to Nationals, the best format and Regionals being held in Naperville, confidence was very high that Illinois would be able to get the job done and qualify for Nationals. It was a cold, windy, wet day on Saturday but Illinois won their first game comfortably. In a shocking turn of events, a lack of focus caused Illinois to come out flat against Eastern Illinois in the regional quarterfinals. Eastern Illinois came out and punched in four breaks in a row. Illinois fought back and tied the score at 5-5, but they could never get over the hump and take the lead. Eastern Illinois' Michael Schwenk carried the team to an upset with a 13-10 victory and gave Illinois their first loss at Regionals since 2008.</p>    \n            <p>With their backs against the wall, Illinois regrouped and took care of business on Saturday and stayed alive in the 2nd place bracket for Sunday. For the first time since 2007, Illinois was not in the Regional Final Sunday morning but instead in a fight for their season in the backdoor semi- finals. They dispatched Indiana 15-7 and had a rematch with Eastern Illinois in the backdoor final. Illinois did not take them lightly this time and came out with a rarely seen intensity and beat Eastern 15-2. However, the team's focus and execution was not there and multiple turnovers on every point culminated in the destruction of Coach Walden Nelson's clipboard. Illinois, after an arduous road, had finally made it to a game to go to Nationals against Michigan State. Illinois started the game out strong and fired up and came out with two quick breaks. MSU played a lot of zone in an effort to negate Ryan Smith's hucks. But Ryan did not take the bait and lead the offense to a clean no break first half and the defense got 3 breaks for an 8-5 halftime lead. Illinois smelled a Nationals berth and came out of half with 2 more points for a commanding 10-5 lead. This was when Michigan State held their ground and began a tenacious comeback. Staying with their zone, MSU began to force more and more turnovers from Illinois and began to convert them for breaks. A 10-5 lead quickly became 10-8 and MSU clawed slowly back from there to finally take the lead at 13-12. A lot of credit is to be given to MSU for never giving up and fighting their way back to the lead. But Illinois' lack of composure on offense coupled with a willingness to turn the disc over, as well as timeout mismanagement by Coach Walden Nelson did not help the cause. Even with all that being said, Illinois scored on offense to make it 13- 13 universe point with the winner going to Nationals. Illinois got the disc twice on universe and both times threw passes into the endzone that hit a receiver's hands, but alas both passes were dropped. After the second drop in the endzone MSU picked up the disc and immediately threw an 80 yard, more than full field huck for the game and the Nationals berth.</p>    \n            <p>This was not the ending to the 2012 season that Illinois imagined. For the first time since 2007, Illinois' graduating seniors did not get to end their careers at Nationals. With a huge graduating class, it will be up to the few returning A-teamers to pick up the pieces and return Illinois to Nationals.</p>    \n        "
	    }, {
	        year: 2011,
	        imagePath: './assets/team-photo-2011.jpg',
	        summaryMarkup: "\n            <p>The program lost several program mainstays such as 5-year A-teamer and 2-time captain Brian Phelan, Top 10 Callahan finisher and captain Walden Nelson, and Team Spirit Leader Kurt Zoellick among others. This required the large junior class to step up and meet the challenge. Juniors Zachary Frantz and Ryan Smith stepped up to become captains alongside returning captain Austin Lien. The captains surveyed the tryout pool and saw that it was one of the most competitive in recent history. Wanting to give everyone a fair look, final cuts weren't made until the end of January. After the smoke cleared, the final roster stood at 27 and after a 1 year hiatus of no freshman making the cut, 2 freshman found themselves on the team.</p>\n            <p>Even with a full roster, Illinois battled the injury bug throughout the season. Dline handler Adam Wright tore his acl at Rivalry Reheat and only returned for a few points at Nationals. Captain Zachary Frantz battled Plantar Fasciitis the whole year, missing every tournament besides Regionals and Nationals. 5th year cutter Chris Hidaka badly sprained his ankle in the 2nd game of the first tournament and never quite regained his old form. Seniors Suleyman Ahmad and Jonathan Hatcher had leg problems of their own and were in and out of the line up. Junior Ryan Kurnik broke his hand and missed the last half of the season. In addition there were numerous other injuries that kept people away from the field.</p>\n            <p>However there were still tournaments to be played and games to be won. Compared to past years, Illinois traveled to less competitive tournaments. Unfortunately this did not lead to more victories as Illinois struggled to maintain focus for whole games, often playing one good and one bad half. There were some benefits as several players were able to gain much needed experience playing new and more challenging roles than they were accustomed to. Illinois made semifinals of both the Freestate Classic and Huck Finn before losing to Central Region teams Iowa and Minnesota. Going into the series, Illinois hoped to follow the trends of the past two Illinois teams and play their best ultimate during the series.</p>\n            <p>Sectionals was held close by in Rantoul, Illinois as people still didn't get the memo not to have tournaments there in the Spring. Saturday was a windy and rainy day, Illinois took care of business and won every game by a comfortable margin. On Sunday, buoyed by the rare beautiful Rantoul weather, Illinois beat Northwestern and Eastern Illinois to repeat as Sectional Champions.</p>\n            <p>Just like 2010, Illinois had the 3rd seed going into Regionals. Unlike past years only 1 team would make it to Nationals, meaning 1 bad half and the season would be over. Another change was the format, with the format being pool play instead of a straight bracket. In a very windy Saturday, Illinois gutted out a close game against Loyola, winning on double game point. After that scare woke them up, they beat Western Michigan and Notre Dame handily. Everyone on the team was looking forward to facing Michigan in semis but first they would have to get through Indiana in the first game of the day on Sunday. Led by their senior leaders Ed Wu and Taylor Kraemer, Indiana gave Illinois all they could handle in a close back and forth game before Illinois pulled it out winning 15-13. This led to the semifinal showdown with Michigan for the third year in a row. However, this year would be different from the past two years as Illinois came out firing with an intensity that Michigan either could not or was unwilling to match. It was a total team effort as everyone contributed to a resounding 15-9 win. It was a great win, but people were too satisfied with that victory considering that the bid to Nationals was still up for grabs. Illinois still had to face a determined opponent in Michigan State who undoubtedly had plans for revenge from 2010. Fortunately for Illinois, Michigan State had several unforced errors in the first half of the game and Illinois took advantage going up several breaks in the first half. Michigan State tried to mount a comeback in the second half but the score difference was too great. Illinois won the region for the 3rd year in a row and took the regions only bid to Nationals with a 15-11 victory. Illinois had several players who played well during Regionals including but not limited to Dane Jorgensen, Brian Pierce, Austin Lien, Zachary Frantz, Ryan Smith and Neal Phelps. In a surprising turn of events, only Ryan Smith was a member of the All-Region team.</p>\n            <p>Going into Nationals, Illinois planned on breaking the curse of two straight 17th places. Ironically enough and deservedly so, Illinois had the 17th seed going in. Illinois was in a pool with overall #1 seed Pittsburgh and #12 seed and fan favorite Colorado College. In the first game of Nationals against Colorado College, Illinois battled nerves and had several unforced errors in the first half. However, led by Neal Phelps' stellar defense on Callahan candidate Nicky Spiva and Dane Jorgensen's aerial ability, Illinois fought and clawed back for a gritty 13-11 victory. This was Illinois' first Nationals pool play victory in 2 years and had them primed to take a spot in prequarters. After losing 15-10 to Pittsburgh highlighted by a break with several Nationals first timers and both rookies, Illinois only needed to win 1 of their next 2 games to take a spot in prequarters. Unfortunately, the issues that beguiled Illinois throughout the season came up once again. To put it simply, Illinois did not show up on Saturday of Nationals. Illinois looked lifeless and lost to Iowa 15-10. Even with that being said, Illinois simply had to win against Tufts to advance to the bracket. With their season on the line, Illinois gave a sad, disappointing effort both on the field and on the sidelines. Their effort was no where close to good enough and they got punished deservedly, 15-7, knocking them into the placement bracket for the 3rd year in a row. Illinois lost to Whitman 16-14 after leading most of the game and then in the game they have never lost, beat Florida and took 17th place for the 3rd year in a row. However there is hope for the future with 20 returning players and a talented incoming class, Illinois will look to break the curse of 17th.</p>\n        "
	    }, {
	        year: 2010,
	        imagePath: './assets/team-photo-2010.jpg',
	        summaryMarkup: "\n            <p>Illinois had to deal with several big losses from the year before but none bigger than the departure of longtime coach Matt Stupca who coached from 2004-2009. The captains Brian Phelan, Walden Nelson and Austin Lien, had to come to terms with the responsibilities and extra work that Matt Stupca provided, and carry a bigger load themselves. Dealing with the heavy losses from the year before, Illinois called up a number of players from the B-team and two from the C-team which was a program first. Illinois spent much of the season acclimating the new players so that they would be ready for Nationals level competition.</p>\n            <p>They had uneven results and growing pains throughout the year, with a highlight being making the finals of Mardis Gras before losing to Wisconsin by a substantial margin. It also included another shellacking by Michigan at Huck Finn as many players got their first taste of the regional rivalry. Illinois had several injuries throughout the year which made practice attendance an issue, however Illinois fought through them and went into the College Series mostly healthy.</p>\n            <p>At Sectionals Illinois held the 1 seed going in, but lost on Saturday of Sectionals for the first time since the Regions and Sections were redrawn. This gave them a 2 seed out of their pool and a first round match up with Notre Dame the 2 seed overall, with good seeding at Regionals on the line. Illinois went up big early but Notre Dame made a furious comeback to tie up late in the game, Illinois received going upwind and threw caution into the wind by throwing several close throws through and around the Notre Dame zone before punching it in and winning 14-13. Illinois then took care of business and made it to finals, exacting revenge on Purdue for the Saturday loss and beating them 15-5 and reclaiming the Sectional title.</p>\n            <p>Going into Regionals Illinois had the 3 seed going in behind Michigan State and Michigan. Illinois beat both Dayton and Purdue handily and advanced to semifinals before finding out that Regionals would be postponed for a week. Having a week to prepare and to heal, Illinois faced Michigan at Regionals as is the norm. In a heavy wind game, which saw several lead changes, but few breaks, and lots of great plays from both teams, Illinois was able to score on a gut-wrenching universe point and won the game 9-8.</p>\n            <p>This sent Illinois to its 3rd straight Regional final with a chance to repeat as Regional champions for the first time in the programs history. Illinois faced Michigan State with the Regional title on the line and prevailed in a close game with Illinois being able to pull away in the end, 15-10. Illinois repeated as Regional champions for the first time and had Brian Phelan and Walden Nelson win first team All-Region honors and had Ryan Smith win 2nd team All-Region, becoming the first sophomore in the programs history to win a regional award. Illinois was seeded 14th going into Nationals. They lost to Harvard handily but was still in contention for a prequarters berth if they were able to beat both UNCW and Iowa. However, in games possibly showing a lack of experience or the burden of captaining and coaching proving too great, Illinois lost late leads in both games and lost to UNCW 14-12 and to Iowa 16-14. Illinois then played Carleton in a much closer than expected 15-12 loss and lost to Wisconsin. Beating Kansas in the last game of the tournament gave Illinois its only win at Nationals and sent them home with another 17th place finish. Illinois did not graduate as many players as in years past, which makes Illinois in a prime position to continue its Nationals qualifying streak.</p>\n        "
	    }, {
	        year: 2009,
	        imagePath: './assets/team-photo-2009.jpg',
	        summaryMarkup: "\n            <p>2009 saw the departures of many fixtures of the Illinois program such as Joel Koehneman, Pat Stephens, Jake Segil and David Abram. In their place it was up to the class of 2005 to step up and lead the program. It was the first time in several years that there were 3 captains vacancies. They were filled by Denis Agniel, Brian Phelan and Charlie O'Brien. Like in 2006 when the team lost several impact players, the team was able to recruit a very deep class that rivals and may surpass the freshman class of 2006. This influx of freshman led to the 2nd year of the C- teams existence in the programs history.</p>    \n            <p>The regular season for Illinois was very rough, with the team trying to find people who would be able to fill the big holes left by the departed players. This led to several big losses throughout the year and poor tournament finishes, culminating in a 13-2 beatdown by regional rival Michigan at Huck Finn. Going into the postseason/the college series, Illinois had a lot of uncertainty. At Sectionals, Illinois took care of business on Saturday and beat a tough North Park team in semifinals and made Finals against Notre Dame. In a rainy, cold final, Illinois looked like they did throughout the season and lost 15-10. This gave Illinois a 4 seed going into Regionals and a definite longshot for one of the two Nationals bids.</p>\n            <p>Illinois faced tougher than expected games against Kenyon and North Park before meeting Michigan in Regional semifinals. Illinois came together in a way that had not been seen all season, and put forth their best effort of the season and beat Michigan in a tense hard fought game 12-9. This put Illinois in its second straight Regional final against Ohio State. The previous day's momentum carried over as Illinois beat Ohio State handily 15-11, taking home its first Regional championship since 2002.</p>\n            <p>Illinois placed Denis Agniel, Brian Phelan, Pavan Sarguru, and Walden Nelson on the Great Lakes 2nd Team All-Region, Coach Matt Stupca won the inaugural Coach of the Region award, and Ryan Smith won Freshman of the year. Winning the Region gave Illinois an 8 seed going into Nationals, however whatever magic Illinois had at Regionals was lost at Nationals, as Illinois lost several games by big margins except for one close pool play game against Tufts and the only win against Cal. They did so in good spirit, winning the 2009 Nationals Spirit Award and dubbed Zubair: The most spirited man in ultimate. Although, this performance gave Illinois a disappointing 17th place finish at Nationals and with several players graduating including captain Denis Agniel, the prospect of another rebuilding year loomed large.</p>\n        "
	    }, {
	        year: 2008,
	        imagePath: './assets/team-photo-2008.jpg',
	        summaryMarkup: "\n            <p>Using the loss at Regionals the previous year as motivation and determined to make Nationals in captains Joel Koehneman, Pat Stephans and David Abrams, final year. Many players on the team spent their summer and fall, going to tournaments together in an effort to get better. Illinois also got a key transfer student Denis Agniel, who created the team at Loyola University in Chicago. This was a very veteran team under coach Matt Stupca that was poised to make a run into Nationals.</p>    \n            <p>Throughout the season, Illinois had a chance to win every game that they played. The biggest margin of victory in Illinois' losses heading into Regionals was 3 points. Illinois suffered some key injuries before Sectionals but managed to persevere and hold of North Park in an exciting 17-16 Sectional Final. Like the previous year Illinois had a 2 seed going into Regionals. They took care of business on Saturday winning all 3 games and securing a spot in the Regional finals. In many people's first Regional final, Illinois played tentatively and lost 15-11 to Michigan putting them in the 2nd place game against Ohio State. In a reversal of the previous years game at Regionals, Illinois stormed out to a big lead and maintained it throughout and punched their first ticket to Nationals in 3 years.</p>    \n            <p>Pat Stephens and Joel Koehneman both won all-region honors. Nationals that year was in Boulder, Colorado and Illinois went into it holding an 8 seed and in a pool with Florida, North Texas and Delaware. Illinois beat Delaware to clinch a spot in prequarters, and lost to Florida and North Texas. In prequarters Illinois was matched up against Michigan, who they had lost to at Regionals and had not beaten since 2004. In a hard fought game led by the graduating players, Illinois prevailed 15-11 sending them into quarters against the hometown team Colorado. In an exciting game that saw several big plays, Illinois lost 15-12 to Colorado and ended their season having them tied for 5th which is the highest finish in the programs history. 2008 saw the departure of many mainstays for Illinois and the following years would show how well the recruiting efforts of 2005 paid off.</p>      \n        "
	    }, {
	        year: 2007,
	        imagePath: '',
	        summaryMarkup: "\n            <p>Coming off of one the worst years in recent history, Illinois started to put the pieces in place to make a run at a Nationals berth. The leadership which added Jake Segil as a captain, joining Joel Koehneman and Brian Korbesmeyer and Matt Stupca as coach, continued to focus on recruiting, resulting in an another big influx of freshman. Resulting in the creation of the first C-team in the programs history. However, unlike the previous year, many of them stopped playing within a year.</p>    \n            <p>In order to gear up to make a run and to face stiffer competition, Illinois designed a much harder tournament schedule travelling to tournaments in Las Vegas and Austin, in addition to ones they had previously gone to in Baton Rouge and Atlanta. This benefited the team, as they were able to match up and see where they stood in relation to both Nationals finalists. As a result, the team was able to see that they were more than prepared to take a Nationals berth out of Regionals.</p>    \n            <p>Illinois steamrolled through Sectionals and reclaimed the Sectionals crown and had a 2-seed going into Regionals. Regionals was held in Rantoul, Illinois and was hosted by Illinois. Illinois took care of business early, beating Dayton and Notre Dame handily before squaring off against Indiana in Regional semifinals. In a very heavy upwind downwind game that saw very few breaks, Illinois received going downwind on universe point but was unable to punch it in and lost on a couple floaty upwind hucks. Out of the running for first, Illinois was now in the backdoor bracket having to win every game in order to advance to Nationals. They beat Northwestern and faced Ohio State, the #1 seed going into the tournament who had also lost in semis to Michigan. Perhaps showing a little bit of inexperience in a pressure filled game, Illinois went down big early, going down 5-0, however, they mounted a furious comeback and came close to negating the early deficit, but eventually succumbed 15-12 and ending their season without a Nationals berth for the 3rd year in a row. Illinois finished 4th at Regionals.</p>    \n            <p>Brian Korbesmeyer and Joel Koehneman both received all-region honors. However unlike the previous year, there were several graduating players most notably Brian Korbesmeyer, who had captained the team the previous 2 years and was a major player on offense. Finding players to step into the holes left by the graduating players was a major question going into the next year.</p>    \n        "
	    }, {
	        year: 2006,
	        imagePath: '',
	        summaryMarkup: "\n            <p>After coming so close to a Nationals berth the year before, 2006 was a rebuilding year for Illinois. After losing several starting players, the captains, Brian Korbesmeyer and Joel Koehneman and coach Matt Stupca, decided to focus their energies on recruiting and replenishing the program. This led to one of the deepest freshman classes in the programs history largely due to the efforts of Brian Korbesmeyer. In order to facilitate the rebuilding process, the leadership decided to go with a very small A-team roster of less than 20 guys, so that everyone would be able to play both on the A-team and on the B-team. The B-team with the services of coach Nick McDuffee was able to nurture the players and have them ready to take the next step onto the A-team. It was a season with very few bright spots, as Illinois did not make the Sectional final for one of the few times in modern history, finishing 4th at Sectionals, and did not even make Sunday of Regionals, finishing tied for 7th after losing in quarterfinals and getting eliminated in the backdoor bracket. However, there were encouraging signs for future years to come, Brian Phelan won freshman of the year for the Great Lakes Region and there were several talented players waiting in the wings, ready to make their mark on the program and the same core of players returning.</p>    \n        "
	    }, {
	        year: 2005,
	        imagePath: '',
	        summaryMarkup: "\n            <p>Illinois advanced to the finals at Regionals and lost to Michigan on double game point, and had to immediately play Michigan State for second place and the chance to return to nationals. Coming out flat after the loss to Michigan Illinois went down 3-0. Battled back to double game point but again lost and were eliminated.</p>\n        "
	    }, {
	        year: 2004,
	        imagePath: '',
	        summaryMarkup: "\n            <p>Illinois finished second at Regionals and advanced to Nationals in Seattle, Washington. Illinois lost a close game to North Carolina State in Prequarters and finished 9th.</p>\n        "
	    }, {
	        year: 2003,
	        imagePath: '',
	        summaryMarkup: "\n            <p>Illinois started being invited to the major tournaments, including its first invite to Easterns. This helped prepare the team for the season. Seeded first at Regionals, Illinois lost in the finals to Ohio State and advanced to Nationals in Austin, TX. After beating Michigan and Georgia fairly handily in the first two games, Illinois beat North Carolina State 17-15 to win the pool. In quarters Illinois matched up with Colorado.They were 3 feet away from being up 14-13, pulling downwind, but victory eluded them, and ended up finishing tied for 5th.</p>\n        "
	    }, {
	        year: 2002,
	        imagePath: '',
	        summaryMarkup: "\n            <p>The program made a big jump forward under the coaching of Joe Ferrari. The team advanced to the Regional Final for the first time ever, the Final was against Michigan. There was a consistent wind of 25-35 mph with gusts of over 40. For a lot of the game it was upwind/downwind with the huck and zone strategy being employed. Then early in the second half we got a big break off and were able to work the disc up the backhand sideline all the way to the endzone for a score to take the lead. From there we maintained our lead up to 13-12. Michigan worked the disc upwind and called a timeout 5 yards out of the endzone on the forehand side. Out of the timeout they had a man break open on the force side. Alvin Wang was able to run past for the game saving d. We were able to score that point and the next downwinder in the back corner of the endzone to advance to our first Nationals. Illinois' first Nationals tournament was in Spokane, WA. We lost many close games early to Colorado and Carleton. We beat Colorado later in the tournament and finished 9th.</p>\n        "
	    }, {
	        year: 2001,
	        imagePath: '',
	        summaryMarkup: "\n            <p>Bill Finn and Nick McDuffee joined the team this year, and the team was the strongest it had ever been with these two outstanding rookies. Many of the older returners now had 3-4 years of competitive ultimate under their belts, and the team was on the verge of breaking through. A Sectional final win over Indiana set up Illinois as the 3rd seed at Regionals behind Michigan and OSU (regional hosts). After beating a tough ND team in quarterfinals, Illinois faced Michigan in the semifinals. Despite being up by a few goals at half-time, Michigan's Nationals experience showed and they ended up winning a closely fought game. Sunday morning, Illinois lost to Oberlin, making it three straight years of semifinal losses at Regionals.</p>\n        "
	    }, {
	        year: 2000,
	        imagePath: '',
	        summaryMarkup: "\n            <p>Illinois changed its name to FIST and had another good recruiting class with the likes of Greg Severin, Chris Hagen, Nels Overgaard-Cook, Kyle Eertmoed, Brian Fifarek, and Dave Draeger. Illinois went to the Stanford Invite for the first time. Regionals was at Purdue University that year, and Illinois lost to Dayton in semifinals, beat Oberlin Sunday morning, and then lost an elimination game to Notre Dame.</p>\n        "
	    }, {
	        year: 1999,
	        imagePath: '',
	        summaryMarkup: "\n            <p>1999 saw another surge in the team's development. More recruits like Alvin Wang, John Koltse, and Kevin Patterson joined the team. The College Regions were redrawn which meant that Illinois had a real opportunity to qualify for nationals in the newly formed Great Lakes Region. It was a great year for the team, which racked up many wins, including wins at Frozen Over in Bloomington, IN and the first Sectional Championship for the team. Coming into Regionals, Illinois was seeded second and hosted the tournament. The team lost a heartbreaker in semifinals to Oberlin College, and then lost an elimination game on Sunday morning to Notre Dame.</p>\n        "
	    }, {
	        year: 1998,
	        imagePath: '',
	        summaryMarkup: "\n            <p>Was a transformational year for the program, as a great class of rookies joined Illinois. Jarrett Bialek, Xia Xi, Andy Zill, Kyle Romberg, and Jacob Dee were among the new players who helped push the team to towards becoming a more legitimate program. The team changed their name to 'Men From Mars', got uniforms, designed new discs, and actually started practicing a real offensive scheme and spent more time working out off the field. Illinois set the goal of qualifying for Regionals, and at that time the Central Region included every state from Minnesota to Illinois to Colorado. A 4th place finish at sectionals propelled them to their first Regionals birth in many years. At Regionals in Michigan, Illinois played Grinnell and Colorado State pool play, but were eliminated from competition on Saturday.</p>\n        "
	    }, {
	        year: 1997,
	        imagePath: '',
	        summaryMarkup: "\n            <p>Tom Coffin aka Iron Man, an older player deserves credit for organizing the program and recruiting efforts. He moved to Champaign in the fall of 1996 and really helped lead the program in the right direction along with players like Joe Ferrari and Ryan Fehrenbacher and others. In the fall of 1996, the team was mostly filled with graduate students and older players, and had a 'serious' pick-up vibe where practices were mostly scrimmages with some occasional drills. Under Captain Ted Winrow, 'Big Red Ultimate' struggled to win many games, but traveled to tournaments in Baton Rouge, LA, Carbondale, IL, Madison, WI, amongst a few others. Key players included John Conour, Leo Wang, Jon Rasmussen, and David Fiske. Joe Ferrari and Matt Taylor were the only freshmen, who showed up consistently, and the year ended with a low finish at Sectionals and Illinois did not qualify for Regionals that year. BRU - the origin of this name comes from the practice on the team where if you got handblocked you had to chug a bottle of Big Red Soda, which had some significance.</p>\n        "
	    }, {
	        year: 1996,
	        imagePath: '',
	        summaryMarkup: "\n            <p>Illinois again hosted Sectionals and qualified for Regionals, finishing 3rd behind Notre Dame and Indiana. Our team by this point was more than half undergraduates; there were at most 14 at Regionals. The team was run at this time by Ted Winrow. Ted and Gary Ledonne were basically the entire team. Bill Branson was still playing, John Connour was in his first year, Leo Wang was in his first year alSophomore Gary Ledonne had to convince players to attend Regionals in West Lafayette. Illinois went 0-3 in pool play losing relatively close games to Colorado and Oberlin.</p>\n        "
	    }, {
	        year: 1995,
	        imagePath: '',
	        summaryMarkup: "\n            <p>After losing 2 of our top grad students Illinois lost in the game to go to Regionals to Ball State.</p>\n        "
	    }, {
	        year: 1994,
	        imagePath: '',
	        summaryMarkup: "\n            <p>In February of 1994, Illinois had winter practices in the Armory and the Bubble. The University would give us 1.5 hours a week Sunday night 10:30 to Midnight, we split use with the women's team. The makeup of the team was much different, there were had 17 players at Sectionals 4 were undergrads. Almost all grad students and most were in their late 20's. There was little to no recruiting effort. Practice generally consisted of some bad drills, but they were drills designed to learn how to throw in most cases, then we scrimmaged. Our level of athleticism was awful compared to today's game, but our older team was pretty strong throwing, at least for a college team at that time. Wind was our friend as it allowed us to run a zone. In any case the team was fairly solid. Tony Curtis, Mike Percy, and Bill Branson were some of the strong grad student throwers. Mike Fritz an old undergrad at 23, Ted Winrow and Gary Ledonne both sophomores were the contributing undergrads. The team hosted Sectionals and took 2nd to Purdue, our big win was beating Indiana who had been the strength of the Section. Regionals was in Grinnell, Iowa. It was the first year they had moved Colorado into our Region as they had lobbied for an easier Region. At Regionals Illinois went 3-1 in pool play, losing to Purdue, beating Colorado, Macalester, and Grinnell. In pre-quarters we beat Dayton making the top 8 double elimination for 3 spots. Lost to Carleton and Oberlin and that was it.</p>\n        "
	    }
	];


/***/ }),
/* 137 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Team History</h1>\n<div class=\"ui secondary pointing menu\">\n    <div #1994dropdown class=\"ui dropdown item\">\n        1994-1999<i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <div routerLink=\"/history/1994\" [routerLinkActive]=\"['active']\" class=\"item\">1994</div>\n            <div routerLink=\"/history/1995\" [routerLinkActive]=\"['active']\" class=\"item\">1995</div>\n            <div routerLink=\"/history/1996\" [routerLinkActive]=\"['active']\" class=\"item\">1996</div>\n            <div routerLink=\"/history/1997\" [routerLinkActive]=\"['active']\" class=\"item\">1997</div>\n            <div routerLink=\"/history/1998\" [routerLinkActive]=\"['active']\" class=\"item\">1998</div>\n            <div routerLink=\"/history/1999\" [routerLinkActive]=\"['active']\" class=\"item\">1999</div>\n        </div>\n    </div>\n    <div #2000dropdown class=\"ui dropdown item\">\n        2000-2009<i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <div routerLink=\"/history/2001\" [routerLinkActive]=\"['active']\" class=\"item\">2001</div>\n            <div routerLink=\"/history/2002\" [routerLinkActive]=\"['active']\" class=\"item\">2002</div>\n            <div routerLink=\"/history/2003\" [routerLinkActive]=\"['active']\" class=\"item\">2003</div>\n            <div routerLink=\"/history/2004\" [routerLinkActive]=\"['active']\" class=\"item\">2004</div>\n            <div routerLink=\"/history/2005\" [routerLinkActive]=\"['active']\" class=\"item\">2005</div>\n            <div routerLink=\"/history/2006\" [routerLinkActive]=\"['active']\" class=\"item\">2006</div>\n            <div routerLink=\"/history/2007\" [routerLinkActive]=\"['active']\" class=\"item\">2007</div>\n            <div routerLink=\"/history/2008\" [routerLinkActive]=\"['active']\" class=\"item\">2008</div>\n            <div routerLink=\"/history/2009\" [routerLinkActive]=\"['active']\" class=\"item\">2009</div>\n        </div>\n    </div>\n    <div #2010dropdown class=\"ui dropdown item\">\n        2010-2017<i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <div routerLink=\"/history/2010\" [routerLinkActive]=\"['active']\" class=\"item\">2010</div>\n            <div routerLink=\"/history/2011\" [routerLinkActive]=\"['active']\" class=\"item\">2011</div>\n            <div routerLink=\"/history/2012\" [routerLinkActive]=\"['active']\" class=\"item\">2012</div>\n            <div routerLink=\"/history/2013\" [routerLinkActive]=\"['active']\" class=\"item\">2013</div>\n            <div routerLink=\"/history/2014\" [routerLinkActive]=\"['active']\" class=\"item\">2014</div>\n            <div routerLink=\"/history/2015\" [routerLinkActive]=\"['active']\" class=\"item\">2015</div>\n            <div routerLink=\"/history/2016\" [routerLinkActive]=\"['active']\" class=\"item\">2016</div>\n            <div routerLink=\"/history/2017\" [routerLinkActive]=\"['active']\" class=\"item\">2017</div>\n\n        </div>\n    </div>\n</div>\n<h2 class=\"ui header\">{{year}}</h2>\n<ng-container *ngFor=\"let historyYear of historyData\">\n    <ng-container *ngIf=\"historyYear.year === year\">\n        <img *ngIf=\"historyYear.imagePath\" src=\"{{historyYear.imagePath}}\"/>\n        <div class=\"summary\" [innerHTML]=\"historyYear.summaryMarkup\"></div>\n    </ng-container>\n</ng-container>\n<!--Only show the previous and next button if they are within the bounds of our history summaries-->\n<a *ngIf=\"year > 1994\" routerLink=\"/history/{{year - 1}}\"><i class=\"angle double left icon\"></i></a>\n<a *ngIf=\"year < 2017\" routerLink=\"/history/{{year + 1}}\"><i class=\"angle double right icon\"></i></a>";

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(139);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "img {\n  width: 75%;\n  border: 1px solid #00004D;\n  margin-bottom: 15px;\n  border-radius: 0.28571429em;\n}\ni {\n  font-size: 2em;\n}\ni.right {\n  float: right;\n}\ni.left {\n  float: left;\n}\n.summary {\n  text-align: left;\n  margin-bottom: 20px;\n}\n.ui.dropdown.item {\n  width: 121px;\n  height: 40px;\n}\n.ui.dropdown.item .active,\n.ui.dropdown.item:focus {\n  border: 0;\n}\n", ""]);
	
	// exports


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var awards_data_1 = __webpack_require__(141);
	var AwardsComponent = (function () {
	    function AwardsComponent() {
	        // Awards data to inject into our template
	        this.awardData = awards_data_1.AWARDS_DATA;
	    }
	    AwardsComponent.prototype.ngOnInit = function () { };
	    return AwardsComponent;
	}());
	AwardsComponent = __decorate([
	    core_1.Component({
	        selector: 'awards',
	        template: __webpack_require__(142),
	        styles: [__webpack_require__(143)]
	    }),
	    __metadata("design:paramtypes", [])
	], AwardsComponent);
	exports.AwardsComponent = AwardsComponent;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

	"use strict";
	exports.AWARDS_DATA = [
	    {
	        year: 2016,
	        name: 'Nick Prozorovsky',
	        award: '1st Team'
	    },
	    {
	        year: 2016,
	        name: 'Johnny Saniat',
	        award: '1st Team'
	    },
	    {
	        year: 2016,
	        name: 'Prayag Patel',
	        award: '2nd Team'
	    },
	    {
	        year: 2016,
	        name: 'Ben Sabourin',
	        award: 'All-Freshman/FOTY'
	    },
	    {
	        year: 2016,
	        name: 'Jacob Cuthbert',
	        award: 'All-Freshman'
	    },
	    {
	        year: 2015,
	        name: 'Matt Stupca',
	        award: 'COTY'
	    },
	    {
	        year: 2015,
	        name: 'Nick Prozorovsky',
	        award: '1st Team'
	    },
	    {
	        year: 2015,
	        name: 'Matt West',
	        award: '1st Team'
	    },
	    {
	        year: 2015,
	        name: 'Kevin Lin',
	        award: 'All-Freshman/FOTY'
	    },
	    {
	        year: 2014,
	        name: 'Neal Phelps',
	        award: '1st Team'
	    },
	    {
	        year: 2014,
	        name: 'Nick Prozorovsky',
	        award: '2nd Team'
	    },
	    {
	        year: 2013,
	        name: 'Nathan Gibbons',
	        award: '1st Team'
	    },
	    {
	        year: 2013,
	        name: 'Neal Phelps',
	        award: '1st Team'
	    },
	    {
	        year: 2013,
	        name: 'Ryan Smith',
	        award: '1st Team/POTY'
	    },
	    {
	        year: 2013,
	        name: 'Brad Bollinger',
	        award: '2nd Team'
	    },
	    {
	        year: 2013,
	        name: 'Nick Prozorovsky',
	        award: 'All Freshman'
	    },
	    {
	        year: 2013,
	        name: 'Johnny Saniat',
	        award: 'All Freshman'
	    },
	    {
	        year: 2013,
	        name: 'Derek Yan',
	        award: 'All Freshman'
	    },
	    {
	        year: 2012,
	        name: 'Ryan Smith',
	        award: '1st Team'
	    },
	    {
	        year: 2012,
	        name: 'Dane Jorgensen',
	        award: '2nd Team'
	    },
	    {
	        year: 2011,
	        name: 'Ryan Smith',
	        award: '1st Team'
	    },
	    {
	        year: 2010,
	        name: 'Walden Nelson',
	        award: '1st Team'
	    },
	    {
	        year: 2010,
	        name: 'Brian Phelan',
	        award: '1st Team'
	    },
	    {
	        year: 2010,
	        name: 'Ryan Smith',
	        award: '2nd Team'
	    },
	    {
	        year: 2009,
	        name: 'Matt Stupca',
	        award: 'COTY'
	    },
	    {
	        year: 2009,
	        name: 'Denis Agniel',
	        award: '2nd Team'
	    },
	    {
	        year: 2009,
	        name: 'Walden Nelson',
	        award: '2nd Team'
	    },
	    {
	        year: 2009,
	        name: 'Pavan Sarguru',
	        award: '2nd Team'
	    },
	    {
	        year: 2009,
	        name: 'Ryan Smith',
	        award: 'FOTY'
	    },
	    {
	        year: 2008,
	        name: 'Joel Koehneman',
	        award: '1st Team'
	    },
	    {
	        year: 2008,
	        name: 'Pat Stephens',
	        award: '1st Team'
	    },
	    {
	        year: 2007,
	        name: 'Joel Koehneman',
	        award: '1st Team'
	    },
	    {
	        year: 2007,
	        name: 'Brian Korbesmeyer',
	        award: '1st Team'
	    },
	    {
	        year: 2006,
	        name: 'Brian Phelan',
	        award: 'FOTY'
	    },
	    {
	        year: 2005,
	        name: 'Nick McDuffee',
	        award: '1st Team'
	    },
	    {
	        year: 2005,
	        name: 'Mike Clark',
	        award: '1st Team'
	    },
	    {
	        year: 2005,
	        name: 'David Abram',
	        award: 'FOTY'
	    },
	    {
	        year: 2004,
	        name: 'Matt Welsh',
	        award: '1st Team'
	    },
	    {
	        year: 2004,
	        name: 'Nick McDuffee',
	        award: '1st Team'
	    },
	    {
	        year: 2004,
	        name: 'Pat Stephens',
	        award: 'FOTY'
	    },
	    {
	        year: 2003,
	        name: 'Nate Bosscher',
	        award: '1st Team'
	    },
	    {
	        year: 2002,
	        name: 'Xi Xia',
	        award: '1st Team'
	    },
	    {
	        year: 2002,
	        name: 'Dane Olsen',
	        award: 'FOTY'
	    }
	];


/***/ }),
/* 142 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Awards</h1>\n<table class=\"ui celled table\">\n    <thead>\n        <tr>\n            <th>Year</th>\n            <th>Name</th>\n            <th>Award</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr *ngFor=\"let award of awardData\">\n            <td>{{award.year}}</td>\n            <td>{{award.name}}</td>\n            <td>{{award.award}}</td>\n        </tr>\n    </tbody>\n</table>\n<p>*All-Freshman team added in 2013, FOTY (Freshman of the Year) given to the All-Freshman member with the most 1st place votes</p>\n<p>*Player of the year award added in 2013, POTY (Player of the Year) given to the All-Region member with the most 1st place votes</p>\n<p>*COTY (Coach of the Year) added in 2009</p>\n<p>*2nd-Team All Region added in 2009</p>\n<p>*Awards first given out in 2002</p>";

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(144);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "p {\n  text-align: left;\n  text-indent: 0;\n}\n", ""]);
	
	// exports


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var results_data_1 = __webpack_require__(146);
	var ResultsComponent = (function () {
	    function ResultsComponent() {
	        // Results data to inject into our template
	        this.resultData = results_data_1.RESULTS_DATA;
	    }
	    ResultsComponent.prototype.ngOnInit = function () { };
	    return ResultsComponent;
	}());
	ResultsComponent = __decorate([
	    core_1.Component({
	        selector: 'results',
	        template: __webpack_require__(147),
	        styles: [__webpack_require__(148)]
	    }),
	    __metadata("design:paramtypes", [])
	], ResultsComponent);
	exports.ResultsComponent = ResultsComponent;


/***/ }),
/* 146 */
/***/ (function(module, exports) {

	"use strict";
	exports.RESULTS_DATA = [
	    {
	        year: 2017,
	        sectionals: '2nd',
	        regionals: '6th',
	        nationals: '-',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://play.usaultimate.org/events/teams/?EventTeamId=TIUxXrZ4pDNhNi4M3QA1J%2b9D8kAdNss8Ny4JyUUuZhg%3d'
	    },
	    {
	        year: 2016,
	        sectionals: '3rd',
	        regionals: '3rd',
	        nationals: '-',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://play.usaultimate.org/teams/events/Eventteam/?TeamId=nQzsCO0fKbUUEFZfKJ%2fOUotd%2f1PM6wo35HPaXJEMUC8%3d'
	    },
	    {
	        year: 2015,
	        sectionals: '2nd',
	        regionals: '1st',
	        nationals: '13th',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://play.usaultimate.org/teams/events/Eventteam/?TeamId=T%2bV6D2XyLTlkLA%2fX2WpaiPGnYy6S3Dn%2fmcblfo08DNo%3d'
	    },
	    {
	        year: 2014,
	        sectionals: '1st',
	        regionals: '5th',
	        nationals: '-',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://play.usaultimate.org/teams/events/Eventteam/?TeamId=1z8hrygGYaDwJqk8F%2fmP4lOk9BD3%2fI%2bKW33IHo8qF9E%3d'
	    },
	    {
	        year: 2013,
	        sectionals: '1st',
	        regionals: '1st',
	        nationals: '17th',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://scores.usaultimate.org/scores/#college-open/team/1794'
	    },
	    {
	        year: 2012,
	        sectionals: '1st',
	        regionals: '3rd',
	        nationals: '-',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://scores.usaultimate.org/scores2012/#college-open/team/1794'
	    },
	    {
	        year: 2011,
	        sectionals: '1st',
	        regionals: '1st',
	        nationals: '17th',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://scores.usaultimate.org/scores2011/#college-open/team/1794'
	    },
	    {
	        year: 2010,
	        sectionals: '1st',
	        regionals: '1st',
	        nationals: '17th',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://scores.usaultimate.org/scores2010/#college-open/team/1794'
	    },
	    {
	        year: 2009,
	        sectionals: '2nd',
	        regionals: '1st',
	        nationals: '13th',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://ultimate.scorereport.net/2009/scores.cgi?div=18&page=3&team=1794'
	    },
	    {
	        year: 2008,
	        sectionals: '1st',
	        regionals: '2nd',
	        nationals: '5th',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://ultimate.scorereport.net/2008/scores.cgi?div=18&page=3&team=1794'
	    },
	    {
	        year: 2007,
	        sectionals: '2st',
	        regionals: '4th',
	        nationals: '-',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://ultimate.scorereport.net/2007/scores.cgi?div=18&page=3&team=1794'
	    },
	    {
	        year: 2006,
	        sectionals: '3rd',
	        regionals: '7th',
	        nationals: '-',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://ultimate.scorereport.net/2006/scores.cgi?div=18&page=3&team=1794'
	    },
	    {
	        year: 2005,
	        sectionals: '2st',
	        regionals: '3rd',
	        nationals: '-',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://ultimate.scorereport.net/2005/scores.cgi?div=18&page=3&team=1794'
	    },
	    {
	        year: 2004,
	        sectionals: '1st',
	        regionals: '2nd',
	        nationals: '17th',
	        teamPageLabel: 'USAU',
	        teamPageLink: 'http://ultimate.scorereport.net/2004/scores.cgi?div=18&page=3&team=1794'
	    }
	];


/***/ }),
/* 147 */
/***/ (function(module, exports) {

	module.exports = "<h1 class=\"ui header\">Results</h1>\n<table class=\"ui celled table\">\n    <thead>\n    <tr>\n        <th>Year</th>\n        <th>Sectionals</th>\n        <th>Regionals</th>\n        <th>Nationals</th>\n        <th>Team Page</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr *ngFor=\"let result of resultData\">\n        <td>{{result.year}}</td>\n        <td>{{result.sectionals}}</td>\n        <td>{{result.regionals}}</td>\n        <td>{{result.nationals}}</td>\n        <td><a target=\"_blank\" href=\"{{result.teamPageLink}}\">{{result.teamPageLabel}}</a></td>\n    </tr>\n    </tbody>\n</table>";

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(149);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, "", ""]);
	
	// exports


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var platform_browser_1 = __webpack_require__(25);
	var router_1 = __webpack_require__(90);
	var team_history_component_1 = __webpack_require__(135);
	var awards_component_1 = __webpack_require__(140);
	var results_component_1 = __webpack_require__(145);
	var app_routes_1 = __webpack_require__(134);
	var HistoryModule = (function () {
	    function HistoryModule() {
	    }
	    return HistoryModule;
	}());
	HistoryModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            platform_browser_1.BrowserModule,
	            router_1.RouterModule.forRoot(app_routes_1.ROUTES)
	        ],
	        declarations: [
	            team_history_component_1.TeamHistoryComponent,
	            awards_component_1.AwardsComponent,
	            results_component_1.ResultsComponent
	        ]
	    }),
	    __metadata("design:paramtypes", [])
	], HistoryModule);
	exports.HistoryModule = HistoryModule;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var router_1 = __webpack_require__(90);
	var menu_desktop_component_1 = __webpack_require__(152);
	var menu_mobile_component_1 = __webpack_require__(158);
	var left_sidebar_component_1 = __webpack_require__(162);
	var right_sidebar_component_1 = __webpack_require__(166);
	var page_frame_component_1 = __webpack_require__(173);
	var app_routes_1 = __webpack_require__(134);
	var footer_component_1 = __webpack_require__(177);
	var PageFrameModule = (function () {
	    function PageFrameModule() {
	    }
	    return PageFrameModule;
	}());
	PageFrameModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            router_1.RouterModule.forRoot(app_routes_1.ROUTES)
	        ],
	        declarations: [
	            page_frame_component_1.PageFrameComponent,
	            menu_desktop_component_1.MenuDesktopComponent,
	            menu_mobile_component_1.MenuMobileComponent,
	            left_sidebar_component_1.LeftSidebarComponent,
	            right_sidebar_component_1.RightSidebarComponent,
	            footer_component_1.FooterComponent
	        ],
	        exports: [
	            page_frame_component_1.PageFrameComponent
	        ]
	    }),
	    __metadata("design:paramtypes", [])
	], PageFrameModule);
	exports.PageFrameModule = PageFrameModule;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var MenuDesktopComponent = (function () {
	    function MenuDesktopComponent() {
	    }
	    /**
	     * Initialize our mobile menu dropdown.
	     */
	    MenuDesktopComponent.prototype.ngAfterViewInit = function () {
	        $(this.teamDropdown.nativeElement).dropdown({});
	        $(this.historyDropdown.nativeElement).dropdown({});
	    };
	    return MenuDesktopComponent;
	}());
	__decorate([
	    core_1.ViewChild('teamDropdown'),
	    __metadata("design:type", typeof (_a = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _a || Object)
	], MenuDesktopComponent.prototype, "teamDropdown", void 0);
	__decorate([
	    core_1.ViewChild('historyDropdown'),
	    __metadata("design:type", typeof (_b = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _b || Object)
	], MenuDesktopComponent.prototype, "historyDropdown", void 0);
	MenuDesktopComponent = __decorate([
	    core_1.Component({
	        selector: 'menu-desktop',
	        template: __webpack_require__(153),
	        styles: [__webpack_require__(155)]
	    }),
	    __metadata("design:paramtypes", [])
	], MenuDesktopComponent);
	exports.MenuDesktopComponent = MenuDesktopComponent;
	var _a, _b;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(130)))

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = "<div class=\"header\">\n    <a routerLink=\"/home\"><img class=\"crest\" src=\"" + __webpack_require__(154) + "\"/></a>\n    <a routerLink=\"/home\"><h1 class=\"header-text\">Illinois Ultimate</h1></a>\n</div>\n\n<div class=\"ui pointing stackable menu\">\n    <a routerLink=\"/home\"       [routerLinkActive]=\"['active']\" class=\"item active\"><i class=\"home icon\"></i>Home</a>\n    <a routerLink=\"/about\"      [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"info icon\"></i>About Us</a>\n    <a routerLink=\"/prospects\"  [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"child icon\"></i>Prospective Players</a>\n    <div #teamDropdown class=\"ui dropdown item\">\n        <i class=\"user icon\"></i>Team<i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <div routerLink=\"/practice\"          [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"soccer icon\"></i>Practice</div>\n            <div routerLink=\"/tournaments/2017\"  [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"calendar icon\"></i>Tournaments</div>\n            <div routerLink=\"/roster/2017\"       [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"ordered list icon\"></i>Roster</div>\n            <div routerLink=\"/absent\"            [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"remove icon\"></i>Absent Form</div>\n        </div>\n    </div>\n    <div #historyDropdown class=\"ui dropdown item\">\n        <i class=\"fast backward icon\"></i>History<i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <div routerLink=\"/history/2016\" [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"undo icon\"></i>Team History</div>\n            <div routerLink=\"/awards\"       [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"trophy icon\"></i>Awards</div>\n            <div routerLink=\"/results\"      [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"archive icon\"></i>Past Results</div>\n        </div>\n    </div>\n    <a href=\"http://www.illiniulti.blogspot.com/\" target=\"_blank\" class=\"item\"><i class=\"comment icon\"></i>Blog</a>\n    <a routerLink=\"/contact\" [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"mail icon\"></i>Contact Us</a>\n</div>";

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/crest.png";

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(156);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".header {\n  width: 100%;\n  background-image: url(" + __webpack_require__(157) + ");\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.header .header-text {\n  font-size: 72px;\n  font-family: 'Oswald', sans-serif;\n  color: #ff6226;\n  text-transform: uppercase;\n  padding: 25px;\n  margin: 0;\n  letter-spacing: 2px;\n  text-shadow: -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white, 1px 1px 0 white;\n}\n.header .crest {\n  max-height: 80px;\n  max-width: 50px;\n}\n.ui.menu {\n  margin-top: 0;\n  justify-content: center;\n  margin-bottom: 20px;\n}\n", ""]);
	
	// exports


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/header-background.jpg";

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var MenuMobileComponent = (function () {
	    function MenuMobileComponent() {
	    }
	    /**
	     * Initialize our mobile menu dropdown.
	     */
	    MenuMobileComponent.prototype.ngAfterViewInit = function () {
	        // $(this.teamDropdown.nativeElement).dropdown({});
	        // $(this.historyDropdown.nativeElement).dropdown({});
	        $(this.mobileDropdown.nativeElement).dropdown({});
	    };
	    return MenuMobileComponent;
	}());
	__decorate([
	    core_1.ViewChild('teamDropdown'),
	    __metadata("design:type", typeof (_a = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _a || Object)
	], MenuMobileComponent.prototype, "teamDropdown", void 0);
	__decorate([
	    core_1.ViewChild('historyDropdown'),
	    __metadata("design:type", typeof (_b = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _b || Object)
	], MenuMobileComponent.prototype, "historyDropdown", void 0);
	__decorate([
	    core_1.ViewChild('mobileDropdown'),
	    __metadata("design:type", typeof (_c = typeof core_1.ElementRef !== "undefined" && core_1.ElementRef) === "function" && _c || Object)
	], MenuMobileComponent.prototype, "mobileDropdown", void 0);
	MenuMobileComponent = __decorate([
	    core_1.Component({
	        selector: 'menu-mobile',
	        template: __webpack_require__(159),
	        styles: [__webpack_require__(160)]
	    }),
	    __metadata("design:paramtypes", [])
	], MenuMobileComponent);
	exports.MenuMobileComponent = MenuMobileComponent;
	var _a, _b, _c;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(130)))

/***/ }),
/* 159 */
/***/ (function(module, exports) {

	module.exports = "<div class=\"header\">\n    <div #mobileDropdown class=\"ui inline dropdown\">\n        <h1 class=\"header-text\">Illinois Ultimate</h1>\n        <i class=\"dropdown icon\"></i>\n        <div class=\"menu\">\n            <a routerLink=\"/home\"               [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"home icon\"></i>Home</a>\n            <a routerLink=\"/about\"              [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"info icon\"></i>About Us</a>\n            <a routerLink=\"/prospects\"          [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"child icon\"></i>Prospective Players</a>\n            <a routerLink=\"/practice\"           [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"soccer icon\"></i>Practice</a>\n            <a routerLink=\"/tournaments/2017\"   [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"calendar icon\"></i>Tournaments</a>\n            <a routerLink=\"/roster/2017\"        [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"ordered list icon\"></i>Roster</a>\n            <a routerLink=\"/absent\"             [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"remove icon\"></i>Absent Form</a>\n            <a routerLink=\"/history/2016\"       [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"undo icon\"></i>Team History</a>\n            <a routerLink=\"/awards\"             [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"trophy icon\"></i>Awards</a>\n            <a routerLink=\"/results\"            [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"archive icon\"></i>Past Results</a>\n            <a routerLink=\"/blog\"               [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"comment icon\"></i>Blog</a>\n            <a routerLink=\"/contact\"            [routerLinkActive]=\"['active']\" class=\"item\"><i class=\"mail icon\"></i>Contact Us</a>\n        </div>\n    </div>\n</div>";

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(161);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".header {\n  width: 100%;\n  background-image: url(" + __webpack_require__(157) + ");\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-bottom: 20px;\n}\n.header .ui.dropdown {\n  text-align: center;\n}\n.header .header-text {\n  font-size: 72px;\n  font-family: 'Oswald', sans-serif;\n  color: #ff6226;\n  text-transform: uppercase;\n  padding: 10px;\n  margin: 0;\n  letter-spacing: 2px;\n  text-shadow: -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white, 1px 1px 0 white;\n}\n.header .dropdown.icon {\n  font-size: 20px;\n  color: white;\n}\n.header .menu {\n  width: 100%;\n}\n", ""]);
	
	// exports


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var LeftSidebarComponent = (function () {
	    function LeftSidebarComponent() {
	    }
	    LeftSidebarComponent.prototype.ngAfterViewInit = function () {
	        this.initializeTwitterWidget();
	    };
	    /**
	     * Twitter script for initializing our Twitter Timeline widget
	     */
	    LeftSidebarComponent.prototype.initializeTwitterWidget = function () {
	        !function (d, s, id) {
	            var js, fjs = d.getElementsByTagName(s)[0], p = 'https';
	            if (!d.getElementById(id)) {
	                js = d.createElement(s);
	                js.id = id;
	                js.src = p + "://platform.twitter.com/widgets.js";
	                fjs.parentNode.insertBefore(js, fjs);
	            }
	        }(document, "script", "twitter-wjs");
	    };
	    return LeftSidebarComponent;
	}());
	LeftSidebarComponent = __decorate([
	    core_1.Component({
	        selector: 'left-sidebar',
	        template: __webpack_require__(163),
	        styles: [__webpack_require__(164)]
	    }),
	    __metadata("design:paramtypes", [])
	], LeftSidebarComponent);
	exports.LeftSidebarComponent = LeftSidebarComponent;


/***/ }),
/* 163 */
/***/ (function(module, exports) {

	module.exports = "<div class=\"ui segment twitter-sidebar\">\n    <a class=\"twitter-timeline\" height=\"500px\" href=\"https://twitter.com/IlliniUlti\" data-widget-id=\"605414836369883136\">Tweets by @IlliniUlti</a>\n</div>";

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(165);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".twitter-sidebar {\n  padding: 0;\n  max-width: 200px;\n  margin-left: auto;\n  margin-right: auto;\n}\n", ""]);
	
	// exports


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var RightSidebarComponent = (function () {
	    function RightSidebarComponent() {
	    }
	    RightSidebarComponent.prototype.ngOnInit = function () { };
	    return RightSidebarComponent;
	}());
	RightSidebarComponent = __decorate([
	    core_1.Component({
	        selector: 'right-sidebar',
	        template: __webpack_require__(167),
	        styles: [__webpack_require__(171)]
	    }),
	    __metadata("design:paramtypes", [])
	], RightSidebarComponent);
	exports.RightSidebarComponent = RightSidebarComponent;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = "<div class=\"ui segment paypal-sidebar\">\n    <h2 class=\"ui header\">Help Out Illinois Ultimate!</h2>\n\n    <p>Illinois Ultimate is mostly student-funded, help us out by donating!</p>\n    <a href=\"https://www.paypal.me/illinoisUltimate\" target=\"_blank\">\n        <img class=\"paypal-donate\" src=\"" + __webpack_require__(168) + "\"/>\n    </a>\n</div>\n<a href=\"https://www.facebook.com/IllinoisUltimate\" target=\"_blank\">\n    <img class=\"social-media-button hvr-sink\" src=\"" + __webpack_require__(169) + "\"/>\n</a>\n<a href=\"https://twitter.com/illiniulti\" target=\"_blank\">\n    <img class=\"social-media-button hvr-sink\" src=\"" + __webpack_require__(170) + "\"/>\n</a>";

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/paypal-donate.png";

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/facebook-button.png";

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "assets/twitter-button.png";

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(172);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".paypal-sidebar {\n  max-width: 200px;\n  margin-left: auto;\n  margin-right: auto;\n}\n.paypal-sidebar p {\n  text-indent: 0;\n  margin-bottom: 0;\n  padding-top: 15px;\n  padding-bottom: 15px;\n}\n.paypal-donate {\n  width: 100px;\n}\n.ui.header {\n  margin-bottom: 0;\n}\n.social-media-button {\n  width: 40%;\n  max-width: 70px;\n  display: inline-block;\n  margin: 3px;\n  border: 1px solid #00004D;\n  box-shadow: 0px 1px 2px 0 rgba(34, 36, 38, 0.15);\n  border-radius: 0.28571429em;\n}\n", ""]);
	
	// exports


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var PageFrameComponent = (function () {
	    function PageFrameComponent() {
	    }
	    PageFrameComponent.prototype.ngOnInit = function () { };
	    return PageFrameComponent;
	}());
	PageFrameComponent = __decorate([
	    core_1.Component({
	        selector: 'page-frame',
	        template: __webpack_require__(174),
	        styles: [__webpack_require__(175)]
	    }),
	    __metadata("design:paramtypes", [])
	], PageFrameComponent);
	exports.PageFrameComponent = PageFrameComponent;


/***/ }),
/* 174 */
/***/ (function(module, exports) {

	module.exports = "<!--Header-->\n<menu-desktop class=\"menu-desktop\"></menu-desktop>\n<menu-mobile class=\"menu-mobile\"></menu-mobile>\n\n<!--Content-->\n<div class=\"main-container\">\n    <div class=\"left-sidebar\">\n        <left-sidebar></left-sidebar>\n    </div>\n    <div class=\"main-content\">\n        <router-outlet></router-outlet>\n    </div>\n    <div class=\"right-sidebar\">\n        <right-sidebar></right-sidebar>\n    </div>\n    <footer></footer>\n</div>";

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(176);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".menu-desktop,\n.left-sidebar,\n.right-sidebar {\n  display: none;\n}\n.main-container {\n  margin-bottom: 50px;\n}\n@media screen and (min-width: 768px) {\n  .main-container {\n    display: flex;\n  }\n  .menu-mobile {\n    display: none;\n  }\n  .menu-desktop,\n  .left-sidebar,\n  .right-sidebar {\n    display: block;\n  }\n  .main-content {\n    padding: 0 10px;\n    width: 100%;\n  }\n  .left-sidebar {\n    margin-left: 10px;\n    flex: 0 0 200px;\n  }\n  .right-sidebar {\n    margin-right: 10px;\n    margin-left: auto;\n    flex: 0 0 150px;\n  }\n}\n@media screen and (min-width: 1024px) {\n  .main-content {\n    padding: 0 30px;\n  }\n  .left-sidebar {\n    margin-left: 50px;\n  }\n  .right-sidebar {\n    margin-right: 50px;\n    flex: 0 0 200px;\n  }\n}\n@media screen and (min-width: 1280px) {\n  .main-content {\n    padding: 0 50px;\n  }\n  .left-sidebar {\n    margin-left: 80px;\n  }\n  .right-sidebar {\n    margin-right: 80px;\n  }\n}\n", ""]);
	
	// exports


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(7);
	var FooterComponent = (function () {
	    function FooterComponent() {
	    }
	    FooterComponent.prototype.ngAfterViewInit = function () { };
	    return FooterComponent;
	}());
	FooterComponent = __decorate([
	    core_1.Component({
	        selector: 'footer',
	        template: __webpack_require__(178),
	        styles: [__webpack_require__(179)]
	    }),
	    __metadata("design:paramtypes", [])
	], FooterComponent);
	exports.FooterComponent = FooterComponent;


/***/ }),
/* 178 */
/***/ (function(module, exports) {

	module.exports = "<div class=\"ui menu\">\n    <p>For support or to report website issues, email the admin at wcjphoenix@gmail.com or the creator at nick.prozorovsky@gmail.com</p>\n</div>";

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	// css-to-string-loader: transforms styles from css-loader to a string output
	
	// Get the styles
	var styles = __webpack_require__(180);
	
	if (typeof styles === 'string') {
	  // Return an existing string
	  module.exports = styles;
	} else {
	  // Call the custom toString method from css-loader module
	  module.exports = styles.toString();
	}

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(38)();
	// imports
	
	
	// module
	exports.push([module.id, ".ui.menu {\n  position: fixed;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  display: flex;\n  align-items: center;\n}\np {\n  margin: 0 auto;\n  font-size: 10px;\n}\n@media screen and (min-width: 768px) {\n  p {\n    font-size: 12px;\n  }\n}\n", ""]);
	
	// exports


/***/ })
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5tb2R1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2hvbWUvaG9tZS5qcGciLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmxlc3M/NzIzNiIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hvbWUvaG9tZS5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvYWJvdXQvYWJvdXQuY29tcG9uZW50Lmxlc3M/YWFlNSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2Fib3V0L2Fib3V0LmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcHJvc3BlY3RpdmUtcGxheWVycy9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3NlcnZpY2UvZ29vZ2xlLXNwcmVhZHNoZWV0LnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50Lmxlc3M/MmI1MSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3Byb3NwZWN0aXZlLXBsYXllcnMvcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50Lmxlc3M/MTc2YyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9zaGFyZWQtc3R5bGUvc3R5bGVzLmNzcz9jOTY1Iiwid2VicGFjazovLy8uL3NyYy9hcHAvc2hhcmVkLXN0eWxlL3N0eWxlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2dsb2JhbC9iYWNrZ3JvdW5kLmpwZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2FwcC5jb21wb25lbnQubGVzcz9jNjA3Iiwid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90ZWFtLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9tYXBzLWFwaS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL2NpcmNsZS1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9tYXJrZXItbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFuYWdlcnMvcG9seWdvbi1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9rbWwtbGF5ZXItbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWNpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWluZm8td2luZG93LmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAta21sLWxheWVyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtbWFya2VyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbGF6eS1tYXBzLWFwaS1sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3V0aWxzL2Jyb3dzZXItZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL25vb3AtbWFwcy1hcGktbG9hZGVyLmpzIiwid2VicGFjazovLy8uL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9jb3JlLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcHJhY3RpY2UvcHJhY3RpY2UuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9kYXRhL3ByYWN0aWNlLmRhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC90ZWFtL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9wcmFjdGljZS5jb21wb25lbnQubGVzcz84NzlhIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9wcmFjdGljZS9wcmFjdGljZS5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vdG91cm5hbWVudHMvdG91cm5hbWVudHMuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy9kYXRhL3RvdXJuYW1lbnRzLmRhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC90ZWFtL3RvdXJuYW1lbnRzL3RvdXJuYW1lbnRzLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzcz85MmI0Iiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9kYXRhL3Jvc3RlcnMuZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQubGVzcz8zYmIwIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9yb3N0ZXIvcm9zdGVyLmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQubGVzcz83ZjlhIiwid2VicGFjazovLy8uL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvYXBwLnJvdXRlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hpc3RvcnkvdGVhbS1oaXN0b3J5L3RlYW0taGlzdG9yeS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L3RlYW0taGlzdG9yeS9kYXRhL2hpc3RvcnkteWVhci5kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5sZXNzPzZjODUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L3RlYW0taGlzdG9yeS90ZWFtLWhpc3RvcnkuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L2F3YXJkcy9hd2FyZHMuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvZGF0YS9hd2FyZHMuZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQubGVzcz9hMTIwIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvYXdhcmRzLmNvbXBvbmVudC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL2RhdGEvcmVzdWx0cy5kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L3Jlc3VsdHMvcmVzdWx0cy5jb21wb25lbnQubGVzcz85MjhjIiwid2VicGFjazovLy8uL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9oaXN0b3J5L2hpc3RvcnkubW9kdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9wYWdlLWZyYW1lLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1kZXNrdG9wL21lbnUtZGVza3RvcC5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbWVudS9jcmVzdC5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50Lmxlc3M/ODhkOCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1kZXNrdG9wL21lbnUtZGVza3RvcC5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9tZW51L2hlYWRlci1iYWNrZ3JvdW5kLmpwZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9tZW51LW1vYmlsZS9tZW51LW1vYmlsZS5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3M/ODczNSIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5odG1sIiwid2VicGFjazovLy8uL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzP2QzMTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zcmMvcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvcGF5cGFsLWRvbmF0ZS5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL2ZhY2Vib29rLWJ1dHRvbi5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL3R3aXR0ZXItYnV0dG9uLnBuZyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcmlnaHQtc2lkZWJhci9yaWdodC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzP2UxNjQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3JpZ2h0LXNpZGViYXIvcmlnaHQtc2lkZWJhci5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmxlc3M/M2FkMCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvZm9vdGVyL2Zvb3Rlci5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9wYWdlLWZyYW1lL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50Lmxlc3M/Y2I2MCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3BhZ2UtZnJhbWUvZm9vdGVyL2Zvb3Rlci5jb21wb25lbnQubGVzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLHlEQUEyRTtBQUMzRSxxQ0FBK0M7QUFFL0MsNENBQTZDO0FBQzdDOztHQUVFO0FBRUYsc0ZBQXFGO0FBQ3JGLEdBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDN0IscUJBQWMsRUFBRSxDQUFDO0FBQ3JCLEVBQUM7QUFDRCxhQUFZO0FBQ1osa0RBQXNCLEVBQUUsQ0FBQyxlQUFlLENBQUMsc0JBQVMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2JwRCxxQ0FBeUM7QUFDekMsd0NBQXlFO0FBQ3pFLGtEQUEyRDtBQUMzRCxzQ0FBMkM7QUFDM0MsdUNBQTZDO0FBRzdDLGdEQUFzRDtBQUN0RCxpREFBeUQ7QUFDekQsK0RBQWtHO0FBQ2xHLG1EQUErRDtBQUMvRCwrQ0FB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R0FBeUIsQ0FBQztTQUM1QyxNQUFNLEVBQUUsQ0FBQyxtQkFBTyxDQUFDLEdBQXlCLENBQUMsQ0FBQztNQUMvQyxDQUFDOztvQkFLRDtBQUhZLDBDQUFlOzs7Ozs7O0FDUjVCLDhMOzs7Ozs7QUNBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0EsRTs7Ozs7O0FDWEE7QUFDQTs7O0FBR0E7QUFDQSxxQ0FBb0Msb0JBQW9CLGFBQWEsY0FBYyxZQUFZLGtCQUFrQix3QkFBd0IsR0FBRyxLQUFLLG1CQUFtQixvQkFBb0IsR0FBRyx3Q0FBd0MsT0FBTyxzQkFBc0IsS0FBSyxHQUFHOztBQUV4USIsImZpbGUiOiJhcHAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbmltcG9ydCB7IGVuYWJsZVByb2RNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFwcE1vZHVsZSB9IGZyb20gJy4vYXBwL2FwcC5tb2R1bGUnO1xuLypcbiBPdXIgYXBwbGljYXRpb24gY29kZVxuKi9cblxuLy8gVHVybnMgb2ZmIGFzc2VydGlvbnMgYW5kIG90aGVyIGNoZWNrcyB3aXRoaW4gdGhlIGZyYW1ld29yayBpZiB3ZSBhcmUgaW4gcHJvZHVjdGlvblxuaWYgKHByb2Nlc3MuZW52LkVOViA9PT0gJ3Byb2QnKSB7XG4gICAgZW5hYmxlUHJvZE1vZGUoKTtcbn1cbi8vIEJvb3RzdHJhcFxucGxhdGZvcm1Ccm93c2VyRHluYW1pYygpLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvbWFpbi50cyIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIYXNoTG9jYXRpb25TdHJhdGVneSwgTG9jYXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gIGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgSHR0cE1vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9odHRwXCI7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuaW1wb3J0IHsgQWdtQ29yZU1vZHVsZSB9IGZyb20gJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuXG5pbXBvcnQgeyBIb21lQ29tcG9uZW50IH0gZnJvbSBcIi4vaG9tZS9ob21lLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgQWJvdXRDb21wb25lbnQgfSBmcm9tIFwiLi9hYm91dC9hYm91dC5jb21wb25lbnRcIjtcbmltcG9ydCB7IFByb3NwZWN0aXZlUGxheWVyc0NvbXBvbmVudCB9IGZyb20gXCIuL3Byb3NwZWN0aXZlLXBsYXllcnMvcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnRcIjtcbmltcG9ydCB7IENvbnRhY3RDb21wb25lbnQgfSBmcm9tIFwiLi9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBUZWFtTW9kdWxlIH0gZnJvbSBcIi4vdGVhbS90ZWFtLm1vZHVsZVwiO1xuaW1wb3J0IHsgSGlzdG9yeU1vZHVsZSB9IGZyb20gXCIuL2hpc3RvcnkvaGlzdG9yeS5tb2R1bGVcIjtcbmltcG9ydCB7IFBhZ2VGcmFtZU1vZHVsZSB9IGZyb20gXCIuL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5tb2R1bGVcIjtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIEJyb3dzZXJNb2R1bGUsXG4gICAgICAgIEh0dHBNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICAvLyBBZ21Db3JlTW9kdWxlLmZvclJvb3Qoe1xuICAgICAgICAvLyAgICAgYXBpS2V5OiAnQUl6YVN5QlJJWEFrNXhkdm4zZXp5cHNTZTU1ZjhkWmhjSGhlQVo4J1xuICAgICAgICAvLyB9KSxcbiAgICAgICAgUGFnZUZyYW1lTW9kdWxlLFxuICAgICAgICBUZWFtTW9kdWxlLFxuICAgICAgICBIaXN0b3J5TW9kdWxlXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQXBwQ29tcG9uZW50LFxuICAgICAgICBIb21lQ29tcG9uZW50LFxuICAgICAgICBBYm91dENvbXBvbmVudCxcbiAgICAgICAgUHJvc3BlY3RpdmVQbGF5ZXJzQ29tcG9uZW50LFxuICAgICAgICBDb250YWN0Q29tcG9uZW50XG4gICAgXSxcbiAgICAvLyBVc2UgaGFzaCBzdHJhdGVneSBzbyBwYWdlIHJlZnJlc2hlcyBvbiBHaXRodWIgcGFnZXMgcm91dGUgY29ycmVjdGx5XG4gICAgcHJvdmlkZXJzOiBbIHtwcm92aWRlOiBMb2NhdGlvblN0cmF0ZWd5LCB1c2VDbGFzczogSGFzaExvY2F0aW9uU3RyYXRlZ3l9IF0sXG4gICAgYm9vdHN0cmFwOiBbIEFwcENvbXBvbmVudCBdXG59KVxuZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2FwcC5tb2R1bGUudHMiLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjIuMi40XG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgncnhqcy9vcGVyYXRvci90b1Byb21pc2UnKSwgcmVxdWlyZSgncnhqcy9TdWJqZWN0JyksIHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpLCByZXF1aXJlKCdyeGpzL29ic2VydmFibGUvZnJvbVByb21pc2UnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvY29yZScsICdyeGpzL29wZXJhdG9yL3RvUHJvbWlzZScsICdyeGpzL1N1YmplY3QnLCAncnhqcy9PYnNlcnZhYmxlJywgJ3J4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZSddLCBmYWN0b3J5KSA6XG4gICAgKGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLmZvcm1zID0gZ2xvYmFsLm5nLmZvcm1zIHx8IHt9KSxnbG9iYWwubmcuY29yZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4LGdsb2JhbC5SeCxnbG9iYWwuUnguT2JzZXJ2YWJsZSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlLHJ4anNfb3BlcmF0b3JfdG9Qcm9taXNlLHJ4anNfU3ViamVjdCxyeGpzX09ic2VydmFibGUscnhqc19vYnNlcnZhYmxlX2Zyb21Qcm9taXNlKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBjb250cm9sIGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiBPbmx5IHVzZWQgaW50ZXJuYWxseSBpbiB0aGUgZm9ybXMgbW9kdWxlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCd1bmltcGxlbWVudGVkJyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC52YWx1ZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWxpZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC52YWxpZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpbnZhbGlkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmludmFsaWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGVuZGluZ1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5wZW5kaW5nIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImVycm9yc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5lcnJvcnMgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicHJpc3RpbmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wucHJpc3RpbmUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlydHlcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuZGlydHkgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG91Y2hlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC50b3VjaGVkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInVudG91Y2hlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC51bnRvdWNoZWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuZGlzYWJsZWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5lbmFibGVkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0YXR1c0NoYW5nZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuc3RhdHVzQ2hhbmdlcyA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wudmFsdWVDaGFuZ2VzIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sLnJlc2V0KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5oYXNFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuaGFzRXJyb3IoZXJyb3JDb2RlLCBwYXRoKSA6IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5nZXRFcnJvcihlcnJvckNvZGUsIHBhdGgpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZGlyZWN0aXZlIHRoYXQgY29udGFpbnMgbXVsdGlwbGUge0BsaW5rIE5nQ29udHJvbH1zLlxuICAgICAqXG4gICAgICogT25seSB1c2VkIGJ5IHRoZSBmb3JtcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbnRyb2xDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShDb250cm9sQ29udGFpbmVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDb250cm9sQ29udGFpbmVyKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xDb250YWluZXIucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGZvcm0gdG8gd2hpY2ggdGhpcyBjb250YWluZXIgYmVsb25ncy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xDb250YWluZXIucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHBhdGggdG8gdGhpcyBjb250YWluZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBDb250cm9sQ29udGFpbmVyO1xuICAgIH0oQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlKSk7XG5cbiAgICBmdW5jdGlvbiBpc1ByZXNlbnQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCbGFuayhvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PSBudWxsO1xuICAgIH1cbiAgICAvLyBKUyBoYXMgTmFOICE9PSBOYU5cbiAgICBmdW5jdGlvbiBsb29zZUlkZW50aWNhbChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiIHx8IHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicgJiYgaXNOYU4oYSkgJiYgaXNOYU4oYik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSnNPYmplY3Qobykge1xuICAgICAgICByZXR1cm4gbyAhPT0gbnVsbCAmJiAodHlwZW9mIG8gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG8gPT09ICdvYmplY3QnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgICAgIHJldHVybiAhaXNKc09iamVjdChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyYXBzIEphdmFzY3JpcHQgT2JqZWN0c1xuICAgICAqL1xuICAgIHZhciBTdHJpbmdNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nTWFwV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIG0gPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhtMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0xW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IE9iamVjdC5rZXlzKG0yKTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBtW2tdID0gbTJba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgICAgICB2YXIgazEgPSBPYmplY3Qua2V5cyhtMSk7XG4gICAgICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gazFbaV07XG4gICAgICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIHZhciBMaXN0V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIChsaXN0LCBpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihpdGVtc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoZWwpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbiAoZmxhdCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBmbGF0SXRlbSA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBMaXN0V3JhcHBlci5mbGF0dGVuKGl0ZW0pIDogaXRlbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdC5jb25jYXQoZmxhdEl0ZW0pO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBpc1Byb21pc2UgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uaXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gaXNFbXB0eUlucHV0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyBmb3IgdmFsaWRhdG9ycyB0byBiZSB1c2VkIGZvciB7QGxpbmsgRm9ybUNvbnRyb2x9cyBpbiBhIGZvcm0uXG4gICAgICpcbiAgICAgKiBQcm92aWRlIHRoaXMgdXNpbmcgYG11bHRpOiB0cnVlYCB0byBhZGQgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9mb3Jtcy90cy9uZ192YWxpZGF0b3JzL25nX3ZhbGlkYXRvcnMudHMgcmVnaW9uPSduZ192YWxpZGF0b3JzJ31cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5HX1ZBTElEQVRPUlMgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignTmdWYWxpZGF0b3JzJyk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXJzIGZvciBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0byBiZSB1c2VkIGZvciB7QGxpbmsgRm9ybUNvbnRyb2x9c1xuICAgICAqIGluIGEgZm9ybS5cbiAgICAgKlxuICAgICAqIFByb3ZpZGUgdGhpcyB1c2luZyBgbXVsdGk6IHRydWVgIHRvIGFkZCB2YWxpZGF0b3JzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBOR19WQUxJREFUT1JTfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOR19BU1lOQ19WQUxJREFUT1JTID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ05nQXN5bmNWYWxpZGF0b3JzJyk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBzZXQgb2YgdmFsaWRhdG9ycyB1c2VkIGJ5IGZvcm0gY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBBIHZhbGlkYXRvciBpcyBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEge0BsaW5rIEZvcm1Db250cm9sfSBvciBjb2xsZWN0aW9uIG9mXG4gICAgICogY29udHJvbHMgYW5kIHJldHVybnMgYSBtYXAgb2YgZXJyb3JzLiBBIG51bGwgbWFwIG1lYW5zIHRoYXQgdmFsaWRhdGlvbiBoYXMgcGFzc2VkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB2YXIgbG9naW5Db250cm9sID0gbmV3IEZvcm1Db250cm9sKFwiXCIsIFZhbGlkYXRvcnMucmVxdWlyZWQpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZhbGlkYXRvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWYWxpZGF0b3JzKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyBjb250cm9scyB0byBoYXZlIGEgbm9uLWVtcHR5IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5yZXF1aXJlZCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFbXB0eUlucHV0VmFsdWUoY29udHJvbC52YWx1ZSkgPyB7ICdyZXF1aXJlZCc6IHRydWUgfSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyBjb250cm9scyB0byBoYXZlIGEgdmFsdWUgb2YgYSBtaW5pbXVtIGxlbmd0aC5cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMubWluTGVuZ3RoID0gZnVuY3Rpb24gKG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHlJbnB1dFZhbHVlKGNvbnRyb2wudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCB2YWxpZGF0ZSBlbXB0eSB2YWx1ZXMgdG8gYWxsb3cgb3B0aW9uYWwgY29udHJvbHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHR5cGVvZiBjb250cm9sLnZhbHVlID09PSAnc3RyaW5nJyA/IGNvbnRyb2wudmFsdWUubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoIDwgbWluTGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICAgeyAnbWlubGVuZ3RoJzogeyAncmVxdWlyZWRMZW5ndGgnOiBtaW5MZW5ndGgsICdhY3R1YWxMZW5ndGgnOiBsZW5ndGggfSB9IDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyBjb250cm9scyB0byBoYXZlIGEgdmFsdWUgb2YgYSBtYXhpbXVtIGxlbmd0aC5cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMubWF4TGVuZ3RoID0gZnVuY3Rpb24gKG1heExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHR5cGVvZiBjb250cm9sLnZhbHVlID09PSAnc3RyaW5nJyA/IGNvbnRyb2wudmFsdWUubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoID4gbWF4TGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICAgeyAnbWF4bGVuZ3RoJzogeyAncmVxdWlyZWRMZW5ndGgnOiBtYXhMZW5ndGgsICdhY3R1YWxMZW5ndGgnOiBsZW5ndGggfSB9IDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyBhIGNvbnRyb2wgdG8gbWF0Y2ggYSByZWdleCB0byBpdHMgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLnBhdHRlcm4gPSBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuKVxuICAgICAgICAgICAgICAgIHJldHVybiBWYWxpZGF0b3JzLm51bGxWYWxpZGF0b3I7XG4gICAgICAgICAgICB2YXIgcmVnZXg7XG4gICAgICAgICAgICB2YXIgcmVnZXhTdHI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVnZXhTdHIgPSBcIl5cIiArIHBhdHRlcm4gKyBcIiRcIjtcbiAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhTdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVnZXhTdHIgPSBwYXR0ZXJuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmVnZXggPSBwYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHlJbnB1dFZhbHVlKGNvbnRyb2wudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCB2YWxpZGF0ZSBlbXB0eSB2YWx1ZXMgdG8gYWxsb3cgb3B0aW9uYWwgY29udHJvbHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXgudGVzdCh2YWx1ZSkgPyBudWxsIDpcbiAgICAgICAgICAgICAgICAgICAgeyAncGF0dGVybic6IHsgJ3JlcXVpcmVkUGF0dGVybic6IHJlZ2V4U3RyLCAnYWN0dWFsVmFsdWUnOiB2YWx1ZSB9IH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTm8tb3AgdmFsaWRhdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5udWxsVmFsaWRhdG9yID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb3NlIG11bHRpcGxlIHZhbGlkYXRvcnMgaW50byBhIHNpbmdsZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHVuaW9uXG4gICAgICAgICAqIG9mIHRoZSBpbmRpdmlkdWFsIGVycm9yIG1hcHMuXG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLmNvbXBvc2UgPSBmdW5jdGlvbiAodmFsaWRhdG9ycykge1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0b3JzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHByZXNlbnRWYWxpZGF0b3JzID0gdmFsaWRhdG9ycy5maWx0ZXIoaXNQcmVzZW50KTtcbiAgICAgICAgICAgIGlmIChwcmVzZW50VmFsaWRhdG9ycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbWVyZ2VFcnJvcnMoX2V4ZWN1dGVWYWxpZGF0b3JzKGNvbnRyb2wsIHByZXNlbnRWYWxpZGF0b3JzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyA9IGZ1bmN0aW9uICh2YWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRvcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgcHJlc2VudFZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzLmZpbHRlcihpc1ByZXNlbnQpO1xuICAgICAgICAgICAgaWYgKHByZXNlbnRWYWxpZGF0b3JzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gX2V4ZWN1dGVBc3luY1ZhbGlkYXRvcnMoY29udHJvbCwgcHJlc2VudFZhbGlkYXRvcnMpLm1hcChfY29udmVydFRvUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKF9tZXJnZUVycm9ycyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVmFsaWRhdG9ycztcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9jb252ZXJ0VG9Qcm9taXNlKG9iaikge1xuICAgICAgICByZXR1cm4gaXNQcm9taXNlKG9iaikgPyBvYmogOiByeGpzX29wZXJhdG9yX3RvUHJvbWlzZS50b1Byb21pc2UuY2FsbChvYmopO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZXhlY3V0ZVZhbGlkYXRvcnMoY29udHJvbCwgdmFsaWRhdG9ycykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9ycy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYoY29udHJvbCk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZXhlY3V0ZUFzeW5jVmFsaWRhdG9ycyhjb250cm9sLCB2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdihjb250cm9sKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9tZXJnZUVycm9ycyhhcnJheU9mRXJyb3JzKSB7XG4gICAgICAgIHZhciByZXMgPSBhcnJheU9mRXJyb3JzLnJlZHVjZShmdW5jdGlvbiAocmVzLCBlcnJvcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQoZXJyb3JzKSA/IFN0cmluZ01hcFdyYXBwZXIubWVyZ2UocmVzLCBlcnJvcnMpIDogcmVzO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXMpLmxlbmd0aCA9PT0gMCA/IG51bGwgOiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBwcm92aWRlIGEge0BsaW5rIENvbnRyb2xWYWx1ZUFjY2Vzc29yfSBmb3IgZm9ybSBjb250cm9scy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgRGVmYXVsdFZhbHVlQWNjZXNzb3J9IGZvciBob3cgdG8gaW1wbGVtZW50IG9uZS5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5HX1ZBTFVFX0FDQ0VTU09SID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ05nVmFsdWVBY2Nlc3NvcicpO1xuXG4gICAgdmFyIENIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gYSBjaGVja2JveCBpbnB1dCBlbGVtZW50LlxuICAgICAqXG4gICAgICogICMjIyBFeGFtcGxlXG4gICAgICogIGBgYFxuICAgICAqICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmFtZT1cInJlbWVtYmVyTG9naW5cIiBuZ01vZGVsPlxuICAgICAqICBgYGBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnY2hlY2tlZCcsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9Y2hlY2tib3hdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1jaGVja2JveF1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9Y2hlY2tib3hdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQuY2hlY2tlZCknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIERFRkFVTFRfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERlZmF1bHRWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGFjY2Vzc29yIGZvciB3cml0aW5nIGEgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIHRoYXQgaXMgdXNlZCBieSB0aGVcbiAgICAgKiB7QGxpbmsgTmdNb2RlbH0sIHtAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7QGxpbmsgRm9ybUNvbnRyb2xOYW1lfSBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogICMjIyBFeGFtcGxlXG4gICAgICogIGBgYFxuICAgICAqICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwic2VhcmNoUXVlcnlcIiBuZ01vZGVsPlxuICAgICAqICBgYGBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIERlZmF1bHRWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCBub3JtYWxpemVkVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW2Zvcm1Db250cm9sTmFtZV0sdGV4dGFyZWFbZm9ybUNvbnRyb2xOYW1lXSxpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtmb3JtQ29udHJvbF0sdGV4dGFyZWFbZm9ybUNvbnRyb2xdLGlucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW25nTW9kZWxdLHRleHRhcmVhW25nTW9kZWxdLFtuZ0RlZmF1bHRDb250cm9sXScsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB2c2F2a2luIHJlcGxhY2UgdGhlIGFib3ZlIHNlbGVjdG9yIHdpdGggdGhlIG9uZSBiZWxvdyBpdCBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMDExIGlzIGltcGxlbWVudGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3RvcjogJ1tuZ0NvbnRyb2xdLFtuZ01vZGVsXSxbbmdGb3JtQ29udHJvbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGlucHV0KSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtERUZBVUxUX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBEZWZhdWx0VmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRvci52YWxpZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiB2YWxpZGF0b3IudmFsaWRhdGUoYyk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUFzeW5jVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgICAgICBpZiAodmFsaWRhdG9yLnZhbGlkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHZhbGlkYXRvci52YWxpZGF0ZShjKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgTlVNQkVSX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOdW1iZXJWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIG51bWJlciB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgdGhhdCBpcyB1c2VkIGJ5IHRoZVxuICAgICAqIHtAbGluayBOZ01vZGVsfSwge0BsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfSwgYW5kIHtAbGluayBGb3JtQ29udHJvbE5hbWV9IGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgKiAgYGBgXG4gICAgICogIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgWyhuZ01vZGVsKV09XCJhZ2VcIj5cbiAgICAgKiAgYGBgXG4gICAgICovXG4gICAgdmFyIE51bWJlclZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOdW1iZXJWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgbmVlZHMgdG8gYmUgbm9ybWFsaXplZCBmb3IgSUU5LCBvdGhlcndpc2UgaXQgaXMgc2V0IHRvICdudWxsJyB3aGVuIG51bGxcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHsgZm4odmFsdWUgPT0gJycgPyBudWxsIDogcGFyc2VGbG9hdCh2YWx1ZSkpOyB9O1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPW51bWJlcl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPW51bWJlcl1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9bnVtYmVyXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGlucHV0KSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdvblRvdWNoZWQoKSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtOVU1CRVJfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTnVtYmVyVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVuaW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGJhc2UgY2xhc3MgdGhhdCBhbGwgY29udHJvbCBkaXJlY3RpdmUgZXh0ZW5kLlxuICAgICAqIEl0IGJpbmRzIGEge0BsaW5rIEZvcm1Db250cm9sfSBvYmplY3QgdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFVzZWQgaW50ZXJuYWxseSBieSBBbmd1bGFyIGZvcm1zLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0NvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMihOZ0NvbnRyb2wsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nQ29udHJvbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IFtdO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbC5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbC5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gTmdDb250cm9sO1xuICAgIH0oQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlKSk7XG5cbiAgICB2YXIgUkFESU9fVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY2xhc3MgdXNlZCBieSBBbmd1bGFyIHRvIHVuY2hlY2sgcmFkaW8gYnV0dG9ucyB3aXRoIHRoZSBtYXRjaGluZyBuYW1lLlxuICAgICAqL1xuICAgIHZhciBSYWRpb0NvbnRyb2xSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJhZGlvQ29udHJvbFJlZ2lzdHJ5KCkge1xuICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjb250cm9sLCBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzLnB1c2goW2NvbnRyb2wsIGFjY2Vzc29yXSk7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9hY2Nlc3NvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWNjZXNzb3JzW2ldWzFdID09PSBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY2Nlc3NvcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGFjY2Vzc29yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzU2FtZUdyb3VwKGMsIGFjY2Vzc29yKSAmJiBjWzFdICE9PSBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgICAgICBjWzFdLmZpcmVVbmNoZWNrKGFjY2Vzc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkucHJvdG90eXBlLl9pc1NhbWVHcm91cCA9IGZ1bmN0aW9uIChjb250cm9sUGFpciwgYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIGlmICghY29udHJvbFBhaXJbMF0uY29udHJvbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbFBhaXJbMF0uX3BhcmVudCA9PT0gYWNjZXNzb3IuX2NvbnRyb2wuX3BhcmVudCAmJlxuICAgICAgICAgICAgICAgIGNvbnRyb2xQYWlyWzFdLm5hbWUgPT09IGFjY2Vzc29yLm5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFJhZGlvQ29udHJvbFJlZ2lzdHJ5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgIFdyaXRlcyByYWRpbyBjb250cm9sIHZhbHVlcyBhbmQgbGlzdGVucyB0byByYWRpbyBjb250cm9sIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IHtAbGluayBOZ01vZGVsfSwge0BsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfSwgYW5kIHtAbGluayBGb3JtQ29udHJvbE5hbWV9XG4gICAgICogdG8ga2VlcCB0aGUgdmlldyBzeW5jZWQgd2l0aCB0aGUge0BsaW5rIEZvcm1Db250cm9sfSBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogSWYgeW91IGhhdmUgaW1wb3J0ZWQgdGhlIHtAbGluayBGb3Jtc01vZHVsZX0gb3IgdGhlIHtAbGluayBSZWFjdGl2ZUZvcm1zTW9kdWxlfSwgdGhpc1xuICAgICAqIHZhbHVlIGFjY2Vzc29yIHdpbGwgYmUgYWN0aXZlIG9uIGFueSByYWRpbyBjb250cm9sIHRoYXQgaGFzIGEgZm9ybSBkaXJlY3RpdmUuIFlvdSBkb1xuICAgICAqICoqbm90KiogbmVlZCB0byBhZGQgYSBzcGVjaWFsIHNlbGVjdG9yIHRvIGFjdGl2YXRlIGl0LlxuICAgICAqXG4gICAgICogIyMjIEhvdyB0byB1c2UgcmFkaW8gYnV0dG9ucyB3aXRoIGZvcm0gZGlyZWN0aXZlc1xuICAgICAqXG4gICAgICogVG8gdXNlIHJhZGlvIGJ1dHRvbnMgaW4gYSB0ZW1wbGF0ZS1kcml2ZW4gZm9ybSwgeW91J2xsIHdhbnQgdG8gZW5zdXJlIHRoYXQgcmFkaW8gYnV0dG9uc1xuICAgICAqIGluIHRoZSBzYW1lIGdyb3VwIGhhdmUgdGhlIHNhbWUgYG5hbWVgIGF0dHJpYnV0ZS4gIFJhZGlvIGJ1dHRvbnMgd2l0aCBkaWZmZXJlbnQgYG5hbWVgXG4gICAgICogYXR0cmlidXRlcyBkbyBub3QgYWZmZWN0IGVhY2ggb3RoZXIuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvcmFkaW9CdXR0b25zL3JhZGlvX2J1dHRvbl9leGFtcGxlLnRzIHJlZ2lvbj0nVGVtcGxhdGVEcml2ZW4nfVxuICAgICAqXG4gICAgICogV2hlbiB1c2luZyByYWRpbyBidXR0b25zIGluIGEgcmVhY3RpdmUgZm9ybSwgcmFkaW8gYnV0dG9ucyBpbiB0aGUgc2FtZSBncm91cCBzaG91bGQgaGF2ZSB0aGVcbiAgICAgKiBzYW1lIGBmb3JtQ29udHJvbE5hbWVgLiBZb3UgY2FuIGFsc28gYWRkIGEgYG5hbWVgIGF0dHJpYnV0ZSwgYnV0IGl0J3Mgb3B0aW9uYWwuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvcmVhY3RpdmVSYWRpb0J1dHRvbnMvcmVhY3RpdmVfcmFkaW9fYnV0dG9uX2V4YW1wbGUudHMgcmVnaW9uPSdSZWFjdGl2ZSd9XG4gICAgICpcbiAgICAgKiAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYsIF9yZWdpc3RyeSwgX2luamVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdHJ5ID0gX3JlZ2lzdHJ5O1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sID0gdGhpcy5faW5qZWN0b3IuZ2V0KE5nQ29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLl9jaGVja05hbWUoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdHJ5LmFkZCh0aGlzLl9jb250cm9sLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3JlZ2lzdHJ5LnJlbW92ZSh0aGlzKTsgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB2YWx1ZSA9PT0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdjaGVja2VkJywgdGhpcy5fc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm4oX3RoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZWdpc3RyeS5zZWxlY3QoX3RoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuZmlyZVVuY2hlY2sgPSBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy53cml0ZVZhbHVlKHZhbHVlKTsgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2NoZWNrTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgJiYgdGhpcy5mb3JtQ29udHJvbE5hbWUgJiYgdGhpcy5uYW1lICE9PSB0aGlzLmZvcm1Db250cm9sTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93TmFtZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubmFtZSAmJiB0aGlzLmZvcm1Db250cm9sTmFtZSlcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmZvcm1Db250cm9sTmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX3Rocm93TmFtZUVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgSWYgeW91IGRlZmluZSBib3RoIGEgbmFtZSBhbmQgYSBmb3JtQ29udHJvbE5hbWUgYXR0cmlidXRlIG9uIHlvdXIgcmFkaW8gYnV0dG9uLCB0aGVpciB2YWx1ZXNcXG4gICAgICBtdXN0IG1hdGNoLiBFeDogPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBmb3JtQ29udHJvbE5hbWU9XFxcImZvb2RcXFwiIG5hbWU9XFxcImZvb2RcXFwiPlxcbiAgICBcIik7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9cmFkaW9dW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1yYWRpb11bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9cmFkaW9dW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUkFESU9fVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBSYWRpb0NvbnRyb2xSZWdpc3RyeSwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RvciwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICAgICAnZm9ybUNvbnRyb2xOYW1lJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIHZhciBSQU5HRV9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gUmFuZ2VWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIHJhbmdlIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyB0aGF0IGlzIHVzZWQgYnkgdGhlXG4gICAgICoge0BsaW5rIE5nTW9kZWx9LCB7QGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge0BsaW5rIEZvcm1Db250cm9sTmFtZX0gZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAqICBgYGBcbiAgICAgKiAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIFsobmdNb2RlbCldPVwiYWdlXCIgPlxuICAgICAqICBgYGBcbiAgICAgKi9cbiAgICB2YXIgUmFuZ2VWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmFuZ2VWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7IGZuKHZhbHVlID09ICcnID8gbnVsbCA6IHBhcnNlRmxvYXQodmFsdWUpKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIFJhbmdlVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1yYW5nZV1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPXJhbmdlXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1yYW5nZV1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUkFOR0VfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBSYW5nZVZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIHZhciBTRUxFQ1RfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9idWlsZFZhbHVlU3RyaW5nKGlkLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaWQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIGlmICghaXNQcmltaXRpdmUodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSAnT2JqZWN0JztcbiAgICAgICAgcmV0dXJuIChpZCArIFwiOiBcIiArIHZhbHVlKS5zbGljZSgwLCA1MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9leHRyYWN0SWQodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyaW5nLnNwbGl0KCc6JylbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFdyaXRlcyB2YWx1ZXMgYW5kIGxpc3RlbnMgdG8gY2hhbmdlcyBvbiBhIHNlbGVjdCBlbGVtZW50LlxuICAgICAqXG4gICAgICogVXNlZCBieSB7QGxpbmsgTmdNb2RlbH0sIHtAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7QGxpbmsgRm9ybUNvbnRyb2xOYW1lfVxuICAgICAqIHRvIGtlZXAgdGhlIHZpZXcgc3luY2VkIHdpdGggdGhlIHtAbGluayBGb3JtQ29udHJvbH0gbW9kZWwuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGltcG9ydGVkIHRoZSB7QGxpbmsgRm9ybXNNb2R1bGV9IG9yIHRoZSB7QGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX0sIHRoaXNcbiAgICAgKiB2YWx1ZSBhY2Nlc3NvciB3aWxsIGJlIGFjdGl2ZSBvbiBhbnkgc2VsZWN0IGNvbnRyb2wgdGhhdCBoYXMgYSBmb3JtIGRpcmVjdGl2ZS4gWW91IGRvXG4gICAgICogKipub3QqKiBuZWVkIHRvIGFkZCBhIHNwZWNpYWwgc2VsZWN0b3IgdG8gYWN0aXZhdGUgaXQuXG4gICAgICpcbiAgICAgKiAjIyMgSG93IHRvIHVzZSBzZWxlY3QgY29udHJvbHMgd2l0aCBmb3JtIGRpcmVjdGl2ZXNcbiAgICAgKlxuICAgICAqIFRvIHVzZSBhIHNlbGVjdCBpbiBhIHRlbXBsYXRlLWRyaXZlbiBmb3JtLCBzaW1wbHkgYWRkIGFuIGBuZ01vZGVsYCBhbmQgYSBgbmFtZWBcbiAgICAgKiBhdHRyaWJ1dGUgdG8gdGhlIG1haW4gYDxzZWxlY3Q+YCB0YWcuXG4gICAgICpcbiAgICAgKiBJZiB5b3VyIG9wdGlvbiB2YWx1ZXMgYXJlIHNpbXBsZSBzdHJpbmdzLCB5b3UgY2FuIGJpbmQgdG8gdGhlIG5vcm1hbCBgdmFsdWVgIHByb3BlcnR5XG4gICAgICogb24gdGhlIG9wdGlvbi4gIElmIHlvdXIgb3B0aW9uIHZhbHVlcyBoYXBwZW4gdG8gYmUgb2JqZWN0cyAoYW5kIHlvdSdkIGxpa2UgdG8gc2F2ZSB0aGVcbiAgICAgKiBzZWxlY3Rpb24gaW4geW91ciBmb3JtIGFzIGFuIG9iamVjdCksIHVzZSBgbmdWYWx1ZWAgaW5zdGVhZDpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zZWxlY3RDb250cm9sL3NlbGVjdF9jb250cm9sX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogSW4gcmVhY3RpdmUgZm9ybXMsIHlvdSdsbCBhbHNvIHdhbnQgdG8gYWRkIHlvdXIgZm9ybSBkaXJlY3RpdmUgKGBmb3JtQ29udHJvbE5hbWVgIG9yXG4gICAgICogYGZvcm1Db250cm9sYCkgb24gdGhlIG1haW4gYDxzZWxlY3Q+YCB0YWcuIExpa2UgaW4gdGhlIGZvcm1lciBleGFtcGxlLCB5b3UgaGF2ZSB0aGVcbiAgICAgKiBjaG9pY2Ugb2YgYmluZGluZyB0byB0aGUgIGB2YWx1ZWAgb3IgYG5nVmFsdWVgIHByb3BlcnR5IG9uIHRoZSBzZWxlY3QncyBvcHRpb25zLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3JlYWN0aXZlU2VsZWN0Q29udHJvbC9yZWFjdGl2ZV9zZWxlY3RfY29udHJvbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIE5vdGU6IFdlIGxpc3RlbiB0byB0aGUgJ2NoYW5nZScgZXZlbnQgYmVjYXVzZSAnaW5wdXQnIGV2ZW50cyBhcmVuJ3QgZmlyZWRcbiAgICAgKiBmb3Igc2VsZWN0cyBpbiBGaXJlZm94IGFuZCBJRTpcbiAgICAgKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDI0MzUwXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvNDY2MDA0NS9cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9pZENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlU3RyaW5nID0gX2J1aWxkVmFsdWVTdHJpbmcodGhpcy5fZ2V0T3B0aW9uSWQodmFsdWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZVN0cmluZyk7XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWVTdHJpbmc7XG4gICAgICAgICAgICAgICAgZm4oX3RoaXMuX2dldE9wdGlvblZhbHVlKHZhbHVlU3RyaW5nKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9yZWdpc3Rlck9wdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLl9pZENvdW50ZXIrKykudG9TdHJpbmcoKTsgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2dldE9wdGlvbklkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gQXJyYXkuZnJvbSh0aGlzLl9vcHRpb25NYXAua2V5cygpKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGxvb3NlSWRlbnRpY2FsKHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fZ2V0T3B0aW9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9leHRyYWN0SWQodmFsdWVTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbk1hcC5oYXMoaWQpID8gdGhpcy5fb3B0aW9uTWFwLmdldChpZCkgOiB2YWx1ZVN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3NlbGVjdDpub3QoW211bHRpcGxlXSlbZm9ybUNvbnRyb2xOYW1lXSxzZWxlY3Q6bm90KFttdWx0aXBsZV0pW2Zvcm1Db250cm9sXSxzZWxlY3Q6bm90KFttdWx0aXBsZV0pW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1NFTEVDVF9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBNYXJrcyBgPG9wdGlvbj5gIGFzIGR5bmFtaWMsIHNvIEFuZ3VsYXIgY2FuIGJlIG5vdGlmaWVkIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFNlZSBkb2NzIGZvciB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9IGZvciB1c2FnZSBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdTZWxlY3RPcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1NlbGVjdE9wdGlvbihfZWxlbWVudCwgX3JlbmRlcmVyLCBfc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdCA9IF9zZWxlY3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KVxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLl9zZWxlY3QuX3JlZ2lzdGVyT3B0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0T3B0aW9uLnByb3RvdHlwZSwgXCJuZ1ZhbHVlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0Ll9vcHRpb25NYXAuc2V0KHRoaXMuaWQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUoX2J1aWxkVmFsdWVTdHJpbmcodGhpcy5pZCwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1NlbGVjdE9wdGlvbi5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5wcm90b3R5cGUuX3NldEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0Ll9vcHRpb25NYXAuZGVsZXRlKHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ29wdGlvbicgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdTZWxlY3RPcHRpb24ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdWYWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdWYWx1ZScsXSB9LF0sXG4gICAgICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ3ZhbHVlJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nU2VsZWN0T3B0aW9uO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgU0VMRUNUX01VTFRJUExFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9idWlsZFZhbHVlU3RyaW5nJDEoaWQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpZCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICB2YWx1ZSA9IFwiJ1wiICsgdmFsdWUgKyBcIidcIjtcbiAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZSh2YWx1ZSkpXG4gICAgICAgICAgICB2YWx1ZSA9ICdPYmplY3QnO1xuICAgICAgICByZXR1cm4gKGlkICsgXCI6IFwiICsgdmFsdWUpLnNsaWNlKDAsIDUwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2V4dHJhY3RJZCQxKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVN0cmluZy5zcGxpdCgnOicpWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gYSBzZWxlY3QgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9pZENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gY29udmVydCB2YWx1ZXMgdG8gaWRzXG4gICAgICAgICAgICB2YXIgaWRzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMuX2dldE9wdGlvbklkKHYpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChvcHQsIG8pIHsgb3B0Ll9zZXRTZWxlY3RlZChpZHMuaW5kZXhPZihvLnRvU3RyaW5nKCkpID4gLTEpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChfLmhhc093blByb3BlcnR5KCdzZWxlY3RlZE9wdGlvbnMnKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF8uc2VsZWN0ZWRPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBvcHRpb25zLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX3RoaXMuX2dldE9wdGlvblZhbHVlKG9wdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gXy5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBvcHRpb25zLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF90aGlzLl9nZXRPcHRpb25WYWx1ZShvcHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbihzZWxlY3RlZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9yZWdpc3Rlck9wdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gKHRoaXMuX2lkQ291bnRlcisrKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFwLnNldChpZCwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25JZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IEFycmF5LmZyb20odGhpcy5fb3B0aW9uTWFwLmtleXMoKSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChsb29zZUlkZW50aWNhbCh0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKS5fdmFsdWUsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2dldE9wdGlvblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfZXh0cmFjdElkJDEodmFsdWVTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbk1hcC5oYXMoaWQpID8gdGhpcy5fb3B0aW9uTWFwLmdldChpZCkuX3ZhbHVlIDogdmFsdWVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3NlbGVjdFttdWx0aXBsZV1bZm9ybUNvbnRyb2xOYW1lXSxzZWxlY3RbbXVsdGlwbGVdW2Zvcm1Db250cm9sXSxzZWxlY3RbbXVsdGlwbGVdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1NFTEVDVF9NVUxUSVBMRV9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogTWFya3MgYDxvcHRpb24+YCBhcyBkeW5hbWljLCBzbyBBbmd1bGFyIGNhbiBiZSBub3RpZmllZCB3aGVuIG9wdGlvbnMgY2hhbmdlLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxzZWxlY3QgbXVsdGlwbGUgbmFtZT1cImNpdHlcIiBuZ01vZGVsPlxuICAgICAqICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgYyBvZiBjaXRpZXNcIiBbdmFsdWVdPVwiY1wiPjwvb3B0aW9uPlxuICAgICAqIDwvc2VsZWN0PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHZhciBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdTZWxlY3RNdWx0aXBsZU9wdGlvbihfZWxlbWVudCwgX3JlbmRlcmVyLCBfc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdCA9IF9zZWxlY3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLCBcIm5nVmFsdWVcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyQxKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyQxKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLl9zZXRFbGVtZW50VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLnByb3RvdHlwZS5fc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdzZWxlY3RlZCcsIHNlbGVjdGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0Ll9vcHRpb25NYXAuZGVsZXRlKHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnb3B0aW9uJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ1ZhbHVlJyxdIH0sXSxcbiAgICAgICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsndmFsdWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdTZWxlY3RNdWx0aXBsZU9wdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgZnVuY3Rpb24gY29udHJvbFBhdGgobmFtZSwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQucGF0aC5jb25jYXQoW25hbWVdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VXBDb250cm9sKGNvbnRyb2wsIGRpcikge1xuICAgICAgICBpZiAoIWNvbnRyb2wpXG4gICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdDYW5ub3QgZmluZCBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgaWYgKCFkaXIudmFsdWVBY2Nlc3NvcilcbiAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ05vIHZhbHVlIGFjY2Vzc29yIGZvciBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICBjb250cm9sLnZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbY29udHJvbC52YWxpZGF0b3IsIGRpci52YWxpZGF0b3JdKTtcbiAgICAgICAgY29udHJvbC5hc3luY1ZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKFtjb250cm9sLmFzeW5jVmFsaWRhdG9yLCBkaXIuYXN5bmNWYWxpZGF0b3JdKTtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZShjb250cm9sLnZhbHVlKTtcbiAgICAgICAgLy8gdmlldyAtPiBtb2RlbFxuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZGlyLnZpZXdUb01vZGVsVXBkYXRlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRyb2wubWFya0FzRGlydHkoKTtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0VmFsdWUobmV3VmFsdWUsIHsgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlOiBmYWxzZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRvdWNoZWRcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPblRvdWNoZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbC5tYXJrQXNUb3VjaGVkKCk7IH0pO1xuICAgICAgICBjb250cm9sLnJlZ2lzdGVyT25DaGFuZ2UoZnVuY3Rpb24gKG5ld1ZhbHVlLCBlbWl0TW9kZWxFdmVudCkge1xuICAgICAgICAgICAgLy8gY29udHJvbCAtPiB2aWV3XG4gICAgICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci53cml0ZVZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIC8vIGNvbnRyb2wgLT4gbmdNb2RlbFxuICAgICAgICAgICAgaWYgKGVtaXRNb2RlbEV2ZW50KVxuICAgICAgICAgICAgICAgIGRpci52aWV3VG9Nb2RlbFVwZGF0ZShuZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGlyLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSkge1xuICAgICAgICAgICAgY29udHJvbC5yZWdpc3Rlck9uRGlzYWJsZWRDaGFuZ2UoZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHsgZGlyLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmUtcnVuIHZhbGlkYXRpb24gd2hlbiB2YWxpZGF0b3IgYmluZGluZyBjaGFuZ2VzLCBlLmcuIG1pbmxlbmd0aD0zIC0+IG1pbmxlbmd0aD00XG4gICAgICAgIGRpci5fcmF3VmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSlcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkaXIuX3Jhd0FzeW5jVmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSlcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhblVwQ29udHJvbChjb250cm9sLCBkaXIpIHtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPbkNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBfbm9Db250cm9sRXJyb3IoZGlyKTsgfSk7XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25Ub3VjaGVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9ub0NvbnRyb2xFcnJvcihkaXIpOyB9KTtcbiAgICAgICAgZGlyLl9yYXdWYWxpZGF0b3JzLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkaXIuX3Jhd0FzeW5jVmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbnRyb2wpXG4gICAgICAgICAgICBjb250cm9sLl9jbGVhckNoYW5nZUZucygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRVcEZvcm1Db250YWluZXIoY29udHJvbCwgZGlyKSB7XG4gICAgICAgIGlmIChpc0JsYW5rKGNvbnRyb2wpKVxuICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnQ2Fubm90IGZpbmQgY29udHJvbCB3aXRoJyk7XG4gICAgICAgIGNvbnRyb2wudmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFtjb250cm9sLnZhbGlkYXRvciwgZGlyLnZhbGlkYXRvcl0pO1xuICAgICAgICBjb250cm9sLmFzeW5jVmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMoW2NvbnRyb2wuYXN5bmNWYWxpZGF0b3IsIGRpci5hc3luY1ZhbGlkYXRvcl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbm9Db250cm9sRXJyb3IoZGlyKSB7XG4gICAgICAgIHJldHVybiBfdGhyb3dFcnJvcihkaXIsICdUaGVyZSBpcyBubyBGb3JtQ29udHJvbCBpbnN0YW5jZSBhdHRhY2hlZCB0byBmb3JtIGNvbnRyb2wgZWxlbWVudCB3aXRoJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF90aHJvd0Vycm9yKGRpciwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgbWVzc2FnZUVuZDtcbiAgICAgICAgaWYgKGRpci5wYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFbmQgPSBcInBhdGg6ICdcIiArIGRpci5wYXRoLmpvaW4oJyAtPiAnKSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpci5wYXRoWzBdKSB7XG4gICAgICAgICAgICBtZXNzYWdlRW5kID0gXCJuYW1lOiAnXCIgKyBkaXIucGF0aCArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZUVuZCA9ICd1bnNwZWNpZmllZCBuYW1lIGF0dHJpYnV0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgKyBcIiBcIiArIG1lc3NhZ2VFbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wb3NlVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodmFsaWRhdG9ycykgPyBWYWxpZGF0b3JzLmNvbXBvc2UodmFsaWRhdG9ycy5tYXAobm9ybWFsaXplVmFsaWRhdG9yKSkgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh2YWxpZGF0b3JzKSA/IFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKHZhbGlkYXRvcnMubWFwKG5vcm1hbGl6ZUFzeW5jVmFsaWRhdG9yKSkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdmlld01vZGVsKSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnbW9kZWwnKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbJ21vZGVsJ107XG4gICAgICAgIGlmIChjaGFuZ2UuaXNGaXJzdENoYW5nZSgpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAhbG9vc2VJZGVudGljYWwodmlld01vZGVsLCBjaGFuZ2UuY3VycmVudFZhbHVlKTtcbiAgICB9XG4gICAgdmFyIEJVSUxUSU5fQUNDRVNTT1JTID0gW1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IsXG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IsXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgIF07XG4gICAgZnVuY3Rpb24gaXNCdWlsdEluQWNjZXNzb3IodmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICByZXR1cm4gQlVJTFRJTl9BQ0NFU1NPUlMuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gdmFsdWVBY2Nlc3Nvci5jb25zdHJ1Y3RvciA9PT0gYTsgfSk7XG4gICAgfVxuICAgIC8vIFRPRE86IHZzYXZraW4gcmVtb3ZlIGl0IG9uY2UgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzAxMSBpcyBpbXBsZW1lbnRlZFxuICAgIGZ1bmN0aW9uIHNlbGVjdFZhbHVlQWNjZXNzb3IoZGlyLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICBpZiAoIXZhbHVlQWNjZXNzb3JzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBkZWZhdWx0QWNjZXNzb3I7XG4gICAgICAgIHZhciBidWlsdGluQWNjZXNzb3I7XG4gICAgICAgIHZhciBjdXN0b21BY2Nlc3NvcjtcbiAgICAgICAgdmFsdWVBY2Nlc3NvcnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHYuY29uc3RydWN0b3IgPT09IERlZmF1bHRWYWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEFjY2Vzc29yID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQnVpbHRJbkFjY2Vzc29yKHYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1aWx0aW5BY2Nlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnTW9yZSB0aGFuIG9uZSBidWlsdC1pbiB2YWx1ZSBhY2Nlc3NvciBtYXRjaGVzIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgICAgICAgICAgYnVpbHRpbkFjY2Vzc29yID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21BY2Nlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnTW9yZSB0aGFuIG9uZSBjdXN0b20gdmFsdWUgYWNjZXNzb3IgbWF0Y2hlcyBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICAgICAgICAgIGN1c3RvbUFjY2Vzc29yID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdXN0b21BY2Nlc3NvcilcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21BY2Nlc3NvcjtcbiAgICAgICAgaWYgKGJ1aWx0aW5BY2Nlc3NvcilcbiAgICAgICAgICAgIHJldHVybiBidWlsdGluQWNjZXNzb3I7XG4gICAgICAgIGlmIChkZWZhdWx0QWNjZXNzb3IpXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEFjY2Vzc29yO1xuICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdObyB2YWxpZCB2YWx1ZSBhY2Nlc3NvciBmb3IgZm9ybSBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgYmFzZSBjbGFzcyBmb3IgY29kZSBzaGFyZWQgYmV0d2VlbiB7QGxpbmsgTmdNb2RlbEdyb3VwfSBhbmQge0BsaW5rIEZvcm1Hcm91cE5hbWV9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1BhcmVudFR5cGUoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRGb3JtR3JvdXAodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlRm9ybUdyb3VwKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHtAbGluayBGb3JtR3JvdXB9IGJhY2tpbmcgdGhpcyBiaW5kaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybURpcmVjdGl2ZS5nZXRGb3JtR3JvdXAodGhpcyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHBhdGggdG8gdGhpcyBjb250cm9sIGdyb3VwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUge0BsaW5rIEZvcm19IHRvIHdoaWNoIHRoaXMgZ3JvdXAgYmVsb25ncy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fYXN5bmNWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHJldHVybiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZTtcbiAgICB9KENvbnRyb2xDb250YWluZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgQWJzdHJhY3RDb250cm9sU3RhdHVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWJzdHJhY3RDb250cm9sU3RhdHVzKGNkKSB7XG4gICAgICAgICAgICB0aGlzLl9jZCA9IGNkO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NVbnRvdWNoZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC51bnRvdWNoZWQgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NUb3VjaGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wudG91Y2hlZCA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1ByaXN0aW5lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2QuY29udHJvbCA/IHRoaXMuX2NkLmNvbnRyb2wucHJpc3RpbmUgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xTdGF0dXMucHJvdG90eXBlLCBcIm5nQ2xhc3NEaXJ0eVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NkLmNvbnRyb2wgPyB0aGlzLl9jZC5jb250cm9sLmRpcnR5IDogZmFsc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzVmFsaWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC52YWxpZCA6IGZhbHNlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc0ludmFsaWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jZC5jb250cm9sID8gdGhpcy5fY2QuY29udHJvbC5pbnZhbGlkIDogZmFsc2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzUGVuZGluZ1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NkLmNvbnRyb2wgPyB0aGlzLl9jZC5jb250cm9sLnBlbmRpbmcgOiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBYnN0cmFjdENvbnRyb2xTdGF0dXM7XG4gICAgfSgpKTtcbiAgICB2YXIgbmdDb250cm9sU3RhdHVzSG9zdCA9IHtcbiAgICAgICAgJ1tjbGFzcy5uZy11bnRvdWNoZWRdJzogJ25nQ2xhc3NVbnRvdWNoZWQnLFxuICAgICAgICAnW2NsYXNzLm5nLXRvdWNoZWRdJzogJ25nQ2xhc3NUb3VjaGVkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1wcmlzdGluZV0nOiAnbmdDbGFzc1ByaXN0aW5lJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1kaXJ0eV0nOiAnbmdDbGFzc0RpcnR5JyxcbiAgICAgICAgJ1tjbGFzcy5uZy12YWxpZF0nOiAnbmdDbGFzc1ZhbGlkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1pbnZhbGlkXSc6ICduZ0NsYXNzSW52YWxpZCcsXG4gICAgICAgICdbY2xhc3MubmctcGVuZGluZ10nOiAnbmdDbGFzc1BlbmRpbmcnLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlyZWN0aXZlIGF1dG9tYXRpY2FsbHkgYXBwbGllZCB0byBBbmd1bGFyIGZvcm0gY29udHJvbHMgdGhhdCBzZXRzIENTUyBjbGFzc2VzXG4gICAgICogYmFzZWQgb24gY29udHJvbCBzdGF0dXMgKHZhbGlkL2ludmFsaWQvZGlydHkvZXRjKS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdDb250cm9sU3RhdHVzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoTmdDb250cm9sU3RhdHVzLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ0NvbnRyb2xTdGF0dXMoY2QpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNkKTtcbiAgICAgICAgfVxuICAgICAgICBOZ0NvbnRyb2xTdGF0dXMuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Db250cm9sTmFtZV0sW25nTW9kZWxdLFtmb3JtQ29udHJvbF0nLCBob3N0OiBuZ0NvbnRyb2xTdGF0dXNIb3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdDb250cm9sU3RhdHVzLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBOZ0NvbnRyb2wsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nQ29udHJvbFN0YXR1cztcbiAgICB9KEFic3RyYWN0Q29udHJvbFN0YXR1cykpO1xuICAgIC8qKlxuICAgICAqIERpcmVjdGl2ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gQW5ndWxhciBmb3JtIGdyb3VwcyB0aGF0IHNldHMgQ1NTIGNsYXNzZXNcbiAgICAgKiBiYXNlZCBvbiBjb250cm9sIHN0YXR1cyAodmFsaWQvaW52YWxpZC9kaXJ0eS9ldGMpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0NvbnRyb2xTdGF0dXNHcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQzKE5nQ29udHJvbFN0YXR1c0dyb3VwLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ0NvbnRyb2xTdGF0dXNHcm91cChjZCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgY2QpO1xuICAgICAgICB9XG4gICAgICAgIE5nQ29udHJvbFN0YXR1c0dyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbZm9ybUdyb3VwTmFtZV0sW2Zvcm1BcnJheU5hbWVdLFtuZ01vZGVsR3JvdXBdLFtmb3JtR3JvdXBdLGZvcm06bm90KFtuZ05vRm9ybV0pLFtuZ0Zvcm1dJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IG5nQ29udHJvbFN0YXR1c0hvc3RcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cC5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTmdDb250cm9sU3RhdHVzR3JvdXA7XG4gICAgfShBYnN0cmFjdENvbnRyb2xTdGF0dXMpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDUgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2UgYnkgZGlyZWN0aXZlcyBhbmQgY29tcG9uZW50cyB0byBlbWl0IGN1c3RvbSBFdmVudHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIEluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgYFppcHB5YCBhbHRlcm5hdGl2ZWx5IGVtaXRzIGBvcGVuYCBhbmQgYGNsb3NlYCBldmVudHMgd2hlbiBpdHNcbiAgICAgKiB0aXRsZSBnZXRzIGNsaWNrZWQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAnemlwcHknLFxuICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJ6aXBweVwiPlxuICAgICAqICAgICA8ZGl2IChjbGljayk9XCJ0b2dnbGUoKVwiPlRvZ2dsZTwvZGl2PlxuICAgICAqICAgICA8ZGl2IFtoaWRkZW5dPVwiIXZpc2libGVcIj5cbiAgICAgKiAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICogICAgIDwvZGl2PlxuICAgICAqICA8L2Rpdj5gfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgWmlwcHkge1xuICAgICAqICAgdmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgICogICBAT3V0cHV0KCkgb3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICogICBAT3V0cHV0KCkgY2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAqXG4gICAgICogICB0b2dnbGUoKSB7XG4gICAgICogICAgIHRoaXMudmlzaWJsZSA9ICF0aGlzLnZpc2libGU7XG4gICAgICogICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgKiAgICAgICB0aGlzLm9wZW4uZW1pdChudWxsKTtcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICB0aGlzLmNsb3NlLmVtaXQobnVsbCk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgZXZlbnRzIHBheWxvYWQgY2FuIGJlIGFjY2Vzc2VkIGJ5IHRoZSBwYXJhbWV0ZXIgYCRldmVudGAgb24gdGhlIGNvbXBvbmVudHMgb3V0cHV0IGV2ZW50XG4gICAgICogaGFuZGxlcjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDx6aXBweSAob3Blbik9XCJvbk9wZW4oJGV2ZW50KVwiIChjbG9zZSk9XCJvbkNsb3NlKCRldmVudClcIj48L3ppcHB5PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVXNlcyBSeC5PYnNlcnZhYmxlIGJ1dCBwcm92aWRlcyBhbiBhZGFwdGVyIHRvIG1ha2UgaXQgd29yayBhcyBzcGVjaWZpZWQgaGVyZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vamh1c2Fpbi9vYnNlcnZhYmxlLXNwZWNcbiAgICAgKlxuICAgICAqIE9uY2UgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWMgaXMgYXZhaWxhYmxlLCBzd2l0Y2ggdG8gaXQuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNShFdmVudEVtaXR0ZXIsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFtFdmVudEVtaXR0ZXJdLCB3aGljaCBkZXBlbmRpbmcgb24gW2lzQXN5bmNdLFxuICAgICAgICAgKiBkZWxpdmVycyBldmVudHMgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcihpc0FzeW5jKSB7XG4gICAgICAgICAgICBpZiAoaXNBc3luYyA9PT0gdm9pZCAwKSB7IGlzQXN5bmMgPSBmYWxzZTsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9faXNBc3luYyA9IGlzQXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsIHZhbHVlKTsgfTtcbiAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgICAgIHZhciBzY2hlZHVsZXJGbjtcbiAgICAgICAgICAgIHZhciBlcnJvckZuID0gZnVuY3Rpb24gKGVycikgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZUZuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQgJiYgdHlwZW9mIGdlbmVyYXRvck9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0Lm5leHQodmFsdWUpOyB9KTtcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHZhbHVlKSB7IGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfTtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uIChlcnIpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikgeyBnZW5lcmF0b3JPck5leHQuZXJyb3IoZXJyKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKCk7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKCk7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICh2YWx1ZSkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dCh2YWx1ZSk7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7IGdlbmVyYXRvck9yTmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IoZXJyKTsgfSk7IH0gOiBmdW5jdGlvbiAoZXJyKSB7IGVycm9yKGVycik7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBsZXRlKCk7IH0pOyB9IDogZnVuY3Rpb24gKCkgeyBjb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnN1YnNjcmliZS5jYWxsKHRoaXMsIHNjaGVkdWxlckZuLCBlcnJvckZuLCBjb21wbGV0ZUZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICB9KHJ4anNfU3ViamVjdC5TdWJqZWN0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ2ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBGb3JtQ29udHJvbCBpcyB2YWxpZCwgaS5lLiB0aGF0IG5vIGVycm9ycyBleGlzdCBpbiB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIFZBTElEID0gJ1ZBTElEJztcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIEZvcm1Db250cm9sIGlzIGludmFsaWQsIGkuZS4gdGhhdCBhbiBlcnJvciBleGlzdHMgaW4gdGhlIGlucHV0IHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBJTlZBTElEID0gJ0lOVkFMSUQnO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgRm9ybUNvbnRyb2wgaXMgcGVuZGluZywgaS5lLiB0aGF0IGFzeW5jIHZhbGlkYXRpb24gaXMgb2NjdXJyaW5nIGFuZFxuICAgICAqIGVycm9ycyBhcmUgbm90IHlldCBhdmFpbGFibGUgZm9yIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgUEVORElORyA9ICdQRU5ESU5HJztcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIEZvcm1Db250cm9sIGlzIGRpc2FibGVkLCBpLmUuIHRoYXQgdGhlIGNvbnRyb2wgaXMgZXhlbXB0IGZyb20gYW5jZXN0b3JcbiAgICAgKiBjYWxjdWxhdGlvbnMgb2YgdmFsaWRpdHkgb3IgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIERJU0FCTEVEID0gJ0RJU0FCTEVEJztcbiAgICBmdW5jdGlvbiBfZmluZChjb250cm9sLCBwYXRoLCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdChkZWxpbWl0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoIGluc3RhbmNlb2YgQXJyYXkgJiYgKHBhdGgubGVuZ3RoID09PSAwKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHYsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgRm9ybUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuY29udHJvbHNbbmFtZV0gfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgRm9ybUFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuYXQobmFtZSkgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCBjb250cm9sKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9PYnNlcnZhYmxlKHIpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJvbWlzZShyKSA/IHJ4anNfb2JzZXJ2YWJsZV9mcm9tUHJvbWlzZS5mcm9tUHJvbWlzZShyKSA6IHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvZXJjZVRvVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWxpZGF0b3IpID8gY29tcG9zZVZhbGlkYXRvcnModmFsaWRhdG9yKSA6IHZhbGlkYXRvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29lcmNlVG9Bc3luY1ZhbGlkYXRvcihhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhc3luY1ZhbGlkYXRvcikgPyBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yKSA6IGFzeW5jVmFsaWRhdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciB7QGxpbmsgRm9ybUNvbnRyb2x9LCB7QGxpbmsgRm9ybUdyb3VwfSwgYW5kXG4gICAgICoge0BsaW5rIEZvcm1BcnJheX0uXG4gICAgICpcbiAgICAgKiBJdCBwcm92aWRlcyBzb21lIG9mIHRoZSBzaGFyZWQgYmVoYXZpb3IgdGhhdCBhbGwgY29udHJvbHMgYW5kIGdyb3VwcyBvZiBjb250cm9scyBoYXZlLCBsaWtlXG4gICAgICogcnVubmluZyB2YWxpZGF0b3JzLCBjYWxjdWxhdGluZyBzdGF0dXMsIGFuZCByZXNldHRpbmcgc3RhdGUuIEl0IGFsc28gZGVmaW5lcyB0aGUgcHJvcGVydGllc1xuICAgICAqIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIGFsbCBzdWItY2xhc3NlcywgbGlrZSBgdmFsdWVgLCBgdmFsaWRgLCBhbmQgYGRpcnR5YC4gSXQgc2hvdWxkbid0IGJlXG4gICAgICogaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBYnN0cmFjdENvbnRyb2wgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2wodmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4gICAgICAgICAgICB0aGlzLmFzeW5jVmFsaWRhdG9yID0gYXN5bmNWYWxpZGF0b3I7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICB0aGlzLl9wcmlzdGluZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl90b3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcGFyZW50IGNvbnRyb2wuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHZhbGlkYXRpb24gc3RhdHVzIG9mIHRoZSBjb250cm9sLiBUaGVyZSBhcmUgZm91ciBwb3NzaWJsZVxuICAgICAgICAgICAgICogdmFsaWRhdGlvbiBzdGF0dXNlczpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAqICoqVkFMSUQqKjogIGNvbnRyb2wgaGFzIHBhc3NlZCBhbGwgdmFsaWRhdGlvbiBjaGVja3NcbiAgICAgICAgICAgICAqICogKipJTlZBTElEKio6IGNvbnRyb2wgaGFzIGZhaWxlZCBhdCBsZWFzdCBvbmUgdmFsaWRhdGlvbiBjaGVja1xuICAgICAgICAgICAgICogKiAqKlBFTkRJTkcqKjogY29udHJvbCBpcyBpbiB0aGUgbWlkc3Qgb2YgY29uZHVjdGluZyBhIHZhbGlkYXRpb24gY2hlY2tcbiAgICAgICAgICAgICAqICogKipESVNBQkxFRCoqOiBjb250cm9sIGlzIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlc2Ugc3RhdHVzZXMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgc28gYSBjb250cm9sIGNhbm5vdCBiZVxuICAgICAgICAgICAgICogYm90aCB2YWxpZCBBTkQgaW52YWxpZCBvciBpbnZhbGlkIEFORCBkaXNhYmxlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ2YWxpZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgdmFsaWRgIHdoZW4gaXRzIGBzdGF0dXMgPT09IFZBTElEYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvcmRlciB0byBoYXZlIHRoaXMgc3RhdHVzLCB0aGUgY29udHJvbCBtdXN0IGhhdmUgcGFzc2VkIGFsbCBpdHNcbiAgICAgICAgICAgICAqIHZhbGlkYXRpb24gY2hlY2tzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gVkFMSUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJpbnZhbGlkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBpbnZhbGlkYCB3aGVuIGl0cyBgc3RhdHVzID09PSBJTlZBTElEYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvcmRlciB0byBoYXZlIHRoaXMgc3RhdHVzLCB0aGUgY29udHJvbCBtdXN0IGhhdmUgZmFpbGVkXG4gICAgICAgICAgICAgKiBhdCBsZWFzdCBvbmUgb2YgaXRzIHZhbGlkYXRpb24gY2hlY2tzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gSU5WQUxJRDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInBlbmRpbmdcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYHBlbmRpbmdgIHdoZW4gaXRzIGBzdGF0dXMgPT09IFBFTkRJTkdgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG9yZGVyIHRvIGhhdmUgdGhpcyBzdGF0dXMsIHRoZSBjb250cm9sIG11c3QgYmUgaW4gdGhlXG4gICAgICAgICAgICAgKiBtaWRkbGUgb2YgY29uZHVjdGluZyBhIHZhbGlkYXRpb24gY2hlY2suXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzID09IFBFTkRJTkc7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgZGlzYWJsZWRgIHdoZW4gaXRzIGBzdGF0dXMgPT09IERJU0FCTEVEYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBEaXNhYmxlZCBjb250cm9scyBhcmUgZXhlbXB0IGZyb20gdmFsaWRhdGlvbiBjaGVja3MgYW5kXG4gICAgICAgICAgICAgKiBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgdGhlaXIgYW5jZXN0b3JcbiAgICAgICAgICAgICAqIGNvbnRyb2xzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gRElTQUJMRUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBlbmFibGVkYCBhcyBsb25nIGFzIGl0cyBgc3RhdHVzICE9PSBESVNBQkxFRGAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3RoZXIgd29yZHMsIGl0IGhhcyBhIHN0YXR1cyBvZiBgVkFMSURgLCBgSU5WQUxJRGAsIG9yXG4gICAgICAgICAgICAgKiBgUEVORElOR2AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzICE9PSBESVNBQkxFRDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcImVycm9yc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYW55IGVycm9ycyBnZW5lcmF0ZWQgYnkgZmFpbGluZyB2YWxpZGF0aW9uLiBJZiB0aGVyZVxuICAgICAgICAgICAgICogYXJlIG5vIGVycm9ycywgaXQgd2lsbCByZXR1cm4gbnVsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lcnJvcnM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJwcmlzdGluZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgcHJpc3RpbmVgIGlmIHRoZSB1c2VyIGhhcyBub3QgeWV0IGNoYW5nZWRcbiAgICAgICAgICAgICAqIHRoZSB2YWx1ZSBpbiB0aGUgVUkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHByb2dyYW1tYXRpYyBjaGFuZ2VzIHRvIGEgY29udHJvbCdzIHZhbHVlIHdpbGxcbiAgICAgICAgICAgICAqICpub3QqIG1hcmsgaXQgZGlydHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJpc3RpbmU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJkaXJ0eVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgZGlydHlgIGlmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICogaW4gdGhlIFVJLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCBwcm9ncmFtbWF0aWMgY2hhbmdlcyB0byBhIGNvbnRyb2wncyB2YWx1ZSB3aWxsXG4gICAgICAgICAgICAgKiAqbm90KiBtYXJrIGl0IGRpcnR5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLnByaXN0aW5lOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidG91Y2hlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogQSBjb250cm9sIGlzIG1hcmtlZCBgdG91Y2hlZGAgb25jZSB0aGUgdXNlciBoYXMgdHJpZ2dlcmVkXG4gICAgICAgICAgICAqIGEgYGJsdXJgIGV2ZW50IG9uIGl0LlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdG91Y2hlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInVudG91Y2hlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgdW50b3VjaGVkYCBpZiB0aGUgdXNlciBoYXMgbm90IHlldCB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAqIGEgYGJsdXJgIGV2ZW50IG9uIGl0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLl90b3VjaGVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW1pdHMgYW4gZXZlbnQgZXZlcnkgdGltZSB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgY2hhbmdlcywgaW5cbiAgICAgICAgICAgICAqIHRoZSBVSSBvciBwcm9ncmFtbWF0aWNhbGx5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlQ2hhbmdlczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInN0YXR1c0NoYW5nZXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbWl0cyBhbiBldmVudCBldmVyeSB0aW1lIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbFxuICAgICAgICAgICAgICogaXMgcmUtY2FsY3VsYXRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXNDaGFuZ2VzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHN5bmNocm9ub3VzIHZhbGlkYXRvcnMgdGhhdCBhcmUgYWN0aXZlIG9uIHRoaXMgY29udHJvbC4gIENhbGxpbmdcbiAgICAgICAgICogdGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgZXhpc3Rpbmcgc3luYyB2YWxpZGF0b3JzLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5zZXRWYWxpZGF0b3JzID0gZnVuY3Rpb24gKG5ld1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBjb2VyY2VUb1ZhbGlkYXRvcihuZXdWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgYXN5bmMgdmFsaWRhdG9ycyB0aGF0IGFyZSBhY3RpdmUgb24gdGhpcyBjb250cm9sLiBDYWxsaW5nIHRoaXNcbiAgICAgICAgICogd2lsbCBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIGFzeW5jIHZhbGlkYXRvcnMuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldEFzeW5jVmFsaWRhdG9ycyA9IGZ1bmN0aW9uIChuZXdWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBjb2VyY2VUb0FzeW5jVmFsaWRhdG9yKG5ld1ZhbGlkYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbXB0aWVzIG91dCB0aGUgc3luYyB2YWxpZGF0b3IgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuY2xlYXJWYWxpZGF0b3JzID0gZnVuY3Rpb24gKCkgeyB0aGlzLnZhbGlkYXRvciA9IG51bGw7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbXB0aWVzIG91dCB0aGUgYXN5bmMgdmFsaWRhdG9yIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmNsZWFyQXN5bmNWYWxpZGF0b3JzID0gZnVuY3Rpb24gKCkgeyB0aGlzLmFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGB0b3VjaGVkYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB3aWxsIGFsc28gbWFyayBhbGwgZGlyZWN0IGFuY2VzdG9ycyBhcyBgdG91Y2hlZGAgdG8gbWFpbnRhaW5cbiAgICAgICAgICogdGhlIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNUb3VjaGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYHVudG91Y2hlZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBhbnkgY2hpbGRyZW4sIGl0IHdpbGwgYWxzbyBtYXJrIGFsbCBjaGlsZHJlbiBhcyBgdW50b3VjaGVkYFxuICAgICAgICAgKiB0byBtYWludGFpbiB0aGUgbW9kZWwsIGFuZCByZS1jYWxjdWxhdGUgdGhlIGB0b3VjaGVkYCBzdGF0dXMgb2YgYWxsIHBhcmVudFxuICAgICAgICAgKiBjb250cm9scy5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzVW50b3VjaGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7IGNvbnRyb2wubWFya0FzVW50b3VjaGVkKHsgb25seVNlbGY6IHRydWUgfSk7IH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgZGlydHlgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYWxzbyBtYXJrIGFsbCBkaXJlY3QgYW5jZXN0b3JzIGFzIGBkaXJ0eWAgdG8gbWFpbnRhaW5cbiAgICAgICAgICogdGhlIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNEaXJ0eSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3ByaXN0aW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNEaXJ0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBwcmlzdGluZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBhbnkgY2hpbGRyZW4sIGl0IHdpbGwgYWxzbyBtYXJrIGFsbCBjaGlsZHJlbiBhcyBgcHJpc3RpbmVgXG4gICAgICAgICAqIHRvIG1haW50YWluIHRoZSBtb2RlbCwgYW5kIHJlLWNhbGN1bGF0ZSB0aGUgYHByaXN0aW5lYCBzdGF0dXMgb2YgYWxsIHBhcmVudFxuICAgICAgICAgKiBjb250cm9scy5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzUHJpc3RpbmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9wcmlzdGluZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5tYXJrQXNQcmlzdGluZSh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBwZW5kaW5nYC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzUGVuZGluZyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IFBFTkRJTkc7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNQZW5kaW5nKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGNvbnRyb2wuIFRoaXMgbWVhbnMgdGhlIGNvbnRyb2wgd2lsbCBiZSBleGVtcHQgZnJvbSB2YWxpZGF0aW9uIGNoZWNrcyBhbmRcbiAgICAgICAgICogZXhjbHVkZWQgZnJvbSB0aGUgYWdncmVnYXRlIHZhbHVlIG9mIGFueSBwYXJlbnQuIEl0cyBzdGF0dXMgaXMgYERJU0FCTEVEYC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGNvbnRyb2wgaGFzIGNoaWxkcmVuLCBhbGwgY2hpbGRyZW4gd2lsbCBiZSBkaXNhYmxlZCB0byBtYWludGFpbiB0aGUgbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBESVNBQkxFRDtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5kaXNhYmxlKHsgb25seVNlbGY6IHRydWUgfSk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChlbWl0RXZlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2VzLmVtaXQodGhpcy5fdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5jZXN0b3JzKG9ubHlTZWxmKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlRm4pIHsgcmV0dXJuIGNoYW5nZUZuKHRydWUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIGNvbnRyb2wuIFRoaXMgbWVhbnMgdGhlIGNvbnRyb2wgd2lsbCBiZSBpbmNsdWRlZCBpbiB2YWxpZGF0aW9uIGNoZWNrcyBhbmRcbiAgICAgICAgICogdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiBpdHMgcGFyZW50LiBJdHMgc3RhdHVzIGlzIHJlLWNhbGN1bGF0ZWQgYmFzZWQgb24gaXRzIHZhbHVlIGFuZFxuICAgICAgICAgKiBpdHMgdmFsaWRhdG9ycy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGNvbnRyb2wgaGFzIGNoaWxkcmVuLCBhbGwgY2hpbGRyZW4gd2lsbCBiZSBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBWQUxJRDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLmVuYWJsZSh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuY2VzdG9ycyhvbmx5U2VsZik7XG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZUZuKSB7IHJldHVybiBjaGFuZ2VGbihmYWxzZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVBbmNlc3RvcnMgPSBmdW5jdGlvbiAob25seVNlbGYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVByaXN0aW5lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVUb3VjaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkgeyB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZS1jYWxjdWxhdGVzIHRoZSB2YWx1ZSBhbmQgdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIGl0IHdpbGwgYWxzbyB1cGRhdGUgdGhlIHZhbHVlIGFuZCB2YWxpZGl0eSBvZiBpdHMgYW5jZXN0b3JzLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fc2V0SW5pdGlhbFN0YXR1cygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSB0aGlzLl9ydW5WYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSB0aGlzLl9jYWxjdWxhdGVTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzID09PSBWQUxJRCB8fCB0aGlzLl9zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnVuQXN5bmNWYWxpZGF0b3IoZW1pdEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW1pdEV2ZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlcy5lbWl0KHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzLmVtaXQodGhpcy5fc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVRyZWVWYWxpZGl0eSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGVtaXRFdmVudCA9IChfYSA9PT0gdm9pZCAwID8geyBlbWl0RXZlbnQ6IHRydWUgfSA6IF9hKS5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGN0cmwpIHsgcmV0dXJuIGN0cmwuX3VwZGF0ZVRyZWVWYWxpZGl0eSh7IGVtaXRFdmVudDogZW1pdEV2ZW50IH0pOyB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fc2V0SW5pdGlhbFN0YXR1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fc3RhdHVzID0gdGhpcy5fYWxsQ29udHJvbHNEaXNhYmxlZCgpID8gRElTQUJMRUQgOiBWQUxJRDsgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fcnVuVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yID8gdGhpcy52YWxpZGF0b3IodGhpcykgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9ydW5Bc3luY1ZhbGlkYXRvciA9IGZ1bmN0aW9uIChlbWl0RXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IFBFTkRJTkc7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsRXhpc3RpbmdTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JzID0gdG9PYnNlcnZhYmxlKHRoaXMuYXN5bmNWYWxpZGF0b3IodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdGlvblN1YnNjcmlwdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIG9icy5zdWJzY3JpYmUoeyBuZXh0OiBmdW5jdGlvbiAocmVzKSB7IHJldHVybiBfdGhpcy5zZXRFcnJvcnMocmVzLCB7IGVtaXRFdmVudDogZW1pdEV2ZW50IH0pOyB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9jYW5jZWxFeGlzdGluZ1N1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgZXJyb3JzIG9uIGEgZm9ybSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWQgd2hlbiB2YWxpZGF0aW9ucyBhcmUgcnVuIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCByYXRoZXIgdGhhbiBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWxsaW5nIGBzZXRFcnJvcnNgIHdpbGwgYWxzbyB1cGRhdGUgdGhlIHZhbGlkaXR5IG9mIHRoZSBwYXJlbnQgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGNvbnN0IGxvZ2luID0gbmV3IEZvcm1Db250cm9sKFwic29tZUxvZ2luXCIpO1xuICAgICAgICAgKiBsb2dpbi5zZXRFcnJvcnMoe1xuICAgICAgICAgKiAgIFwibm90VW5pcXVlXCI6IHRydWVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChsb2dpbi52YWxpZCkudG9FcXVhbChmYWxzZSk7XG4gICAgICAgICAqIGV4cGVjdChsb2dpbi5lcnJvcnMpLnRvRXF1YWwoe1wibm90VW5pcXVlXCI6IHRydWV9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogbG9naW4uc2V0VmFsdWUoXCJzb21lT3RoZXJMb2dpblwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KGxvZ2luLnZhbGlkKS50b0VxdWFsKHRydWUpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0RXJyb3JzID0gZnVuY3Rpb24gKGVycm9ycywgX2EpIHtcbiAgICAgICAgICAgIHZhciBlbWl0RXZlbnQgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRXJyb3JzKGVtaXRFdmVudCAhPT0gZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGEgY2hpbGQgY29udHJvbCBnaXZlbiB0aGUgY29udHJvbCdzIG5hbWUgb3IgcGF0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogUGF0aHMgY2FuIGJlIHBhc3NlZCBpbiBhcyBhbiBhcnJheSBvciBhIHN0cmluZyBkZWxpbWl0ZWQgYnkgYSBkb3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIGdldCBhIGNvbnRyb2wgbmVzdGVkIHdpdGhpbiBhIGBwZXJzb25gIHN1Yi1ncm91cDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgdGhpcy5mb3JtLmdldCgncGVyc29uLm5hbWUnKTtgXG4gICAgICAgICAqXG4gICAgICAgICAqIC1PUi1cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgdGhpcy5mb3JtLmdldChbJ3BlcnNvbicsICduYW1lJ10pO2BcbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIF9maW5kKHRoaXMsIHBhdGgsICcuJyk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gcGF0aCBoYXMgdGhlIGVycm9yIHNwZWNpZmllZC4gT3RoZXJ3aXNlXG4gICAgICAgICAqIHJldHVybnMgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIG5vIHBhdGggaXMgZ2l2ZW4sIGl0IGNoZWNrcyBmb3IgdGhlIGVycm9yIG9uIHRoZSBwcmVzZW50IGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBwYXRoID8gdGhpcy5nZXQocGF0aCkgOiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wgJiYgY29udHJvbC5fZXJyb3JzID8gY29udHJvbC5fZXJyb3JzW2Vycm9yQ29kZV0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGggaGFzIHRoZSBlcnJvciBzcGVjaWZpZWQuIE90aGVyd2lzZVxuICAgICAgICAgKiByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBubyBwYXRoIGlzIGdpdmVuLCBpdCBjaGVja3MgZm9yIHRoZSBlcnJvciBvbiB0aGUgcHJlc2VudCBjb250cm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5oYXNFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RXJyb3IoZXJyb3JDb2RlLCBwYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicm9vdFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyB0aGUgdG9wLWxldmVsIGFuY2VzdG9yIG9mIHRoaXMgY29udHJvbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdoaWxlICh4Ll9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHguX3BhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVDb250cm9sc0Vycm9ycyA9IGZ1bmN0aW9uIChlbWl0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IHRoaXMuX2NhbGN1bGF0ZVN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKGVtaXRFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlQ29udHJvbHNFcnJvcnMoZW1pdEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9pbml0T2JzZXJ2YWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9jYWxjdWxhdGVTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWxsQ29udHJvbHNEaXNhYmxlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBESVNBQkxFRDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW55Q29udHJvbHNIYXZlU3RhdHVzKFBFTkRJTkcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQRU5ESU5HO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyhJTlZBTElEKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIHJldHVybiBWQUxJRDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9sc0hhdmVTdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW55Q29udHJvbHMoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuc3RhdHVzID09PSBzdGF0dXM7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2FueUNvbnRyb2xzRGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW55Q29udHJvbHMoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuZGlydHk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2FueUNvbnRyb2xzVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250cm9scyhmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC50b3VjaGVkOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVQcmlzdGluZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3ByaXN0aW5lID0gIXRoaXMuX2FueUNvbnRyb2xzRGlydHkoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVUb3VjaGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hlZCA9IHRoaXMuX2FueUNvbnRyb2xzVG91Y2hlZCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5faXNCb3hlZFZhbHVlID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtU3RhdGUgPT09ICdvYmplY3QnICYmIGZvcm1TdGF0ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGZvcm1TdGF0ZSkubGVuZ3RoID09PSAyICYmICd2YWx1ZScgaW4gZm9ybVN0YXRlICYmICdkaXNhYmxlZCcgaW4gZm9ybVN0YXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgVHJhY2tzIHRoZSB2YWx1ZSBhbmQgdmFsaWRhdGlvbiBzdGF0dXMgb2YgYW4gaW5kaXZpZHVhbCBmb3JtIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBJdCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyBvZiBBbmd1bGFyIGZvcm1zLCBhbG9uZyB3aXRoXG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0gYW5kIHtAbGluayBGb3JtQXJyYXl9LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBXaGVuIGluc3RhbnRpYXRpbmcgYSB7QGxpbmsgRm9ybUNvbnRyb2x9LCB5b3UgY2FuIHBhc3MgaW4gYW4gaW5pdGlhbCB2YWx1ZSBhcyB0aGVcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbCgnc29tZSB2YWx1ZScpO1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwudmFsdWUpOyAgICAgLy8gJ3NvbWUgdmFsdWUnXG4gICAgICpgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBpbml0aWFsaXplIHRoZSBjb250cm9sIHdpdGggYSBmb3JtIHN0YXRlIG9iamVjdCBvbiBpbnN0YW50aWF0aW9uLFxuICAgICAqIHdoaWNoIGluY2x1ZGVzIGJvdGggdGhlIHZhbHVlIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgY29udHJvbCBpcyBkaXNhYmxlZC5cbiAgICAgKiBZb3UgY2FuJ3QgdXNlIHRoZSB2YWx1ZSBrZXkgd2l0aG91dCB0aGUgZGlzYWJsZWQga2V5OyBib3RoIGFyZSByZXF1aXJlZFxuICAgICAqIHRvIHVzZSB0aGlzIHdheSBvZiBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbCh7dmFsdWU6ICduL2EnLCBkaXNhYmxlZDogdHJ1ZX0pO1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwudmFsdWUpOyAgICAgLy8gJ24vYSdcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnN0YXR1cyk7ICAgLy8gJ0RJU0FCTEVEJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVG8gaW5jbHVkZSBhIHN5bmMgdmFsaWRhdG9yIChvciBhbiBhcnJheSBvZiBzeW5jIHZhbGlkYXRvcnMpIHdpdGggdGhlIGNvbnRyb2wsXG4gICAgICogcGFzcyBpdCBpbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LiBBc3luYyB2YWxpZGF0b3JzIGFyZSBhbHNvIHN1cHBvcnRlZCwgYnV0XG4gICAgICogaGF2ZSB0byBiZSBwYXNzZWQgaW4gc2VwYXJhdGVseSBhcyB0aGUgdGhpcmQgYXJnLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjdHJsID0gbmV3IEZvcm1Db250cm9sKCcnLCBWYWxpZGF0b3JzLnJlcXVpcmVkKTtcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnZhbHVlKTsgICAgIC8vICcnXG4gICAgICogY29uc29sZS5sb2coY3RybC5zdGF0dXMpOyAgIC8vICdJTlZBTElEJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2VlIGl0cyBzdXBlcmNsYXNzLCB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSwgZm9yIG1vcmUgcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Db250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRm9ybUNvbnRyb2wsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Db250cm9sKGZvcm1TdGF0ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKGZvcm1TdGF0ZSA9PT0gdm9pZCAwKSB7IGZvcm1TdGF0ZSA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3IgPT09IHZvaWQgMCkgeyBhc3luY1ZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNvZXJjZVRvVmFsaWRhdG9yKHZhbGlkYXRvciksIGNvZXJjZVRvQXN5bmNWYWxpZGF0b3IoYXN5bmNWYWxpZGF0b3IpKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlID0gW107XG4gICAgICAgICAgICB0aGlzLl9hcHBseUZvcm1TdGF0ZShmb3JtU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgZm9ybSBjb250cm9sIHRvIGB2YWx1ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBvbmx5U2VsZmAgaXMgYHRydWVgLCB0aGlzIGNoYW5nZSB3aWxsIG9ubHkgYWZmZWN0IHRoZSB2YWxpZGF0aW9uIG9mIHRoaXMgYEZvcm1Db250cm9sYFxuICAgICAgICAgKiBhbmQgbm90IGl0cyBwYXJlbnQgY29tcG9uZW50LiBUaGlzIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZW1pdEV2ZW50YCBpcyBgdHJ1ZWAsIHRoaXNcbiAgICAgICAgICogY2hhbmdlIHdpbGwgY2F1c2UgYSBgdmFsdWVDaGFuZ2VzYCBldmVudCBvbiB0aGUgYEZvcm1Db250cm9sYCB0byBiZSBlbWl0dGVkLiBUaGlzIGRlZmF1bHRzXG4gICAgICAgICAqIHRvIHRydWUgKGFzIGl0IGZhbGxzIHRocm91Z2ggdG8gYHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHlgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGVtaXRNb2RlbFRvVmlld0NoYW5nZWAgaXMgYHRydWVgLCB0aGUgdmlldyB3aWxsIGJlIG5vdGlmaWVkIGFib3V0IHRoZSBuZXcgdmFsdWVcbiAgICAgICAgICogdmlhIGFuIGBvbkNoYW5nZWAgZXZlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaWYgYGVtaXRNb2RlbFRvVmlld0NoYW5nZWAgaXMgbm90XG4gICAgICAgICAqIHNwZWNpZmllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGVtaXRWaWV3VG9Nb2RlbENoYW5nZWAgaXMgYHRydWVgLCBhbiBuZ01vZGVsQ2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgdG8gdXBkYXRlIHRoZVxuICAgICAgICAgKiBtb2RlbC4gIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaWYgYGVtaXRWaWV3VG9Nb2RlbENoYW5nZWAgaXMgbm90IHNwZWNpZmllZC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50LCBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2UgPSBfYi5lbWl0TW9kZWxUb1ZpZXdDaGFuZ2UsIGVtaXRWaWV3VG9Nb2RlbENoYW5nZSA9IF9iLmVtaXRWaWV3VG9Nb2RlbENoYW5nZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UubGVuZ3RoICYmIGVtaXRNb2RlbFRvVmlld0NoYW5nZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2VGbikgeyByZXR1cm4gY2hhbmdlRm4oX3RoaXMuX3ZhbHVlLCBlbWl0Vmlld1RvTW9kZWxDaGFuZ2UgIT09IGZhbHNlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGF0Y2hlcyB0aGUgdmFsdWUgb2YgYSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZ1bmN0aW9uYWxseSB0aGUgc2FtZSBhcyB7QGxpbmsgRm9ybUNvbnRyb2wuc2V0VmFsdWV9IGF0IHRoaXMgbGV2ZWwuXG4gICAgICAgICAqIEl0IGV4aXN0cyBmb3Igc3ltbWV0cnkgd2l0aCB7QGxpbmsgRm9ybUdyb3VwLnBhdGNoVmFsdWV9IG9uIGBGb3JtR3JvdXBzYCBhbmQgYEZvcm1BcnJheXNgLFxuICAgICAgICAgKiB3aGVyZSBpdCBkb2VzIGJlaGF2ZSBkaWZmZXJlbnRseS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5wYXRjaFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGZvcm0gY29udHJvbC4gVGhpcyBtZWFucyBieSBkZWZhdWx0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGl0IGlzIG1hcmtlZCBhcyBgcHJpc3RpbmVgXG4gICAgICAgICAqICogaXQgaXMgbWFya2VkIGFzIGB1bnRvdWNoZWRgXG4gICAgICAgICAqICogdmFsdWUgaXMgc2V0IHRvIG51bGxcbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhbHNvIHJlc2V0IHRvIGEgc3BlY2lmaWMgZm9ybSBzdGF0ZSBieSBwYXNzaW5nIHRocm91Z2ggYSBzdGFuZGFsb25lXG4gICAgICAgICAqIHZhbHVlIG9yIGEgZm9ybSBzdGF0ZSBvYmplY3QgdGhhdCBjb250YWlucyBib3RoIGEgdmFsdWUgYW5kIGEgZGlzYWJsZWQgc3RhdGVcbiAgICAgICAgICogKHRoZXNlIGFyZSB0aGUgb25seSB0d28gcHJvcGVydGllcyB0aGF0IGNhbm5vdCBiZSBjYWxjdWxhdGVkKS5cbiAgICAgICAgICpcbiAgICAgICAgICogRXg6XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIHRoaXMuY29udHJvbC5yZXNldCgnTmFuY3knKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5jb250cm9sLnZhbHVlKTsgIC8vICdOYW5jeSdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIE9SXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiB0aGlzLmNvbnRyb2wucmVzZXQoe3ZhbHVlOiAnTmFuY3knLCBkaXNhYmxlZDogdHJ1ZX0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmNvbnRyb2wudmFsdWUpOyAgLy8gJ05hbmN5J1xuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmNvbnRyb2wuc3RhdHVzKTsgIC8vICdESVNBQkxFRCdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoZm9ybVN0YXRlLCBfYSkge1xuICAgICAgICAgICAgaWYgKGZvcm1TdGF0ZSA9PT0gdm9pZCAwKSB7IGZvcm1TdGF0ZSA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9hcHBseUZvcm1TdGF0ZShmb3JtU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5tYXJrQXNQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIHRoaXMubWFya0FzVW50b3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLl92YWx1ZSwgeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2FueUNvbnRyb2xzID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fYWxsQ29udHJvbHNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlzYWJsZWQ7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIGxpc3RlbmVyIGZvciBjaGFuZ2UgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UucHVzaChmbik7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fY2xlYXJDaGFuZ2VGbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgZGlzYWJsZWQgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnJlZ2lzdGVyT25EaXNhYmxlZENoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZS5wdXNoKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoY2IpIHsgfTtcbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9hcHBseUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChmb3JtU3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0JveGVkVmFsdWUoZm9ybVN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gZm9ybVN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGZvcm1TdGF0ZS5kaXNhYmxlZCA/IHRoaXMuZGlzYWJsZSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gZm9ybVN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUNvbnRyb2w7XG4gICAgfShBYnN0cmFjdENvbnRyb2wpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBUcmFja3MgdGhlIHZhbHVlIGFuZCB2YWxpZGl0eSBzdGF0ZSBvZiBhIGdyb3VwIG9mIHtAbGluayBGb3JtQ29udHJvbH1cbiAgICAgKiBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBBIGBGb3JtR3JvdXBgIGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlcyBvZiBlYWNoIGNoaWxkIHtAbGluayBGb3JtQ29udHJvbH0gaW50byBvbmUgb2JqZWN0LFxuICAgICAqIHdpdGggZWFjaCBjb250cm9sIG5hbWUgYXMgdGhlIGtleS4gIEl0IGNhbGN1bGF0ZXMgaXRzIHN0YXR1cyBieSByZWR1Y2luZyB0aGUgc3RhdHVzZXNcbiAgICAgKiBvZiBpdHMgY2hpbGRyZW4uIEZvciBleGFtcGxlLCBpZiBvbmUgb2YgdGhlIGNvbnRyb2xzIGluIGEgZ3JvdXAgaXMgaW52YWxpZCwgdGhlIGVudGlyZVxuICAgICAqIGdyb3VwIGJlY29tZXMgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIGBGb3JtR3JvdXBgIGlzIG9uZSBvZiB0aGUgdGhyZWUgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2tzIHVzZWQgdG8gZGVmaW5lIGZvcm1zIGluIEFuZ3VsYXIsXG4gICAgICogYWxvbmcgd2l0aCB7QGxpbmsgRm9ybUNvbnRyb2x9IGFuZCB7QGxpbmsgRm9ybUFycmF5fS5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogV2hlbiBpbnN0YW50aWF0aW5nIGEge0BsaW5rIEZvcm1Hcm91cH0sIHBhc3MgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkIGNvbnRyb2xzIGFzIHRoZSBmaXJzdFxuICAgICAqIGFyZ3VtZW50LiBUaGUga2V5IGZvciBlYWNoIGNoaWxkIHdpbGwgYmUgdGhlIG5hbWUgdW5kZXIgd2hpY2ggaXQgaXMgcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICogICBmaXJzdDogbmV3IEZvcm1Db250cm9sKCdOYW5jeScsIFZhbGlkYXRvcnMubWluTGVuZ3RoKDIpKSxcbiAgICAgKiAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgnRHJldycpLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OyAnRHJldyd9XG4gICAgICogY29uc29sZS5sb2coZm9ybS5zdGF0dXMpOyAgLy8gJ1ZBTElEJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogWW91IGNhbiBhbHNvIGluY2x1ZGUgZ3JvdXAtbGV2ZWwgdmFsaWRhdG9ycyBhcyB0aGUgc2Vjb25kIGFyZywgb3IgZ3JvdXAtbGV2ZWwgYXN5bmNcbiAgICAgKiB2YWxpZGF0b3JzIGFzIHRoZSB0aGlyZCBhcmcuIFRoZXNlIGNvbWUgaW4gaGFuZHkgd2hlbiB5b3Ugd2FudCB0byBwZXJmb3JtIHZhbGlkYXRpb25cbiAgICAgKiB0aGF0IGNvbnNpZGVycyB0aGUgdmFsdWUgb2YgbW9yZSB0aGFuIG9uZSBjaGlsZCBjb250cm9sLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIHBhc3N3b3JkOiBuZXcgRm9ybUNvbnRyb2woJycsIFZhbGlkYXRvcnMubWluTGVuZ3RoKDIpKSxcbiAgICAgKiAgIHBhc3N3b3JkQ29uZmlybTogbmV3IEZvcm1Db250cm9sKCcnLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gICAgICogfSwgcGFzc3dvcmRNYXRjaFZhbGlkYXRvcik7XG4gICAgICpcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHBhc3N3b3JkTWF0Y2hWYWxpZGF0b3IoZzogRm9ybUdyb3VwKSB7XG4gICAgICogICAgcmV0dXJuIGcuZ2V0KCdwYXNzd29yZCcpLnZhbHVlID09PSBnLmdldCgncGFzc3dvcmRDb25maXJtJykudmFsdWVcbiAgICAgKiAgICAgICA/IG51bGwgOiB7J21pc21hdGNoJzogdHJ1ZX07XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRm9ybUdyb3VwLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtR3JvdXAoY29udHJvbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3IgPT09IHZvaWQgMCkgeyBhc3luY1ZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgICAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRVcENvbnRyb2xzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXJzIGEgY29udHJvbCB3aXRoIHRoZSBncm91cCdzIGxpc3Qgb2YgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVwZGF0ZSB2YWx1ZSBvciB2YWxpZGl0eSBvZiB0aGUgY29udHJvbCwgc28gZm9yXG4gICAgICAgICAqIG1vc3QgY2FzZXMgeW91J2xsIHdhbnQgdG8gdXNlIHtAbGluayBGb3JtR3JvdXAuYWRkQ29udHJvbH0gaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUucmVnaXN0ZXJDb250cm9sID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW25hbWVdKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzW25hbWVdO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sc1tuYW1lXSA9IGNvbnRyb2w7XG4gICAgICAgICAgICBjb250cm9sLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIGNvbnRyb2wgdG8gdGhpcyBncm91cC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIChuYW1lLCBjb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbChuYW1lLCBjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSBjb250cm9sIGZyb20gdGhpcyBncm91cC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tuYW1lXSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgZGVsZXRlICh0aGlzLmNvbnRyb2xzW25hbWVdKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBsYWNlIGFuIGV4aXN0aW5nIGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnNldENvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSwgY29udHJvbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1tuYW1lXS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSAodGhpcy5jb250cm9sc1tuYW1lXSk7XG4gICAgICAgICAgICBpZiAoY29udHJvbClcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbChuYW1lLCBjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB3aGV0aGVyIHRoZXJlIGlzIGFuIGVuYWJsZWQgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBuYW1lIGluIHRoZSBncm91cC5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIGRpc2FibGVkIGNvbnRyb2xzLiBJZiB5b3UnZCBsaWtlIHRvIGNoZWNrIGZvclxuICAgICAgICAgKiBleGlzdGVuY2UgaW4gdGhlIGdyb3VwIG9ubHksIHVzZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLmdldH0gaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udHJvbE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLmhhc093blByb3BlcnR5KGNvbnRyb2xOYW1lKSAmJiB0aGlzLmNvbnRyb2xzW2NvbnRyb2xOYW1lXS5lbmFibGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogIFNldHMgdGhlIHZhbHVlIG9mIHRoZSB7QGxpbmsgRm9ybUdyb3VwfS4gSXQgYWNjZXB0cyBhbiBvYmplY3QgdGhhdCBtYXRjaGVzXG4gICAgICAgICAqICB0aGUgc3RydWN0dXJlIG9mIHRoZSBncm91cCwgd2l0aCBjb250cm9sIG5hbWVzIGFzIGtleXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHN0cmljdCBjaGVja3MsIHNvIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgeW91IHRyeVxuICAgICAgICAgKiB0byBzZXQgdGhlIHZhbHVlIG9mIGEgY29udHJvbCB0aGF0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgeW91IGV4Y2x1ZGUgdGhlXG4gICAgICAgICAqIHZhbHVlIG9mIGEgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgICAgICogICAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgICAgICogICAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICAgICAqICB9KTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogbnVsbCwgbGFzdDogbnVsbH1cbiAgICAgICAgICpcbiAgICAgICAgICogIGZvcm0uc2V0VmFsdWUoe2ZpcnN0OiAnTmFuY3knLCBsYXN0OiAnRHJldyd9KTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogJ05hbmN5JywgbGFzdDogJ0RyZXcnfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0FsbFZhbHVlc1ByZXNlbnQodmFsdWUpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGhyb3dJZkNvbnRyb2xNaXNzaW5nKG5hbWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2xzW25hbWVdLnNldFZhbHVlKHZhbHVlW25hbWVdLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBQYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGUge0BsaW5rIEZvcm1Hcm91cH0uIEl0IGFjY2VwdHMgYW4gb2JqZWN0IHdpdGggY29udHJvbFxuICAgICAgICAgKiAgbmFtZXMgYXMga2V5cywgYW5kIHdpbGwgZG8gaXRzIGJlc3QgdG8gbWF0Y2ggdGhlIHZhbHVlcyB0byB0aGUgY29ycmVjdCBjb250cm9sc1xuICAgICAgICAgKiAgaW4gdGhlIGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgSXQgYWNjZXB0cyBib3RoIHN1cGVyLXNldHMgYW5kIHN1Yi1zZXRzIG9mIHRoZSBncm91cCB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgICAgKiAgICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbGFzdDogbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIH0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiBudWxsLCBsYXN0OiBudWxsfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgZm9ybS5wYXRjaFZhbHVlKHtmaXJzdDogJ05hbmN5J30pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OiBudWxsfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnBhdGNoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRyb2xzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2xzW25hbWVdLnBhdGNoVmFsdWUodmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUge0BsaW5rIEZvcm1Hcm91cH0uIFRoaXMgbWVhbnMgYnkgZGVmYXVsdDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBUaGUgZ3JvdXAgYW5kIGFsbCBkZXNjZW5kYW50cyBhcmUgbWFya2VkIGBwcmlzdGluZWBcbiAgICAgICAgICogKiBUaGUgZ3JvdXAgYW5kIGFsbCBkZXNjZW5kYW50cyBhcmUgbWFya2VkIGB1bnRvdWNoZWRgXG4gICAgICAgICAqICogVGhlIHZhbHVlIG9mIGFsbCBkZXNjZW5kYW50cyB3aWxsIGJlIG51bGwgb3IgbnVsbCBtYXBzXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWxzbyByZXNldCB0byBhIHNwZWNpZmljIGZvcm0gc3RhdGUgYnkgcGFzc2luZyBpbiBhIG1hcCBvZiBzdGF0ZXNcbiAgICAgICAgICogdGhhdCBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgeW91ciBmb3JtLCB3aXRoIGNvbnRyb2wgbmFtZXMgYXMga2V5cy4gVGhlIHN0YXRlXG4gICAgICAgICAqIGNhbiBiZSBhIHN0YW5kYWxvbmUgdmFsdWUgb3IgYSBmb3JtIHN0YXRlIG9iamVjdCB3aXRoIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZFxuICAgICAgICAgKiBzdGF0dXMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIHRoaXMuZm9ybS5yZXNldCh7Zmlyc3Q6ICduYW1lJywgbGFzdDogJ2xhc3QgbmFtZSd9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5mb3JtLnZhbHVlKTsgIC8vIHtmaXJzdDogJ25hbWUnLCBsYXN0OiAnbGFzdCBuYW1lJ31cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIC0gT1IgLVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogdGhpcy5mb3JtLnJlc2V0KHtcbiAgICAgICAgICogICBmaXJzdDoge3ZhbHVlOiAnbmFtZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgICAgICogICBsYXN0OiAnbGFzdCdcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuZm9ybS52YWx1ZSk7ICAvLyB7Zmlyc3Q6ICduYW1lJywgbGFzdDogJ2xhc3QgbmFtZSd9XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuZm9ybS5nZXQoJ2ZpcnN0Jykuc3RhdHVzKTsgIC8vICdESVNBQkxFRCdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB7fTsgfVxuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucmVzZXQodmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGUge0BsaW5rIEZvcm1Hcm91cH0sIGluY2x1ZGluZyBhbnkgZGlzYWJsZWQgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSdkIGxpa2UgdG8gaW5jbHVkZSBhbGwgdmFsdWVzIHJlZ2FyZGxlc3Mgb2YgZGlzYWJsZWQgc3RhdHVzLCB1c2UgdGhpcyBtZXRob2QuXG4gICAgICAgICAqIE90aGVyd2lzZSwgdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgdGhlIGJlc3Qgd2F5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIGdyb3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5nZXRSYXdWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VDaGlsZHJlbih7fSwgZnVuY3Rpb24gKGFjYywgY29udHJvbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IGNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX3Rocm93SWZDb250cm9sTWlzc2luZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgICAgVGhlcmUgYXJlIG5vIGZvcm0gY29udHJvbHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgZ3JvdXAgeWV0LiAgSWYgeW91J3JlIHVzaW5nIG5nTW9kZWwsXFxuICAgICAgICB5b3UgbWF5IHdhbnQgdG8gY2hlY2sgbmV4dCB0aWNrIChlLmcuIHVzZSBzZXRUaW1lb3V0KS5cXG4gICAgICBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udHJvbHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBmb3JtIGNvbnRyb2wgd2l0aCBuYW1lOiBcIiArIG5hbWUgKyBcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb250cm9scykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyByZXR1cm4gY2IoX3RoaXMuY29udHJvbHNba10sIGspOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9zZXRVcENvbnRyb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KF90aGlzKTtcbiAgICAgICAgICAgICAgICBjb250cm9sLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShfdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92YWx1ZSA9IHRoaXMuX3JlZHVjZVZhbHVlKCk7IH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fYW55Q29udHJvbHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHJlcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzIHx8IChfdGhpcy5jb250YWlucyhuYW1lKSAmJiBjb25kaXRpb24oY29udHJvbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX3JlZHVjZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VDaGlsZHJlbih7fSwgZnVuY3Rpb24gKGFjYywgY29udHJvbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLmVuYWJsZWQgfHwgX3RoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX3JlZHVjZUNoaWxkcmVuID0gZnVuY3Rpb24gKGluaXRWYWx1ZSwgZm4pIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBpbml0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHsgcmVzID0gZm4ocmVzLCBjb250cm9sLCBuYW1lKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX2FsbENvbnRyb2xzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXModGhpcy5jb250cm9scyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xOYW1lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW2NvbnRyb2xOYW1lXS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jb250cm9scykubGVuZ3RoID4gMCB8fCB0aGlzLmRpc2FibGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX2NoZWNrQWxsVmFsdWVzUHJlc2VudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzdXBwbHkgYSB2YWx1ZSBmb3IgZm9ybSBjb250cm9sIHdpdGggbmFtZTogJ1wiICsgbmFtZSArIFwiJy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtR3JvdXA7XG4gICAgfShBYnN0cmFjdENvbnRyb2wpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBUcmFja3MgdGhlIHZhbHVlIGFuZCB2YWxpZGl0eSBzdGF0ZSBvZiBhbiBhcnJheSBvZiB7QGxpbmsgRm9ybUNvbnRyb2x9XG4gICAgICogaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQSBgRm9ybUFycmF5YCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXMgb2YgZWFjaCBjaGlsZCB7QGxpbmsgRm9ybUNvbnRyb2x9IGludG8gYW4gYXJyYXkuXG4gICAgICogSXQgY2FsY3VsYXRlcyBpdHMgc3RhdHVzIGJ5IHJlZHVjaW5nIHRoZSBzdGF0dXNlcyBvZiBpdHMgY2hpbGRyZW4uIEZvciBleGFtcGxlLCBpZiBvbmUgb2ZcbiAgICAgKiB0aGUgY29udHJvbHMgaW4gYSBgRm9ybUFycmF5YCBpcyBpbnZhbGlkLCB0aGUgZW50aXJlIGFycmF5IGJlY29tZXMgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIGBGb3JtQXJyYXlgIGlzIG9uZSBvZiB0aGUgdGhyZWUgZnVuZGFtZW50YWwgYnVpbGRpbmcgYmxvY2tzIHVzZWQgdG8gZGVmaW5lIGZvcm1zIGluIEFuZ3VsYXIsXG4gICAgICogYWxvbmcgd2l0aCB7QGxpbmsgRm9ybUNvbnRyb2x9IGFuZCB7QGxpbmsgRm9ybUdyb3VwfS5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogV2hlbiBpbnN0YW50aWF0aW5nIGEge0BsaW5rIEZvcm1BcnJheX0sIHBhc3MgaW4gYW4gYXJyYXkgb2YgY2hpbGQgY29udHJvbHMgYXMgdGhlIGZpcnN0XG4gICAgICogYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICogICBuZXcgRm9ybUNvbnRyb2woJ05hbmN5JywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqICAgbmV3IEZvcm1Db250cm9sKCdEcmV3JyksXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFsnTmFuY3knLCAnRHJldyddXG4gICAgICogY29uc29sZS5sb2coYXJyLnN0YXR1cyk7ICAvLyAnVkFMSUQnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gaW5jbHVkZSBhcnJheS1sZXZlbCB2YWxpZGF0b3JzIGFzIHRoZSBzZWNvbmQgYXJnLCBvciBhcnJheS1sZXZlbCBhc3luY1xuICAgICAqIHZhbGlkYXRvcnMgYXMgdGhlIHRoaXJkIGFyZy4gVGhlc2UgY29tZSBpbiBoYW5keSB3aGVuIHlvdSB3YW50IHRvIHBlcmZvcm0gdmFsaWRhdGlvblxuICAgICAqIHRoYXQgY29uc2lkZXJzIHRoZSB2YWx1ZSBvZiBtb3JlIHRoYW4gb25lIGNoaWxkIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiAjIyMgQWRkaW5nIG9yIHJlbW92aW5nIGNvbnRyb2xzXG4gICAgICpcbiAgICAgKiBUbyBjaGFuZ2UgdGhlIGNvbnRyb2xzIGluIHRoZSBhcnJheSwgdXNlIHRoZSBgcHVzaGAsIGBpbnNlcnRgLCBvciBgcmVtb3ZlQXRgIG1ldGhvZHNcbiAgICAgKiBpbiBgRm9ybUFycmF5YCBpdHNlbGYuIFRoZXNlIG1ldGhvZHMgZW5zdXJlIHRoZSBjb250cm9scyBhcmUgcHJvcGVybHkgdHJhY2tlZCBpbiB0aGVcbiAgICAgKiBmb3JtJ3MgaGllcmFyY2h5LiBEbyBub3QgbW9kaWZ5IHRoZSBhcnJheSBvZiBgQWJzdHJhY3RDb250cm9sYHMgdXNlZCB0byBpbnN0YW50aWF0ZVxuICAgICAqIHRoZSBgRm9ybUFycmF5YCBkaXJlY3RseSwgYXMgdGhhdCB3aWxsIHJlc3VsdCBpbiBzdHJhbmdlIGFuZCB1bmV4cGVjdGVkIGJlaGF2aW9yIHN1Y2hcbiAgICAgKiBhcyBicm9rZW4gY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1BcnJheSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KEZvcm1BcnJheSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUFycmF5KGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgICAgIHRoaXMuX2luaXRPYnNlcnZhYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5fc2V0VXBDb250cm9scygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbH0gYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250cm9sc1tpbmRleF07IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnQgYSBuZXcge0BsaW5rIEFic3RyYWN0Q29udHJvbH0gYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5wdXNoKGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCBhIG5ldyB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgY29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5zcGxpY2UoaW5kZXgsIDAsIGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgY29udHJvbCBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnJlbW92ZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tpbmRleF0pXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1tpbmRleF0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwbGFjZSBhbiBleGlzdGluZyBjb250cm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5zZXRDb250cm9sID0gZnVuY3Rpb24gKGluZGV4LCBjb250cm9sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tpbmRleF0pXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1tpbmRleF0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBpZiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAwLCBjb250cm9sKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlckNvbnRyb2woY29udHJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5LnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMZW5ndGggb2YgdGhlIGNvbnRyb2wgYXJyYXkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9scy5sZW5ndGg7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogIFNldHMgdGhlIHZhbHVlIG9mIHRoZSB7QGxpbmsgRm9ybUFycmF5fS4gSXQgYWNjZXB0cyBhbiBhcnJheSB0aGF0IG1hdGNoZXNcbiAgICAgICAgICogIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHN0cmljdCBjaGVja3MsIHNvIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgeW91IHRyeVxuICAgICAgICAgKiB0byBzZXQgdGhlIHZhbHVlIG9mIGEgY29udHJvbCB0aGF0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgeW91IGV4Y2x1ZGUgdGhlXG4gICAgICAgICAqIHZhbHVlIG9mIGEgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogIGNvbnN0IGFyciA9IG5ldyBGb3JtQXJyYXkoW1xuICAgICAgICAgKiAgICAgbmV3IEZvcm1Db250cm9sKCksXG4gICAgICAgICAqICAgICBuZXcgRm9ybUNvbnRyb2woKVxuICAgICAgICAgKiAgXSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFtudWxsLCBudWxsXVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYXJyLnNldFZhbHVlKFsnTmFuY3knLCAnRHJldyddKTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gWydOYW5jeScsICdEcmV3J11cbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tBbGxWYWx1ZXNQcmVzZW50KHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKG5ld1ZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl90aHJvd0lmQ29udHJvbE1pc3NpbmcoaW5kZXgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmF0KGluZGV4KS5zZXRWYWx1ZShuZXdWYWx1ZSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgUGF0Y2hlcyB0aGUgdmFsdWUgb2YgdGhlIHtAbGluayBGb3JtQXJyYXl9LiBJdCBhY2NlcHRzIGFuIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGVcbiAgICAgICAgICogIHN0cnVjdHVyZSBvZiB0aGUgY29udHJvbCwgYW5kIHdpbGwgZG8gaXRzIGJlc3QgdG8gbWF0Y2ggdGhlIHZhbHVlcyB0byB0aGUgY29ycmVjdFxuICAgICAgICAgKiAgY29udHJvbHMgaW4gdGhlIGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgSXQgYWNjZXB0cyBib3RoIHN1cGVyLXNldHMgYW5kIHN1Yi1zZXRzIG9mIHRoZSBhcnJheSB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICAgICAqICAgICBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgICAgICogICAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICAgICAqICBdKTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gW251bGwsIG51bGxdXG4gICAgICAgICAqXG4gICAgICAgICAqICBhcnIucGF0Y2hWYWx1ZShbJ05hbmN5J10pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgbnVsbF1cbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5wYXRjaFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChuZXdWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXQoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0KGluZGV4KS5wYXRjaFZhbHVlKG5ld1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIHtAbGluayBGb3JtQXJyYXl9LiBUaGlzIG1lYW5zIGJ5IGRlZmF1bHQ6XG4gICAgICAgICAqXG4gICAgICAgICAqICogVGhlIGFycmF5IGFuZCBhbGwgZGVzY2VuZGFudHMgYXJlIG1hcmtlZCBgcHJpc3RpbmVgXG4gICAgICAgICAqICogVGhlIGFycmF5IGFuZCBhbGwgZGVzY2VuZGFudHMgYXJlIG1hcmtlZCBgdW50b3VjaGVkYFxuICAgICAgICAgKiAqIFRoZSB2YWx1ZSBvZiBhbGwgZGVzY2VuZGFudHMgd2lsbCBiZSBudWxsIG9yIG51bGwgbWFwc1xuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgY2FuIGFsc28gcmVzZXQgdG8gYSBzcGVjaWZpYyBmb3JtIHN0YXRlIGJ5IHBhc3NpbmcgaW4gYW4gYXJyYXkgb2Ygc3RhdGVzXG4gICAgICAgICAqIHRoYXQgbWF0Y2hlcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBjb250cm9sLiBUaGUgc3RhdGUgY2FuIGJlIGEgc3RhbmRhbG9uZSB2YWx1ZVxuICAgICAgICAgKiBvciBhIGZvcm0gc3RhdGUgb2JqZWN0IHdpdGggYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkIHN0YXR1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogdGhpcy5hcnIucmVzZXQoWyduYW1lJywgJ2xhc3QgbmFtZSddKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5hcnIudmFsdWUpOyAgLy8gWyduYW1lJywgJ2xhc3QgbmFtZSddXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiAtIE9SIC1cbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHRoaXMuYXJyLnJlc2V0KFtcbiAgICAgICAgICogICB7dmFsdWU6ICduYW1lJywgZGlzYWJsZWQ6IHRydWV9LFxuICAgICAgICAgKiAgICdsYXN0J1xuICAgICAgICAgKiBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5hcnIudmFsdWUpOyAgLy8gWyduYW1lJywgJ2xhc3QgbmFtZSddXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuYXJyLmdldCgwKS5zdGF0dXMpOyAgLy8gJ0RJU0FCTEVEJ1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IFtdOyB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucmVzZXQodmFsdWVbaW5kZXhdLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByaXN0aW5lKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgdGhlIGFycmF5LCBpbmNsdWRpbmcgYW55IGRpc2FibGVkIGNvbnRyb2xzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB5b3UnZCBsaWtlIHRvIGluY2x1ZGUgYWxsIHZhbHVlcyByZWdhcmRsZXNzIG9mIGRpc2FibGVkIHN0YXR1cywgdXNlIHRoaXMgbWV0aG9kLlxuICAgICAgICAgKiBPdGhlcndpc2UsIHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIHRoZSBiZXN0IHdheSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuZ2V0UmF3VmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2xzLm1hcChmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC52YWx1ZTsgfSk7IH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fdGhyb3dJZkNvbnRyb2xNaXNzaW5nID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udHJvbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgICBUaGVyZSBhcmUgbm8gZm9ybSBjb250cm9scyByZWdpc3RlcmVkIHdpdGggdGhpcyBhcnJheSB5ZXQuICBJZiB5b3UncmUgdXNpbmcgbmdNb2RlbCxcXG4gICAgICAgIHlvdSBtYXkgd2FudCB0byBjaGVjayBuZXh0IHRpY2sgKGUuZy4gdXNlIHNldFRpbWVvdXQpLlxcbiAgICAgIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5hdChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBmb3JtIGNvbnRyb2wgYXQgaW5kZXggXCIgKyBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2wsIGluZGV4KSB7IGNiKGNvbnRyb2wsIGluZGV4KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLmNvbnRyb2xzLmZpbHRlcihmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC5lbmFibGVkIHx8IF90aGlzLmRpc2FibGVkOyB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wudmFsdWU7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX2FueUNvbnRyb2xzID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMuc29tZShmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC5lbmFibGVkICYmIGNvbmRpdGlvbihjb250cm9sKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fc2V0VXBDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIF90aGlzLl9yZWdpc3RlckNvbnRyb2woY29udHJvbCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX2NoZWNrQWxsVmFsdWVzUHJlc2VudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzdXBwbHkgYSB2YWx1ZSBmb3IgZm9ybSBjb250cm9sIGF0IGluZGV4OiBcIiArIGkgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fYWxsQ29udHJvbHNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNvbnRyb2xzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLmVuYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLmxlbmd0aCA+IDAgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fcmVnaXN0ZXJDb250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UodGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1BcnJheTtcbiAgICB9KEFic3RyYWN0Q29udHJvbCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBmb3JtRGlyZWN0aXZlUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdGb3JtOyB9KVxuICAgIH07XG4gICAgdmFyIHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBDcmVhdGVzIGEgdG9wLWxldmVsIHtAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIGFuZCBiaW5kcyBpdCB0byBhIGZvcm1cbiAgICAgKiB0byB0cmFjayBhZ2dyZWdhdGUgZm9ybSB2YWx1ZSBhbmQgdmFsaWRhdGlvbiBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIEFzIHNvb24gYXMgeW91IGltcG9ydCB0aGUgYEZvcm1zTW9kdWxlYCwgdGhpcyBkaXJlY3RpdmUgYmVjb21lcyBhY3RpdmUgYnkgZGVmYXVsdCBvblxuICAgICAqIGFsbCBgPGZvcm0+YCB0YWdzLiAgWW91IGRvbid0IG5lZWQgdG8gYWRkIGEgc3BlY2lhbCBzZWxlY3Rvci5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gZXhwb3J0IHRoZSBkaXJlY3RpdmUgaW50byBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ0Zvcm1gIGFzIHRoZSBrZXlcbiAgICAgKiAoZXg6IGAjbXlGb3JtPVwibmdGb3JtXCJgKS4gVGhpcyBpcyBvcHRpb25hbCwgYnV0IHVzZWZ1bC4gIE1hbnkgcHJvcGVydGllcyBmcm9tIHRoZSB1bmRlcmx5aW5nXG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgYXJlIGR1cGxpY2F0ZWQgb24gdGhlIGRpcmVjdGl2ZSBpdHNlbGYsIHNvIGEgcmVmZXJlbmNlIHRvIGl0XG4gICAgICogd2lsbCBnaXZlIHlvdSBhY2Nlc3MgdG8gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBhbmQgdmFsaWRpdHkgc3RhdHVzIG9mIHRoZSBmb3JtLCBhcyB3ZWxsIGFzXG4gICAgICogdXNlciBpbnRlcmFjdGlvbiBwcm9wZXJ0aWVzIGxpa2UgYGRpcnR5YCBhbmQgYHRvdWNoZWRgLlxuICAgICAqXG4gICAgICogVG8gcmVnaXN0ZXIgY2hpbGQgY29udHJvbHMgd2l0aCB0aGUgZm9ybSwgeW91J2xsIHdhbnQgdG8gdXNlIHtAbGluayBOZ01vZGVsfSB3aXRoIGFcbiAgICAgKiBgbmFtZWAgYXR0cmlidXRlLiAgWW91IGNhbiBhbHNvIHVzZSB7QGxpbmsgTmdNb2RlbEdyb3VwfSBpZiB5b3UnZCBsaWtlIHRvIGNyZWF0ZVxuICAgICAqIHN1Yi1ncm91cHMgd2l0aGluIHRoZSBmb3JtLlxuICAgICAqXG4gICAgICogWW91IGNhbiBsaXN0ZW4gdG8gdGhlIGRpcmVjdGl2ZSdzIGBuZ1N1Ym1pdGAgZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdXNlciBoYXNcbiAgICAgKiB0cmlnZ2VyZWQgYSBmb3JtIHN1Ym1pc3Npb24uIFRoZSBgbmdTdWJtaXRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aXRoIHRoZSBvcmlnaW5hbCBmb3JtXG4gICAgICogc3VibWlzc2lvbiBldmVudC5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtL3NpbXBsZV9mb3JtX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0Zvcm0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNChOZ0Zvcm0sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nRm9ybSh2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5nU3VibWl0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5mb3JtID1cbiAgICAgICAgICAgICAgICBuZXcgRm9ybUdyb3VwKHt9LCBjb21wb3NlVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSwgY29tcG9zZUFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcnMpKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJzdWJtaXR0ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdWJtaXR0ZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JtLnByb3RvdHlwZSwgXCJjb250cm9sc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybS5jb250cm9sczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBkaXIuX2NvbnRyb2wgPSBjb250YWluZXIucmVnaXN0ZXJDb250cm9sKGRpci5uYW1lLCBkaXIuY29udHJvbCk7XG4gICAgICAgICAgICAgICAgc2V0VXBDb250cm9sKGRpci5jb250cm9sLCBkaXIpO1xuICAgICAgICAgICAgICAgIGRpci5jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuZ2V0Q29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpOyB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ29udHJvbChkaXIubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuYWRkRm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IG5ldyBGb3JtR3JvdXAoe30pO1xuICAgICAgICAgICAgICAgIHNldFVwRm9ybUNvbnRhaW5lcihncm91cCwgZGlyKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVnaXN0ZXJDb250cm9sKGRpci5uYW1lLCBncm91cCk7XG4gICAgICAgICAgICAgICAgZ3JvdXAudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5yZW1vdmVGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ29udHJvbChkaXIubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuZ2V0Rm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoZGlyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3RybCA9IF90aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuY29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUub25TdWJtaXQgPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdC5lbWl0KCRldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUub25SZXNldCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5yZXNldEZvcm0oKTsgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5yZXNldEZvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICB0aGlzLmZvcm0ucmVzZXQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5fZmluZENvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID8gdGhpcy5mb3JtLmdldChwYXRoKSA6IHRoaXMuZm9ybTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdmb3JtOm5vdChbbmdOb0Zvcm1dKTpub3QoW2Zvcm1Hcm91cF0pLG5nRm9ybSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtmb3JtRGlyZWN0aXZlUHJvdmlkZXJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKHN1Ym1pdCknOiAnb25TdWJtaXQoJGV2ZW50KScsICcocmVzZXQpJzogJ29uUmVzZXQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFsnbmdTdWJtaXQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nRm9ybS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nRm9ybTtcbiAgICB9KENvbnRyb2xDb250YWluZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgRXhhbXBsZXMgPSB7XG4gICAgICAgIGZvcm1Db250cm9sTmFtZTogXCJcXG4gICAgPGRpdiBbZm9ybUdyb3VwXT1cXFwibXlHcm91cFxcXCI+XFxuICAgICAgPGlucHV0IGZvcm1Db250cm9sTmFtZT1cXFwiZmlyc3ROYW1lXFxcIj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgICBmaXJzdE5hbWU6IG5ldyBGb3JtQ29udHJvbCgpXFxuICAgIH0pO1wiLFxuICAgICAgICBmb3JtR3JvdXBOYW1lOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICAgPGRpdiBmb3JtR3JvdXBOYW1lPVxcXCJwZXJzb25cXFwiPlxcbiAgICAgICAgICA8aW5wdXQgZm9ybUNvbnRyb2xOYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgICBwZXJzb246IG5ldyBGb3JtR3JvdXAoeyBmaXJzdE5hbWU6IG5ldyBGb3JtQ29udHJvbCgpIH0pXFxuICAgIH0pO1wiLFxuICAgICAgICBmb3JtQXJyYXlOYW1lOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICA8ZGl2IGZvcm1BcnJheU5hbWU9XFxcImNpdGllc1xcXCI+XFxuICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IGNpdHkgb2YgY2l0eUFycmF5LmNvbnRyb2xzOyBsZXQgaT1pbmRleFxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBbZm9ybUNvbnRyb2xOYW1lXT1cXFwiaVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMuY2l0eUFycmF5ID0gbmV3IEZvcm1BcnJheShbbmV3IEZvcm1Db250cm9sKCdTRicpXSk7XFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgIGNpdGllczogdGhpcy5jaXR5QXJyYXlcXG4gICAgfSk7XCIsXG4gICAgICAgIG5nTW9kZWxHcm91cDogXCJcXG4gICAgPGZvcm0+XFxuICAgICAgIDxkaXYgbmdNb2RlbEdyb3VwPVxcXCJwZXJzb25cXFwiPlxcbiAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcInBlcnNvbi5uYW1lXFxcIiBuYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICAgICA8L2Rpdj5cXG4gICAgPC9mb3JtPlwiLFxuICAgICAgICBuZ01vZGVsV2l0aEZvcm1Hcm91cDogXCJcXG4gICAgPGRpdiBbZm9ybUdyb3VwXT1cXFwibXlHcm91cFxcXCI+XFxuICAgICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XFxcImZpcnN0TmFtZVxcXCI+XFxuICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwic2hvd01vcmVDb250cm9sc1xcXCIgW25nTW9kZWxPcHRpb25zXT1cXFwie3N0YW5kYWxvbmU6IHRydWV9XFxcIj5cXG4gICAgPC9kaXY+XFxuICBcIlxuICAgIH07XG5cbiAgICB2YXIgVGVtcGxhdGVEcml2ZW5FcnJvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZURyaXZlbkVycm9ycygpIHtcbiAgICAgICAgfVxuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5tb2RlbFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgIG5nTW9kZWwgY2Fubm90IGJlIHVzZWQgdG8gcmVnaXN0ZXIgZm9ybSBjb250cm9scyB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBUcnkgdXNpbmdcXG4gICAgICBmb3JtR3JvdXAncyBwYXJ0bmVyIGRpcmVjdGl2ZSBcXFwiZm9ybUNvbnRyb2xOYW1lXFxcIiBpbnN0ZWFkLiAgRXhhbXBsZTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Db250cm9sTmFtZSArIFwiXFxuXFxuICAgICAgT3IsIGlmIHlvdSdkIGxpa2UgdG8gYXZvaWQgcmVnaXN0ZXJpbmcgdGhpcyBmb3JtIGNvbnRyb2wsIGluZGljYXRlIHRoYXQgaXQncyBzdGFuZGFsb25lIGluIG5nTW9kZWxPcHRpb25zOlxcblxcbiAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsV2l0aEZvcm1Hcm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLmZvcm1Hcm91cE5hbWVFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBuZ01vZGVsIGNhbm5vdCBiZSB1c2VkIHRvIHJlZ2lzdGVyIGZvcm0gY29udHJvbHMgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXBOYW1lIG9yIGZvcm1BcnJheU5hbWUgZGlyZWN0aXZlLlxcblxcbiAgICAgIE9wdGlvbiAxOiBVc2UgZm9ybUNvbnRyb2xOYW1lIGluc3RlYWQgb2YgbmdNb2RlbCAocmVhY3RpdmUgc3RyYXRlZ3kpOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSArIFwiXFxuXFxuICAgICAgT3B0aW9uIDI6ICBVcGRhdGUgbmdNb2RlbCdzIHBhcmVudCBiZSBuZ01vZGVsR3JvdXAgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSk6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsR3JvdXApO1xuICAgICAgICB9O1xuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5taXNzaW5nTmFtZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklmIG5nTW9kZWwgaXMgdXNlZCB3aXRoaW4gYSBmb3JtIHRhZywgZWl0aGVyIHRoZSBuYW1lIGF0dHJpYnV0ZSBtdXN0IGJlIHNldCBvciB0aGUgZm9ybVxcbiAgICAgIGNvbnRyb2wgbXVzdCBiZSBkZWZpbmVkIGFzICdzdGFuZGFsb25lJyBpbiBuZ01vZGVsT3B0aW9ucy5cXG5cXG4gICAgICBFeGFtcGxlIDE6IDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwicGVyc29uLmZpcnN0TmFtZVxcXCIgbmFtZT1cXFwiZmlyc3RcXFwiPlxcbiAgICAgIEV4YW1wbGUgMjogPGlucHV0IFsobmdNb2RlbCldPVxcXCJwZXJzb24uZmlyc3ROYW1lXFxcIiBbbmdNb2RlbE9wdGlvbnNdPVxcXCJ7c3RhbmRhbG9uZTogdHJ1ZX1cXFwiPlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubW9kZWxHcm91cFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgIG5nTW9kZWxHcm91cCBjYW5ub3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuXFxuXFxuICAgICAgT3B0aW9uIDE6IFVzZSBmb3JtR3JvdXBOYW1lIGluc3RlYWQgb2YgbmdNb2RlbEdyb3VwIChyZWFjdGl2ZSBzdHJhdGVneSk6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtR3JvdXBOYW1lICsgXCJcXG5cXG4gICAgICBPcHRpb24gMjogIFVzZSBhIHJlZ3VsYXIgZm9ybSB0YWcgaW5zdGVhZCBvZiB0aGUgZm9ybUdyb3VwIGRpcmVjdGl2ZSAodGVtcGxhdGUtZHJpdmVuIHN0cmF0ZWd5KTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLm5nTW9kZWxHcm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZURyaXZlbkVycm9ycztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBtb2RlbEdyb3VwUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdNb2RlbEdyb3VwOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhbmQgYmluZHMgYSB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIGFzIGEgY2hpbGQgb2Yge0BsaW5rIE5nRm9ybX0gKG9yIGluIG90aGVyIHdvcmRzLFxuICAgICAqIHdpdGhpbiBgPGZvcm0+YCB0YWdzKS5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGRpcmVjdGl2ZSBpZiB5b3UnZCBsaWtlIHRvIGNyZWF0ZSBhIHN1Yi1ncm91cCB3aXRoaW4gYSBmb3JtLiBUaGlzIGNhblxuICAgICAqIGNvbWUgaW4gaGFuZHkgaWYgeW91IHdhbnQgdG8gdmFsaWRhdGUgYSBzdWItZ3JvdXAgb2YgeW91ciBmb3JtIHNlcGFyYXRlbHkgZnJvbVxuICAgICAqIHRoZSByZXN0IG9mIHlvdXIgZm9ybSwgb3IgaWYgc29tZSB2YWx1ZXMgaW4geW91ciBkb21haW4gbW9kZWwgbWFrZSBtb3JlIHNlbnNlIHRvXG4gICAgICogY29uc3VtZSB0b2dldGhlciBpbiBhIG5lc3RlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBQYXNzIGluIHRoZSBuYW1lIHlvdSdkIGxpa2UgdGhpcyBzdWItZ3JvdXAgdG8gaGF2ZSBhbmQgaXQgd2lsbCBiZWNvbWUgdGhlIGtleVxuICAgICAqIGZvciB0aGUgc3ViLWdyb3VwIGluIHRoZSBmb3JtJ3MgZnVsbCB2YWx1ZS4gWW91IGNhbiBhbHNvIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG9cbiAgICAgKiBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ01vZGVsR3JvdXBgIChleDogYCNteUdyb3VwPVwibmdNb2RlbEdyb3VwXCJgKS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9uZ01vZGVsR3JvdXAvbmdfbW9kZWxfZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdNb2RlbEdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDgoTmdNb2RlbEdyb3VwLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ01vZGVsR3JvdXAocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IHZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ01vZGVsR3JvdXAucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ01vZGVsR3JvdXApICYmICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdGb3JtKSkge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1vZGVsR3JvdXBQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbEdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ01vZGVsR3JvdXBdJywgcHJvdmlkZXJzOiBbbW9kZWxHcm91cFByb3ZpZGVyXSwgZXhwb3J0QXM6ICduZ01vZGVsR3JvdXAnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdNb2RlbEdyb3VwLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ01vZGVsR3JvdXAucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbEdyb3VwJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kZWxHcm91cDtcbiAgICB9KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ3ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGZvcm1Db250cm9sQmluZGluZyA9IHtcbiAgICAgICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nTW9kZWw7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBgbmdNb2RlbGAgZm9yY2VzIGFuIGFkZGl0aW9uYWwgY2hhbmdlIGRldGVjdGlvbiBydW4gd2hlbiBpdHMgaW5wdXRzIGNoYW5nZTpcbiAgICAgKiBFLmcuOlxuICAgICAqIGBgYFxuICAgICAqIDxkaXY+e3tteU1vZGVsLnZhbGlkfX08L2Rpdj5cbiAgICAgKiA8aW5wdXQgWyhuZ01vZGVsKV09XCJteVZhbHVlXCIgI215TW9kZWw9XCJuZ01vZGVsXCI+XG4gICAgICogYGBgXG4gICAgICogSS5lLiBgbmdNb2RlbGAgY2FuIGV4cG9ydCBpdHNlbGYgb24gdGhlIGVsZW1lbnQgYW5kIHRoZW4gYmUgdXNlZCBpbiB0aGUgdGVtcGxhdGUuXG4gICAgICogTm9ybWFsbHksIHRoaXMgd291bGQgcmVzdWx0IGluIGV4cHJlc3Npb25zIGJlZm9yZSB0aGUgYGlucHV0YCB0aGF0IHVzZSB0aGUgZXhwb3J0ZWQgZGlyZWN0aXZlXG4gICAgICogdG8gaGF2ZSBhbmQgb2xkIHZhbHVlIGFzIHRoZXkgaGF2ZSBiZWVuXG4gICAgICogZGlydHkgY2hlY2tlZCBiZWZvcmUuIEFzIHRoaXMgaXMgYSB2ZXJ5IGNvbW1vbiBjYXNlIGZvciBgbmdNb2RlbGAsIHdlIGFkZGVkIHRoaXMgc2Vjb25kIGNoYW5nZVxuICAgICAqIGRldGVjdGlvbiBydW4uXG4gICAgICpcbiAgICAgKiBOb3RlczpcbiAgICAgKiAtIHRoaXMgaXMganVzdCBvbmUgZXh0cmEgcnVuIG5vIG1hdHRlciBob3cgbWFueSBgbmdNb2RlbGAgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gICAgICogLSB0aGlzIGlzIGEgZ2VuZXJhbCBwcm9ibGVtIHdoZW4gdXNpbmcgYGV4cG9ydEFzYCBmb3IgZGlyZWN0aXZlcyFcbiAgICAgKi9cbiAgICB2YXIgcmVzb2x2ZWRQcm9taXNlJDEgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgZnJvbSBhIGRvbWFpbiBtb2RlbCBhbmQgYmluZHMgaXRcbiAgICAgKiB0byBhIGZvcm0gY29udHJvbCBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhlIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2Ugd2lsbCB0cmFjayB0aGUgdmFsdWUsIHVzZXIgaW50ZXJhY3Rpb24sIGFuZFxuICAgICAqIHZhbGlkYXRpb24gc3RhdHVzIG9mIHRoZSBjb250cm9sIGFuZCBrZWVwIHRoZSB2aWV3IHN5bmNlZCB3aXRoIHRoZSBtb2RlbC4gSWYgdXNlZFxuICAgICAqIHdpdGhpbiBhIHBhcmVudCBmb3JtLCB0aGUgZGlyZWN0aXZlIHdpbGwgYWxzbyByZWdpc3RlciBpdHNlbGYgd2l0aCB0aGUgZm9ybSBhcyBhIGNoaWxkXG4gICAgICogY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgYnkgaXRzZWxmIG9yIGFzIHBhcnQgb2YgYSBsYXJnZXIgZm9ybS4gQWxsIHlvdSBuZWVkIGlzIHRoZVxuICAgICAqIGBuZ01vZGVsYCBzZWxlY3RvciB0byBhY3RpdmF0ZSBpdC5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgYSBkb21haW4gbW9kZWwgYXMgYW4gb3B0aW9uYWwge0BsaW5rIEBJbnB1dH0uIElmIHlvdSBoYXZlIGEgb25lLXdheSBiaW5kaW5nXG4gICAgICogdG8gYG5nTW9kZWxgIHdpdGggYFtdYCBzeW50YXgsIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgZG9tYWluIG1vZGVsIGluIHRoZSBjb21wb25lbnRcbiAgICAgKiBjbGFzcyB3aWxsIHNldCB0aGUgdmFsdWUgaW4gdGhlIHZpZXcuIElmIHlvdSBoYXZlIGEgdHdvLXdheSBiaW5kaW5nIHdpdGggYFsoKV1gIHN5bnRheFxuICAgICAqIChhbHNvIGtub3duIGFzICdiYW5hbmEtYm94IHN5bnRheCcpLCB0aGUgdmFsdWUgaW4gdGhlIFVJIHdpbGwgYWx3YXlzIGJlIHN5bmNlZCBiYWNrIHRvXG4gICAgICogdGhlIGRvbWFpbiBtb2RlbCBpbiB5b3VyIGNsYXNzIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2lzaCB0byBpbnNwZWN0IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBhc3NvY2lhdGVkIHtAbGluayBGb3JtQ29udHJvbH0gKGxpa2VcbiAgICAgKiB2YWxpZGl0eSBzdGF0ZSksIHlvdSBjYW4gYWxzbyBleHBvcnQgdGhlIGRpcmVjdGl2ZSBpbnRvIGEgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGUgdXNpbmdcbiAgICAgKiBgbmdNb2RlbGAgYXMgdGhlIGtleSAoZXg6IGAjbXlWYXI9XCJuZ01vZGVsXCJgKS4gWW91IGNhbiB0aGVuIGFjY2VzcyB0aGUgY29udHJvbCB1c2luZyB0aGVcbiAgICAgKiBkaXJlY3RpdmUncyBgY29udHJvbGAgcHJvcGVydHksIGJ1dCBtb3N0IHByb3BlcnRpZXMgeW91J2xsIG5lZWQgKGxpa2UgYHZhbGlkYCBhbmQgYGRpcnR5YClcbiAgICAgKiB3aWxsIGZhbGwgdGhyb3VnaCB0byB0aGUgY29udHJvbCBhbnl3YXksIHNvIHlvdSBjYW4gYWNjZXNzIHRoZW0gZGlyZWN0bHkuIFlvdSBjYW4gc2VlIGFcbiAgICAgKiBmdWxsIGxpc3Qgb2YgcHJvcGVydGllcyBkaXJlY3RseSBhdmFpbGFibGUgaW4ge0BsaW5rIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZX0uXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGlzIGFuIGV4YW1wbGUgb2YgYSBzaW1wbGUgc3RhbmRhbG9uZSBjb250cm9sIHVzaW5nIGBuZ01vZGVsYDpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVOZ01vZGVsL3NpbXBsZV9uZ19tb2RlbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIFdoZW4gdXNpbmcgdGhlIGBuZ01vZGVsYCB3aXRoaW4gYDxmb3JtPmAgdGFncywgeW91J2xsIGFsc28gbmVlZCB0byBzdXBwbHkgYSBgbmFtZWAgYXR0cmlidXRlXG4gICAgICogc28gdGhhdCB0aGUgY29udHJvbCBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBwYXJlbnQgZm9ybSB1bmRlciB0aGF0IG5hbWUuXG4gICAgICpcbiAgICAgKiBJdCdzIHdvcnRoIG5vdGluZyB0aGF0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGZvcm0sIHlvdSBvZnRlbiBjYW4gc2tpcCBvbmUtd2F5IG9yXG4gICAgICogdHdvLXdheSBiaW5kaW5nIGJlY2F1c2UgdGhlIHBhcmVudCBmb3JtIHdpbGwgc3luYyB0aGUgdmFsdWUgZm9yIHlvdS4gWW91IGNhbiBhY2Nlc3NcbiAgICAgKiBpdHMgcHJvcGVydGllcyBieSBleHBvcnRpbmcgaXQgaW50byBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ0Zvcm1gIChleDpcbiAgICAgKiBgI2Y9XCJuZ0Zvcm1cImApLiBUaGVuIHlvdSBjYW4gcGFzcyBpdCB3aGVyZSBpdCBuZWVkcyB0byBnbyBvbiBzdWJtaXQuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgZG8gbmVlZCB0byBwb3B1bGF0ZSBpbml0aWFsIHZhbHVlcyBpbnRvIHlvdXIgZm9ybSwgdXNpbmcgYSBvbmUtd2F5IGJpbmRpbmcgZm9yXG4gICAgICogYG5nTW9kZWxgIHRlbmRzIHRvIGJlIHN1ZmZpY2llbnQgYXMgbG9uZyBhcyB5b3UgdXNlIHRoZSBleHBvcnRlZCBmb3JtJ3MgdmFsdWUgcmF0aGVyXG4gICAgICogdGhhbiB0aGUgZG9tYWluIG1vZGVsJ3MgdmFsdWUgb24gc3VibWl0LlxuICAgICAqXG4gICAgICogVGFrZSBhIGxvb2sgYXQgYW4gZXhhbXBsZSBvZiB1c2luZyBgbmdNb2RlbGAgd2l0aGluIGEgZm9ybTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtL3NpbXBsZV9mb3JtX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogVG8gc2VlIGBuZ01vZGVsYCBleGFtcGxlcyB3aXRoIGRpZmZlcmVudCBmb3JtIGNvbnRyb2wgdHlwZXMsIHNlZTpcbiAgICAgKlxuICAgICAqICogUmFkaW8gYnV0dG9uczoge0BsaW5rIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3J9XG4gICAgICogKiBTZWxlY3RzOiB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9XG4gICAgICpcbiAgICAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICoqTmdNb2R1bGUqKjogYEZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdNb2RlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ3KE5nTW9kZWwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nTW9kZWwocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0ZvckVycm9ycygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWdpc3RlcmVkKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbCgpO1xuICAgICAgICAgICAgaWYgKCdpc0Rpc2FibGVkJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5mb3JtRGlyZWN0aXZlICYmIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sKHRoaXMpOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRyb2w7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpIDogW3RoaXMubmFtZV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fcmF3VmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQobmV3VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fc2V0VXBDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5faXNTdGFuZGFsb25lKCkgPyB0aGlzLl9zZXRVcFN0YW5kYWxvbmUoKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZENvbnRyb2wodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX2lzU3RhbmRhbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fcGFyZW50IHx8ICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnN0YW5kYWxvbmUpO1xuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fc2V0VXBTdGFuZGFsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VXBDb250cm9sKHRoaXMuX2NvbnRyb2wsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX2NoZWNrRm9yRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1N0YW5kYWxvbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hlY2tOYW1lKCk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ01vZGVsR3JvdXApICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50IGluc3RhbmNlb2YgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5mb3JtR3JvdXBOYW1lRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nTW9kZWxHcm91cCkgJiYgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ0Zvcm0pKSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubW9kZWxQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX2NoZWNrTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm5hbWUpXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5vcHRpb25zLm5hbWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzU3RhbmRhbG9uZSgpICYmICF0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5taXNzaW5nTmFtZUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UkMS50aGVuKGZ1bmN0aW9uICgpIHsgX3RoaXMuY29udHJvbC5zZXRWYWx1ZSh2YWx1ZSwgeyBlbWl0Vmlld1RvTW9kZWxDaGFuZ2U6IGZhbHNlIH0pOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3VwZGF0ZURpc2FibGVkID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWRWYWx1ZSA9IGNoYW5nZXNbJ2lzRGlzYWJsZWQnXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IGRpc2FibGVkVmFsdWUgPT09ICcnIHx8IChkaXNhYmxlZFZhbHVlICYmIGRpc2FibGVkVmFsdWUgIT09ICdmYWxzZScpO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgJiYgIV90aGlzLmNvbnRyb2wuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbC5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0Rpc2FibGVkICYmIF90aGlzLmNvbnRyb2wuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbC5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nTW9kZWxdOm5vdChbZm9ybUNvbnRyb2xOYW1lXSk6bm90KFtmb3JtQ29udHJvbF0pJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nTW9kZWwnXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdNb2RlbC5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTFVFX0FDQ0VTU09SLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nTW9kZWwucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICAgICAgJ2lzRGlzYWJsZWQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Rpc2FibGVkJyxdIH0sXSxcbiAgICAgICAgICAgICdtb2RlbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbCcsXSB9LF0sXG4gICAgICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbE9wdGlvbnMnLF0gfSxdLFxuICAgICAgICAgICAgJ3VwZGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3V0cHV0LCBhcmdzOiBbJ25nTW9kZWxDaGFuZ2UnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdNb2RlbDtcbiAgICB9KE5nQ29udHJvbCkpO1xuXG4gICAgdmFyIFJlYWN0aXZlRXJyb3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVhY3RpdmVFcnJvcnMoKSB7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuY29udHJvbFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Db250cm9sTmFtZSBtdXN0IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgWW91J2xsIHdhbnQgdG8gYWRkIGEgZm9ybUdyb3VwXFxuICAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cXG5cXG4gICAgICBFeGFtcGxlOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUNvbnRyb2xOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RpdmVFcnJvcnMubmdNb2RlbEdyb3VwRXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybUNvbnRyb2xOYW1lIGNhbm5vdCBiZSB1c2VkIHdpdGggYW4gbmdNb2RlbEdyb3VwIHBhcmVudC4gSXQgaXMgb25seSBjb21wYXRpYmxlIHdpdGggcGFyZW50c1xcbiAgICAgICB0aGF0IGFsc28gaGF2ZSBhIFxcXCJmb3JtXFxcIiBwcmVmaXg6IGZvcm1Hcm91cE5hbWUsIGZvcm1BcnJheU5hbWUsIG9yIGZvcm1Hcm91cC5cXG5cXG4gICAgICAgT3B0aW9uIDE6ICBVcGRhdGUgdGhlIHBhcmVudCB0byBiZSBmb3JtR3JvdXBOYW1lIChyZWFjdGl2ZSBmb3JtIHN0cmF0ZWd5KVxcblxcbiAgICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtR3JvdXBOYW1lICsgXCJcXG5cXG4gICAgICAgIE9wdGlvbiAyOiBVc2UgbmdNb2RlbCBpbnN0ZWFkIG9mIGZvcm1Db250cm9sTmFtZSAodGVtcGxhdGUtZHJpdmVuIHN0cmF0ZWd5KVxcblxcbiAgICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsR3JvdXApO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5taXNzaW5nRm9ybUV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Hcm91cCBleHBlY3RzIGEgRm9ybUdyb3VwIGluc3RhbmNlLiBQbGVhc2UgcGFzcyBvbmUgaW4uXFxuXFxuICAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUNvbnRyb2xOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuZ3JvdXBQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtR3JvdXBOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcXG4gICAgICBkaXJlY3RpdmUgYW5kIHBhc3MgaXQgYW4gZXhpc3RpbmcgRm9ybUdyb3VwIGluc3RhbmNlICh5b3UgY2FuIGNyZWF0ZSBvbmUgaW4geW91ciBjbGFzcykuXFxuXFxuICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Hcm91cE5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5hcnJheVBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1BcnJheU5hbWUgbXVzdCBiZSB1c2VkIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwIGRpcmVjdGl2ZS4gIFlvdSdsbCB3YW50IHRvIGFkZCBhIGZvcm1Hcm91cFxcbiAgICAgICBkaXJlY3RpdmUgYW5kIHBhc3MgaXQgYW4gZXhpc3RpbmcgRm9ybUdyb3VwIGluc3RhbmNlICh5b3UgY2FuIGNyZWF0ZSBvbmUgaW4geW91ciBjbGFzcykuXFxuXFxuICAgICAgICBFeGFtcGxlOlxcblxcbiAgICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtQXJyYXlOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuZGlzYWJsZWRBdHRyV2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlxcbiAgICAgIEl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgd2l0aCBhIHJlYWN0aXZlIGZvcm0gZGlyZWN0aXZlLiBJZiB5b3Ugc2V0IGRpc2FibGVkIHRvIHRydWVcXG4gICAgICB3aGVuIHlvdSBzZXQgdXAgdGhpcyBjb250cm9sIGluIHlvdXIgY29tcG9uZW50IGNsYXNzLCB0aGUgZGlzYWJsZWQgYXR0cmlidXRlIHdpbGwgYWN0dWFsbHkgYmUgc2V0IGluIHRoZSBET00gZm9yXFxuICAgICAgeW91LiBXZSByZWNvbW1lbmQgdXNpbmcgdGhpcyBhcHByb2FjaCB0byBhdm9pZCAnY2hhbmdlZCBhZnRlciBjaGVja2VkJyBlcnJvcnMuXFxuICAgICAgIFxcbiAgICAgIEV4YW1wbGU6IFxcbiAgICAgIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcXG4gICAgICAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woe3ZhbHVlOiAnTmFuY3knLCBkaXNhYmxlZDogdHJ1ZX0sIFZhbGlkYXRvcnMucmVxdWlyZWQpLFxcbiAgICAgICAgbGFzdDogbmV3IEZvcm1Db250cm9sKCdEcmV3JywgVmFsaWRhdG9ycy5yZXF1aXJlZClcXG4gICAgICB9KTtcXG4gICAgXCIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVhY3RpdmVFcnJvcnM7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgZm9ybUNvbnRyb2xCaW5kaW5nJDEgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5nQ29udHJvbCxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBGb3JtQ29udHJvbERpcmVjdGl2ZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFN5bmNzIGEgc3RhbmRhbG9uZSB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIHRvIGEgZm9ybSBjb250cm9sIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJbiBvdGhlciB3b3JkcywgdGhpcyBkaXJlY3RpdmUgZW5zdXJlcyB0aGF0IGFueSB2YWx1ZXMgd3JpdHRlbiB0byB0aGUge0BsaW5rIEZvcm1Db250cm9sfVxuICAgICAqIGluc3RhbmNlIHByb2dyYW1tYXRpY2FsbHkgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBET00gZWxlbWVudCAobW9kZWwgLT4gdmlldykuIENvbnZlcnNlbHksXG4gICAgICogYW55IHZhbHVlcyB3cml0dGVuIHRvIHRoZSBET00gZWxlbWVudCB0aHJvdWdoIHVzZXIgaW5wdXQgd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlXG4gICAgICoge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSAodmlldyAtPiBtb2RlbCkuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGRpcmVjdGl2ZSBpZiB5b3UnZCBsaWtlIHRvIGNyZWF0ZSBhbmQgbWFuYWdlIGEge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSBkaXJlY3RseS5cbiAgICAgKiBTaW1wbHkgY3JlYXRlIGEge0BsaW5rIEZvcm1Db250cm9sfSwgc2F2ZSBpdCB0byB5b3VyIGNvbXBvbmVudCBjbGFzcywgYW5kIHBhc3MgaXQgaW50byB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBhcyBhIHN0YW5kYWxvbmUgY29udHJvbC4gIFVubGlrZSB7QGxpbmsgRm9ybUNvbnRyb2xOYW1lfSxcbiAgICAgKiBpdCBkb2VzIG5vdCByZXF1aXJlIHRoYXQgeW91ciB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIGJlIHBhcnQgb2YgYW55IHBhcmVudFxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9LCBhbmQgaXQgd29uJ3QgYmUgcmVnaXN0ZXJlZCB0byBhbnkge0BsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0gdGhhdFxuICAgICAqIGV4aXN0cyBhYm92ZSBpdC5cbiAgICAgKlxuICAgICAqICoqR2V0IHRoZSB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlXG4gICAgICoge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZS4gU2VlIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIGluXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbH0uXG4gICAgICpcbiAgICAgKiAqKlNldCB0aGUgdmFsdWUqKjogWW91IGNhbiBwYXNzIGluIGFuIGluaXRpYWwgdmFsdWUgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9LFxuICAgICAqIG9yIHlvdSBjYW4gc2V0IGl0IHByb2dyYW1tYXRpY2FsbHkgbGF0ZXIgdXNpbmcge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3JcbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnBhdGNoVmFsdWV9LlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBpc1xuICAgICAqIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm1Db250cm9sL3NpbXBsZV9mb3JtX2NvbnRyb2xfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBSZWFjdGl2ZUZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUNvbnRyb2xEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOShGb3JtQ29udHJvbERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUNvbnRyb2xEaXJlY3RpdmUodmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3Nvcih0aGlzLCB2YWx1ZUFjY2Vzc29ycyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpc0Rpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHsgUmVhY3RpdmVFcnJvcnMuZGlzYWJsZWRBdHRyV2FybmluZygpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NvbnRyb2xDaGFuZ2VkKGNoYW5nZXMpKSB7XG4gICAgICAgICAgICAgICAgc2V0VXBDb250cm9sKHRoaXMuZm9ybSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbC5kaXNhYmxlZCAmJiB0aGlzLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybS5zZXRWYWx1ZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl9yYXdWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLl9pc0NvbnRyb2xDaGFuZ2VkID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VzLmhhc093blByb3BlcnR5KCdmb3JtJyk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQ29udHJvbF0nLCBwcm92aWRlcnM6IFtmb3JtQ29udHJvbEJpbmRpbmckMV0sIGV4cG9ydEFzOiAnbmdGb3JtJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1IsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnZm9ybSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUNvbnRyb2wnLF0gfSxdLFxuICAgICAgICAgICAgJ21vZGVsJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ01vZGVsJyxdIH0sXSxcbiAgICAgICAgICAgICd1cGRhdGUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk91dHB1dCwgYXJnczogWyduZ01vZGVsQ2hhbmdlJyxdIH0sXSxcbiAgICAgICAgICAgICdpc0Rpc2FibGVkJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydkaXNhYmxlZCcsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQ29udHJvbERpcmVjdGl2ZTtcbiAgICB9KE5nQ29udHJvbCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgZm9ybURpcmVjdGl2ZVByb3ZpZGVyJDEgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUdyb3VwRGlyZWN0aXZlOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQmluZHMgYW4gZXhpc3Rpbmcge0BsaW5rIEZvcm1Hcm91cH0gdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgYWNjZXB0cyBhbiBleGlzdGluZyB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZS4gSXQgd2lsbCB0aGVuIHVzZSB0aGlzXG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgdG8gbWF0Y2ggYW55IGNoaWxkIHtAbGluayBGb3JtQ29udHJvbH0sIHtAbGluayBGb3JtR3JvdXB9LFxuICAgICAqIGFuZCB7QGxpbmsgRm9ybUFycmF5fSBpbnN0YW5jZXMgdG8gY2hpbGQge0BsaW5rIEZvcm1Db250cm9sTmFtZX0sIHtAbGluayBGb3JtR3JvdXBOYW1lfSxcbiAgICAgKiBhbmQge0BsaW5rIEZvcm1BcnJheU5hbWV9IGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiAqKlNldCB2YWx1ZSoqOiBZb3UgY2FuIHNldCB0aGUgZm9ybSdzIGluaXRpYWwgdmFsdWUgd2hlbiBpbnN0YW50aWF0aW5nIHRoZVxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9LCBvciB5b3UgY2FuIHNldCBpdCBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nIHRoZSB7QGxpbmsgRm9ybUdyb3VwfSdzXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3Ige0BsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfSBtZXRob2RzLlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBmb3JtLCB5b3UgY2FuIHN1YnNjcmliZVxuICAgICAqIHRvIHRoZSB7QGxpbmsgRm9ybUdyb3VwfSdzIHtAbGluayBBYnN0cmFjdENvbnRyb2wudmFsdWVDaGFuZ2VzfSBldmVudC4gIFlvdSBjYW4gYWxzbyBsaXN0ZW4gdG9cbiAgICAgKiBpdHMge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBpc1xuICAgICAqIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiBGdXJ0aGVybW9yZSwgeW91IGNhbiBsaXN0ZW4gdG8gdGhlIGRpcmVjdGl2ZSdzIGBuZ1N1Ym1pdGAgZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdXNlciBoYXNcbiAgICAgKiB0cmlnZ2VyZWQgYSBmb3JtIHN1Ym1pc3Npb24uIFRoZSBgbmdTdWJtaXRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aXRoIHRoZSBvcmlnaW5hbCBmb3JtXG4gICAgICogc3VibWlzc2lvbiBldmVudC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGNyZWF0ZSBmb3JtIGNvbnRyb2xzIGZvciBmaXJzdCBuYW1lIGFuZCBsYXN0IG5hbWUuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybUdyb3VwL3NpbXBsZV9mb3JtX2dyb3VwX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqKk5nTW9kdWxlKio6IHtAbGluayBSZWFjdGl2ZUZvcm1zTW9kdWxlfVxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUdyb3VwRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDExKEZvcm1Hcm91cERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUdyb3VwRGlyZWN0aXZlKF92YWxpZGF0b3JzLCBfYXN5bmNWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvcnMgPSBfdmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IF9hc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmdTdWJtaXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0Zvcm1QcmVzZW50KCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnZm9ybScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsaWRhdG9ycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURvbVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmVnaXN0cmF0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdWJtaXR0ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdWJtaXR0ZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgY3RybCA9IHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgc2V0VXBDb250cm9sKGN0cmwsIGRpcik7XG4gICAgICAgICAgICBjdHJsLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goZGlyKTtcbiAgICAgICAgICAgIHJldHVybiBjdHJsO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmdldENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTsgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKGRpcikgeyBMaXN0V3JhcHBlci5yZW1vdmUodGhpcy5kaXJlY3RpdmVzLCBkaXIpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmFkZEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoY3RybCwgZGlyKTtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUucmVtb3ZlRm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikgeyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmdldEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmFkZEZvcm1BcnJheSA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoY3RybCwgZGlyKTtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUucmVtb3ZlRm9ybUFycmF5ID0gZnVuY3Rpb24gKGRpcikgeyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmdldEZvcm1BcnJheSA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnVwZGF0ZU1vZGVsID0gZnVuY3Rpb24gKGRpciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5vblN1Ym1pdCA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5nU3VibWl0LmVtaXQoJGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5vblJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnJlc2V0Rm9ybSgpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnJlc2V0Rm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgIHRoaXMuZm9ybS5yZXNldCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVEb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0N0cmwgPSBfdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpci5fY29udHJvbCAhPT0gbmV3Q3RybCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhblVwQ29udHJvbChkaXIuX2NvbnRyb2wsIGRpcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDdHJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VXBDb250cm9sKG5ld0N0cmwsIGRpcik7XG4gICAgICAgICAgICAgICAgICAgIGRpci5fY29udHJvbCA9IG5ld0N0cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZvcm0uX3VwZGF0ZVRyZWVWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZVJlZ2lzdHJhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5mb3JtLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTsgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2xkRm9ybSlcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRGb3JtLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb2xkRm9ybSA9IHRoaXMuZm9ybTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5fdXBkYXRlVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzeW5jID0gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB0aGlzLmZvcm0udmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFt0aGlzLmZvcm0udmFsaWRhdG9yLCBzeW5jXSk7XG4gICAgICAgICAgICB2YXIgYXN5bmMgPSBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX2FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB0aGlzLmZvcm0uYXN5bmNWYWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyhbdGhpcy5mb3JtLmFzeW5jVmFsaWRhdG9yLCBhc3luY10pO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl9jaGVja0Zvcm1QcmVzZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5taXNzaW5nRm9ybUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tmb3JtR3JvdXBdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2Zvcm1EaXJlY3RpdmVQcm92aWRlciQxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhzdWJtaXQpJzogJ29uU3VibWl0KCRldmVudCknLCAnKHJlc2V0KSc6ICdvblJlc2V0KCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nRm9ybSdcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdmb3JtJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydmb3JtR3JvdXAnLF0gfSxdLFxuICAgICAgICAgICAgJ25nU3VibWl0JzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PdXRwdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIH0oQ29udHJvbENvbnRhaW5lcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgZm9ybUdyb3VwTmFtZVByb3ZpZGVyID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1Hcm91cE5hbWU7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBTeW5jcyBhIG5lc3RlZCB7QGxpbmsgRm9ybUdyb3VwfSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBwYXJlbnQge0BsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0gKHNlbGVjdG9yOlxuICAgICAqIGBbZm9ybUdyb3VwXWApLlxuICAgICAqXG4gICAgICogSXQgYWNjZXB0cyB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIG5lc3RlZCB7QGxpbmsgRm9ybUdyb3VwfSB5b3Ugd2FudCB0byBsaW5rLCBhbmRcbiAgICAgKiB3aWxsIGxvb2sgZm9yIGEge0BsaW5rIEZvcm1Hcm91cH0gcmVnaXN0ZXJlZCB3aXRoIHRoYXQgbmFtZSBpbiB0aGUgcGFyZW50XG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgeW91IHBhc3NlZCBpbnRvIHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogTmVzdGVkIGZvcm0gZ3JvdXBzIGNhbiBjb21lIGluIGhhbmR5IHdoZW4geW91IHdhbnQgdG8gdmFsaWRhdGUgYSBzdWItZ3JvdXAgb2YgYVxuICAgICAqIGZvcm0gc2VwYXJhdGVseSBmcm9tIHRoZSByZXN0IG9yIHdoZW4geW91J2QgbGlrZSB0byBncm91cCB0aGUgdmFsdWVzIG9mIGNlcnRhaW5cbiAgICAgKiBjb250cm9scyBpbnRvIHRoZWlyIG93biBuZXN0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogKipBY2Nlc3MgdGhlIGdyb3VwKio6IFlvdSBjYW4gYWNjZXNzIHRoZSBhc3NvY2lhdGVkIHtAbGluayBGb3JtR3JvdXB9IHVzaW5nIHRoZVxuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuZ2V0fSBtZXRob2QuIEV4OiBgdGhpcy5mb3JtLmdldCgnbmFtZScpYC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBhY2Nlc3MgaW5kaXZpZHVhbCBjb250cm9scyB3aXRoaW4gdGhlIGdyb3VwIHVzaW5nIGRvdCBzeW50YXguXG4gICAgICogRXg6IGB0aGlzLmZvcm0uZ2V0KCduYW1lLmZpcnN0JylgXG4gICAgICpcbiAgICAgKiAqKkdldCB0aGUgdmFsdWUqKjogdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgYWx3YXlzIHN5bmNlZCBhbmQgYXZhaWxhYmxlIG9uIHRoZVxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9LiBTZWUgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHByb3BlcnRpZXMgaW4ge0BsaW5rIEFic3RyYWN0Q29udHJvbH0uXG4gICAgICpcbiAgICAgKiAqKlNldCB0aGUgdmFsdWUqKjogWW91IGNhbiBzZXQgYW4gaW5pdGlhbCB2YWx1ZSBmb3IgZWFjaCBjaGlsZCBjb250cm9sIHdoZW4gaW5zdGFudGlhdGluZ1xuICAgICAqIHRoZSB7QGxpbmsgRm9ybUdyb3VwfSwgb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZ1xuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtAbGluayBBYnN0cmFjdENvbnRyb2wucGF0Y2hWYWx1ZX0uXG4gICAgICpcbiAgICAgKiAqKkxpc3RlbiB0byB2YWx1ZSoqOiBJZiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIGdyb3VwLCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBpc1xuICAgICAqIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL25lc3RlZEZvcm1Hcm91cC9uZXN0ZWRfZm9ybV9ncm91cF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqICoqTmdNb2R1bGUqKjogYFJlYWN0aXZlRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Hcm91cE5hbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTIoRm9ybUdyb3VwTmFtZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUdyb3VwTmFtZShwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cE5hbWUucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX2hhc0ludmFsaWRQYXJlbnQodGhpcy5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLmdyb3VwUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cE5hbWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Hcm91cE5hbWVdJywgcHJvdmlkZXJzOiBbZm9ybUdyb3VwTmFtZVByb3ZpZGVyXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Hcm91cE5hbWUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBGb3JtR3JvdXBOYW1lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Hcm91cE5hbWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUdyb3VwTmFtZTtcbiAgICB9KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSk7XG4gICAgdmFyIGZvcm1BcnJheU5hbWVQcm92aWRlciA9IHtcbiAgICAgICAgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBGb3JtQXJyYXlOYW1lOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgU3luY3MgYSBuZXN0ZWQge0BsaW5rIEZvcm1BcnJheX0gdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIGEgcGFyZW50IHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9IChzZWxlY3RvcjpcbiAgICAgKiBgW2Zvcm1Hcm91cF1gKS5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgdGhlIHN0cmluZyBuYW1lIG9mIHRoZSBuZXN0ZWQge0BsaW5rIEZvcm1BcnJheX0geW91IHdhbnQgdG8gbGluaywgYW5kXG4gICAgICogd2lsbCBsb29rIGZvciBhIHtAbGluayBGb3JtQXJyYXl9IHJlZ2lzdGVyZWQgd2l0aCB0aGF0IG5hbWUgaW4gdGhlIHBhcmVudFxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIHlvdSBwYXNzZWQgaW50byB7QGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfS5cbiAgICAgKlxuICAgICAqIE5lc3RlZCBmb3JtIGFycmF5cyBjYW4gY29tZSBpbiBoYW5keSB3aGVuIHlvdSBoYXZlIGEgZ3JvdXAgb2YgZm9ybSBjb250cm9scyBidXRcbiAgICAgKiB5b3UncmUgbm90IHN1cmUgaG93IG1hbnkgdGhlcmUgd2lsbCBiZS4gRm9ybSBhcnJheXMgYWxsb3cgeW91IHRvIGNyZWF0ZSBuZXdcbiAgICAgKiBmb3JtIGNvbnRyb2xzIGR5bmFtaWNhbGx5LlxuICAgICAqXG4gICAgICogKipBY2Nlc3MgdGhlIGFycmF5Kio6IFlvdSBjYW4gYWNjZXNzIHRoZSBhc3NvY2lhdGVkIHtAbGluayBGb3JtQXJyYXl9IHVzaW5nIHRoZVxuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuZ2V0fSBtZXRob2Qgb24gdGhlIHBhcmVudCB7QGxpbmsgRm9ybUdyb3VwfS5cbiAgICAgKiBFeDogYHRoaXMuZm9ybS5nZXQoJ2NpdGllcycpYC5cbiAgICAgKlxuICAgICAqICoqR2V0IHRoZSB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlXG4gICAgICoge0BsaW5rIEZvcm1BcnJheX0uIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpbiB7QGxpbmsgQWJzdHJhY3RDb250cm9sfS5cbiAgICAgKlxuICAgICAqICoqU2V0IHRoZSB2YWx1ZSoqOiBZb3UgY2FuIHNldCBhbiBpbml0aWFsIHZhbHVlIGZvciBlYWNoIGNoaWxkIGNvbnRyb2wgd2hlbiBpbnN0YW50aWF0aW5nXG4gICAgICogdGhlIHtAbGluayBGb3JtQXJyYXl9LCBvciB5b3UgY2FuIHNldCB0aGUgdmFsdWUgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZyB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUFycmF5fSdzIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtAbGluayBBYnN0cmFjdENvbnRyb2wucGF0Y2hWYWx1ZX1cbiAgICAgKiBtZXRob2RzLlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBhcnJheSwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge0BsaW5rIEZvcm1BcnJheX0ncyB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc29cbiAgICAgKiBsaXN0ZW4gdG8gaXRzIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvblxuICAgICAqIHN0YXR1cyBpcyByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogKipBZGQgbmV3IGNvbnRyb2xzKio6IFlvdSBjYW4gYWRkIG5ldyBjb250cm9scyB0byB0aGUge0BsaW5rIEZvcm1BcnJheX0gZHluYW1pY2FsbHkgYnlcbiAgICAgKiBjYWxsaW5nIGl0cyB7QGxpbmsgRm9ybUFycmF5LnB1c2h9IG1ldGhvZC5cbiAgICAgKiAgRXg6IGB0aGlzLmZvcm0uZ2V0KCdjaXRpZXMnKS5wdXNoKG5ldyBGb3JtQ29udHJvbCgpKTtgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL25lc3RlZEZvcm1BcnJheS9uZXN0ZWRfZm9ybV9hcnJheV9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqICoqTmdNb2R1bGUqKjogYFJlYWN0aXZlRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1BcnJheU5hbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTIoRm9ybUFycmF5TmFtZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUFycmF5TmFtZShwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgfVxuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZEZvcm1BcnJheSh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUFycmF5TmFtZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUZvcm1BcnJheSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm1EaXJlY3RpdmUuZ2V0Rm9ybUFycmF5KHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5TmFtZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl92YWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fYXN5bmNWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEZvcm1BcnJheU5hbWUucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX2hhc0ludmFsaWRQYXJlbnQodGhpcy5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLmFycmF5UGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1BcnJheU5hbWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1BcnJheU5hbWVdJywgcHJvdmlkZXJzOiBbZm9ybUFycmF5TmFtZVByb3ZpZGVyXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1BcnJheU5hbWUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1BcnJheU5hbWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUFycmF5TmFtZTtcbiAgICB9KENvbnRyb2xDb250YWluZXIpKTtcbiAgICBmdW5jdGlvbiBfaGFzSW52YWxpZFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuICEocGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwTmFtZSkgJiYgIShwYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBEaXJlY3RpdmUpICYmXG4gICAgICAgICAgICAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1BcnJheU5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEwID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGNvbnRyb2xOYW1lQmluZGluZyA9IHtcbiAgICAgICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1Db250cm9sTmFtZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzICBTeW5jcyBhIHtAbGluayBGb3JtQ29udHJvbH0gaW4gYW4gZXhpc3Rpbmcge0BsaW5rIEZvcm1Hcm91cH0gdG8gYSBmb3JtIGNvbnRyb2xcbiAgICAgKiBlbGVtZW50IGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBJbiBvdGhlciB3b3JkcywgdGhpcyBkaXJlY3RpdmUgZW5zdXJlcyB0aGF0IGFueSB2YWx1ZXMgd3JpdHRlbiB0byB0aGUge0BsaW5rIEZvcm1Db250cm9sfVxuICAgICAqIGluc3RhbmNlIHByb2dyYW1tYXRpY2FsbHkgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBET00gZWxlbWVudCAobW9kZWwgLT4gdmlldykuIENvbnZlcnNlbHksXG4gICAgICogYW55IHZhbHVlcyB3cml0dGVuIHRvIHRoZSBET00gZWxlbWVudCB0aHJvdWdoIHVzZXIgaW5wdXQgd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlXG4gICAgICoge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSAodmlldyAtPiBtb2RlbCkuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgd2l0aCBhIHBhcmVudCB7QGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfSAoc2VsZWN0b3I6XG4gICAgICogYFtmb3JtR3JvdXBdYCkuXG4gICAgICpcbiAgICAgKiBJdCBhY2NlcHRzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSB5b3Ugd2FudCB0b1xuICAgICAqIGxpbmssIGFuZCB3aWxsIGxvb2sgZm9yIGEge0BsaW5rIEZvcm1Db250cm9sfSByZWdpc3RlcmVkIHdpdGggdGhhdCBuYW1lIGluIHRoZVxuICAgICAqIGNsb3Nlc3Qge0BsaW5rIEZvcm1Hcm91cH0gb3Ige0BsaW5rIEZvcm1BcnJheX0gYWJvdmUgaXQuXG4gICAgICpcbiAgICAgKiAqKkFjY2VzcyB0aGUgY29udHJvbCoqOiBZb3UgY2FuIGFjY2VzcyB0aGUge0BsaW5rIEZvcm1Db250cm9sfSBhc3NvY2lhdGVkIHdpdGhcbiAgICAgKiB0aGlzIGRpcmVjdGl2ZSBieSB1c2luZyB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbC5nZXR9IG1ldGhvZC5cbiAgICAgKiBFeDogYHRoaXMuZm9ybS5nZXQoJ2ZpcnN0Jyk7YFxuICAgICAqXG4gICAgICogKipHZXQgdmFsdWUqKjogdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgYWx3YXlzIHN5bmNlZCBhbmQgYXZhaWxhYmxlIG9uIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9LlxuICAgICAqIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpbiB7QGxpbmsgQWJzdHJhY3RDb250cm9sfS5cbiAgICAgKlxuICAgICAqICAqKlNldCB2YWx1ZSoqOiBZb3UgY2FuIHNldCBhbiBpbml0aWFsIHZhbHVlIGZvciB0aGUgY29udHJvbCB3aGVuIGluc3RhbnRpYXRpbmcgdGhlXG4gICAgICogIHtAbGluayBGb3JtQ29udHJvbH0sIG9yIHlvdSBjYW4gc2V0IGl0IHByb2dyYW1tYXRpY2FsbHkgbGF0ZXIgdXNpbmdcbiAgICAgKiAge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3Ige0BsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfS5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbC52YWx1ZUNoYW5nZXN9IGV2ZW50LiAgWW91IGNhbiBhbHNvIGxpc3RlbiB0b1xuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXNcbiAgICAgKiByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIEluIHRoaXMgZXhhbXBsZSwgd2UgY3JlYXRlIGZvcm0gY29udHJvbHMgZm9yIGZpcnN0IG5hbWUgYW5kIGxhc3QgbmFtZS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtR3JvdXAvc2ltcGxlX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBUbyBzZWUgYGZvcm1Db250cm9sTmFtZWAgZXhhbXBsZXMgd2l0aCBkaWZmZXJlbnQgZm9ybSBjb250cm9sIHR5cGVzLCBzZWU6XG4gICAgICpcbiAgICAgKiAqIFJhZGlvIGJ1dHRvbnM6IHtAbGluayBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICAgICAqICogU2VsZWN0czoge0BsaW5rIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqKk5nTW9kdWxlKio6IHtAbGluayBSZWFjdGl2ZUZvcm1zTW9kdWxlfVxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUNvbnRyb2xOYW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEwKEZvcm1Db250cm9sTmFtZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUNvbnRyb2xOYW1lKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9yYXdWYWxpZGF0b3JzID0gdmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImlzRGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoaXNEaXNhYmxlZCkgeyBSZWFjdGl2ZUVycm9ycy5kaXNhYmxlZEF0dHJXYXJuaW5nKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYWRkZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VXBDb250cm9sKCk7XG4gICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS51cGRhdGVNb2RlbCh0aGlzLCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlQ29udHJvbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQobmV3VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3Jhd1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udHJvbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50IGluc3RhbmNlb2YgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5uZ01vZGVsR3JvdXBFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwTmFtZSkgJiYgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBEaXJlY3RpdmUpICYmXG4gICAgICAgICAgICAgICAgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBGb3JtQXJyYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLmNvbnRyb2xQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS5fc2V0VXBDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sID0gdGhpcy5mb3JtRGlyZWN0aXZlLmFkZENvbnRyb2wodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sLmRpc2FibGVkICYmIHRoaXMudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUNvbnRyb2xOYW1lXScsIHByb3ZpZGVyczogW2NvbnRyb2xOYW1lQmluZGluZ10gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1IsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Db250cm9sTmFtZScsXSB9LF0sXG4gICAgICAgICAgICAnbW9kZWwnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWwnLF0gfSxdLFxuICAgICAgICAgICAgJ3VwZGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3V0cHV0LCBhcmdzOiBbJ25nTW9kZWxDaGFuZ2UnLF0gfSxdLFxuICAgICAgICAgICAgJ2lzRGlzYWJsZWQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Rpc2FibGVkJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Db250cm9sTmFtZTtcbiAgICB9KE5nQ29udHJvbCkpO1xuXG4gICAgdmFyIFJFUVVJUkVEX1ZBTElEQVRPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBSZXF1aXJlZFZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIERpcmVjdGl2ZSB0aGF0IGFkZHMgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yIHRvIGFueSBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAgICAgKiBgcmVxdWlyZWRgIGF0dHJpYnV0ZSwgdmlhIHRoZSB7QGxpbmsgTkdfVkFMSURBVE9SU30gYmluZGluZy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8aW5wdXQgbmFtZT1cImZ1bGxOYW1lXCIgbmdNb2RlbCByZXF1aXJlZD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUmVxdWlyZWRWYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZXF1aXJlZFZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVxdWlyZWRWYWxpZGF0b3IucHJvdG90eXBlLCBcInJlcXVpcmVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVkID0gdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UgJiYgXCJcIiArIHZhbHVlICE9PSAnZmFsc2UnO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZWQgPyBWYWxpZGF0b3JzLnJlcXVpcmVkKGMpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tyZXF1aXJlZF1bZm9ybUNvbnRyb2xOYW1lXSxbcmVxdWlyZWRdW2Zvcm1Db250cm9sXSxbcmVxdWlyZWRdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1JFUVVJUkVEX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5yZXF1aXJlZF0nOiAncmVxdWlyZWQgPyBcIlwiIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ3JlcXVpcmVkJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZXF1aXJlZFZhbGlkYXRvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVyIHdoaWNoIGFkZHMge0BsaW5rIE1pbkxlbmd0aFZhbGlkYXRvcn0gdG8ge0BsaW5rIE5HX1ZBTElEQVRPUlN9LlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vZm9ybXMvdHMvdmFsaWRhdG9ycy92YWxpZGF0b3JzLnRzIHJlZ2lvbj0nbWluJ31cbiAgICAgKi9cbiAgICB2YXIgTUlOX0xFTkdUSF9WQUxJREFUT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWluTGVuZ3RoVmFsaWRhdG9yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZGlyZWN0aXZlIHdoaWNoIGluc3RhbGxzIHRoZSB7QGxpbmsgTWluTGVuZ3RoVmFsaWRhdG9yfSBmb3IgYW55IGBmb3JtQ29udHJvbE5hbWVgLFxuICAgICAqIGBmb3JtQ29udHJvbGAsIG9yIGNvbnRyb2wgd2l0aCBgbmdNb2RlbGAgdGhhdCBhbHNvIGhhcyBhIGBtaW5sZW5ndGhgIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTWluTGVuZ3RoVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTWluTGVuZ3RoVmFsaWRhdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKCdtaW5sZW5ndGgnIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlubGVuZ3RoID09IG51bGwgPyBudWxsIDogdGhpcy5fdmFsaWRhdG9yKGMpO1xuICAgICAgICB9O1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5taW5MZW5ndGgocGFyc2VJbnQodGhpcy5taW5sZW5ndGgsIDEwKSk7XG4gICAgICAgIH07XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21pbmxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbbWlubGVuZ3RoXVtmb3JtQ29udHJvbF0sW21pbmxlbmd0aF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTUlOX0xFTkdUSF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIubWlubGVuZ3RoXSc6ICdtaW5sZW5ndGggPyBtaW5sZW5ndGggOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdtaW5sZW5ndGgnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1pbkxlbmd0aFZhbGlkYXRvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVyIHdoaWNoIGFkZHMge0BsaW5rIE1heExlbmd0aFZhbGlkYXRvcn0gdG8ge0BsaW5rIE5HX1ZBTElEQVRPUlN9LlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vZm9ybXMvdHMvdmFsaWRhdG9ycy92YWxpZGF0b3JzLnRzIHJlZ2lvbj0nbWF4J31cbiAgICAgKi9cbiAgICB2YXIgTUFYX0xFTkdUSF9WQUxJREFUT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF4TGVuZ3RoVmFsaWRhdG9yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZGlyZWN0aXZlIHdoaWNoIGluc3RhbGxzIHRoZSB7QGxpbmsgTWF4TGVuZ3RoVmFsaWRhdG9yfSBmb3IgYW55IGBmb3JtQ29udHJvbE5hbWUsXG4gICAgICogYGZvcm1Db250cm9sYCxcbiAgICAgKiBvciBjb250cm9sIHdpdGggYG5nTW9kZWxgIHRoYXQgYWxzbyBoYXMgYSBgbWF4bGVuZ3RoYCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE1heExlbmd0aFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1heExlbmd0aFZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICgnbWF4bGVuZ3RoJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlVmFsaWRhdG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heGxlbmd0aCAhPSBudWxsID8gdGhpcy5fdmFsaWRhdG9yKGMpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUuX2NyZWF0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvciA9IFZhbGlkYXRvcnMubWF4TGVuZ3RoKHBhcnNlSW50KHRoaXMubWF4bGVuZ3RoLCAxMCkpO1xuICAgICAgICB9O1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYXhsZW5ndGhdW2Zvcm1Db250cm9sTmFtZV0sW21heGxlbmd0aF1bZm9ybUNvbnRyb2xdLFttYXhsZW5ndGhdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01BWF9MRU5HVEhfVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLm1heGxlbmd0aF0nOiAnbWF4bGVuZ3RoID8gbWF4bGVuZ3RoIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbWF4bGVuZ3RoJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNYXhMZW5ndGhWYWxpZGF0b3I7XG4gICAgfSgpKTtcbiAgICB2YXIgUEFUVEVSTl9WQUxJREFUT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gUGF0dGVyblZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIERpcmVjdGl2ZSB0aGF0IGFkZHMgdGhlIGBwYXR0ZXJuYCB2YWxpZGF0b3IgdG8gYW55IGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxuICAgICAqIGBwYXR0ZXJuYCBhdHRyaWJ1dGUsIHZpYSB0aGUge0BsaW5rIE5HX1ZBTElEQVRPUlN9IGJpbmRpbmcuIFVzZXMgYXR0cmlidXRlIHZhbHVlXG4gICAgICogYXMgdGhlIHJlZ2V4IHRvIHZhbGlkYXRlIENvbnRyb2wgdmFsdWUgYWdhaW5zdC4gIEZvbGxvd3MgcGF0dGVybiBhdHRyaWJ1dGVcbiAgICAgKiBzZW1hbnRpY3M7IGkuZS4gcmVnZXggbXVzdCBtYXRjaCBlbnRpcmUgQ29udHJvbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8aW5wdXQgW25hbWVdPVwiZnVsbE5hbWVcIiBwYXR0ZXJuPVwiW2EtekEtWiBdKlwiIG5nTW9kZWw+XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBQYXR0ZXJuVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUGF0dGVyblZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoJ3BhdHRlcm4nIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvcihjKTsgfTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLnBhdHRlcm4odGhpcy5wYXR0ZXJuKTsgfTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW3BhdHRlcm5dW2Zvcm1Db250cm9sTmFtZV0sW3BhdHRlcm5dW2Zvcm1Db250cm9sXSxbcGF0dGVybl1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUEFUVEVSTl9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIucGF0dGVybl0nOiAncGF0dGVybiA/IHBhdHRlcm4gOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ3BhdHRlcm4nOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBhdHRlcm5WYWxpZGF0b3I7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIENyZWF0ZXMgYW4ge0BsaW5rIEFic3RyYWN0Q29udHJvbH0gZnJvbSBhIHVzZXItc3BlY2lmaWVkIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBJdCBpcyBlc3NlbnRpYWxseSBzeW50YWN0aWMgc3VnYXIgdGhhdCBzaG9ydGVucyB0aGUgYG5ldyBGb3JtR3JvdXAoKWAsXG4gICAgICogYG5ldyBGb3JtQ29udHJvbCgpYCwgYW5kIGBuZXcgRm9ybUFycmF5KClgIGJvaWxlcnBsYXRlIHRoYXQgY2FuIGJ1aWxkIHVwIGluIGxhcmdlclxuICAgICAqIGZvcm1zLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUbyB1c2UsIGluamVjdCBgRm9ybUJ1aWxkZXJgIGludG8geW91ciBjb21wb25lbnQgY2xhc3MuIFlvdSBjYW4gdGhlbiBjYWxsIGl0cyBtZXRob2RzXG4gICAgICogZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvZm9ybUJ1aWxkZXIvZm9ybV9idWlsZGVyX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAgKiAqKk5nTW9kdWxlKio6IHtAbGluayBSZWFjdGl2ZUZvcm1zTW9kdWxlfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1CdWlsZGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBuZXcge0BsaW5rIEZvcm1Hcm91cH0gd2l0aCB0aGUgZ2l2ZW4gbWFwIG9mIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIFZhbGlkIGtleXMgZm9yIHRoZSBgZXh0cmFgIHBhcmFtZXRlciBtYXAgYXJlIGB2YWxpZGF0b3JgIGFuZCBgYXN5bmNWYWxpZGF0b3JgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgdGhlIHtAbGluayBGb3JtR3JvdXB9IGNvbnN0cnVjdG9yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuZ3JvdXAgPSBmdW5jdGlvbiAoY29udHJvbHNDb25maWcsIGV4dHJhKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmEgPT09IHZvaWQgMCkgeyBleHRyYSA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBjb250cm9scyA9IHRoaXMuX3JlZHVjZUNvbnRyb2xzKGNvbnRyb2xzQ29uZmlnKTtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBpc1ByZXNlbnQoZXh0cmEpID8gZXh0cmFbJ3ZhbGlkYXRvciddIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBhc3luY1ZhbGlkYXRvciA9IGlzUHJlc2VudChleHRyYSkgPyBleHRyYVsnYXN5bmNWYWxpZGF0b3InXSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1Hcm91cChjb250cm9scywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBuZXcge0BsaW5rIEZvcm1Db250cm9sfSB3aXRoIHRoZSBnaXZlbiBgZm9ybVN0YXRlYCxgdmFsaWRhdG9yYCwgYW5kXG4gICAgICAgICAqIGBhc3luY1ZhbGlkYXRvcmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBmb3JtU3RhdGVgIGNhbiBlaXRoZXIgYmUgYSBzdGFuZGFsb25lIHZhbHVlIGZvciB0aGUgZm9ybSBjb250cm9sIG9yIGFuIG9iamVjdFxuICAgICAgICAgKiB0aGF0IGNvbnRhaW5zIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZCBzdGF0dXMuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuY29udHJvbCA9IGZ1bmN0aW9uIChmb3JtU3RhdGUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3IgPT09IHZvaWQgMCkgeyBhc3luY1ZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybUNvbnRyb2woZm9ybVN0YXRlLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBGb3JtQXJyYXl9IGZyb20gdGhlIGdpdmVuIGBjb250cm9sc0NvbmZpZ2AgYXJyYXkgb2ZcbiAgICAgICAgICogY29uZmlndXJhdGlvbiwgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uYWwgYHZhbGlkYXRvcmAgYW5kIGBhc3luY1ZhbGlkYXRvcmAuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoY29udHJvbHNDb25maWcsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgY29udHJvbHMgPSBjb250cm9sc0NvbmZpZy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIF90aGlzLl9jcmVhdGVDb250cm9sKGMpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybUFycmF5KGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuX3JlZHVjZUNvbnRyb2xzID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb250cm9sc0NvbmZpZykuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sc1tjb250cm9sTmFtZV0gPSBfdGhpcy5fY3JlYXRlQ29udHJvbChjb250cm9sc0NvbmZpZ1tjb250cm9sTmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbHM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVDb250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2xDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgRm9ybUNvbnRyb2wgfHwgY29udHJvbENvbmZpZyBpbnN0YW5jZW9mIEZvcm1Hcm91cCB8fFxuICAgICAgICAgICAgICAgIGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBGb3JtQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udHJvbENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250cm9sQ29uZmlnWzBdO1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBjb250cm9sQ29uZmlnLmxlbmd0aCA+IDEgPyBjb250cm9sQ29uZmlnWzFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgYXN5bmNWYWxpZGF0b3IgPSBjb250cm9sQ29uZmlnLmxlbmd0aCA+IDIgPyBjb250cm9sQ29uZmlnWzJdIDogbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sKHZhbHVlLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2woY29udHJvbENvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1CdWlsZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIEZvcm1CdWlsZGVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgU0hBUkVEX0ZPUk1fRElSRUNUSVZFUyA9IFtcbiAgICAgICAgTmdTZWxlY3RPcHRpb24sIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24sIERlZmF1bHRWYWx1ZUFjY2Vzc29yLCBOdW1iZXJWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBSYW5nZVZhbHVlQWNjZXNzb3IsIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IsIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLCBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOZ0NvbnRyb2xTdGF0dXMsXG4gICAgICAgIE5nQ29udHJvbFN0YXR1c0dyb3VwLCBSZXF1aXJlZFZhbGlkYXRvciwgTWluTGVuZ3RoVmFsaWRhdG9yLCBNYXhMZW5ndGhWYWxpZGF0b3IsIFBhdHRlcm5WYWxpZGF0b3JcbiAgICBdO1xuICAgIHZhciBURU1QTEFURV9EUklWRU5fRElSRUNUSVZFUyA9IFtOZ01vZGVsLCBOZ01vZGVsR3JvdXAsIE5nRm9ybV07XG4gICAgdmFyIFJFQUNUSVZFX0RSSVZFTl9ESVJFQ1RJVkVTID0gW0Zvcm1Db250cm9sRGlyZWN0aXZlLCBGb3JtR3JvdXBEaXJlY3RpdmUsIEZvcm1Db250cm9sTmFtZSwgRm9ybUdyb3VwTmFtZSwgRm9ybUFycmF5TmFtZV07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbW9kdWxlIHVzZWQgZm9yIHNoYXJpbmcgZGlyZWN0aXZlcyBiZXR3ZWVuIEZvcm1zTW9kdWxlIGFuZCBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gICAgICovXG4gICAgdmFyIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogU0hBUkVEX0ZPUk1fRElSRUNUSVZFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFNIQVJFRF9GT1JNX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5nIG1vZHVsZSBmb3IgZm9ybXMuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3Jtc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1zTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIEZvcm1zTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFRFTVBMQVRFX0RSSVZFTl9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUmFkaW9Db250cm9sUmVnaXN0cnldLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW0ludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIFRFTVBMQVRFX0RSSVZFTl9ESVJFQ1RJVkVTXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1zTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBGb3Jtc01vZHVsZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBuZyBtb2R1bGUgZm9yIHJlYWN0aXZlIGZvcm1zLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUmVhY3RpdmVGb3Jtc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlYWN0aXZlRm9ybXNNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbUkVBQ1RJVkVfRFJJVkVOX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbRm9ybUJ1aWxkZXIsIFJhZGlvQ29udHJvbFJlZ2lzdHJ5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLCBSRUFDVElWRV9EUklWRU5fRElSRUNUSVZFU11cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBSZWFjdGl2ZUZvcm1zTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICBleHBvcnRzLkFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSA9IEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZTtcbiAgICBleHBvcnRzLkFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlID0gQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLkNvbnRyb2xDb250YWluZXIgPSBDb250cm9sQ29udGFpbmVyO1xuICAgIGV4cG9ydHMuTkdfVkFMVUVfQUNDRVNTT1IgPSBOR19WQUxVRV9BQ0NFU1NPUjtcbiAgICBleHBvcnRzLkRlZmF1bHRWYWx1ZUFjY2Vzc29yID0gRGVmYXVsdFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5OZ0NvbnRyb2wgPSBOZ0NvbnRyb2w7XG4gICAgZXhwb3J0cy5OZ0NvbnRyb2xTdGF0dXMgPSBOZ0NvbnRyb2xTdGF0dXM7XG4gICAgZXhwb3J0cy5OZ0NvbnRyb2xTdGF0dXNHcm91cCA9IE5nQ29udHJvbFN0YXR1c0dyb3VwO1xuICAgIGV4cG9ydHMuTmdGb3JtID0gTmdGb3JtO1xuICAgIGV4cG9ydHMuTmdNb2RlbCA9IE5nTW9kZWw7XG4gICAgZXhwb3J0cy5OZ01vZGVsR3JvdXAgPSBOZ01vZGVsR3JvdXA7XG4gICAgZXhwb3J0cy5SYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yID0gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLkZvcm1Db250cm9sRGlyZWN0aXZlID0gRm9ybUNvbnRyb2xEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5Gb3JtQ29udHJvbE5hbWUgPSBGb3JtQ29udHJvbE5hbWU7XG4gICAgZXhwb3J0cy5Gb3JtR3JvdXBEaXJlY3RpdmUgPSBGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5Gb3JtQXJyYXlOYW1lID0gRm9ybUFycmF5TmFtZTtcbiAgICBleHBvcnRzLkZvcm1Hcm91cE5hbWUgPSBGb3JtR3JvdXBOYW1lO1xuICAgIGV4cG9ydHMuTmdTZWxlY3RPcHRpb24gPSBOZ1NlbGVjdE9wdGlvbjtcbiAgICBleHBvcnRzLlNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5TZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yID0gU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLk1heExlbmd0aFZhbGlkYXRvciA9IE1heExlbmd0aFZhbGlkYXRvcjtcbiAgICBleHBvcnRzLk1pbkxlbmd0aFZhbGlkYXRvciA9IE1pbkxlbmd0aFZhbGlkYXRvcjtcbiAgICBleHBvcnRzLlBhdHRlcm5WYWxpZGF0b3IgPSBQYXR0ZXJuVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuUmVxdWlyZWRWYWxpZGF0b3IgPSBSZXF1aXJlZFZhbGlkYXRvcjtcbiAgICBleHBvcnRzLkZvcm1CdWlsZGVyID0gRm9ybUJ1aWxkZXI7XG4gICAgZXhwb3J0cy5BYnN0cmFjdENvbnRyb2wgPSBBYnN0cmFjdENvbnRyb2w7XG4gICAgZXhwb3J0cy5Gb3JtQXJyYXkgPSBGb3JtQXJyYXk7XG4gICAgZXhwb3J0cy5Gb3JtQ29udHJvbCA9IEZvcm1Db250cm9sO1xuICAgIGV4cG9ydHMuRm9ybUdyb3VwID0gRm9ybUdyb3VwO1xuICAgIGV4cG9ydHMuTkdfQVNZTkNfVkFMSURBVE9SUyA9IE5HX0FTWU5DX1ZBTElEQVRPUlM7XG4gICAgZXhwb3J0cy5OR19WQUxJREFUT1JTID0gTkdfVkFMSURBVE9SUztcbiAgICBleHBvcnRzLlZhbGlkYXRvcnMgPSBWYWxpZGF0b3JzO1xuICAgIGV4cG9ydHMuRm9ybXNNb2R1bGUgPSBGb3Jtc01vZHVsZTtcbiAgICBleHBvcnRzLlJlYWN0aXZlRm9ybXNNb2R1bGUgPSBSZWFjdGl2ZUZvcm1zTW9kdWxlO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL2Zvcm1zL2J1bmRsZXMvZm9ybXMudW1kLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdob21lJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9ob21lLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9ob21lLmNvbXBvbmVudC5sZXNzJyldLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG59KVxuXG5leHBvcnQgY2xhc3MgSG9tZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0hvbWUgQ29tcG9uZW50IScpO1xuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aW1nIGNsYXNzPVxcXCJob21lLWltYWdlXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2hvbWUvaG9tZS5qcGdcIikgKyBcIlxcXCIvPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9ob21lL2hvbWUuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9ob21lLmpwZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2hvbWUvaG9tZS5qcGdcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vaG9tZS5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuaG9tZS1pbWFnZSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJveC1zaGFkb3c6IDBweCAxcHggMnB4IDAgcmdiYSgzNCwgMzYsIDM4LCAwLjE1KTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICMwMDAwNEQ7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvaG9tZS9ob21lLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2Fib3V0JyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9hYm91dC5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vYWJvdXQuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBBYm91dENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Fib3V0IENvbXBvbmVudCEnKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvYWJvdXQvYWJvdXQuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxoMSBjbGFzcz1cXFwidWkgaGVhZGVyXFxcIj5BYm91dCBVczwvaDE+XFxuPHA+SWxsaW5vaXMgVWx0aW1hdGUgaXMgb25lIG9mIHRoZSBwcmVtaWVyIHVsdGltYXRlIHByb2dyYW1zIGluIHRoZSBNaWR3ZXN0IGFuZCBmcmVxdWVudGx5IHJhbmtzIGluIHRoZSBOYXRpb25hbCB0b3AgMjUuIFdlIHN0cml2ZSB0byBjb250ZW5kIHdpdGggdGhlIGJlc3QgcHJvZ3JhbXMgaW4gdGhlIGNvdW50cnkgYW5kIGhhdmUgcXVhbGlmaWVkIHRvIGNvbXBldGUgYXQgTmF0aW9uYWxzIDcgb2YgdGhlIGxhc3QgMTAgeWVhcnMuIFdlIGFyZSBhIHByb2dyYW0gdGhhdCBwcmlkZXMgaXRzZWxmIG9uIGRldmVsb3BpbmcgcGxheWVycyB3aG8gY29tZSB0byBJbGxpbm9pcyB3aXRoIG5vIGV4cGVyaWVuY2UgcGxheWluZyBjb21wZXRpdGl2ZSB1bHRpbWF0ZS4gV2UgdGVhY2ggYWxsIGxldmVscyBvZiB1bHRpbWF0ZSwgZnJvbSB0aGUgYmFzaWNzIG9mIHRocm93aW5nIGEgZm9yZWhhbmQgYWxsIHRoZSB3YXkgdG8gdGhyb3dpbmcgYm9tYnMgaW4gdGhlIHdvcnN0IG9mIHdlYXRoZXIuPC9wPlxcbjxoMiBjbGFzcz1cXFwidWkgaGVhZGVyXFxcIj5NaXNzaW9uIFN0YXRlbWVudDwvaDI+XFxuPHA+V2Ugd2FudCB0byBjb21wZXRlIGF0IHRoZSBoaWdoZXN0IGxldmVsIHBvc3NpYmxlIGluIGNvbGxlZ2UgdWx0aW1hdGUgd2hpbGUgcmVtYWluaW5nIHJlc3BlY3RmdWwgdG8gb3VyIG9wcG9uZW50cy4gIFdlIHdhbnQgdG8gZGV2ZWxvcCBhbGwgb3VyIG9mIHBsYXllcnMgdG8gYmVjb21lIHRoZSBiZXN0IHRoZXkgY2FuIGJlIGF0IHVsdGltYXRlLCBhcyB3ZWxsIGFzIHBsYXllcnMgd2hvIGV4ZW1wbGlmeSB0aGUgdHJ1ZSBtZWFuaW5nIG9mIHNwb3J0c21hbnNoaXAsIHdoaWNoIGlzIHBpdm90YWwgdG8gdGhlIHByb2dyZXNzIG9mIHVsdGltYXRlIGZyaXNiZWUgaW4gaXRzIGN1cnJlbnQgc3RhdGUuPC9wPlxcbjxoMiBjbGFzcz1cXFwidWkgaGVhZGVyXFxcIj5UZWFtIFN0cnVjdHVyZS9BZmZpbGlhdGlvbiB3aXRoIFVuaXZlcnNpdHk8L2gyPlxcbjxwPk91ciB0ZWFtIGlzIGEgUmVnaXN0ZXJlZCBTdHVkZW50IE9yZ2FuaXphdGlvbiAoUlNPKSBhdCB0aGUgVW5pdmVyc2l0eSBvZiBJbGxpbm9pcyBhbmQgd2UgYXJlIGNsYXNzaWZpZWQgYXMgYSBjbHViIHNwb3J0LiBXZSByZWNlaXZlIHNvbWUgZnVuZGluZyBmcm9tIHRoZSBVbml2ZXJzaXR5IHRoYXQgaGVscHMgcGF5IGZvciBvdXIgdHJhdmVsIGNvc3RzIGFuZCBob3RlbHMgd2hpbGUgd2UgYXJlIGF0IHRvdXJuYW1lbnRzLjwvcD5cXG48cD5XZSBhcmUgYSBtZW1iZXIgb2YgdGhlIFVTQVUgIENvbGxlZ2UgU2VyaWVzIGFuZCBjb21wZXRlIGluIGEgc2VyaWVzIG9mIHRvdXJuYW1lbnRzIHRoYXQgIGN1bG1pbmF0ZSBpbiB0aGUgQ29sbGVnZSBDaGFtcGlvbnNoaXBzIGhlbGQgZXZlcnkgeWVhciBkdXJpbmcgTWVtb3JpYWwgRGF5IHdlZWtlbmQuIE1vc3QsIGlmIG5vdCBhbGwsIHN0YXRlIHNjaG9vbHMgaGF2ZSBlc3RhYmxpc2hlZCB1bHRpbWF0ZSB0ZWFtcyBhbmQgbWFueSBzbWFsbGVyIHNjaG9vbHMgaGF2ZSB0ZWFtcyBhcyB3ZWxsLiAgV2UgY29tcGV0ZSBpbiB0aGUgSWxsaW5vaXMgY29uZmVyZW5jZSB3aGljaCBpcyBhcyB5b3UgY2FuIGd1ZXNzLCB0aGUgc2Nob29scyBpbiB0aGUgc3RhdGUgb2YgSWxsaW5vaXMuIFRoZSBuZXh0IGxhcmdlc3QgZGl2aXNpb24gaXMgdGhlIEdyZWF0IExha2VzIFJlZ2lvbiwgd2hpY2ggaW5jbHVkZXMgdGhlIHN0YXRlcyBvZiBJbGxpbm9pcywgSW5kaWFuYSwgTWljaGlnYW4sIGFuZCBLZW50dWNreS4gVGhlIGZpbmFsIHN0ZXAgaXMgdGhlIGFmb3JlbWVudGlvbmVkIE5hdGlvbmFsIENoYW1waW9uc2hpcHMuPC9wPlxcbjxwPk91ciBwcm9ncmFtIGlzIHNwbGl0IHVwIGludG8gdHdvIHRlYW1zLCBBIGFuZCBCLiBPdXIgQSB0ZWFtIGlzIGEgZ3JvdXAgb2YgaW5kaXZpZHVhbHMgd2hvIGFyZSB2ZXJ5IGRlZGljYXRlZCB0byB0aGUgdGVhbSBhbmQgd2hvIHB1dCBpbiBhIGxhcmdlIGFtb3VudCBvZiB0aW1lIGZvciBwcmFjdGljZXMgYXMgd2VsbCBhcyB0cmFpbmluZyBvdXRzaWRlIG9mIHByYWN0aWNlcy4gT3VyIEIgdGVhbSBpcyBtb3JlIG9yaWVudGVkIHRvd2FyZHMgdGhlIGRldmVsb3BtZW50IG9mIHlvdW5nZXIgb3IgaW5leHBlcmllbmNlZCBwbGF5ZXJzLiBCIHRlYW0gcHJvdmlkZXMgYSBtdWNoIG1vcmUgcmVsYXhlZCBhdG1vc3BoZXJlIGJ1dCBzdGlsbCByZW1haW5zIGNvbXBldGl0aXZlIHdpdGggYWxsIG90aGVyIEIgdGVhbXMgaW4gdGhlIHJlZ2lvbiwgYW5kIGV2ZW4gYmVhdHMgc29tZSBzbWFsbGVyIHNjaG9vbHMnIEEgdGVhbXMuPC9wPlxcbjxwPkEgdGVhbSBoYXMgdHJ5b3V0cyBlYWNoIHllYXIuIFRoaXMgeWVhcidzIHRyeW91dHMgd2lsbCBjb25zaXN0IG9mIGZvdXIgZmFsbCB0b3VybmFtZW50cy4gVGhlcmUgd2lsbCBiZSBhIHJvdW5kIG9mIGN1dHMgbWFkZSBhZnRlciB0aGUgc2Vjb25kIHRvdXJuYW1lbnQuIFRoZSB0cnlvdXQgcm9zdGVyIHdpbGwgdGhlbiBiZSBuYXJyb3dlZCBkb3duIHRvIG9uZSB0ZWFtIGJlZm9yZSB0aGUgZmluYWwgdG91cm5hbWVudCBvZiB0aGUgZmFsbCwgdmlhIGN1dHMgb24gYSByb2xsaW5nIGJhc2lzLiBQbGF5ZXJzIG1heSBiZSBtb3ZlZCBiZXR3ZWVuIHRoZSBBIGFuZCBCIHRlYW0gcm9zdGVycyBhcyBuZWNlc3NhcnkuPC9wPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9hYm91dC9hYm91dC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9hYm91dC5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvYWJvdXQvYWJvdXQuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcInAge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9hYm91dC9hYm91dC5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgU3ByZWFkc2hlZXRTZXJ2aWNlIH0gZnJvbSBcIi4uL3NlcnZpY2UvZ29vZ2xlLXNwcmVhZHNoZWV0LnNlcnZpY2VcIjtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdwcm9zcGVjdGl2ZS1wbGF5ZXJzJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudC5sZXNzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgUHJvc3BlY3RpdmVQbGF5ZXJzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIC8vIEFQSSB1cmwgZm9yIG91ciBwZXJzb25hbCBzZXJ2ZXJcbiAgICBwcml2YXRlIGdvb2dsZVNoZWV0c0FwaVVybCA9ICdodHRwczovL25pY2stcHJvei1nb29nbGUtc2hlZXQtYXBpLmhlcm9rdWFwcC5jb20vc2hlZXRzLzExaWpySG95c2lJd3NGZkVnZ2JTTk05WThWdnpVNjVqZXVoUTN2a1Y1Rkd3L3NoZWV0SW5kZXgvMi9yb3dzLyc7XG4gICAgLy8gQVBJIHVybCBmb3Igb3VyIGJhY2t1cCBzZXJ2ZXIgKHNoZWV0c3UgQVBJKVxuICAgIC8vIHByaXZhdGUgZ29vZ2xlU2hlZXRzQmFja3VwQXBpVXJsID0gJ2h0dHBzOi8vc2hlZXRzdS5jb20vYXBpcy92MS4wLzdhMDMwYWU2MGI3ZCc7XG4gICAgcHJpdmF0ZSBnb29nbGVTaGVldHNCYWNrdXBBcGlVcmwgPSAnJztcblxuICAgIC8vIEVycm9yIG1lc3NhZ2VzXG4gICAgcHJpdmF0ZSB2YWxpZGF0aW9uRXJyb3JzOiBzdHJpbmcgPSAnUGxlYXNlIGRvIG5vdCBsZWF2ZSBhbnkgcmVxdWlyZWQgZmllbGRzIGJsYW5rLic7XG4gICAgcHJpdmF0ZSBzdWJtaXNzaW9uRXJyb3I6IHN0cmluZyA9ICdDb3VsZCBub3Qgc3VibWl0IHRoZSBmb3JtICBkdWUgdG8gYSBzZXJ2ZXIgZXJyb3IuIFBsZWFzZSB0cnkgYWdhaW4gc29vbiBvciBjb250YWN0IHRoZSB3ZWIgYWRtaW5zLic7XG5cbiAgICAvLyBGaXJzdCBuYW1lIGlucHV0XG4gICAgcHJpdmF0ZSBmaXJzdE5hbWU6IHN0cmluZztcbiAgICAvLyBMYXN0IG5hbWUgaW5wdXRcbiAgICBwcml2YXRlIGxhc3ROYW1lOiBzdHJpbmc7XG4gICAgLy8gUmVhc29uIGlucHV0XG4gICAgcHJpdmF0ZSBlbWFpbEFkZHJlc3M6IHN0cmluZztcbiAgICAvLyBUaW1lIGlucHV0XG4gICAgcHJpdmF0ZSBob21ldG93bjogc3RyaW5nO1xuICAgIC8vIERheSBpbnB1dFxuICAgIHByaXZhdGUgaGlnaHNjaG9vbDogc3RyaW5nO1xuICAgIC8vIE1vbnRoIGlucHV0XG4gICAgcHJpdmF0ZSBtYWpvcjogc3RyaW5nO1xuICAgIC8vIEV4cGVyaWVuY2UgaW5wdXRcbiAgICBwcml2YXRlIGV4cGVyaWVuY2U6IHN0cmluZztcbiAgICAvLyBPdGhlciBDbHVicyBpbnB1dFxuICAgIHByaXZhdGUgb3RoZXJDbHViczogc3RyaW5nO1xuICAgIC8vIENvbnRhY3QgaW5wdXRcbiAgICBwcml2YXRlIGNvbnRhY3Q6IHN0cmluZyA9ICdZZXMnO1xuICAgIC8vIEJvb2xlYW4gaW5kaWNhdGluZyBpZiBvdXIgZm9ybSBpcyBpbiB0aGUgcHJvY2VzcyBvZiBzdWJtaXR0aW5nICh0byBzaG93IG91ciBsb2FkaW5nIGljb24pXG4gICAgcHJpdmF0ZSBmb3JtSXNTdWJtaXR0aW5nOiBib29sZWFuID0gZmFsc2U7XG4gICAgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIGlmIG91ciBmb3JtIHdhcyBzdWNjZXNzZnVsbHkgc3VibWl0dGVkICh0byBzaG93IG91ciBzdWNjZXNzIG1lc3NhZ2UpXG4gICAgcHJpdmF0ZSBzdWJtaXRTdWNjZXNzOiBib29sZWFuID0gZmFsc2U7XG4gICAgLy8gRm9ybSBlcnJvcnMgb3V0cHV0XG4gICAgcHJpdmF0ZSBmb3JtRXJyb3JzOiBzdHJpbmc7XG5cbiAgICAvLyBDb25zdHJ1Y3RvciB3aXRoIG91ciBodHRwIHNlcnZpY2UgaW5qZWN0ZWRcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNwcmVhZHNoZWV0U2VydmljZTogU3ByZWFkc2hlZXRTZXJ2aWNlKSB7fVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxuXG4gICAgaGFuZGxlU3VibWl0KGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zdWJtaXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgICAgICAgaWYoIXRoaXMuZm9ybUlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtRXJyb3JzID0gdGhpcy52YWxpZGF0aW9uRXJyb3JzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JtSXNTdWJtaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBcIlRpbWVzdGFtcFwiOiBkYXRlLnRvTG9jYWxlU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgXCJGaXJzdCBOYW1lXCI6IHRoaXMuZmlyc3ROYW1lLFxuICAgICAgICAgICAgICAgIFwiTGFzdCBOYW1lXCI6IHRoaXMubGFzdE5hbWUsXG4gICAgICAgICAgICAgICAgXCJFbWFpbCBBZGRyZXNzXCI6IHRoaXMuZW1haWxBZGRyZXNzLFxuICAgICAgICAgICAgICAgIFwiSG9tZXRvd25cIjogdGhpcy5ob21ldG93bixcbiAgICAgICAgICAgICAgICBcIkhpZ2hzY2hvb2xcIjogdGhpcy5oaWdoc2Nob29sLFxuICAgICAgICAgICAgICAgIFwiTWFqb3JcIjogdGhpcy5tYWpvcixcbiAgICAgICAgICAgICAgICBcIkV4cGVyaWVuY2VcIjogdGhpcy5leHBlcmllbmNlLFxuICAgICAgICAgICAgICAgIFwiT3RoZXIgQ2x1YnNcIjogdGhpcy5vdGhlckNsdWJzLFxuICAgICAgICAgICAgICAgIFwiQ29udGFjdCBNZVwiOiB0aGlzLmNvbnRhY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN1Ym1pdEFic2VudEZvcm0oZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJtaXRzIG91ciBmb3JtIHRvIHRoZSBzcHJlYWRzaGVldCBieSBjYWxsaW5nIG91ciBzZXJ2aWNlIG1ldGhvZC5cbiAgICAgKiBPbiBzdWNjZXNzLCB3ZSBzaG93IG91ciBjb25maXJtYXRpb24gbW9kYWwgYW5kIHJlc2V0IG91ciByc3ZwIG1vZGFsLlxuICAgICAqIE9uIGZhaWx1cmUsIHdlIGhpZGUgb3VyIHN1Ym1pdHRpbmcgZGlhbG9nIGFuZCBzaG93IG91ciBzdWJtaXNzaW9uIGVycm9yIHRvIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgLSBkYXRhIHRvIHN1Ym1pdCB0byBvdXIgc3ByZWFkc2hlZXRcbiAgICAgKi9cbiAgICBwcml2YXRlIHN1Ym1pdEFic2VudEZvcm0oZGF0YTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3ByZWFkc2hlZXRTZXJ2aWNlLnBvc3RSb3dUb1NwcmVhZHNoZWV0KHRoaXMuZ29vZ2xlU2hlZXRzQXBpVXJsLCB0aGlzLmdvb2dsZVNoZWV0c0JhY2t1cEFwaVVybCwgZGF0YSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rm9ybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VibWl0U3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Jc1N1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1FcnJvcnMgPSB0aGlzLnN1Ym1pc3Npb25FcnJvcjtcbiAgICAgICAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIG91ciBpbnB1dCBmaWVsZHMsIGVycm9ycywgYW5kIHJlc2V0cyBvdXIgZm9ybSBpcyBzdWJtaXR0aW5nIGZsYWcuXG4gICAgICovXG4gICAgcHJpdmF0ZSByZXNldEZvcm0oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmlyc3ROYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0TmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1haWxBZGRyZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5ob21ldG93biA9IG51bGw7XG4gICAgICAgIHRoaXMuaGlnaHNjaG9vbCA9IG51bGw7XG4gICAgICAgIHRoaXMubWFqb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmV4cGVyaWVuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLm90aGVyQ2x1YnMgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcm1FcnJvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcm1Jc1N1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGcm9udC1lbmQgdmFsaWRhdGlvbiBmb3Igb3VyIGZvcm0uXG4gICAgICogT3VyIGZvcm0gaXMgdmFsaWQgb25seSBpZiBhbGwgZmllbGRzIGFyZSBwb3B1bGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBmb3JtIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGZvcm1Jc1ZhbGlkKCk6IGJvb2xlYW4ge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0TmFtZSAhPSBudWxsICAgICAgICYmIHRoaXMuZmlyc3ROYW1lICE9ICcnXG4gICAgICAgICAgICAmJiB0aGlzLmxhc3ROYW1lICE9IG51bGwgICAgICAgICYmIHRoaXMubGFzdE5hbWUgIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMuZW1haWxBZGRyZXNzICE9IG51bGwgICAgJiYgdGhpcy5lbWFpbEFkZHJlc3MgIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMuaG9tZXRvd24gIT0gbnVsbCAgICAgICAgJiYgdGhpcy5ob21ldG93biAhPSAnJ1xuICAgICAgICAgICAgJiYgdGhpcy5oaWdoc2Nob29sICE9IG51bGwgICAgICAmJiB0aGlzLmhpZ2hzY2hvb2wgIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMubWFqb3IgIT0gbnVsbCAgICAgICAgICAgJiYgdGhpcy5tYWpvciAhPSAnJ1xuICAgICAgICAgICAgJiYgdGhpcy5leHBlcmllbmNlICE9IG51bGwgICAgICAmJiB0aGlzLmV4cGVyaWVuY2UgIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMub3RoZXJDbHVicyAhPSBudWxsICAgICAgJiYgdGhpcy5vdGhlckNsdWJzICE9ICcnXG4gICAgICAgICAgICAmJiB0aGlzLmNvbnRhY3QgIT0gbnVsbCAgICAgICAgICYmIHRoaXMuY29udGFjdCAhPSAnJztcblxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBIZWFkZXJzLCBIdHRwIH0gZnJvbSBcIkBhbmd1bGFyL2h0dHBcIjtcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGludGVyYWN0IHdpdGggb3VyIEdvb2dsZSBzcHJlYWRzaGVldC5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNwcmVhZHNoZWV0U2VydmljZSB7XG5cbiAgICAvLyBIVFRQIGhlYWRlcnNcbiAgICBwcml2YXRlIGhlYWRlcnMgPSBuZXcgSGVhZGVycyh7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ30pO1xuXG4gICAgLy8gQ29uc3RydWN0b3Igd2l0aCBvdXIgaHR0cCBzZXJ2aWNlIGluamVjdGVkXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwOiBIdHRwKSB7fVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcG9zdCB0aGUgZGF0YSBwYXNzZWQgaW4gdG8gb3VyIHNwcmVhZHNoZWV0LlxuICAgICAqIFJlamVjdHMgdGhlIHByb21pc2UgaWYgdGhlcmUgaXMgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXBpVXJsIC0gdXJsIG9mIHRoZSBnb29nbGUgc2hlZXRzIEFQSVxuICAgICAqIEBwYXJhbSBiYWNrdXBBcGlVcmwgLSB1cmwgb2YgaHRlIGdvb2dsZSBzaGVldHMgYmFja3VwIEFQSVxuICAgICAqIEBwYXJhbSBkYXRhIC0gZGF0YSB0byBhZGQgdG8gb3VyIHNwcmVhZHNoZWV0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8SlNPTj59IC0gUHJvbWlzZSBob2xkaW5nIHRoZSBzdWNjZXNzZnVsbHkgcG9zdGVkIG9iamVjdCwgb3IgYSByZWplY3RlZCBwcm9taXNlIHdpdGggYW4gZXJyb3JcbiAgICAgKi9cbiAgICBwdWJsaWMgcG9zdFJvd1RvU3ByZWFkc2hlZXQoYXBpVXJsOiBzdHJpbmcsIGJhY2t1cEFwaVVybDogc3RyaW5nLCBkYXRhOiBPYmplY3QpOiBQcm9taXNlPEpTT04+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cFxuICAgICAgICAgICAgLnBvc3QoYXBpVXJsLCBkYXRhLCB7aGVhZGVyczogdGhpcy5oZWFkZXJzfSlcbiAgICAgICAgICAgIC50b1Byb21pc2UoKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHRoaXMucG9zdFJvd1RvU3ByZWFkc2hlZXRCYWNrdXAoYmFja3VwQXBpVXJsLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gcG9zdCB0aGUgZGF0YSBwYXNzZWQgaW4gdG8gb3VyIGJhY2t1cCBzcHJlYWRzaGVldC5cbiAgICAgKiBUaGlzIGlzIGEgYmFja3VwIHBvc3QgaW4gY2FzZSBvdXIgcGVyc29uYWwgc2VydmVyIGZhaWxzLlxuICAgICAqIFJlamVjdHMgdGhlIHByb21pc2UgaWYgdGhlcmUgaXMgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFja3VwQXBpVXJsIC0gdXJsIG9mIGh0ZSBnb29nbGUgc2hlZXRzIGJhY2t1cCBBUElcbiAgICAgKiBAcGFyYW0gZGF0YSAtIGRhdGEgdG8gYWRkIHRvIG91ciBzcHJlYWRzaGVldFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEpTT04+fSAtIFByb21pc2UgaG9sZGluZyB0aGUgc3VjY2Vzc2Z1bGx5IHBvc3RlZCBvYmplY3QsIG9yIGEgcmVqZWN0ZWQgcHJvbWlzZSB3aXRoIGFuIGVycm9yXG4gICAgICovXG4gICAgcHVibGljIHBvc3RSb3dUb1NwcmVhZHNoZWV0QmFja3VwKGJhY2t1cEFwaVVybDogc3RyaW5nLCBkYXRhOiBPYmplY3QpOiBQcm9taXNlPEpTT04+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHR0cFxuICAgICAgICAgICAgLnBvc3QoYmFja3VwQXBpVXJsLCBkYXRhLCB7aGVhZGVyczogdGhpcy5oZWFkZXJzfSlcbiAgICAgICAgICAgIC50b1Byb21pc2UoKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgLmNhdGNoKFNwcmVhZHNoZWV0U2VydmljZS5oYW5kbGVFcnJvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbGwgcnN2cCBzZXJ2aWNlIGVycm9ycyAoYWZ0ZXIgb3VyIGJhY2t1cCBjYWxsKSB3aGVuIGludGVyZmFjaW5nXG4gICAgICogd2l0aCB0aGUgZ29vZ2xlIHNwcmVhZHNoZWV0IGFwaS4gV2UgbG9nIHRoZSBlcnJvciBhbmQgcmVqZWN0IHRoZSBwcm9taXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVycm9yIC0gRXJyb3IgdG8gbG9nIGFuZCByZWplY3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSAtIEEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGhhbmRsZUVycm9yKGVycm9yOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCB3aGVuIGF0dGVtcHRpbmcgdG8gc2VuZCBkYXRhIHRvIG91ciBzcHJlYWRzaGVldDogJywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvc2VydmljZS9nb29nbGUtc3ByZWFkc2hlZXQuc2VydmljZS50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+UHJvc3BlY3RpdmUgUGxheWVyczwvaDE+XFxuPHA+SWxsaW5vaXMgVWx0aW1hdGUgaGFzIGhhZCBhIGxvbmcgaGlzdG9yeSBzaW5jZSBpdHMgaW5jZXB0aW9uIGluIHRoZSBlYXJseSAxOTkwcyBhbmQgbm93IGNvbnNpc3RlbnRseSBjb21wZXRlcyB3aXRoIGJlc3QgY29tcGV0aXRpb24gYXJvdW5kIHRoZSBjb3VudHJ5LiBJbGxpbm9pcyBoYXMgcXVhbGlmaWVkIGZvciBuYXRpb25hbCBjaGFtcGlvbnNoaXBzIDYgb3V0IG9mIHRoZSBsYXN0IDkgeWVhcnMgYmVoaW5kIG91ciBkZWRpY2F0aW9uLCBkZXRlcm1pbmF0aW9uLCBhbmQgZGlzdGluZ3Vpc2hlZCBjaGFyYWN0ZXIgb24gYW5kIG9mZiB0aGUgZmllbGQuIElsbGlub2lzIGFsdW1uaSBoYXZlIGdvbmUgb24gdG8gcGxheSBmb3IgbmF0aW9uYWxzIGNhbGliZXIgY2x1YiB0ZWFtcyBzdWNoIGFzIENoaWNhZ28gTWFjaGluZSwgTWlubmVhcG9saXMgRHJhZyAnbiBUaHJ1c3QsIENpbmNpbm5hdGkgU3RlYW1ib2F0LCBBdGxhbnRhIENoYWluIExpZ2h0bmluZywgYW5kIFNhbiBGcmFuY2lzY28gQmxhY2tiaXJkLiBBbHVtbmkgaGF2ZSBwbGF5ZWQgb24gcHJvZmVzc2lvbmFsIEFVREwgdGVhbXMgc3VjaCBhcyB0aGUgQ2hpY2FnbyBXaWxkZmlyZSwgTWlubmVzb3RhIFdpbmRjaGlsbCwgQ2luY2lubmF0aSBSZXZvbHV0aW9uLCBhbmQgdGhlIFNhbiBKb3NlIFNwaWRlcnMuIFRoZXkgaGF2ZSBhbHNvIGNyZWF0ZWQgYW5kIGNhcHRhaW5lZCBjbHViIHRlYW1zIGluY2x1ZGluZyBDaGljYWdvIE1hY2hpbmUsIEJsYWNrIE1hcmtldCBVbHRpbWF0ZSwgYW5kIEJlYWNoZnJvbnQgVWx0aW1hdGUsIGFuZCBoYXZlIGdvbmUgb24gdG8gY29hY2ggY29sbGVnZSB1bHRpbWF0ZSBhdCB0aGUgVW5pdmVyc2l0eSBvZiBJbGxpbm9pcywgdGhlIFVuaXZlcnNpdHkgb2YgQ2hpY2FnbywgTm9ydGh3ZXN0ZXJuIFVuaXZlcnNpdHksIGFuZCB0aGUgVW5pdmVyc2l0eSBvZiBLZW50dWNreS4gSXQncyBzYWZlIHRvIHNheSB0aGF0IG9uY2UgeW91IHBsYXkgdWx0aW1hdGUgYXQgSWxsaW5vaXMgeW91IGFyZSBvcGVuZWQgdXAgdG8gYSB3b3JsZCBvZiBvcHBvcnR1bml0eSB0aHJvdWdoIG91ciBhbHVtbmkgbmV0d29yaywgd2hvIGFyZSBtb3JlIHRoYW4gd2lsbGluZyB0byBhc3Npc3QgeW91IG9uIHlvdXIgam91cm5leSB0aG91Z2ggdWx0aW1hdGUgZHVyaW5nIGFuZCBiZXlvbmQgeW91ciBjb2xsZWdlIHllYXJzLjwvcD5cXG48cD5XaGlsZSB5b3UgYXJlIGF0IElsbGlub2lzIHlvdSB3aWxsIGVuam95IGEgbnVtYmVyIG9mIGV4cGVyaWVuY2VzLiBUaGlzIHJhbmdlcyBmcm9tIHRlYW0gc29jaWFscyB0byBzdHVkeSBncm91cHMgYW5kIGZyb20gcHJhY3RpY2VzIGluIElyd2luIEZpZWxkaG91c2UgdG8gcGxheWluZyBnYW1lcyBvbiB0aGUgc2hvcmVzIG9mIFNhbiBEaWVnby4gWW91ciB0ZWFtbWF0ZXMgd29uJ3Qgb25seSBiZSB5b3VyIGJlc3QgZnJpZW5kcywgdGhleSB3aWxsIGJlIGZhbWlseS4gWW91IHdpbGwgbGVhcm4gdGhlIHZhcmlvdXMgd2F5cyB1bHRpbWF0ZSBpcyBwbGF5ZWQsIGhvdyB0byBleHBhbmQgeW91ciB0aHJvd2luZyBhcnNlbmFsLCBob3cgdG8gaW1wcm92ZSB5b3VyIGF0aGxldGljaXNtLCBhbmQgaG93IHRvIHRha2UgeW91ciBnYW1lIHRvIHRoZSBuZXh0IGxldmVsLiBBIG1ham9yaXR5IG9mIG91ciB0ZWFtIGRpZG4ndCBwbGF5IG9yZ2FuaXplZCB1bHRpbWF0ZSBiZWZvcmUgY29taW5nIHRvIGNvbGxlZ2UsIGFuZCBhcmUgbm93IHNvbWUgb2YgdGhlIGJlc3QgcGxheWVycyBpbiB0aGUgR3JlYXQgTGFrZXMgcmVnaW9uIChzZWUgb3VyIEFsbC1SZWdpb25zIGhvbm9ycyBwYWdlKS48L3A+XFxuPHA+V2UgZW5jb3VyYWdlIHByb3NwZWN0aXZlIHBsYXllcnMgdG8gZmlsbCBvdXQgb3VyIGludGVyZXN0IGZvcm0gYW5kIHRvIHJlYWNoIG91dCB0byB0aGUgY2FwdGFpbnMgZXNwZWNpYWxseSBpZiB5b3Ugd2lsbCBiZSBvbiBjYW1wdXMuIFdlIGFyZSBtb3JlIHRoYW4gaGFwcHkgdG8gbWVldCB1cCBhbmQgZGlzY3VzcyB3aGF0IElsbGlub2lzIGNhbiBkbyBmb3IgeW91LCBhbmQgdG8gc2VlIHdoYXQgeW91IGNhbiBkbyB0byBiZSByZWFkeSBmb3IgSWxsaW5vaXMgb25jZSB5b3UgZ2V0IG9uIGNhbXB1cy4gT3VyIGNvbnRhY3QgaW5mb3JtYXRpb24gaXMgYmVsb3cuIFRoYW5rIHlvdSBmb3IgdGFraW5nIHRoZSB0aW1lIHRvIHZpc2l0IG91ciB3ZWJzaXRlLCBhbmQgd2UgaG9wZSB0byBoZWFyIGZyb20geW91IHNvb24uPC9wPlxcblxcbjxmb3JtIGNsYXNzPVxcXCJ1aSBmb3JtXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInR3byBmaWVsZHNcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxhYmVsPkZpcnN0IE5hbWUgPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwiZmlyc3ROYW1lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJmaXJzdC1uYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiRmlyc3QgTmFtZVxcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+TGFzdCBOYW1lIDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcImxhc3ROYW1lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJsYXN0LW5hbWVcXFwiIHBsYWNlaG9sZGVyPVxcXCJMYXN0IE5hbWVcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0d28gZmllbGRzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD5FbWFpbCBBZGRyZXNzIDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcImVtYWlsQWRkcmVzc1xcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwiZW1haWwtYWRkcmVzc1xcXCIgcGxhY2Vob2xkZXI9XFxcIkVtYWlsIEFkZHJlc3NcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxhYmVsPldoYXQgaXMgeW91ciBIb21ldG93bj8gPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwiaG9tZXRvd25cXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcImhvbWUtdG93blxcXCIgcGxhY2Vob2xkZXI9XFxcIkhvbWV0b3duXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidHdvIGZpZWxkc1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGFiZWw+V2hhdCBoaWdoIHNjaG9vbCBkaWQgeW91IGF0dGVuZD8gPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwiaGlnaHNjaG9vbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwiaGlnaHNjaG9vbFxcXCIgcGxhY2Vob2xkZXI9XFxcIkhpZ2ggU2Nob29sXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD5XaGF0IG1ham9yIGFyZSB5b3UgcGxhbm5pbmcgb24gZ29pbmcgaW50bz8gPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwibWFqb3JcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcIm1ham9yXFxcIiBwbGFjZWhvbGRlcj1cXFwiTWFqb3JcXFwiPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPkhvdyBsb25nIGhhdmUgeW91IHBsYXllZCB1bHRpbWF0ZS93aGF0IGtpbmQgb2YgZXhwZXJpZW5jZSBkbyB5b3UgaGF2ZT8gPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgPHRleHRhcmVhIFsobmdNb2RlbCldPVxcXCJleHBlcmllbmNlXFxcIiBuYW1lPVxcXCJleHBlcmllbmNlXFxcIiByb3dzPVxcXCIyXFxcIj48L3RleHRhcmVhPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPldoYXQgb3RoZXIgY2x1YnMvb3JnYW5pemF0aW9ucyBhcmUgeW91IHBsYW5uaW5nIG9uIGpvaW5pbmcgd2hlbiB5b3UgYXJyaXZlIG9uIGNhbXB1cz8gPHNwYW4gY2xhc3M9XFxcInJlcXVpcmVkXFxcIj4qPC9zcGFuPjwvbGFiZWw+XFxuICAgICAgICAgICAgPHRleHRhcmVhIFsobmdNb2RlbCldPVxcXCJvdGhlckNsdWJzXFxcIiBuYW1lPVxcXCJvdGhlci1jbHVic1xcXCIgcm93cz1cXFwiMlxcXCI+PC90ZXh0YXJlYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5saW5lIGZpZWxkc1xcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPldvdWxkIHlvdSBiZSBhbHJpZ2h0IHdpdGggYSBjYXB0YWluIG9yIGNvYWNoIHJlYWNoaW5nIG91dCB0byB5b3U/IDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidWkgcmFkaW8gY2hlY2tib3hcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJjb250YWN0LXllc1xcXCIgWyhuZ01vZGVsKV09XFxcImNvbnRhY3RcXFwiIHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJjb250YWN0XFxcIiB2YWx1ZT1cXFwiWWVzXFxcIiBjaGVja2VkPVxcXCJjaGVja2VkXFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcImhpZGRlblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJjb250YWN0LXllc1xcXCI+WWVzPC9sYWJlbD5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ1aSByYWRpbyBjaGVja2JveFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgaWQ9XFxcImNvbnRhY3Qtbm9cXFwiIFsobmdNb2RlbCldPVxcXCJjb250YWN0XFxcIiB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwiY29udGFjdFxcXCIgdmFsdWU9XFxcIk5vXFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcImhpZGRlblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJjb250YWN0LW5vXFxcIj5ObzwvbGFiZWw+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDxidXR0b24gKGNsaWNrKT1cXFwiaGFuZGxlU3VibWl0KCRldmVudClcXFwiIGNsYXNzPVxcXCJ1aSBidXR0b25cXFwiIHR5cGU9XFxcInN1Ym1pdFxcXCI+U3VibWl0PC9idXR0b24+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpIGVycm9yIG1lc3NhZ2VcXFwiICpuZ0lmPVxcXCJmb3JtRXJyb3JzXFxcIj5cXG4gICAgICAgIDxwPnt7Zm9ybUVycm9yc319PC9wPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidWkgc3VjY2VzcyBtZXNzYWdlXFxcIiAqbmdJZj1cXFwic3VibWl0U3VjY2Vzc1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoZWFkZXJcXFwiPkZvcm0gU3VibWl0dGVkPC9kaXY+XFxuICAgICAgICA8cD5UaGUgZm9ybSB3YXMgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZCEgVGhhbmtzIGZvciB0YWtpbmcgdGhlIHRpbWUgdG8gZmlsbCBpdCBvdXQuPC9wPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiAqbmdJZj1cXFwiZm9ybUlzU3VibWl0dGluZ1xcXCIgY2xhc3M9XFxcInVpIGFjdGl2ZSBpbnZlcnRlZCBkaW1tZXJcXFwiPjxkaXYgY2xhc3M9XFxcInVpIHRleHQgbG9hZGVyXFxcIj5TdWJtaXR0aW5nPC9kaXY+PC9kaXY+XFxuPC9mb3JtPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJvc3BlY3RpdmUtcGxheWVycy5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcHJvc3BlY3RpdmUtcGxheWVycy9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJwLFxcbmxhYmVsIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbi51aS5mb3JtIHtcXG4gIG1hcmdpbjogMjBweCBhdXRvO1xcbn1cXG4udWkuZm9ybSAudWkuZXJyb3IubWVzc2FnZSxcXG4udWkuZm9ybSAudWkuc3VjY2Vzcy5tZXNzYWdlIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4udWkuZm9ybSAudWkuZXJyb3IubWVzc2FnZSBwLFxcbi51aS5mb3JtIC51aS5zdWNjZXNzLm1lc3NhZ2UgcCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvcHJvc3BlY3RpdmUtcGxheWVycy9wcm9zcGVjdGl2ZS1wbGF5ZXJzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2NvbnRhY3QnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2NvbnRhY3QuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2NvbnRhY3QuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBDb250YWN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICBjb25zb2xlLmxvZygnQ29udGFjdCBDb21wb25lbnQhJyk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGgxIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPkNvbnRhY3QgVXM8L2gxPlxcbjxwPkZvciBhbnkgcXVlc3Rpb25zIHJlZ2FyZGluZyBwcmFjdGljZSBvciBjbHViIGRldGFpbHMsIGZlZWwgZnJlZSB0byBjb250YWN0IGFueSBvZiB0aGUgY3VycmVudCBjYXB0YWluczo8L3A+XFxuXFxuPHAgY2xhc3M9XFxcImNhcHRhaW5cXFwiPkNocmlzIEJ1Y2h0YSAtLSBjYnVjaHRhMkBnbWFpbC5jb208L3A+XFxuPHAgY2xhc3M9XFxcImNhcHRhaW5cXFwiPkJlbiBGb3N0ZXIgLS0gYmVuLmZvc3RlcjIzNEBnbWFpbC5jb208L3A+XFxuPHAgY2xhc3M9XFxcImNhcHRhaW5cXFwiPkphY29iIEtvbWVuZGEgLS0gamFjb2Iua29tZW5kYUBnbWFpbC5jb208L3A+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2NvbnRhY3QvY29udGFjdC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9jb250YWN0LmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9jb250YWN0L2NvbnRhY3QuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5jYXB0YWluIHtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvY29udGFjdC9jb250YWN0LmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgJy4vc2hhcmVkLXN0eWxlL3N0eWxlcy5jc3MnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FwcCcsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYXBwLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9hcHAuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2FwcC5jb21wb25lbnQudHMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZXMuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3R5bGVzLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zdHlsZXMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvc2hhcmVkLXN0eWxlL3N0eWxlcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIEdlbmVyYWwgRWxlbWVudHMgKi9cXG5ib2R5IHtcXG4gICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgcmVxdWlyZShcIi4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL2dsb2JhbC9iYWNrZ3JvdW5kLmpwZ1wiKSArIFwiKTtcXG4gICAgZm9udC1mYW1pbHk6ICdRdWF0dHJvY2VudG8nLCBzZXJpZjtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBvdmVyZmxvdy15OiBzY3JvbGw7XFxufVxcbnAge1xcbiAgICB0ZXh0LWluZGVudDogMjVweDtcXG4gICAgcGFkZGluZzogNXB4O1xcbn1cXG5hIHtcXG4gICAgY29sb3I6ICNmZjYyMjY7XFxufVxcbmE6aG92ZXIge1xcbiAgICBjb2xvcjogIzAwMDA0RDtcXG59XFxuaW5wdXQge1xcbiAgICBmb250LWZhbWlseTogJ1F1YXR0cm9jZW50bycsIHNlcmlmICFpbXBvcnRhbnQ7XFxufVxcblxcbmlucHV0OmZvY3VzIHtcXG4gICAgIGJvcmRlci1jb2xvcjogI2ZmNjIyNiAhaW1wb3J0YW50O1xcbn1cXG5cXG4vKiBIZWFkZXJzICovXFxuLnVpLmhlYWRlciB7XFxuICAgIGZvbnQtZmFtaWx5OiAnT3N3YWxkJywgc2Fucy1zZXJpZjtcXG4gICAgY29sb3I6ICMwMDAwNEQ7XFxuICAgIGxldHRlci1zcGFjaW5nOiAxcHg7XFxuICAgIC8qdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsqL1xcbn1cXG5cXG4vKiBUYWJsZXMgKi9cXG4udWkudGFibGUgdHIsIC51aS50YWJsZSB0ZCB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgYm9yZGVyLXRvcDogMDtcXG59XFxuXFxuLyogU2Vjb25kYXJ5IE1lbnVzICovXFxuLnVpLnNlY29uZGFyeS5wb2ludGluZy5tZW51IHtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcbi51aS5zZWNvbmRhcnkucG9pbnRpbmcubWVudSAuaXRlbS5hY3RpdmUge1xcbiAgICBib3JkZXItY29sb3I6ICMwMDAwNEQ7XFxufVxcblxcbi8qIFJhbmRvbSAqL1xcbi5idXR0b24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmY2MjI2ICFpbXBvcnRhbnQ7XFxuICAgIGNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xcbn1cXG4ucmVxdWlyZWQge1xcbiAgICBjb2xvcjogI2ZmNjIyNjtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9zcmMvYXBwL3NoYXJlZC1zdHlsZS9zdHlsZXMuY3NzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvYmFja2dyb3VuZC5qcGdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9nbG9iYWwvYmFja2dyb3VuZC5qcGdcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCI8bWFpbiBjbGFzcz1cXFwibWFpbi1jb250YWluZXJcXFwiPlxcbiAgICA8cGFnZS1mcmFtZT48L3BhZ2UtZnJhbWU+XFxuPC9tYWluPlxcblwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9hcHAuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9hcHAuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5tYWluLWNvbnRhaW5lciB7XFxuICBoZWlnaHQ6IDEwMCU7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvYXBwLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWdtQ29yZU1vZHVsZSB9IGZyb20gJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCI7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuXG5pbXBvcnQgeyBQcmFjdGljZUNvbXBvbmVudCB9IGZyb20gXCIuL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgVG91cm5hbWVudHNDb21wb25lbnQgfSBmcm9tIFwiLi90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnRcIjtcbmltcG9ydCB7IFJvc3RlckNvbXBvbmVudCB9IGZyb20gXCIuL3Jvc3Rlci9yb3N0ZXIuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBBYnNlbnRDb21wb25lbnQgfSBmcm9tIFwiLi9hYnNlbnQvYWJzZW50LmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL3JvdXRlclwiO1xuaW1wb3J0IHsgUk9VVEVTIH0gZnJvbSBcIi4uL2FwcC5yb3V0ZXNcIjtcbmltcG9ydCB7IFNwcmVhZHNoZWV0U2VydmljZSB9IGZyb20gXCIuLi9zZXJ2aWNlL2dvb2dsZS1zcHJlYWRzaGVldC5zZXJ2aWNlXCI7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBCcm93c2VyTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgQWdtQ29yZU1vZHVsZS5mb3JSb290KHtcbiAgICAgICAgICAgIGFwaUtleTogJ0FJemFTeUJSSVhBazV4ZHZuM2V6eXBzU2U1NWY4ZFpoY0hoZUFaOCdcbiAgICAgICAgfSksXG4gICAgICAgIFJvdXRlck1vZHVsZS5mb3JSb290KFJPVVRFUylcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBQcmFjdGljZUNvbXBvbmVudCxcbiAgICAgICAgVG91cm5hbWVudHNDb21wb25lbnQsXG4gICAgICAgIFJvc3RlckNvbXBvbmVudCxcbiAgICAgICAgQWJzZW50Q29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFsgU3ByZWFkc2hlZXRTZXJ2aWNlIF1cbn0pXG5leHBvcnQgY2xhc3MgVGVhbU1vZHVsZSB7fVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3RlYW0vdGVhbS5tb2R1bGUudHMiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG4vLyBtYWluIG1vZHVsZXNcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZGlyZWN0aXZlcycpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc2VydmljZXMnKSk7XG4vLyBHb29nbGUgTWFwcyB0eXBlc1xuLy8gY29yZSBtb2R1bGVcbi8vIHdlIGV4cGxpY2l0bHkgZXhwb3J0IHRoZSBtb2R1bGUgaGVyZSB0byBwcmV2ZW50IHRoaXMgSW9uaWMgMiBidWc6XG4vLyBodHRwOi8vc3RldmVtaWNoZWxvdHRpLmNvbS9pbnRlZ3JhdGUtYW5ndWxhci0yLWdvb2dsZS1tYXBzLWludG8taW9uaWMtMi9cbnZhciBjb3JlX21vZHVsZV8xID0gcmVxdWlyZSgnLi9jb3JlLW1vZHVsZScpO1xuZXhwb3J0cy5BZ21Db3JlTW9kdWxlID0gY29yZV9tb2R1bGVfMS5BZ21Db3JlTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGdvb2dsZV9tYXBfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXAgPSBnb29nbGVfbWFwXzEuU2VibUdvb2dsZU1hcDtcbnZhciBnb29nbGVfbWFwX2NpcmNsZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtY2lyY2xlJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBDaXJjbGUgPSBnb29nbGVfbWFwX2NpcmNsZV8xLlNlYm1Hb29nbGVNYXBDaXJjbGU7XG52YXIgZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtaW5mby13aW5kb3cnKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgPSBnb29nbGVfbWFwX2luZm9fd2luZG93XzEuU2VibUdvb2dsZU1hcEluZm9XaW5kb3c7XG52YXIgZ29vZ2xlX21hcF9rbWxfbGF5ZXJfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwLWttbC1sYXllcicpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwS21sTGF5ZXIgPSBnb29nbGVfbWFwX2ttbF9sYXllcl8xLlNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbnZhciBnb29nbGVfbWFwX21hcmtlcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtbWFya2VyJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBNYXJrZXIgPSBnb29nbGVfbWFwX21hcmtlcl8xLlNlYm1Hb29nbGVNYXBNYXJrZXI7XG52YXIgZ29vZ2xlX21hcF9wb2x5Z29uXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5Z29uJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBQb2x5Z29uID0gZ29vZ2xlX21hcF9wb2x5Z29uXzEuU2VibUdvb2dsZU1hcFBvbHlnb247XG52YXIgZ29vZ2xlX21hcF9wb2x5bGluZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUnKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlsaW5lID0gZ29vZ2xlX21hcF9wb2x5bGluZV8xLlNlYm1Hb29nbGVNYXBQb2x5bGluZTtcbnZhciBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCcpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludCA9IGdvb2dsZV9tYXBfcG9seWxpbmVfcG9pbnRfMS5TZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9nb29nbGUtbWFwcy1hcGktd3JhcHBlcicpO1xudmFyIGNpcmNsZV9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9jaXJjbGUtbWFuYWdlcicpO1xudmFyIGluZm9fd2luZG93X21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL2luZm8td2luZG93LW1hbmFnZXInKTtcbnZhciBtYXJrZXJfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvbWFya2VyLW1hbmFnZXInKTtcbnZhciBwb2x5Z29uX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlnb24tbWFuYWdlcicpO1xudmFyIHBvbHlsaW5lX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlsaW5lLW1hbmFnZXInKTtcbnZhciBrbWxfbGF5ZXJfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi8uLi9zZXJ2aWNlcy9tYW5hZ2Vycy9rbWwtbGF5ZXItbWFuYWdlcicpO1xuLyoqXG4gKiBTZWJNR29vZ2xlTWFwIHJlbmRlcnMgYSBHb29nbGUgTWFwLlxuICogKipJbXBvcnRhbnQgbm90ZSoqOiBUbyBiZSBhYmxlIHNlZSBhIG1hcCBpbiB0aGUgYnJvd3NlciwgeW91IGhhdmUgdG8gZGVmaW5lIGEgaGVpZ2h0IGZvciB0aGUgQ1NTXG4gKiBjbGFzcyBgc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lcmAuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgU2VibUdvb2dsZU1hcCB9IGZyb20gJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgZGlyZWN0aXZlczogW1NlYm1Hb29nbGVNYXBdLFxuICogIHN0eWxlczogW2BcbiAqICAgIC5zZWJtLWdvb2dsZS1tYXAtY29udGFpbmVyIHtcbiAqICAgICAgaGVpZ2h0OiAzMDBweDtcbiAqICAgIH1cbiAqIGBdLFxuICogIHRlbXBsYXRlOiBgXG4gKiAgICA8c2VibS1nb29nbGUtbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cbiAqICAgIDwvc2VibS1nb29nbGUtbWFwPlxuICogIGBcbiAqIH0pXG4gKiBgYGBcbiAqL1xudmFyIFNlYm1Hb29nbGVNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXAoX2VsZW0sIF9tYXBzV3JhcHBlcikge1xuICAgICAgICB0aGlzLl9lbGVtID0gX2VsZW07XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvbmdpdHVkZSB0aGF0IGRlZmluZXMgdGhlIGNlbnRlciBvZiB0aGUgbWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb25naXR1ZGUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhdGl0dWRlIHRoYXQgZGVmaW5lcyB0aGUgY2VudGVyIG9mIHRoZSBtYXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhdGl0dWRlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIFRoZSBkZWZhdWx0IHpvb20gbGV2ZWwgaXMgOC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuem9vbSA9IDg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzL2Rpc2FibGVzIGlmIG1hcCBpcyBkcmFnZ2FibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHpvb20gYW5kIGNlbnRlciBvbiBkb3VibGUgY2xpY2suIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZURvdWJsZUNsaWNrWm9vbSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcy9kaXNhYmxlcyBhbGwgZGVmYXVsdCBVSSBvZiB0aGUgR29vZ2xlIG1hcC4gUGxlYXNlIG5vdGU6IFdoZW4gdGhlIG1hcCBpcyBjcmVhdGVkLCB0aGlzXG4gICAgICAgICAqIHZhbHVlIGNhbm5vdCBnZXQgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZURlZmF1bHRVSSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZmFsc2UsIGRpc2FibGVzIHNjcm9sbHdoZWVsIHpvb21pbmcgb24gdGhlIG1hcC4gVGhlIHNjcm9sbHdoZWVsIGlzIGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsd2hlZWwgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZmFsc2UsIHByZXZlbnRzIHRoZSBtYXAgZnJvbSBiZWluZyBjb250cm9sbGVkIGJ5IHRoZSBrZXlib2FyZC4gS2V5Ym9hcmQgc2hvcnRjdXRzIGFyZVxuICAgICAgICAgKiBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlbmFibGVkL2Rpc2FibGVkIHN0YXRlIG9mIHRoZSBab29tIGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb21Db250cm9sID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0eWxlcyB0byBhcHBseSB0byBlYWNoIG9mIHRoZSBkZWZhdWx0IG1hcCB0eXBlcy4gTm90ZSB0aGF0IGZvciBTYXRlbGxpdGUvSHlicmlkIGFuZCBUZXJyYWluXG4gICAgICAgICAqIG1vZGVzLCB0aGVzZSBzdHlsZXMgd2lsbCBvbmx5IGFwcGx5IHRvIGxhYmVscyBhbmQgZ2VvbWV0cnkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0cnVlIGFuZCB0aGUgbGF0aXR1ZGUgYW5kL29yIGxvbmdpdHVkZSB2YWx1ZXMgY2hhbmdlcywgdGhlIEdvb2dsZSBNYXBzIHBhblRvIG1ldGhvZCBpc1xuICAgICAgICAgKiB1c2VkIHRvXG4gICAgICAgICAqIGNlbnRlciB0aGUgbWFwLiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNNYXBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlUGFubmluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZSBvZiB0aGUgU3RyZWV0IFZpZXcgUGVnbWFuIGNvbnRyb2wuXG4gICAgICAgICAqIFRoaXMgY29udHJvbCBpcyBwYXJ0IG9mIHRoZSBkZWZhdWx0IFVJLCBhbmQgc2hvdWxkIGJlIHNldCB0byBmYWxzZSB3aGVuIGRpc3BsYXlpbmcgYSBtYXAgdHlwZVxuICAgICAgICAgKiBvbiB3aGljaCB0aGUgU3RyZWV0IFZpZXcgcm9hZCBvdmVybGF5IHNob3VsZCBub3QgYXBwZWFyIChlLmcuIGEgbm9uLUVhcnRoIG1hcCB0eXBlKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RyZWV0Vmlld0NvbnRyb2wgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdmlld3BvcnQgdG8gY29udGFpbiB0aGUgZ2l2ZW4gYm91bmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXRCb3VuZHMgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluaXRpYWwgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZSBvZiB0aGUgU2NhbGUgY29udHJvbC4gVGhpcyBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2FsZUNvbnRyb2wgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbml0aWFsIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2YgdGhlIE1hcCB0eXBlIGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcFR5cGVDb250cm9sID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrIG9uIGFcbiAgICAgICAgICogbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgcmlnaHQtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXG4gICAgICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBSaWdodENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXG4gICAgICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBEYmxDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIGNlbnRlciBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZW50ZXJDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB2aWV3cG9ydCBib3VuZHMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBtYXAgYmVjb21lcyBpZGxlIGFmdGVyIHBhbm5pbmcgb3Igem9vbWluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWRsZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHpvb20gbGV2ZWwgaGFzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb21DaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRvZG86IHRoaXMgc2hvdWxkIGJlIHNvbHZlZCB3aXRoIGEgbmV3IGNvbXBvbmVudCBhbmQgYSB2aWV3Q2hpbGQgZGVjb3JhdG9yXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9lbGVtLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXItaW5uZXInKTtcbiAgICAgICAgdGhpcy5faW5pdE1hcEluc3RhbmNlKGNvbnRhaW5lcik7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5faW5pdE1hcEluc3RhbmNlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyLmNyZWF0ZU1hcChlbCwge1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogdGhpcy5sYXRpdHVkZSB8fCAwLCBsbmc6IHRoaXMubG9uZ2l0dWRlIHx8IDAgfSxcbiAgICAgICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgICAgIG1pblpvb206IHRoaXMubWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4Wm9vbSxcbiAgICAgICAgICAgIGRpc2FibGVEZWZhdWx0VUk6IHRoaXMuZGlzYWJsZURlZmF1bHRVSSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRoaXMuZHJhZ2dhYmxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlQ3Vyc29yOiB0aGlzLmRyYWdnYWJsZUN1cnNvcixcbiAgICAgICAgICAgIGRyYWdnaW5nQ3Vyc29yOiB0aGlzLmRyYWdnaW5nQ3Vyc29yLFxuICAgICAgICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IHRoaXMua2V5Ym9hcmRTaG9ydGN1dHMsXG4gICAgICAgICAgICB6b29tQ29udHJvbDogdGhpcy56b29tQ29udHJvbCxcbiAgICAgICAgICAgIHN0eWxlczogdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICBzdHJlZXRWaWV3Q29udHJvbDogdGhpcy5zdHJlZXRWaWV3Q29udHJvbCxcbiAgICAgICAgICAgIHNjYWxlQ29udHJvbDogdGhpcy5zY2FsZUNvbnRyb2wsXG4gICAgICAgICAgICBtYXBUeXBlQ29udHJvbDogdGhpcy5tYXBUeXBlQ29udHJvbFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX2hhbmRsZU1hcENlbnRlckNoYW5nZSgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVNYXBab29tQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZU1hcE1vdXNlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUJvdW5kc0NoYW5nZSgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVJZGxlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgfTtcbiAgICAvKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hcE9wdGlvbnNDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbihjaGFuZ2VzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl91cGRhdGVNYXBPcHRpb25zQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBTZWJtR29vZ2xlTWFwLl9tYXBPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMTsgfSk7XG4gICAgICAgIG9wdGlvbktleXMuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBvcHRpb25zW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7IH0pO1xuICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5zZXRNYXBPcHRpb25zKG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYSByZXNpemUgZXZlbnQgb24gdGhlIGdvb2dsZSBtYXAgaW5zdGFuY2UuXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBnZXRzIHJlc29sdmVkIGFmdGVyIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLnRyaWdnZXJSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE5vdGU6IFdoZW4gd2Ugd291bGQgdHJpZ2dlciB0aGUgcmVzaXplIGV2ZW50IGFuZCBzaG93IHRoZSBtYXAgaW4gdGhlIHNhbWUgdHVybiAod2hpY2ggaXMgYVxuICAgICAgICAvLyBjb21tb24gY2FzZSBmb3IgdHJpZ2dlcmluZyBhIHJlc2l6ZSBldmVudCksIHRoZW4gdGhlIHJlc2l6ZSBldmVudCB3b3VsZCBub3RcbiAgICAgICAgLy8gd29yayAodG8gc2hvdyB0aGUgbWFwKSwgc28gd2UgdHJpZ2dlciB0aGUgZXZlbnQgaW4gYSB0aW1lb3V0LlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLnRyaWdnZXJNYXBFdmVudCgncmVzaXplJykudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snbGF0aXR1ZGUnXSA9PSBudWxsICYmIGNoYW5nZXNbJ2xvbmdpdHVkZSddID09IG51bGwgJiZcbiAgICAgICAgICAgIGNoYW5nZXNbJ2ZpdEJvdW5kcyddID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIHBvc2l0aW9uIHVwZGF0ZSBuZWVkZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBwcmVmZXIgZml0Qm91bmRzIGluIGNoYW5nZXNcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2ZpdEJvdW5kcyddICYmIHRoaXMuZml0Qm91bmRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpdEJvdW5kcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sYXRpdHVkZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMubG9uZ2l0dWRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdDZW50ZXIgPSB7XG4gICAgICAgICAgICBsYXQ6IHRoaXMubGF0aXR1ZGUsXG4gICAgICAgICAgICBsbmc6IHRoaXMubG9uZ2l0dWRlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy51c2VQYW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5wYW5UbyhuZXdDZW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIuc2V0Q2VudGVyKG5ld0NlbnRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9maXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZVBhbm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcHNXcmFwcGVyLnBhblRvQm91bmRzKHRoaXMuZml0Qm91bmRzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5maXRCb3VuZHModGhpcy5maXRCb3VuZHMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUuX2hhbmRsZU1hcENlbnRlckNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9tYXBzV3JhcHBlci5zdWJzY3JpYmVUb01hcEV2ZW50KCdjZW50ZXJfY2hhbmdlZCcpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWFwc1dyYXBwZXIuZ2V0Q2VudGVyKCkudGhlbihmdW5jdGlvbiAoY2VudGVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGF0aXR1ZGUgPSBjZW50ZXIubGF0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9uZ2l0dWRlID0gY2VudGVyLmxuZygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNlbnRlckNoYW5nZS5lbWl0KHsgbGF0OiBfdGhpcy5sYXRpdHVkZSwgbG5nOiBfdGhpcy5sb25naXR1ZGUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLnB1c2gocyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5faGFuZGxlQm91bmRzQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcyA9IHRoaXMuX21hcHNXcmFwcGVyLnN1YnNjcmliZVRvTWFwRXZlbnQoJ2JvdW5kc19jaGFuZ2VkJykuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9tYXBzV3JhcHBlci5nZXRCb3VuZHMoKS50aGVuKGZ1bmN0aW9uIChib3VuZHMpIHsgX3RoaXMuYm91bmRzQ2hhbmdlLmVtaXQoYm91bmRzKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKHMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUuX2hhbmRsZU1hcFpvb21DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzID0gdGhpcy5fbWFwc1dyYXBwZXIuc3Vic2NyaWJlVG9NYXBFdmVudCgnem9vbV9jaGFuZ2VkJykuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9tYXBzV3JhcHBlci5nZXRab29tKCkudGhlbihmdW5jdGlvbiAoeikge1xuICAgICAgICAgICAgICAgIF90aGlzLnpvb20gPSB6O1xuICAgICAgICAgICAgICAgIF90aGlzLnpvb21DaGFuZ2UuZW1pdCh6KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9oYW5kbGVJZGxlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzID0gdGhpcy5fbWFwc1dyYXBwZXIuc3Vic2NyaWJlVG9NYXBFdmVudCgnaWRsZScpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IF90aGlzLmlkbGUuZW1pdCh2b2lkIDApOyB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9oYW5kbGVNYXBNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgZW1pdHRlcjogdGhpcy5tYXBDbGljayB9LFxuICAgICAgICAgICAgeyBuYW1lOiAncmlnaHRjbGljaycsIGVtaXR0ZXI6IHRoaXMubWFwUmlnaHRDbGljayB9LFxuICAgICAgICBdO1xuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBfdGhpcy5fbWFwc1dyYXBwZXIuc3Vic2NyaWJlVG9NYXBFdmVudChlLm5hbWUpLnN1YnNjcmliZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB7IGNvb3JkczogeyBsYXQ6IGV2ZW50LmxhdExuZy5sYXQoKSwgbG5nOiBldmVudC5sYXRMbmcubG5nKCkgfSB9O1xuICAgICAgICAgICAgICAgIGUuZW1pdHRlci5lbWl0KHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLnB1c2gocyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFwIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgY2FuIGNoYW5nZSBvdmVyIHRpbWVcbiAgICAgKi9cbiAgICBTZWJtR29vZ2xlTWFwLl9tYXBPcHRpb25zQXR0cmlidXRlcyA9IFtcbiAgICAgICAgJ2Rpc2FibGVEb3VibGVDbGlja1pvb20nLCAnc2Nyb2xsd2hlZWwnLCAnZHJhZ2dhYmxlJywgJ2RyYWdnYWJsZUN1cnNvcicsICdkcmFnZ2luZ0N1cnNvcicsXG4gICAgICAgICdrZXlib2FyZFNob3J0Y3V0cycsICd6b29tQ29udHJvbCcsICdzdHlsZXMnLCAnc3RyZWV0Vmlld0NvbnRyb2wnLCAnem9vbScsICdtYXBUeXBlQ29udHJvbCcsXG4gICAgICAgICdtaW5ab29tJywgJ21heFpvb20nXG4gICAgXTtcbiAgICBTZWJtR29vZ2xlTWFwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkNvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIG1hcmtlcl9tYW5hZ2VyXzEuTWFya2VyTWFuYWdlciwgaW5mb193aW5kb3dfbWFuYWdlcl8xLkluZm9XaW5kb3dNYW5hZ2VyLCBjaXJjbGVfbWFuYWdlcl8xLkNpcmNsZU1hbmFnZXIsIHBvbHlsaW5lX21hbmFnZXJfMS5Qb2x5bGluZU1hbmFnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uX21hbmFnZXJfMS5Qb2x5Z29uTWFuYWdlciwga21sX2xheWVyX21hbmFnZXJfMS5LbWxMYXllck1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJywgJ3pvb20nLCAnbWluWm9vbScsICdtYXhab29tJywgJ2RyYWdnYWJsZTogbWFwRHJhZ2dhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNhYmxlRG91YmxlQ2xpY2tab29tJywgJ2Rpc2FibGVEZWZhdWx0VUknLCAnc2Nyb2xsd2hlZWwnLCAnYmFja2dyb3VuZENvbG9yJywgJ2RyYWdnYWJsZUN1cnNvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZHJhZ2dpbmdDdXJzb3InLCAna2V5Ym9hcmRTaG9ydGN1dHMnLCAnem9vbUNvbnRyb2wnLCAnc3R5bGVzJywgJ3VzZVBhbm5pbmcnLCAnc3RyZWV0Vmlld0NvbnRyb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpdEJvdW5kcycsICdzY2FsZUNvbnRyb2wnLCAnbWFwVHlwZUNvbnRyb2wnXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXBDbGljaycsICdtYXBSaWdodENsaWNrJywgJ21hcERibENsaWNrJywgJ2NlbnRlckNoYW5nZScsICdpZGxlJywgJ2JvdW5kc0NoYW5nZScsICd6b29tQ2hhbmdlJ1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbY2xhc3Muc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lcl0nOiAndHJ1ZScgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBbXCJcXG4gICAgLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXItaW5uZXIge1xcbiAgICAgIHdpZHRoOiBpbmhlcml0O1xcbiAgICAgIGhlaWdodDogaW5oZXJpdDtcXG4gICAgfVxcbiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRlbnQge1xcbiAgICAgIGRpc3BsYXk6bm9uZTtcXG4gICAgfVxcbiAgXCJdLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdiBjbGFzcz0nc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lci1pbm5lcic+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9J3NlYm0tZ29vZ2xlLW1hcC1jb250ZW50Jz5cXG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgIDwvZGl2PlxcbiAgXCJcbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBTZWJtR29vZ2xlTWFwO1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcCA9IFNlYm1Hb29nbGVNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb29nbGUtbWFwLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIG1hcHNfYXBpX2xvYWRlcl8xID0gcmVxdWlyZSgnLi9tYXBzLWFwaS1sb2FkZXIvbWFwcy1hcGktbG9hZGVyJyk7XG4vKipcbiAqIFdyYXBwZXIgY2xhc3MgdGhhdCBoYW5kbGVzIHRoZSBjb21tdW5pY2F0aW9uIHdpdGggdGhlIEdvb2dsZSBNYXBzIEphdmFzY3JpcHRcbiAqIEFQSSB2M1xuICovXG52YXIgR29vZ2xlTWFwc0FQSVdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdvb2dsZU1hcHNBUElXcmFwcGVyKF9sb2FkZXIsIF96b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xvYWRlciA9IF9sb2FkZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFwID1cbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IF90aGlzLl9tYXBSZXNvbHZlciA9IHJlc29sdmU7IH0pO1xuICAgIH1cbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY3JlYXRlTWFwID0gZnVuY3Rpb24gKGVsLCBtYXBPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZXIubG9hZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoZWwsIG1hcE9wdGlvbnMpO1xuICAgICAgICAgICAgX3RoaXMuX21hcFJlc29sdmVyKG1hcCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnNldE1hcE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobSkgeyBtLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGdvb2dsZSBtYXAgbWFya2VyIHdpdGggdGhlIG1hcCBjb250ZXh0XG4gICAgICovXG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmNyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBvcHRpb25zLm1hcCA9IG1hcDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVJbmZvV2luZG93ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KG9wdGlvbnMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBnb29nbGUubWFwLkNpcmNsZSBmb3IgdGhlIGN1cnJlbnQgbWFwLlxuICAgICAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVDaXJjbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgb3B0aW9ucy5tYXAgPSBtYXA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZShvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY3JlYXRlUG9seWxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVNYXAoKS50aGVuKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKG9wdGlvbnMpO1xuICAgICAgICAgICAgbGluZS5zZXRNYXAobWFwKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVQb2x5Z29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlTWFwKCkudGhlbihmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBnb29nbGUubWFwcy5Qb2x5Z29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgcG9seWdvbi5zZXRNYXAobWFwKTtcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgZ2l2ZW4gY29vcmRpbmF0ZXMgYXJlIGluc2l0ZSBhIFBvbHlnb24gcGF0aC5cbiAgICAgKi9cbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY29udGFpbnNMb2NhdGlvbiA9IGZ1bmN0aW9uIChsYXRMbmcsIHBvbHlnb24pIHtcbiAgICAgICAgcmV0dXJuIGdvb2dsZS5tYXBzLmdlb21ldHJ5LnBvbHkuY29udGFpbnNMb2NhdGlvbihsYXRMbmcsIHBvbHlnb24pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnN1YnNjcmliZVRvTWFwRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGFyZykgeyBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChhcmcpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGxhdExuZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLnNldENlbnRlcihsYXRMbmcpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5nZXRab29tID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLmdldFpvb20oKTsgfSk7IH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIG1hcC5nZXRCb3VuZHMoKTsgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uICh6b29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7IHJldHVybiBtYXAuc2V0Wm9vbSh6b29tKTsgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLmdldENlbnRlcigpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5wYW5UbyA9IGZ1bmN0aW9uIChsYXRMbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIG1hcC5wYW5UbyhsYXRMbmcpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5maXRCb3VuZHMgPSBmdW5jdGlvbiAobGF0TG5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7IHJldHVybiBtYXAuZml0Qm91bmRzKGxhdExuZyk7IH0pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnBhblRvQm91bmRzID0gZnVuY3Rpb24gKGxhdExuZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLnBhblRvQm91bmRzKGxhdExuZyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmF0aXZlIEdvb2dsZSBNYXBzIE1hcCBpbnN0YW5jZS4gQmUgY2FyZWZ1bCB3aGVuIHVzaW5nIHRoaXMgaW5zdGFuY2UgZGlyZWN0bHkuXG4gICAgICovXG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmdldE5hdGl2ZU1hcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcDsgfTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgZ2l2ZW4gZXZlbnQgbmFtZSBvbiB0aGUgbWFwIGluc3RhbmNlLlxuICAgICAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS50cmlnZ2VyTWFwRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtLCBldmVudE5hbWUpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IG1hcHNfYXBpX2xvYWRlcl8xLk1hcHNBUElMb2FkZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBHb29nbGVNYXBzQVBJV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLkdvb2dsZU1hcHNBUElXcmFwcGVyID0gR29vZ2xlTWFwc0FQSVdyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb29nbGUtbWFwcy1hcGktd3JhcHBlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9nb29nbGUtbWFwcy1hcGktd3JhcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE1hcHNBUElMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcHNBUElMb2FkZXIoKSB7XG4gICAgfVxuICAgIE1hcHNBUElMb2FkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTWFwc0FQSUxvYWRlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBNYXBzQVBJTG9hZGVyO1xufSgpKTtcbmV4cG9ydHMuTWFwc0FQSUxvYWRlciA9IE1hcHNBUElMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXBzLWFwaS1sb2FkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL21hcHMtYXBpLWxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEgPSByZXF1aXJlKCcuLi9nb29nbGUtbWFwcy1hcGktd3JhcHBlcicpO1xudmFyIENpcmNsZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENpcmNsZU1hbmFnZXIoX2FwaVdyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX2FwaVdyYXBwZXIgPSBfYXBpV3JhcHBlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9jaXJjbGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5hZGRDaXJjbGUgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHRoaXMuX2NpcmNsZXMuc2V0KGNpcmNsZSwgdGhpcy5fYXBpV3JhcHBlci5jcmVhdGVDaXJjbGUoe1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogY2lyY2xlLmxhdGl0dWRlLCBsbmc6IGNpcmNsZS5sb25naXR1ZGUgfSxcbiAgICAgICAgICAgIGNsaWNrYWJsZTogY2lyY2xlLmNsaWNrYWJsZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogY2lyY2xlLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBjaXJjbGUuZWRpdGFibGUsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IGNpcmNsZS5maWxsQ29sb3IsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogY2lyY2xlLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgcmFkaXVzOiBjaXJjbGUucmFkaXVzLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IGNpcmNsZS5zdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IGNpcmNsZS5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlUG9zaXRpb246IGNpcmNsZS5zdHJva2VQb3NpdGlvbixcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogY2lyY2xlLnN0cm9rZVdlaWdodCxcbiAgICAgICAgICAgIHZpc2libGU6IGNpcmNsZS52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBjaXJjbGUuekluZGV4XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjaXJjbGUgZnJvbSB0aGUgbWFwLlxuICAgICAqL1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUNpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgYy5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICBfdGhpcy5fY2lyY2xlcy5kZWxldGUoY2lyY2xlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKGNpcmNsZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5nZXRCb3VuZHMoKTsgfSk7XG4gICAgfTtcbiAgICA7XG4gICAgQ2lyY2xlTWFuYWdlci5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmdldENlbnRlcigpOyB9KTtcbiAgICB9O1xuICAgIDtcbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRSYWRpdXMgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuZ2V0UmFkaXVzKCk7IH0pO1xuICAgIH07XG4gICAgQ2lyY2xlTWFuYWdlci5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldENlbnRlcih7IGxhdDogY2lyY2xlLmxhdGl0dWRlLCBsbmc6IGNpcmNsZS5sb25naXR1ZGUgfSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldEVkaXRhYmxlID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldEVkaXRhYmxlKGNpcmNsZS5lZGl0YWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zZXREcmFnZ2FibGUoY2lyY2xlLmRyYWdnYWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuc2V0VmlzaWJsZShjaXJjbGUudmlzaWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldFJhZGl1cyA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zZXRSYWRpdXMoY2lyY2xlLnJhZGl1cyk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNpcmNsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoZSk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaXJjbGVNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIENpcmNsZU1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIENpcmNsZU1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5DaXJjbGVNYW5hZ2VyID0gQ2lyY2xlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNpcmNsZS1tYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL2NpcmNsZS1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJyk7XG52YXIgbWFya2VyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vbWFya2VyLW1hbmFnZXInKTtcbnZhciBJbmZvV2luZG93TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5mb1dpbmRvd01hbmFnZXIoX21hcHNXcmFwcGVyLCBfem9uZSwgX21hcmtlck1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlciA9IF9tYXJrZXJNYW5hZ2VyO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93cyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUluZm9XaW5kb3cgPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaVdpbmRvdyA9IHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KTtcbiAgICAgICAgaWYgKGlXaW5kb3cgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaW5mbyB3aW5kb3cgYWxyZWFkeSBkZWxldGVkXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlXaW5kb3cudGhlbihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9pbmZvV2luZG93cy5kZWxldGUoaW5mb1dpbmRvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5mb1dpbmRvd3MuZ2V0KGluZm9XaW5kb3cpLnRoZW4oZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2V0UG9zaXRpb24oe1xuICAgICAgICAgICAgbGF0OiBpbmZvV2luZG93LmxhdGl0dWRlLFxuICAgICAgICAgICAgbG5nOiBpbmZvV2luZG93LmxvbmdpdHVkZVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gKGluZm9XaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2V0WkluZGV4KGluZm9XaW5kb3cuekluZGV4KTsgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChpbmZvV2luZG93KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKGluZm9XaW5kb3cuaG9zdE1hcmtlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9tYXJrZXJNYW5hZ2VyLmdldE5hdGl2ZU1hcmtlcihpbmZvV2luZG93Lmhvc3RNYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gdy5vcGVuKG1hcCwgbWFya2VyKTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gdy5vcGVuKG1hcCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChpbmZvV2luZG93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAodykgeyByZXR1cm4gdy5jbG9zZSgpOyB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKGluZm9XaW5kb3csIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KS50aGVuKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmFkZEluZm9XaW5kb3cgPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGluZm9XaW5kb3cuY29udGVudCxcbiAgICAgICAgICAgIG1heFdpZHRoOiBpbmZvV2luZG93Lm1heFdpZHRoLFxuICAgICAgICAgICAgekluZGV4OiBpbmZvV2luZG93LnpJbmRleCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvV2luZG93LmxhdGl0dWRlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgaW5mb1dpbmRvdy5sb25naXR1ZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0geyBsYXQ6IGluZm9XaW5kb3cubGF0aXR1ZGUsIGxuZzogaW5mb1dpbmRvdy5sb25naXR1ZGUgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mb1dpbmRvd1Byb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVJbmZvV2luZG93KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93cy5zZXQoaW5mb1dpbmRvdywgaW5mb1dpbmRvd1Byb21pc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEdvb2dsZSBNYXBzIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gSW5mb1dpbmRvdyBhcyBhbiBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGluZm9XaW5kb3cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIGkuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoZSk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBtYXJrZXJfbWFuYWdlcl8xLk1hcmtlck1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW5mb1dpbmRvd01hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5JbmZvV2luZG93TWFuYWdlciA9IEluZm9XaW5kb3dNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mby13aW5kb3ctbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4vLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbnZhciBNYXJrZXJNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXJrZXJNYW5hZ2VyKF9tYXBzV3JhcHBlciwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFya2VycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcik7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG1hcmtlciBhbHJlYWR5IGRlbGV0ZWRcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBtLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWFya2Vycy5kZWxldGUobWFya2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU1hcmtlclBvc2l0aW9uID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnNldFBvc2l0aW9uKHsgbGF0OiBtYXJrZXIubGF0aXR1ZGUsIGxuZzogbWFya2VyLmxvbmdpdHVkZSB9KTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVUaXRsZSA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRUaXRsZShtYXJrZXIudGl0bGUpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUxhYmVsID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IG0uc2V0TGFiZWwobWFya2VyLmxhYmVsKTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVEcmFnZ2FibGUgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2V0RHJhZ2dhYmxlKG1hcmtlci5kcmFnZ2FibGUpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUljb24gPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2V0SWNvbihtYXJrZXIuaWNvblVybCk7IH0pO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUudXBkYXRlT3BhY2l0eSA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRPcGFjaXR5KG1hcmtlci5vcGFjaXR5KTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVWaXNpYmxlID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnNldFZpc2libGUobWFya2VyLnZpc2libGUpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVpJbmRleCA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRaSW5kZXgobWFya2VyLnpJbmRleCk7IH0pO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUuYWRkTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICB2YXIgbWFya2VyUHJvbWlzZSA9IHRoaXMuX21hcHNXcmFwcGVyLmNyZWF0ZU1hcmtlcih7XG4gICAgICAgICAgICBwb3NpdGlvbjogeyBsYXQ6IG1hcmtlci5sYXRpdHVkZSwgbG5nOiBtYXJrZXIubG9uZ2l0dWRlIH0sXG4gICAgICAgICAgICBsYWJlbDogbWFya2VyLmxhYmVsLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBtYXJrZXIuZHJhZ2dhYmxlLFxuICAgICAgICAgICAgaWNvbjogbWFya2VyLmljb25VcmwsXG4gICAgICAgICAgICBvcGFjaXR5OiBtYXJrZXIub3BhY2l0eSxcbiAgICAgICAgICAgIHZpc2libGU6IG1hcmtlci52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBtYXJrZXIuekluZGV4LFxuICAgICAgICAgICAgdGl0bGU6IG1hcmtlci50aXRsZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWFya2Vycy5zZXQobWFya2VyLCBtYXJrZXJQcm9taXNlKTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLmdldE5hdGl2ZU1hcmtlciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcik7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBtYXJrZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZlci5uZXh0KGUpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIE1hcmtlck1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIE1hcmtlck1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5NYXJrZXJNYW5hZ2VyID0gTWFya2VyTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcmtlci1tYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL21hcmtlci1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJyk7XG52YXIgUG9seWdvbk1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvbHlnb25NYW5hZ2VyKF9tYXBzV3JhcHBlciwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fcG9seWdvbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS5hZGRQb2x5Z29uID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHBvbHlnb25Qcm9taXNlID0gdGhpcy5fbWFwc1dyYXBwZXIuY3JlYXRlUG9seWdvbih7XG4gICAgICAgICAgICBjbGlja2FibGU6IHBhdGguY2xpY2thYmxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBwYXRoLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBwYXRoLmVkaXRhYmxlLFxuICAgICAgICAgICAgZmlsbENvbG9yOiBwYXRoLmZpbGxDb2xvcixcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBwYXRoLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgZ2VvZGVzaWM6IHBhdGguZ2VvZGVzaWMsXG4gICAgICAgICAgICBwYXRoczogcGF0aC5wYXRocyxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBwYXRoLnN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogcGF0aC5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBwYXRoLnN0cm9rZVdlaWdodCxcbiAgICAgICAgICAgIHZpc2libGU6IHBhdGgudmlzaWJsZSxcbiAgICAgICAgICAgIHpJbmRleDogcGF0aC56SW5kZXgsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wb2x5Z29ucy5zZXQocGF0aCwgcG9seWdvblByb21pc2UpO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVBvbHlnb24gPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLnRoZW4oZnVuY3Rpb24gKGwpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IGwuc2V0UGF0aHMocG9seWdvbi5wYXRocyk7IH0pOyB9KTtcbiAgICB9O1xuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRQb2x5Z29uT3B0aW9ucyA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29ucy5nZXQocGF0aCkudGhlbihmdW5jdGlvbiAobCkgeyBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZVBvbHlnb24gPSBmdW5jdGlvbiAocGF0aHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG0gPSB0aGlzLl9wb2x5Z29ucy5nZXQocGF0aHMpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbC5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3BvbHlnb25zLmRlbGV0ZShwYXRocyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb2x5Z29uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlRXZlbnRPYnNlcnZhYmxlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgcGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMuX3BvbHlnb25zLmdldChwYXRoKS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgbC5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChlKTsgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgUG9seWdvbk1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFBvbHlnb25NYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuUG9seWdvbk1hbmFnZXIgPSBQb2x5Z29uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlnb24tbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5Z29uLW1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKTtcbnZhciBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xID0gcmVxdWlyZSgnLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbnZhciBQb2x5bGluZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvbHlsaW5lTWFuYWdlcihfbWFwc1dyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgUG9seWxpbmVNYW5hZ2VyLl9jb252ZXJ0UG9pbnRzID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBsaW5lLl9nZXRQb2ludHMoKS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyBsYXQ6IHBvaW50LmxhdGl0dWRlLCBsbmc6IHBvaW50LmxvbmdpdHVkZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICBQb2x5bGluZU1hbmFnZXIucHJvdG90eXBlLmFkZFBvbHlsaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBQb2x5bGluZU1hbmFnZXIuX2NvbnZlcnRQb2ludHMobGluZSk7XG4gICAgICAgIHZhciBwb2x5bGluZVByb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVQb2x5bGluZSh7XG4gICAgICAgICAgICBjbGlja2FibGU6IGxpbmUuY2xpY2thYmxlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBsaW5lLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBsaW5lLmVkaXRhYmxlLFxuICAgICAgICAgICAgZ2VvZGVzaWM6IGxpbmUuZ2VvZGVzaWMsXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogbGluZS5zdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IGxpbmUuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogbGluZS5zdHJva2VXZWlnaHQsXG4gICAgICAgICAgICB2aXNpYmxlOiBsaW5lLnZpc2libGUsXG4gICAgICAgICAgICB6SW5kZXg6IGxpbmUuekluZGV4LFxuICAgICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVzLnNldChsaW5lLCBwb2x5bGluZVByb21pc2UpO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVQb2x5bGluZVBvaW50cyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYXRoID0gUG9seWxpbmVNYW5hZ2VyLl9jb252ZXJ0UG9pbnRzKGxpbmUpO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGZ1bmN0aW9uIChsKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyBsLnNldFBhdGgocGF0aCk7IH0pOyB9KTtcbiAgICB9O1xuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUuc2V0UG9seWxpbmVPcHRpb25zID0gZnVuY3Rpb24gKGxpbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSkudGhlbihmdW5jdGlvbiAobCkgeyBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVQb2x5bGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtID0gdGhpcy5fcG9seWxpbmVzLmdldChsaW5lKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLnRoZW4oZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGwuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9wb2x5bGluZXMuZGVsZXRlKGxpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fcG9seWxpbmVzLmdldChsaW5lKS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgbC5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChlKTsgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFBvbHlsaW5lTWFuYWdlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xLkdvb2dsZU1hcHNBUElXcmFwcGVyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5OZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gUG9seWxpbmVNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuUG9seWxpbmVNYW5hZ2VyID0gUG9seWxpbmVNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9seWxpbmUtbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4vLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbi8qKlxuICogTWFuYWdlcyBhbGwgS01MIExheWVycyBmb3IgYSBHb29nbGUgTWFwIGluc3RhbmNlLlxuICovXG52YXIgS21sTGF5ZXJNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBLbWxMYXllck1hbmFnZXIoX3dyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIgPSBfd3JhcHBlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9sYXllcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgS01MIExheWVyIHRvIHRoZSBtYXAuXG4gICAgICovXG4gICAgS21sTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5hZGRLbWxMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICB2YXIgbmV3TGF5ZXIgPSB0aGlzLl93cmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuS21sTGF5ZXIoe1xuICAgICAgICAgICAgICAgIGNsaWNrYWJsZTogbGF5ZXIuY2xpY2thYmxlLFxuICAgICAgICAgICAgICAgIG1hcDogbSxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVZpZXdwb3J0OiBsYXllci5wcmVzZXJ2ZVZpZXdwb3J0LFxuICAgICAgICAgICAgICAgIHNjcmVlbk92ZXJsYXlzOiBsYXllci5zY3JlZW5PdmVybGF5cyxcbiAgICAgICAgICAgICAgICBzdXBwcmVzc0luZm9XaW5kb3dzOiBsYXllci5zdXBwcmVzc0luZm9XaW5kb3dzLFxuICAgICAgICAgICAgICAgIHVybDogbGF5ZXIudXJsLFxuICAgICAgICAgICAgICAgIHpJbmRleDogbGF5ZXIuekluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xheWVycy5zZXQobGF5ZXIsIG5ld0xheWVyKTtcbiAgICB9O1xuICAgIEttbExheWVyTWFuYWdlci5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChsYXllciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKS50aGVuKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgS21sTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVLbWxMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICBsLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIF90aGlzLl9sYXllcnMuZGVsZXRlKGxheWVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR29vZ2xlIE1hcHMgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBLbWxMYXllciBhcyBhbiBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgS21sTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsYXllcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMuX2xheWVycy5nZXQobGF5ZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZlci5uZXh0KGUpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBLbWxMYXllck1hbmFnZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgS21sTGF5ZXJNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBLbWxMYXllck1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5LbWxMYXllck1hbmFnZXIgPSBLbWxMYXllck1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rbWwtbGF5ZXItbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9rbWwtbGF5ZXItbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGNpcmNsZV9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9jaXJjbGUtbWFuYWdlcicpO1xudmFyIFNlYm1Hb29nbGVNYXBDaXJjbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBDaXJjbGUoX21hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlciA9IF9tYW5hZ2VyO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBDaXJjbGUgaGFuZGxlcyBtb3VzZSBldmVudHMuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGRyYWcgdGhpcyBjaXJjbGUgb3ZlciB0aGUgbWFwLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGVkaXQgdGhpcyBjaXJjbGUgYnkgZHJhZ2dpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIHNob3duIGF0XG4gICAgICAgICAqIHRoZSBjZW50ZXIgYW5kIGFyb3VuZCB0aGUgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2lyY2xlLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByYWRpdXMgaW4gbWV0ZXJzIG9uIHRoZSBFYXJ0aCdzIHN1cmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3Ryb2tlIHBvc2l0aW9uLiBEZWZhdWx0cyB0byBDRU5URVIuXG4gICAgICAgICAqIFRoaXMgcHJvcGVydHkgaXMgbm90IHN1cHBvcnRlZCBvbiBJbnRlcm5ldCBFeHBsb3JlciA4IGFuZCBlYXJsaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHJva2VQb3NpdGlvbiA9ICdDRU5URVInO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0cm9rZSB3aWR0aCBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0cm9rZVdlaWdodCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgY2lyY2xlIGlzIHZpc2libGUgb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGNpcmNsZSdzIGNlbnRlciBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZW50ZXJDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaXJjbGVDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNpcmNsZURibENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgcmVwZWF0ZWRseSBmaXJlZCB3aGlsZSB0aGUgdXNlciBkcmFncyB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnRW5kID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIGNpcmNsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlZG93biBldmVudCBpcyBmaXJlZCBvbiB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vtb3ZlIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlTW92ZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIGNpcmNsZSBtb3VzZW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW91c2VPdXQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBjaXJjbGUgbW91c2VvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZU92ZXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZVVwID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgY2lyY2xlJ3MgcmFkaXVzIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1c0NoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGNpcmNsZSBpcyByaWdodC1jbGlja2VkIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yaWdodENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fY2lyY2xlQWRkZWRUb01hbmFnZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXZlbnRTdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5hZGRDaXJjbGUodGhpcyk7XG4gICAgICAgIHRoaXMuX2NpcmNsZUFkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudExpc3RlbmVycygpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jaXJjbGVBZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLnNldENlbnRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snZWRpdGFibGUnXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5zZXRFZGl0YWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snZHJhZ2dhYmxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIuc2V0RHJhZ2dhYmxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd2aXNpYmxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIuc2V0VmlzaWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1sncmFkaXVzJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIuc2V0UmFkaXVzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNpcmNsZU9wdGlvbnNDaGFuZ2VzKGNoYW5nZXMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcENpcmNsZS5wcm90b3R5cGUuX3VwZGF0ZUNpcmNsZU9wdGlvbnNDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFNlYm1Hb29nbGVNYXBDaXJjbGUuX21hcE9wdGlvbnMuaW5kZXhPZihrKSAhPT0gLTE7IH0pO1xuICAgICAgICBvcHRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHsgb3B0aW9uc1trXSA9IGNoYW5nZXNba10uY3VycmVudFZhbHVlOyB9KTtcbiAgICAgICAgaWYgKG9wdGlvbktleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5fcmVnaXN0ZXJFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZXZlbnRzLnNldCgnY2VudGVyX2NoYW5nZWQnLCB0aGlzLmNlbnRlckNoYW5nZSk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ2NsaWNrJywgdGhpcy5jaXJjbGVDbGljayk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ2RibGNsaWNrJywgdGhpcy5jaXJjbGVEYmxDbGljayk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ2RyYWcnLCB0aGlzLmRyYWcpO1xuICAgICAgICBldmVudHMuc2V0KCdkcmFnZW5kJywgdGhpcy5kcmFnRW5kKTtcbiAgICAgICAgZXZlbnRzLnNldCgnZHJhZ1N0YXJ0JywgdGhpcy5kcmFnU3RhcnQpO1xuICAgICAgICBldmVudHMuc2V0KCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlRG93bik7XG4gICAgICAgIGV2ZW50cy5zZXQoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlKTtcbiAgICAgICAgZXZlbnRzLnNldCgnbW91c2VvdXQnLCB0aGlzLm1vdXNlT3V0KTtcbiAgICAgICAgZXZlbnRzLnNldCgnbW91c2VvdmVyJywgdGhpcy5tb3VzZU92ZXIpO1xuICAgICAgICBldmVudHMuc2V0KCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwKTtcbiAgICAgICAgZXZlbnRzLnNldCgncmFkaXVzX2NoYW5nZWQnLCB0aGlzLnJhZGl1c0NoYW5nZSk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ3JpZ2h0Y2xpY2snLCB0aGlzLnJpZ2h0Q2xpY2spO1xuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRFbWl0dGVyLCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgIF90aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMucHVzaChfdGhpcy5fbWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUoZXZlbnROYW1lLCBfdGhpcykuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGl1c19jaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYW5hZ2VyLmdldFJhZGl1cyhfdGhpcykudGhlbihmdW5jdGlvbiAocmFkaXVzKSB7IHJldHVybiBldmVudEVtaXR0ZXIuZW1pdChyYWRpdXMpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXJfY2hhbmdlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbWFuYWdlci5nZXRDZW50ZXIoX3RoaXMpLnRoZW4oZnVuY3Rpb24gKGNlbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudEVtaXR0ZXIuZW1pdCh7IGxhdDogY2VudGVyLmxhdCgpLCBsbmc6IGNlbnRlci5sbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCh7IGNvb3JkczogeyBsYXQ6IHZhbHVlLmxhdExuZy5sYXQoKSwgbG5nOiB2YWx1ZS5sYXRMbmcubG5nKCkgfSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocykgeyBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgICAgICB0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLnJlbW92ZUNpcmNsZSh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIExhdExuZ0JvdW5kcyBvZiB0aGlzIENpcmNsZS5cbiAgICAgKi9cbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYW5hZ2VyLmdldEJvdW5kcyh0aGlzKTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYW5hZ2VyLmdldENlbnRlcih0aGlzKTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLl9tYXBPcHRpb25zID0gW1xuICAgICAgICAnZmlsbENvbG9yJywgJ2ZpbGxPcGFjaXR5JywgJ3N0cm9rZUNvbG9yJywgJ3N0cm9rZU9wYWNpdHknLCAnc3Ryb2tlUG9zaXRpb24nLCAnc3Ryb2tlV2VpZ2h0JyxcbiAgICAgICAgJ3Zpc2libGUnLCAnekluZGV4J1xuICAgIF07XG4gICAgU2VibUdvb2dsZU1hcENpcmNsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VibS1nb29nbGUtbWFwLWNpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xhdGl0dWRlJywgJ2xvbmdpdHVkZScsICdjbGlja2FibGUnLCAnZHJhZ2dhYmxlOiBjaXJjbGVEcmFnZ2FibGUnLCAnZWRpdGFibGUnLCAnZmlsbENvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsT3BhY2l0eScsICdyYWRpdXMnLCAnc3Ryb2tlQ29sb3InLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VQb3NpdGlvbicsICdzdHJva2VXZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc2libGUnLCAnekluZGV4J1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2VudGVyQ2hhbmdlJywgJ2NpcmNsZUNsaWNrJywgJ2NpcmNsZURibENsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnU3RhcnQnLCAnbW91c2VEb3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncmFkaXVzQ2hhbmdlJywgJ3JpZ2h0Q2xpY2snXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogY2lyY2xlX21hbmFnZXJfMS5DaXJjbGVNYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBDaXJjbGU7XG59KCkpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwQ2lyY2xlID0gU2VibUdvb2dsZU1hcENpcmNsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtY2lyY2xlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1jaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBpbmZvX3dpbmRvd19tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyJyk7XG52YXIgaW5mb1dpbmRvd0lkID0gMDtcbi8qKlxuICogU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgcmVuZGVycyBhIGluZm8gd2luZG93IGluc2lkZSBhIHtAbGluayBTZWJtR29vZ2xlTWFwTWFya2VyfSBvciBzdGFuZGFsb25lLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIsIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93IH0gZnJvbVxuICogJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgZGlyZWN0aXZlczogW1NlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIsIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93XSxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlYm0tZ29vZ2xlLW1hcCBbbGF0aXR1ZGVdPVwibGF0XCIgW2xvbmdpdHVkZV09XCJsbmdcIiBbem9vbV09XCJ6b29tXCI+XG4gKiAgICAgIDxzZWJtLWdvb2dsZS1tYXAtbWFya2VyIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFtsYWJlbF09XCInTSdcIj5cbiAqICAgICAgICA8c2VibS1nb29nbGUtbWFwLWluZm8td2luZG93IFtkaXNhYmxlQXV0b1Bhbl09XCJ0cnVlXCI+XG4gKiAgICAgICAgICBIaSwgdGhpcyBpcyB0aGUgY29udGVudCBvZiB0aGUgPHN0cm9uZz5pbmZvIHdpbmRvdzwvc3Ryb25nPlxuICogICAgICAgIDwvc2VibS1nb29nbGUtbWFwLWluZm8td2luZG93PlxuICogICAgICA8L3NlYm0tZ29vZ2xlLW1hcC1tYXJrZXI+XG4gKiAgICA8L3NlYm0tZ29vZ2xlLW1hcD5cbiAqICBgXG4gKiB9KVxuICogYGBgXG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcEluZm9XaW5kb3coX2luZm9XaW5kb3dNYW5hZ2VyLCBfZWwpIHtcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvd01hbmFnZXIgPSBfaW5mb1dpbmRvd01hbmFnZXI7XG4gICAgICAgIHRoaXMuX2VsID0gX2VsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgb3BlbiBzdGF0ZSBmb3IgdGhlIEluZm9XaW5kb3cuIFlvdSBjYW4gYWxzbyBjYWxsIHRoZSBvcGVuKCkgYW5kIGNsb3NlKCkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBpbmZvIHdpbmRvdyBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZm9XaW5kb3dDbG9zZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3dBZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pZCA9IChpbmZvV2luZG93SWQrKykudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWJtLWdvb2dsZS1tYXAtaW5mby13aW5kb3ctY29udGVudCcpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93TWFuYWdlci5hZGRJbmZvV2luZG93KHRoaXMpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93QWRkZWRUb01hbmFnZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl91cGRhdGVPcGVuU3RhdGUoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudExpc3RlbmVycygpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5mb1dpbmRvd0FkZGVkVG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSAmJiB0eXBlb2YgdGhpcy5sYXRpdHVkZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmxvbmdpdHVkZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLnNldFBvc2l0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd6SW5kZXgnXSkge1xuICAgICAgICAgICAgdGhpcy5faW5mb1dpbmRvd01hbmFnZXIuc2V0WkluZGV4KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydpc09wZW4nXSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlT3BlblN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0SW5mb1dpbmRvd09wdGlvbnMoY2hhbmdlcyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuX3JlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnY2xvc2VjbGljaycsIHRoaXMpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLmluZm9XaW5kb3dDbG9zZS5lbWl0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLl91cGRhdGVPcGVuU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNPcGVuID8gdGhpcy5vcGVuKCkgOiB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuX3NldEluZm9XaW5kb3dPcHRpb25zID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93Ll9pbmZvV2luZG93T3B0aW9uc0lucHV0cy5pbmRleE9mKGspICE9PSAtMTsgfSk7XG4gICAgICAgIG9wdGlvbktleXMuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBvcHRpb25zW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7IH0pO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93TWFuYWdlci5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGluZm8gd2luZG93LlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW5mb1dpbmRvd01hbmFnZXIub3Blbih0aGlzKTsgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGluZm8gd2luZG93LlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmNsb3NlKHRoaXMpLnRoZW4oZnVuY3Rpb24gKCkgeyBfdGhpcy5pbmZvV2luZG93Q2xvc2UuZW1pdCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZDsgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1NlYm1Hb29nbGVNYXBJbmZvV2luZG93LScgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmRlbGV0ZUluZm9XaW5kb3codGhpcyk7IH07XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cuX2luZm9XaW5kb3dPcHRpb25zSW5wdXRzID0gWydkaXNhYmxlQXV0b1BhbicsICdtYXhXaWR0aCddO1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkNvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAtaW5mby13aW5kb3cnLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFsnbGF0aXR1ZGUnLCAnbG9uZ2l0dWRlJywgJ2Rpc2FibGVBdXRvUGFuJywgJ2lzT3BlbicsICd6SW5kZXgnLCAnbWF4V2lkdGgnXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWydpbmZvV2luZG93Q2xvc2UnXSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz0nc2VibS1nb29nbGUtbWFwLWluZm8td2luZG93LWNvbnRlbnQnPlxcbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgPC9kaXY+XFxuICBcIlxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogaW5mb193aW5kb3dfbWFuYWdlcl8xLkluZm9XaW5kb3dNYW5hZ2VyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5FbGVtZW50UmVmLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93O1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgPSBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtaW5mby13aW5kb3cuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWluZm8td2luZG93LmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIga21sX2xheWVyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vLi4vc2VydmljZXMvbWFuYWdlcnMva21sLWxheWVyLW1hbmFnZXInKTtcbnZhciBsYXllcklkID0gMDtcbnZhciBTZWJtR29vZ2xlTWFwS21sTGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBLbWxMYXllcihfbWFuYWdlcikge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyID0gX21hbmFnZXI7XG4gICAgICAgIHRoaXMuX2FkZGVkVG9NYW5hZ2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lkID0gKGxheWVySWQrKykudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGxheWVyIHJlY2VpdmVzIG1vdXNlIGV2ZW50cy4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGlucHV0IG1hcCBpcyBjZW50ZXJlZCBhbmQgem9vbWVkIHRvIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgKiBsYXllci5cbiAgICAgICAgICogSWYgdGhpcyBvcHRpb24gaXMgc2V0IHRvIHRydWUsIHRoZSB2aWV3cG9ydCBpcyBsZWZ0IHVuY2hhbmdlZCwgdW5sZXNzIHRoZSBtYXAncyBjZW50ZXIgYW5kIHpvb21cbiAgICAgICAgICogd2VyZSBuZXZlciBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXNlcnZlVmlld3BvcnQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gcmVuZGVyIHRoZSBzY3JlZW4gb3ZlcmxheXMuIERlZmF1bHQgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NyZWVuT3ZlcmxheXMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VwcHJlc3MgdGhlIHJlbmRlcmluZyBvZiBpbmZvIHdpbmRvd3Mgd2hlbiBsYXllciBmZWF0dXJlcyBhcmUgY2xpY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcHJlc3NJbmZvV2luZG93cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgS01MIGRvY3VtZW50IHRvIGRpc3BsYXkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpJbmRleCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBmZWF0dXJlIGluIHRoZSBsYXllciBpcyBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXllckNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgS01MIGxheWVycyBkZWZhdWx0IHZpZXdwb3J0IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0Vmlld3BvcnRDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBLTUwgbGF5ZXIgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgICAqIEF0IHRoaXMgcG9pbnQgaXQgaXMgc2FmZSB0byByZWFkIHRoZSBzdGF0dXMgcHJvcGVydHkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBsYXllciBsb2FkZWRcbiAgICAgICAgICogc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkZWRUb01hbmFnZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYW5hZ2VyLmFkZEttbExheWVyKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRlZFRvTWFuYWdlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvbHlnb25PcHRpb25zKGNoYW5nZXMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLnByb3RvdHlwZS5fdXBkYXRlUG9seWdvbk9wdGlvbnMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBTZWJtR29vZ2xlTWFwS21sTGF5ZXIuX2ttbExheWVyT3B0aW9ucy5pbmRleE9mKGspICE9PSAtMTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaykge1xuICAgICAgICAgICAgb2JqW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBLbWxMYXllci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxheWVyQ2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RlZmF1bHR2aWV3cG9ydF9jaGFuZ2VkJywgaGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGVmYXVsdFZpZXdwb3J0Q2hhbmdlLmVtaXQoKTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnc3RhdHVzX2NoYW5nZWQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdGF0dXNDaGFuZ2UuZW1pdCgpOyB9IH0sXG4gICAgICAgIF07XG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9tYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZShvYmoubmFtZSwgX3RoaXMpLnN1YnNjcmliZShvYmouaGFuZGxlcik7XG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKG9zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJTZWJtR29vZ2xlTWFwS21sTGF5ZXItXCIgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLmRlbGV0ZUttbExheWVyKHRoaXMpO1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBhbGwgcmVnaXN0ZXJlZCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLl9rbWxMYXllck9wdGlvbnMgPSBbJ2NsaWNrYWJsZScsICdwcmVzZXJ2ZVZpZXdwb3J0JywgJ3NjcmVlbk92ZXJsYXlzJywgJ3N1cHByZXNzSW5mb1dpbmRvd3MnLCAndXJsJywgJ3pJbmRleCddO1xuICAgIFNlYm1Hb29nbGVNYXBLbWxMYXllci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VibS1nb29nbGUtbWFwLWttbC1sYXllcicsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydjbGlja2FibGUnLCAncHJlc2VydmVWaWV3cG9ydCcsICdzY3JlZW5PdmVybGF5cycsICdzdXBwcmVzc0luZm9XaW5kb3dzJywgJ3VybCcsICd6SW5kZXgnXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWydsYXllckNsaWNrJywgJ2RlZmF1bHRWaWV3cG9ydENoYW5nZScsICdzdGF0dXNDaGFuZ2UnXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGttbF9sYXllcl9tYW5hZ2VyXzEuS21sTGF5ZXJNYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBLbWxMYXllciA9IFNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAta21sLWxheWVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1rbWwtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBtYXJrZXJfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvbWFya2VyLW1hbmFnZXInKTtcbnZhciBnb29nbGVfbWFwX2luZm9fd2luZG93XzEgPSByZXF1aXJlKCcuL2dvb2dsZS1tYXAtaW5mby13aW5kb3cnKTtcbnZhciBtYXJrZXJJZCA9IDA7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBNYXJrZXIgcmVuZGVycyBhIG1hcCBtYXJrZXIgaW5zaWRlIGEge0BsaW5rIFNlYm1Hb29nbGVNYXB9LlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIgfSBmcm9tICdhbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxuICogIGRpcmVjdGl2ZXM6IFtTZWJtR29vZ2xlTWFwLCBTZWJtR29vZ2xlTWFwTWFya2VyXSxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlYm0tZ29vZ2xlLW1hcCBbbGF0aXR1ZGVdPVwibGF0XCIgW2xvbmdpdHVkZV09XCJsbmdcIiBbem9vbV09XCJ6b29tXCI+XG4gKiAgICAgIDxzZWJtLWdvb2dsZS1tYXAtbWFya2VyIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFtsYWJlbF09XCInTSdcIj5cbiAqICAgICAgPC9zZWJtLWdvb2dsZS1tYXAtbWFya2VyPlxuICogICAgPC9zZWJtLWdvb2dsZS1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGBgYFxuICovXG52YXIgU2VibUdvb2dsZU1hcE1hcmtlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcE1hcmtlcihfbWFya2VyTWFuYWdlcikge1xuICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyID0gX21hcmtlck1hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgbWFya2VyIGNhbiBiZSBkcmFnZ2VkLiBEZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIHRoZSBtYXJrZXIgaXMgdmlzaWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBvcGVuIHRoZSBjaGlsZCBpbmZvIHdpbmRvdyB3aGVuIHRoZSBtYXJrZXIgaXMgY2xpY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BlbkluZm9XaW5kb3cgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1hcmtlcidzIG9wYWNpdHkgYmV0d2VlbiAwLjAgYW5kIDEuMC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgbWFya2VycyBhcmUgZGlzcGxheWVkIG9uIHRoZSBtYXAgaW4gb3JkZXIgb2YgdGhlaXIgekluZGV4LCB3aXRoIGhpZ2hlciB2YWx1ZXMgZGlzcGxheWluZyBpblxuICAgICAgICAgKiBmcm9udCBvZiBtYXJrZXJzIHdpdGggbG93ZXIgdmFsdWVzLiBCeSBkZWZhdWx0LCBtYXJrZXJzIGFyZSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvIHRoZWlyXG4gICAgICAgICAqIHZlcnRpY2FsIHBvc2l0aW9uIG9uIHNjcmVlbiwgd2l0aCBsb3dlciBtYXJrZXJzIGFwcGVhcmluZyBpbiBmcm9udCBvZiBtYXJrZXJzIGZ1cnRoZXIgdXAgdGhlXG4gICAgICAgICAqIHNjcmVlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuekluZGV4ID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcmtlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFya2VyQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBtYXJrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdFbmQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIG1vdXNlcyBvdmVyIHRoZSBtYXJrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlT3ZlciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgbW91c2VzIG91dHNpZGUgdGhlIG1hcmtlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW91c2VPdXQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuX2lkID0gKG1hcmtlcklkKyspLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5mb1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZm9XaW5kb3cuaG9zdE1hcmtlciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5sYXRpdHVkZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMubG9uZ2l0dWRlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlcikge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlci5hZGRNYXJrZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xhdGl0dWRlJ10gfHwgY2hhbmdlc1snbG9uZ2l0dWRlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlTWFya2VyUG9zaXRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ3RpdGxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlVGl0bGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xhYmVsJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlTGFiZWwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2RyYWdnYWJsZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZURyYWdnYWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snaWNvblVybCddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZUljb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ29wYWNpdHknXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlci51cGRhdGVPcGFjaXR5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd2aXNpYmxlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlVmlzaWJsZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1snekluZGV4J10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlWkluZGV4KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjcyA9IHRoaXMuX21hcmtlck1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKCdjbGljaycsIHRoaXMpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3BlbkluZm9XaW5kb3cgJiYgX3RoaXMuaW5mb1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5mb1dpbmRvdy5vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5tYXJrZXJDbGljay5lbWl0KG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChjcyk7XG4gICAgICAgIHZhciBkcyA9IHRoaXMuX21hcmtlck1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKCdkcmFnZW5kJywgdGhpcylcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmRyYWdFbmQuZW1pdCh7IGNvb3JkczogeyBsYXQ6IGUubGF0TG5nLmxhdCgpLCBsbmc6IGUubGF0TG5nLmxuZygpIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKGRzKTtcbiAgICAgICAgdmFyIG1vdmVyID0gdGhpcy5fbWFya2VyTWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUoJ21vdXNlb3ZlcicsIHRoaXMpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5tb3VzZU92ZXIuZW1pdCh7IGNvb3JkczogeyBsYXQ6IGUubGF0TG5nLmxhdCgpLCBsbmc6IGUubGF0TG5nLmxuZygpIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKG1vdmVyKTtcbiAgICAgICAgdmFyIG1vdXQgPSB0aGlzLl9tYXJrZXJNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnbW91c2VvdXQnLCB0aGlzKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMubW91c2VPdXQuZW1pdCh7IGNvb3JkczogeyBsYXQ6IGUubGF0TG5nLmxhdCgpLCBsbmc6IGUubGF0TG5nLmxuZygpIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKG1vdXQpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWQ7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1NlYm1Hb29nbGVNYXBNYXJrZXItJyArIHRoaXMuX2lkLnRvU3RyaW5nKCk7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLmRlbGV0ZU1hcmtlcih0aGlzKTtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAtbWFya2VyJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGF0aXR1ZGUnLCAnbG9uZ2l0dWRlJywgJ3RpdGxlJywgJ2xhYmVsJywgJ2RyYWdnYWJsZTogbWFya2VyRHJhZ2dhYmxlJywgJ2ljb25VcmwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5JbmZvV2luZG93JywgJ29wYWNpdHknLCAndmlzaWJsZScsICd6SW5kZXgnXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFsnbWFya2VyQ2xpY2snLCAnZHJhZ0VuZCcsICdtb3VzZU92ZXInLCAnbW91c2VPdXQnXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcE1hcmtlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBtYXJrZXJfbWFuYWdlcl8xLk1hcmtlck1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnaW5mb1dpbmRvdyc6IFt7IHR5cGU6IGNvcmVfMS5Db250ZW50Q2hpbGQsIGFyZ3M6IFtnb29nbGVfbWFwX2luZm9fd2luZG93XzEuU2VibUdvb2dsZU1hcEluZm9XaW5kb3csXSB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gU2VibUdvb2dsZU1hcE1hcmtlcjtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBNYXJrZXIgPSBTZWJtR29vZ2xlTWFwTWFya2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z29vZ2xlLW1hcC1tYXJrZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLW1hcmtlci5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIHBvbHlnb25fbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvcG9seWdvbi1tYW5hZ2VyJyk7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBQb2x5Z29uIHJlbmRlcnMgYSBwb2x5Z29uIG9uIGEge0BsaW5rIFNlYm1Hb29nbGVNYXB9XG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgU2VibUdvb2dsZU1hcCwgU2VibUdvb2dsZVBvbHlnb24sIExhdExuZ0xpdGVyYWwgfSBmcm9tICdhbmd1bGFyMi1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgc3R5bGVzOiBbYFxuICogICAgLnNlbWItbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlbWItbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cbiAqICAgICAgPHNlbWItbWFwLXBvbHlnb24gW3BhdGhzXT1cInBhdGhzXCI+XG4gKiAgICAgIDwvc2VtYi1tYXAtcG9seWdvbj5cbiAqICAgIDwvc2VtYi1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBNeU1hcENtcCB7XG4gKiAgIGxhdDogbnVtYmVyID0gMDtcbiAqICAgbG5nOiBudW1iZXIgPSAwO1xuICogICB6b29tOiBudW1iZXIgPSAxMDtcbiAqICAgcGF0aHM6IEFycmF5PExhdExuZ0xpdGVyYWw+ID0gW1xuICogICAgIHsgbGF0OiAwLCAgbG5nOiAxMCB9LFxuICogICAgIHsgbGF0OiAwLCAgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiAxMCwgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiAxMCwgbG5nOiAxMCB9LFxuICogICAgIHsgbGF0OiAwLCAgbG5nOiAxMCB9XG4gKiAgIF1cbiAqICAgLy8gTmVzdGluZyBwYXRocyB3aWxsIGNyZWF0ZSBhIGhvbGUgd2hlcmUgdGhleSBvdmVybGFwO1xuICogICBuZXN0ZWRQYXRoczogQXJyYXk8QXJyYXk8TGF0TG5nTGl0ZXJhbD4+ID0gW1tcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMTAgfSxcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMjAgfSxcbiAqICAgICB7IGxhdDogMTAsIGxuZzogMjAgfSxcbiAqICAgICB7IGxhdDogMTAsIGxuZzogMTAgfSxcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMTAgfVxuICogICBdLCBbXG4gKiAgICAgeyBsYXQ6IDAsIGxuZzogMTUgfSxcbiAqICAgICB7IGxhdDogMCwgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiA1LCBsbmc6IDIwIH0sXG4gKiAgICAgeyBsYXQ6IDUsIGxuZzogMTUgfSxcbiAqICAgICB7IGxhdDogMCwgbG5nOiAxNSB9XG4gKiAgIF1dXG4gKiB9XG4gKiBgYGBcbiAqL1xudmFyIFNlYm1Hb29nbGVNYXBQb2x5Z29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWJtR29vZ2xlTWFwUG9seWdvbihfcG9seWdvbk1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIgPSBfcG9seWdvbk1hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIFBvbHlnb24gaGFuZGxlcyBtb3VzZSBldmVudHMuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGRyYWcgdGhpcyBzaGFwZSBvdmVyIHRoZSBtYXAuIFRoZSBnZW9kZXNpY1xuICAgICAgICAgKiBwcm9wZXJ0eSBkZWZpbmVzIHRoZSBtb2RlIG9mIGRyYWdnaW5nLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGVkaXQgdGhpcyBzaGFwZSBieSBkcmFnZ2luZyB0aGUgY29udHJvbFxuICAgICAgICAgKiBwb2ludHMgc2hvd24gYXQgdGhlIHZlcnRpY2VzIGFuZCBvbiBlYWNoIHNlZ21lbnQuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0cnVlLCBlZGdlcyBvZiB0aGUgcG9seWdvbiBhcmUgaW50ZXJwcmV0ZWQgYXMgZ2VvZGVzaWMgYW5kIHdpbGxcbiAgICAgICAgICogZm9sbG93IHRoZSBjdXJ2YXR1cmUgb2YgdGhlIEVhcnRoLiBXaGVuIGZhbHNlLCBlZGdlcyBvZiB0aGUgcG9seWdvbiBhcmVcbiAgICAgICAgICogcmVuZGVyZWQgYXMgc3RyYWlnaHQgbGluZXMgaW4gc2NyZWVuIHNwYWNlLiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGFcbiAgICAgICAgICogZ2VvZGVzaWMgcG9seWdvbiBtYXkgYXBwZWFyIHRvIGNoYW5nZSB3aGVuIGRyYWdnZWQsIGFzIHRoZSBkaW1lbnNpb25zXG4gICAgICAgICAqIGFyZSBtYWludGFpbmVkIHJlbGF0aXZlIHRvIHRoZSBzdXJmYWNlIG9mIHRoZSBlYXJ0aC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlb2Rlc2ljID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3JkZXJlZCBzZXF1ZW5jZSBvZiBjb29yZGluYXRlcyB0aGF0IGRlc2lnbmF0ZXMgYSBjbG9zZWQgbG9vcC5cbiAgICAgICAgICogVW5saWtlIHBvbHlsaW5lcywgYSBwb2x5Z29uIG1heSBjb25zaXN0IG9mIG9uZSBvciBtb3JlIHBhdGhzLlxuICAgICAgICAgKiAgQXMgYSByZXN1bHQsIHRoZSBwYXRocyBwcm9wZXJ0eSBtYXkgc3BlY2lmeSBvbmUgb3IgbW9yZSBhcnJheXMgb2ZcbiAgICAgICAgICogTGF0TG5nIGNvb3JkaW5hdGVzLiBQYXRocyBhcmUgY2xvc2VkIGF1dG9tYXRpY2FsbHk7IGRvIG5vdCByZXBlYXQgdGhlXG4gICAgICAgICAqIGZpcnN0IHZlcnRleCBvZiB0aGUgcGF0aCBhcyB0aGUgbGFzdCB2ZXJ0ZXguIFNpbXBsZSBwb2x5Z29ucyBtYXkgYmVcbiAgICAgICAgICogZGVmaW5lZCB1c2luZyBhIHNpbmdsZSBhcnJheSBvZiBMYXRMbmdzLiBNb3JlIGNvbXBsZXggcG9seWdvbnMgbWF5XG4gICAgICAgICAqIHNwZWNpZnkgYW4gYXJyYXkgb2YgYXJyYXlzLiBBbnkgc2ltcGxlIGFycmF5cyBhcmUgY29udmVydGVkIGludG8gQXJyYXlzLlxuICAgICAgICAgKiBJbnNlcnRpbmcgb3IgcmVtb3ZpbmcgTGF0TG5ncyBmcm9tIHRoZSBBcnJheSB3aWxsIGF1dG9tYXRpY2FsbHkgdXBkYXRlXG4gICAgICAgICAqIHRoZSBwb2x5Z29uIG9uIHRoZSBtYXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdGhzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9seUNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIGRibGNsaWNrIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5RGJsQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyByZXBlYXRlZGx5IGZpcmVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBwb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5RHJhZyA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlnb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlEcmFnRW5kID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIHBvbHlnb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlEcmFnU3RhcnQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vkb3duIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VEb3duID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9seU1vdXNlTW92ZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIFBvbHlnb24gbW91c2VvdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlNb3VzZU91dCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIFBvbHlnb24gbW91c2VvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VPdmVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VVcCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW4gaXMgZmlyZWQgd2hlbiB0aGUgUG9seWdvbiBpcyByaWdodC1jbGlja2VkIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5UmlnaHRDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWdvbi5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWdvbi5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BvbHlnb25NYW5hZ2VyLnNldFBvbHlnb25PcHRpb25zKHRoaXMsIHRoaXMuX3VwZGF0ZVBvbHlnb25PcHRpb25zKGNoYW5nZXMpKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIuYWRkUG9seWdvbih0aGlzKTtcbiAgICAgICAgdGhpcy5fcG9seWdvbkFkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5Q2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RiY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEYmxDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZycsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seURyYWcuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdlbmQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEcmFnRW5kLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEcmFnU3RhcnQuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlZG93bicsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seU1vdXNlRG93bi5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5TW91c2VNb3ZlLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seU1vdXNlT3V0LmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlNb3VzZU92ZXIuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNldXAnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlNb3VzZVVwLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5UmlnaHRDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICBdO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9wb2x5Z29uTWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUob2JqLm5hbWUsIF90aGlzKS5zdWJzY3JpYmUob2JqLmhhbmRsZXIpO1xuICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChvcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlnb24ucHJvdG90eXBlLl91cGRhdGVQb2x5Z29uT3B0aW9ucyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjaGFuZ2VzKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gU2VibUdvb2dsZU1hcFBvbHlnb24uX3BvbHlnb25PcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaykge1xuICAgICAgICAgICAgb2JqW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlnb24ucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWQ7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIuZGVsZXRlUG9seWdvbih0aGlzKTtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gcy51bnN1YnNjcmliZSgpOyB9KTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLl9wb2x5Z29uT3B0aW9uc0F0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdjbGlja2FibGUnLCAnZHJhZ2dhYmxlJywgJ2VkaXRhYmxlJywgJ2ZpbGxDb2xvcicsICdmaWxsT3BhY2l0eScsICdnZW9kZXNpYycsICdpY29uJywgJ21hcCcsXG4gICAgICAgICdwYXRocycsICdzdHJva2VDb2xvcicsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdlaWdodCcsICd2aXNpYmxlJywgJ3pJbmRleCcsICdkcmFnZ2FibGUnLFxuICAgICAgICAnZWRpdGFibGUnLCAndmlzaWJsZSdcbiAgICBdO1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLW1hcC1wb2x5Z29uJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xpY2thYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkcmFnZ2FibGU6IHBvbHlEcmFnZ2FibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2VkaXRhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsQ29sb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGxPcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZW9kZXNpYycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF0aHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VXZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3pJbmRleCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb2x5Q2xpY2snLCAncG9seURibENsaWNrJywgJ3BvbHlEcmFnJywgJ3BvbHlEcmFnRW5kJywgJ3BvbHlNb3VzZURvd24nLCAncG9seU1vdXNlTW92ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9seU1vdXNlT3V0JywgJ3BvbHlNb3VzZU92ZXInLCAncG9seU1vdXNlVXAnLCAncG9seVJpZ2h0Q2xpY2snXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHBvbHlnb25fbWFuYWdlcl8xLlBvbHlnb25NYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBQb2x5Z29uO1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlnb24gPSBTZWJtR29vZ2xlTWFwUG9seWdvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtcG9seWdvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIHBvbHlsaW5lX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlsaW5lLW1hbmFnZXInKTtcbnZhciBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEgPSByZXF1aXJlKCcuL2dvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQnKTtcbnZhciBwb2x5bGluZUlkID0gMDtcbi8qKlxuICogU2VibUdvb2dsZU1hcFBvbHlsaW5lIHJlbmRlcnMgYSBwb2x5bGluZSBvbiBhIHtAbGluayBTZWJtR29vZ2xlTWFwfVxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVQb2x5bGluZSwgU2VibUdvb2dsZVBvbHlsaW5lUG9pbnQgfSBmcm9tXG4gKiAnYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZSc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcbiAqICBkaXJlY3RpdmVzOiBbU2VibUdvb2dsZU1hcCwgU2VibUdvb2dsZVBvbHlsaW5lLCBTZWJtR29vZ2xlUG9seWxpbmVQb2ludF0sXG4gKiAgc3R5bGVzOiBbYFxuICogICAgLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXIge1xuICogICAgICBoZWlnaHQ6IDMwMHB4O1xuICogICAgfVxuICogYF0sXG4gKiAgdGVtcGxhdGU6IGBcbiAqICAgIDxzZWJtLWdvb2dsZS1tYXAgW2xhdGl0dWRlXT1cImxhdFwiIFtsb25naXR1ZGVdPVwibG5nXCIgW3pvb21dPVwiem9vbVwiPlxuICogICAgICA8c2VibS1nb29nbGUtbWFwLXBvbHlsaW5lPlxuICogICAgICAgICAgPHNlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCBbbGF0aXR1ZGVdPVwibGF0QVwiIFtsb25naXR1ZGVdPVwibG5nQVwiPlxuICogICAgICAgICAgPC9zZWJtLWdvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQ+XG4gKiAgICAgICAgICA8c2VibS1nb29nbGUtbWFwLXBvbHlsaW5lLXBvaW50IFtsYXRpdHVkZV09XCJsYXRCXCIgW2xvbmdpdHVkZV09XCJsbmdCXCI+XG4gKiAgICAgICAgICA8L3NlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludD5cbiAqICAgICAgPC9zZWJtLWdvb2dsZS1tYXAtcG9seWxpbmU+XG4gKiAgICA8L3NlYm0tZ29vZ2xlLW1hcD5cbiAqICBgXG4gKiB9KVxuICogYGBgXG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwUG9seWxpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBQb2x5bGluZShfcG9seWxpbmVNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlciA9IF9wb2x5bGluZU1hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIFBvbHlsaW5lIGhhbmRsZXMgbW91c2UgZXZlbnRzLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBkcmFnIHRoaXMgc2hhcGUgb3ZlciB0aGUgbWFwLiBUaGUgZ2VvZGVzaWMgcHJvcGVydHkgZGVmaW5lcyB0aGVcbiAgICAgICAgICogbW9kZSBvZiBkcmFnZ2luZy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBlZGl0IHRoaXMgc2hhcGUgYnkgZHJhZ2dpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIHNob3duIGF0IHRoZVxuICAgICAgICAgKiB2ZXJ0aWNlcyBhbmQgb24gZWFjaCBzZWdtZW50LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdHJ1ZSwgZWRnZXMgb2YgdGhlIHBvbHlnb24gYXJlIGludGVycHJldGVkIGFzIGdlb2Rlc2ljIGFuZCB3aWxsIGZvbGxvdyB0aGUgY3VydmF0dXJlIG9mXG4gICAgICAgICAqIHRoZSBFYXJ0aC4gV2hlbiBmYWxzZSwgZWRnZXMgb2YgdGhlIHBvbHlnb24gYXJlIHJlbmRlcmVkIGFzIHN0cmFpZ2h0IGxpbmVzIGluIHNjcmVlbiBzcGFjZS5cbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBzaGFwZSBvZiBhIGdlb2Rlc2ljIHBvbHlnb24gbWF5IGFwcGVhciB0byBjaGFuZ2Ugd2hlbiBkcmFnZ2VkLCBhcyB0aGUgZGltZW5zaW9uc1xuICAgICAgICAgKiBhcmUgbWFpbnRhaW5lZCByZWxhdGl2ZSB0byB0aGUgc3VyZmFjZSBvZiB0aGUgZWFydGguIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW9kZXNpYyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIHBvbHlsaW5lIGlzIHZpc2libGUgb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVEYmxDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIHJlcGVhdGVkbHkgZmlyZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIHBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lRHJhZyA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lRHJhZ0VuZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBwb2x5bGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZURyYWdTdGFydCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZWRvd24gZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lTW91c2VEb3duID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVNb3VzZU1vdmUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBQb2x5bGluZSBtb3VzZW91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZU1vdXNlT3V0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWxpbmUgbW91c2VvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lTW91c2VPdmVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZU1vdXNlVXAgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVuIGlzIGZpcmVkIHdoZW4gdGhlIFBvbHlsaW5lIGlzIHJpZ2h0LWNsaWNrZWQgb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVSaWdodENsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVBZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuX2lkID0gKHBvbHlsaW5lSWQrKykudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5wb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gcG9pbnQucG9zaXRpb25DaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IF90aGlzLl9wb2x5bGluZU1hbmFnZXIudXBkYXRlUG9seWxpbmVQb2ludHMoX3RoaXMpOyB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wb2x5bGluZUFkZGVkVG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSB0aGlzLnBvaW50cy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcG9seWxpbmVNYW5hZ2VyLnVwZGF0ZVBvbHlsaW5lUG9pbnRzKF90aGlzKTsgfSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVNYW5hZ2VyLnVwZGF0ZVBvbHlsaW5lUG9pbnRzKHRoaXMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5fcG9seWxpbmVBZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBTZWJtR29vZ2xlTWFwUG9seWxpbmUuX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTE7IH0pO1xuICAgICAgICBvcHRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHsgcmV0dXJuIG9wdGlvbnNba10gPSBjaGFuZ2VzW2tdLmN1cnJlbnRWYWx1ZTsgfSk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlci5zZXRQb2x5bGluZU9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb2x5bGluZU1hbmFnZXIuYWRkUG9seWxpbmUodGhpcyk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lQWRkZWRUb01hbmFnZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lQ2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RiY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVEYmxDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZycsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZURyYWcuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdlbmQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVEcmFnRW5kLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVEcmFnU3RhcnQuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlZG93bicsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZU1vdXNlRG93bi5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lTW91c2VNb3ZlLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZU1vdXNlT3V0LmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVNb3VzZU92ZXIuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNldXAnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVNb3VzZVVwLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lUmlnaHRDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICBdO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9wb2x5bGluZU1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKG9iai5uYW1lLCBfdGhpcykuc3Vic2NyaWJlKG9iai5oYW5kbGVyKTtcbiAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25zLnB1c2gob3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvdG90eXBlLl9nZXRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzLnRvQXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb2x5bGluZU1hbmFnZXIuZGVsZXRlUG9seWxpbmUodGhpcyk7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGFsbCByZWdpc3RlcmVkIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUuX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdkcmFnZ2FibGUnLCAnZWRpdGFibGUnLCAndmlzaWJsZScsICdnZW9kZXNpYycsICdzdHJva2VDb2xvcicsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdlaWdodCcsXG4gICAgICAgICd6SW5kZXgnXG4gICAgXTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3NlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZScsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsaWNrYWJsZScsICdkcmFnZ2FibGU6IHBvbHlsaW5lRHJhZ2dhYmxlJywgJ2VkaXRhYmxlJywgJ2dlb2Rlc2ljJywgJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VXZWlnaHQnLCAnc3Ryb2tlT3BhY2l0eScsICd2aXNpYmxlJywgJ3pJbmRleCdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmVDbGljaycsICdsaW5lRGJsQ2xpY2snLCAnbGluZURyYWcnLCAnbGluZURyYWdFbmQnLCAnbGluZU1vdXNlRG93bicsICdsaW5lTW91c2VNb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lTW91c2VPdXQnLCAnbGluZU1vdXNlT3ZlcicsICdsaW5lTW91c2VVcCcsICdsaW5lUmlnaHRDbGljaydcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHBvbHlsaW5lX21hbmFnZXJfMS5Qb2x5bGluZU1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdwb2ludHMnOiBbeyB0eXBlOiBjb3JlXzEuQ29udGVudENoaWxkcmVuLCBhcmdzOiBbZ29vZ2xlX21hcF9wb2x5bGluZV9wb2ludF8xLlNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50LF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBQb2x5bGluZTtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBQb2x5bGluZSA9IFNlYm1Hb29nbGVNYXBQb2x5bGluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtcG9seWxpbmUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50IHJlcHJlc2VudHMgb25lIGVsZW1lbnQgb2YgYSBwb2x5bGluZSB3aXRoaW4gYSAge0BsaW5rXG4gKiBTZW1iR29vZ2xlTWFwUG9seWxpbmV9XG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZWQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlc1snbGF0aXR1ZGUnXSB8fCBjaGFuZ2VzWydsb25naXR1ZGUnXSkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIGxhdDogY2hhbmdlc1snbGF0aXR1ZGUnXS5jdXJyZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgbG5nOiBjaGFuZ2VzWydsb25naXR1ZGUnXS5jdXJyZW50VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlZC5lbWl0KHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ3NlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCcgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAnbGF0aXR1ZGUnOiBbeyB0eXBlOiBjb3JlXzEuSW5wdXQgfSxdLFxuICAgICAgICAnbG9uZ2l0dWRlJzogW3sgdHlwZTogY29yZV8xLklucHV0IH0sXSxcbiAgICAgICAgJ3Bvc2l0aW9uQ2hhbmdlZCc6IFt7IHR5cGU6IGNvcmVfMS5PdXRwdXQgfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50O1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQgPSBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lLXBvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9nb29nbGUtbWFwcy1hcGktd3JhcHBlcicpO1xuZXhwb3J0cy5Hb29nbGVNYXBzQVBJV3JhcHBlciA9IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXI7XG52YXIgY2lyY2xlX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMvY2lyY2xlLW1hbmFnZXInKTtcbmV4cG9ydHMuQ2lyY2xlTWFuYWdlciA9IGNpcmNsZV9tYW5hZ2VyXzEuQ2lyY2xlTWFuYWdlcjtcbnZhciBpbmZvX3dpbmRvd19tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hbmFnZXJzL2luZm8td2luZG93LW1hbmFnZXInKTtcbmV4cG9ydHMuSW5mb1dpbmRvd01hbmFnZXIgPSBpbmZvX3dpbmRvd19tYW5hZ2VyXzEuSW5mb1dpbmRvd01hbmFnZXI7XG52YXIgbWFya2VyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMvbWFya2VyLW1hbmFnZXInKTtcbmV4cG9ydHMuTWFya2VyTWFuYWdlciA9IG1hcmtlcl9tYW5hZ2VyXzEuTWFya2VyTWFuYWdlcjtcbnZhciBwb2x5Z29uX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMvcG9seWdvbi1tYW5hZ2VyJyk7XG5leHBvcnRzLlBvbHlnb25NYW5hZ2VyID0gcG9seWdvbl9tYW5hZ2VyXzEuUG9seWdvbk1hbmFnZXI7XG52YXIgcG9seWxpbmVfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyJyk7XG5leHBvcnRzLlBvbHlsaW5lTWFuYWdlciA9IHBvbHlsaW5lX21hbmFnZXJfMS5Qb2x5bGluZU1hbmFnZXI7XG52YXIga21sX2xheWVyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMva21sLWxheWVyLW1hbmFnZXInKTtcbmV4cG9ydHMuS21sTGF5ZXJNYW5hZ2VyID0ga21sX2xheWVyX21hbmFnZXJfMS5LbWxMYXllck1hbmFnZXI7XG52YXIgbGF6eV9tYXBzX2FwaV9sb2FkZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyJyk7XG5leHBvcnRzLkdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbCA9IGxhenlfbWFwc19hcGlfbG9hZGVyXzEuR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sO1xuZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyA9IGxhenlfbWFwc19hcGlfbG9hZGVyXzEuTEFaWV9NQVBTX0FQSV9DT05GSUc7XG5leHBvcnRzLkxhenlNYXBzQVBJTG9hZGVyID0gbGF6eV9tYXBzX2FwaV9sb2FkZXJfMS5MYXp5TWFwc0FQSUxvYWRlcjtcbnZhciBtYXBzX2FwaV9sb2FkZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL21hcHMtYXBpLWxvYWRlcicpO1xuZXhwb3J0cy5NYXBzQVBJTG9hZGVyID0gbWFwc19hcGlfbG9hZGVyXzEuTWFwc0FQSUxvYWRlcjtcbnZhciBub29wX21hcHNfYXBpX2xvYWRlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbm9vcC1tYXBzLWFwaS1sb2FkZXInKTtcbmV4cG9ydHMuTm9PcE1hcHNBUElMb2FkZXIgPSBub29wX21hcHNfYXBpX2xvYWRlcl8xLk5vT3BNYXBzQVBJTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGJyb3dzZXJfZ2xvYmFsc18xID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3Nlci1nbG9iYWxzJyk7XG52YXIgbWFwc19hcGlfbG9hZGVyXzEgPSByZXF1aXJlKCcuL21hcHMtYXBpLWxvYWRlcicpO1xuKGZ1bmN0aW9uIChHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wpIHtcbiAgICBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2xbR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW1wiSFRUUFwiXSA9IDFdID0gXCJIVFRQXCI7XG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkhUVFBTXCJdID0gMl0gPSBcIkhUVFBTXCI7XG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkFVVE9cIl0gPSAzXSA9IFwiQVVUT1wiO1xufSkoZXhwb3J0cy5Hb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wgfHwgKGV4cG9ydHMuR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sID0ge30pKTtcbnZhciBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wgPSBleHBvcnRzLkdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbDtcbi8qKlxuICogVG9rZW4gZm9yIHRoZSBjb25maWcgb2YgdGhlIExhenlNYXBzQVBJTG9hZGVyLiBQbGVhc2UgcHJvdmlkZSBhbiBvYmplY3Qgb2YgdHlwZSB7QGxpbmtcbiAqIExhenlNYXBzQVBJTG9hZGVyQ29uZmlnfS5cbiAqL1xuZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyA9IG5ldyBjb3JlXzEuT3BhcXVlVG9rZW4oJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzIExBWllfTUFQU19BUElfQ09ORklHJyk7XG52YXIgTGF6eU1hcHNBUElMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXp5TWFwc0FQSUxvYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXp5TWFwc0FQSUxvYWRlcihjb25maWcsIHcsIGQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgdGhpcy5fd2luZG93UmVmID0gdztcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWYgPSBkO1xuICAgIH1cbiAgICBMYXp5TWFwc0FQSUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmlwdCA9IHRoaXMuX2RvY3VtZW50UmVmLmdldE5hdGl2ZURvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIHZhciBjYWxsYmFja05hbWUgPSBcImFuZ3VsYXIyR29vZ2xlTWFwc0xhenlNYXBzQVBJTG9hZGVyXCI7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLl9nZXRTY3JpcHRTcmMoY2FsbGJhY2tOYW1lKTtcbiAgICAgICAgdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5fd2luZG93UmVmLmdldE5hdGl2ZVdpbmRvdygpW2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoKSB7IHJlc29sdmUoKTsgfTtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7IHJlamVjdChlcnJvcik7IH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kb2N1bWVudFJlZi5nZXROYXRpdmVEb2N1bWVudCgpLmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlO1xuICAgIH07XG4gICAgTGF6eU1hcHNBUElMb2FkZXIucHJvdG90eXBlLl9nZXRTY3JpcHRTcmMgPSBmdW5jdGlvbiAoY2FsbGJhY2tOYW1lKSB7XG4gICAgICAgIHZhciBwcm90b2NvbFR5cGUgPSAodGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5wcm90b2NvbCkgfHwgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFBTO1xuICAgICAgICB2YXIgcHJvdG9jb2w7XG4gICAgICAgIHN3aXRjaCAocHJvdG9jb2xUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5BVVRPOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5IVFRQOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHA6JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFBTOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHBzOic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvc3RBbmRQYXRoID0gdGhpcy5fY29uZmlnLmhvc3RBbmRQYXRoIHx8ICdtYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzJztcbiAgICAgICAgdmFyIHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgICAgICAgdjogdGhpcy5fY29uZmlnLmFwaVZlcnNpb24gfHwgJzMnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrTmFtZSxcbiAgICAgICAgICAgIGtleTogdGhpcy5fY29uZmlnLmFwaUtleSxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5fY29uZmlnLmNsaWVudElkLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5fY29uZmlnLmNoYW5uZWwsXG4gICAgICAgICAgICBsaWJyYXJpZXM6IHRoaXMuX2NvbmZpZy5saWJyYXJpZXMsXG4gICAgICAgICAgICByZWdpb246IHRoaXMuX2NvbmZpZy5yZWdpb24sXG4gICAgICAgICAgICBsYW5ndWFnZTogdGhpcy5fY29uZmlnLmxhbmd1YWdlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhxdWVyeVBhcmFtcylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHF1ZXJ5UGFyYW1zW2tdICE9IG51bGw7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgYXJyYXlzXG4gICAgICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pICYmIHF1ZXJ5UGFyYW1zW2tdLmxlbmd0aCA+IDApO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgLy8gam9pbiBhcnJheXMgYXMgY29tbWEgc2VwZXJhdGVkIHN0cmluZ3NcbiAgICAgICAgICAgIHZhciBpID0gcXVlcnlQYXJhbXNba107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGtleTogaywgdmFsdWU6IGkuam9pbignLCcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGssIHZhbHVlOiBxdWVyeVBhcmFtc1trXSB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmtleSArIFwiPVwiICsgZW50cnkudmFsdWU7IH0pXG4gICAgICAgICAgICAuam9pbignJicpO1xuICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBcIi8vXCIgKyBob3N0QW5kUGF0aCArIFwiP1wiICsgcGFyYW1zO1xuICAgIH07XG4gICAgTGF6eU1hcHNBUElMb2FkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTGF6eU1hcHNBUElMb2FkZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IGJyb3dzZXJfZ2xvYmFsc18xLldpbmRvd1JlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBicm93c2VyX2dsb2JhbHNfMS5Eb2N1bWVudFJlZiwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBMYXp5TWFwc0FQSUxvYWRlcjtcbn0obWFwc19hcGlfbG9hZGVyXzEuTWFwc0FQSUxvYWRlcikpO1xuZXhwb3J0cy5MYXp5TWFwc0FQSUxvYWRlciA9IExhenlNYXBzQVBJTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eS1tYXBzLWFwaS1sb2FkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBXaW5kb3dSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpbmRvd1JlZigpIHtcbiAgICB9XG4gICAgV2luZG93UmVmLnByb3RvdHlwZS5nZXROYXRpdmVXaW5kb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3c7IH07XG4gICAgcmV0dXJuIFdpbmRvd1JlZjtcbn0oKSk7XG5leHBvcnRzLldpbmRvd1JlZiA9IFdpbmRvd1JlZjtcbnZhciBEb2N1bWVudFJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9jdW1lbnRSZWYoKSB7XG4gICAgfVxuICAgIERvY3VtZW50UmVmLnByb3RvdHlwZS5nZXROYXRpdmVEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50OyB9O1xuICAgIHJldHVybiBEb2N1bWVudFJlZjtcbn0oKSk7XG5leHBvcnRzLkRvY3VtZW50UmVmID0gRG9jdW1lbnRSZWY7XG5leHBvcnRzLkJST1dTRVJfR0xPQkFMU19QUk9WSURFUlMgPSBbV2luZG93UmVmLCBEb2N1bWVudFJlZl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLWdsb2JhbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvdXRpbHMvYnJvd3Nlci1nbG9iYWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogV2hlbiB1c2luZyB0aGUgTm9PcE1hcHNBUElMb2FkZXIsIHRoZSBHb29nbGUgTWFwcyBBUEkgbXVzdCBiZSBhZGRlZCB0byB0aGUgcGFnZSB2aWEgYSBgPHNjcmlwdD5gXG4gKiBUYWcuXG4gKiBJdCdzIGltcG9ydGFudCB0aGF0IHRoZSBHb29nbGUgTWFwcyBBUEkgc2NyaXB0IGdldHMgbG9hZGVkIGZpcnN0IG9uIHRoZSBwYWdlLlxuICovXG52YXIgTm9PcE1hcHNBUElMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vT3BNYXBzQVBJTG9hZGVyKCkge1xuICAgIH1cbiAgICBOb09wTWFwc0FQSUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cuZ29vZ2xlIHx8ICF3aW5kb3cuZ29vZ2xlLm1hcHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR29vZ2xlIE1hcHMgQVBJIG5vdCBsb2FkZWQgb24gcGFnZS4gTWFrZSBzdXJlIHdpbmRvdy5nb29nbGUubWFwcyBpcyBhdmFpbGFibGUhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBOb09wTWFwc0FQSUxvYWRlcjtcbn0oKSk7XG5leHBvcnRzLk5vT3BNYXBzQVBJTG9hZGVyID0gTm9PcE1hcHNBUElMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub29wLW1hcHMtYXBpLWxvYWRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbm9vcC1tYXBzLWFwaS1sb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBnb29nbGVfbWFwX2ttbF9sYXllcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAta21sLWxheWVyJyk7XG52YXIgZ29vZ2xlX21hcF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAnKTtcbnZhciBnb29nbGVfbWFwX2NpcmNsZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtY2lyY2xlJyk7XG52YXIgZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtaW5mby13aW5kb3cnKTtcbnZhciBnb29nbGVfbWFwX21hcmtlcl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtbWFya2VyJyk7XG52YXIgZ29vZ2xlX21hcF9wb2x5Z29uXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5Z29uJyk7XG52YXIgZ29vZ2xlX21hcF9wb2x5bGluZV8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUnKTtcbnZhciBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCcpO1xudmFyIGxhenlfbWFwc19hcGlfbG9hZGVyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9sYXp5LW1hcHMtYXBpLWxvYWRlcicpO1xudmFyIGxhenlfbWFwc19hcGlfbG9hZGVyXzIgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9sYXp5LW1hcHMtYXBpLWxvYWRlcicpO1xudmFyIG1hcHNfYXBpX2xvYWRlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbWFwcy1hcGktbG9hZGVyJyk7XG52YXIgYnJvd3Nlcl9nbG9iYWxzXzEgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXItZ2xvYmFscycpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY29yZURpcmVjdGl2ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZ29vZ2xlX21hcF8xLlNlYm1Hb29nbGVNYXAsIGdvb2dsZV9tYXBfbWFya2VyXzEuU2VibUdvb2dsZU1hcE1hcmtlciwgZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xLlNlYm1Hb29nbGVNYXBJbmZvV2luZG93LCBnb29nbGVfbWFwX2NpcmNsZV8xLlNlYm1Hb29nbGVNYXBDaXJjbGUsXG4gICAgICAgIGdvb2dsZV9tYXBfcG9seWdvbl8xLlNlYm1Hb29nbGVNYXBQb2x5Z29uLCBnb29nbGVfbWFwX3BvbHlsaW5lXzEuU2VibUdvb2dsZU1hcFBvbHlsaW5lLCBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEuU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQsIGdvb2dsZV9tYXBfa21sX2xheWVyXzEuU2VibUdvb2dsZU1hcEttbExheWVyXG4gICAgXTtcbn1cbmV4cG9ydHMuY29yZURpcmVjdGl2ZXMgPSBjb3JlRGlyZWN0aXZlcztcbjtcbi8qKlxuICogVGhlIGFuZ3VsYXIyLWdvb2dsZS1tYXBzIGNvcmUgbW9kdWxlLiBDb250YWlucyBhbGwgRGlyZWN0aXZlcy9TZXJ2aWNlcy9QaXBlc1xuICogb2YgdGhlIGNvcmUgbW9kdWxlLiBQbGVhc2UgdXNlIGBBZ21Db3JlTW9kdWxlLmZvclJvb3QoKWAgaW4geW91ciBhcHAgbW9kdWxlLlxuICovXG52YXIgQWdtQ29yZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWdtQ29yZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxlYXNlIHVzZSB0aGlzIG1ldGhvZCB3aGVuIHlvdSByZWdpc3RlciB0aGUgbW9kdWxlIGF0IHRoZSByb290IGxldmVsLlxuICAgICAqL1xuICAgIEFnbUNvcmVNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uIChsYXp5TWFwc0FQSUxvYWRlckNvbmZpZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEFnbUNvcmVNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IGJyb3dzZXJfZ2xvYmFsc18xLkJST1dTRVJfR0xPQkFMU19QUk9WSURFUlMuY29uY2F0KFtcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IG1hcHNfYXBpX2xvYWRlcl8xLk1hcHNBUElMb2FkZXIsIHVzZUNsYXNzOiBsYXp5X21hcHNfYXBpX2xvYWRlcl8xLkxhenlNYXBzQVBJTG9hZGVyIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBsYXp5X21hcHNfYXBpX2xvYWRlcl8yLkxBWllfTUFQU19BUElfQ09ORklHLCB1c2VWYWx1ZTogbGF6eU1hcHNBUElMb2FkZXJDb25maWcgfVxuICAgICAgICAgICAgXSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBZ21Db3JlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nTW9kdWxlLCBhcmdzOiBbeyBkZWNsYXJhdGlvbnM6IGNvcmVEaXJlY3RpdmVzKCksIGV4cG9ydHM6IGNvcmVEaXJlY3RpdmVzKCkgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBBZ21Db3JlTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIEFnbUNvcmVNb2R1bGU7XG59KCkpO1xuZXhwb3J0cy5BZ21Db3JlTW9kdWxlID0gQWdtQ29yZU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUtbW9kdWxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2NvcmUtbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUFJBQ1RJQ0VfREFUQSB9IGZyb20gXCIuL2RhdGEvcHJhY3RpY2UuZGF0YVwiO1xuaW1wb3J0IHsgUHJhY3RpY2UgfSBmcm9tIFwiLi9tb2RlbC9wcmFjdGljZS5tb2RlbFwiO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3ByYWN0aWNlJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9wcmFjdGljZS5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vcHJhY3RpY2UuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBQcmFjdGljZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvLyBQcmFjdGljZSBkYXRhIHRvIGluamVjdCBpbnRvIG91ciB0ZW1wbGF0ZVxuICAgIHByaXZhdGUgcHJhY3RpY2VEYXRhOiBQcmFjdGljZVtdID0gUFJBQ1RJQ0VfREFUQTtcblxuICAgIG5nT25Jbml0KCk6IHZvaWQge31cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudC50cyIsImltcG9ydCB7IFByYWN0aWNlIH0gZnJvbSBcIi4uL21vZGVsL3ByYWN0aWNlLm1vZGVsXCI7XG5cbmV4cG9ydCBjb25zdCBQUkFDVElDRV9EQVRBOiBQcmFjdGljZVtdID0gW1xuICAgIHtcbiAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgIHdoYXQ6ICdOb3JtYWwgUHJhY3RpY2UnLFxuICAgICAgICB0aW1lOiAnNDozMFBNLTdQTScsXG4gICAgICAgIHdoZW46ICdNb25kYXlzICYgV2VkbmVzZGF5cycsXG4gICAgICAgIGxvY2F0aW9uTGFiZWw6ICdDb21wbGV4IEZpZWxkcycsXG4gICAgICAgIGxvY2F0aW9uTGluazogJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20vbWFwcy9wbGFjZS9GbG9yaWRhK2FuZCtMaW5jb2xuK1BsYXlpbmcrRmllbGQvQDQwLjA5NjY5NjQsLTg4LjIyNDI4MDYsMTZ6L2RhdGE9ITRtNSExbTIhMm0xITFzY29tcGxleCtmaWVsZHMhM20xITFzMHgwMDAwMDAwMDAwMDAwMDAwOjB4MTM2MzM4NDA4OTZlMjViZidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgc2Vhc29uOiAnRmFsbCcsXG4gICAgICAgIHdoYXQ6ICdXZWVrZW5kIEludml0ZSBQcmFjdGljZScsXG4gICAgICAgIHRpbWU6ICdUQkQnLFxuICAgICAgICB3aGVuOiAnV2Vla2VuZHMnLFxuICAgICAgICBsb2NhdGlvbkxhYmVsOiAnQ29tcGxleCBGaWVsZHMnLFxuICAgICAgICBsb2NhdGlvbkxpbms6ICdodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvcGxhY2UvRmxvcmlkYSthbmQrTGluY29sbitQbGF5aW5nK0ZpZWxkL0A0MC4wOTY2OTY0LC04OC4yMjQyODA2LDE2ei9kYXRhPSE0bTUhMW0yITJtMSExc2NvbXBsZXgrZmllbGRzITNtMSExczB4MDAwMDAwMDAwMDAwMDAwMDoweDEzNjMzODQwODk2ZTI1YmYnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHNlYXNvbjogJ1dpbnRlcicsXG4gICAgICAgIHdoYXQ6ICdOb3JtYWwgUHJhY3RpY2UnLFxuICAgICAgICB0aW1lOiAnOTozMFBNLTEyQU0nLFxuICAgICAgICB3aGVuOiAnTW9uZGF5cyAmIFdlZG5lc2RheXMnLFxuICAgICAgICBsb2NhdGlvbkxhYmVsOiAnQXJtb3J5JyxcbiAgICAgICAgbG9jYXRpb25MaW5rOiAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL3BsYWNlL0FybW9yeS9ANDAuMTA1NDAyLC04OC4yMzU1MzQsMTd6L2RhdGE9ITNtMSE1czB4ODgwY2Q3M2I4YzRmYmI3ZDoweGE4NDg5MDExMGFmZDA5OTAhNG03ITFtNCEzbTMhMXMweDg4MGNkNzNhMTZjMWQ3OGY6MHhlMWJiMDA5MjI1ZmMxMjI1ITJzRStBcm1vcnkrQXZlLCtDaGFtcGFpZ24sK0lMKzYxODIwITNiMSEzbTEhMXMweDAwMDAwMDAwMDAwMDAwMDA6MHgwYjIxZDU2ZjJiOTUxOTc4J1xuICAgIH0sXG4gICAge1xuICAgICAgICBzZWFzb246ICdXaW50ZXInLFxuICAgICAgICB3aGF0OiAnSW5kb29yIEZpZWxkIFByYWN0aWNlJyxcbiAgICAgICAgdGltZTogJzExUE0tMTJBTScsXG4gICAgICAgIHdoZW46ICdUaHVyc2RheXMnLFxuICAgICAgICBsb2NhdGlvbkxhYmVsOiAnSXJ3aW4gRmFjaWxpdHknLFxuICAgICAgICBsb2NhdGlvbkxpbms6ICdodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvcGxhY2UvSXJ3aW4rSW5kb29yK0Zvb3RiYWxsK0ZhY2lsaXR5LCtVbml2ZXJzaXR5K29mK0lsbGlub2lzK2F0K1VyYmFuYS1DaGFtcGFpZ24sK0NoYW1wYWlnbiwrSUwrNjE4MjAvQDQwLjEwMDY0NzUsLTg4LjIzNDIyMDQsMTd6L2RhdGE9ITNtMSE0YjEhNG02ITFtMyEzbTIhMXMweDg4MGNkNzI0YTkyNjU1ZTk6MHhhNTNjMDUyNTA0NjgyNmZhITJzVW5pdmVyc2l0eStvZitJbGxpbm9pcythdCtVcmJhbmEtQ2hhbXBhaWduITNtMSExczB4ODgwY2Q3MjUyOTJjMDJiZDoweDE4ZjVhMDNkYWFkODY3N2EnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgIHdoYXQ6ICdOb3JtYWwgUHJhY3RpY2UnLFxuICAgICAgICB0aW1lOiAnOTozMFBNLTEyQU0nLFxuICAgICAgICB3aGVuOiAnTW9uZGF5cyAmIFdlZG5lc2RheXMnLFxuICAgICAgICBsb2NhdGlvbkxhYmVsOiAnQ29tcGxleCBGaWVsZHMnLFxuICAgICAgICBsb2NhdGlvbkxpbms6ICdodHRwczovL3d3dy5nb29nbGUuY29tL21hcHMvcGxhY2UvRmxvcmlkYSthbmQrTGluY29sbitQbGF5aW5nK0ZpZWxkL0A0MC4wOTY2OTY0LC04OC4yMjQyODA2LDE2ei9kYXRhPSE0bTUhMW0yITJtMSExc2NvbXBsZXgrZmllbGRzITNtMSExczB4MDAwMDAwMDAwMDAwMDAwMDoweDEzNjMzODQwODk2ZTI1YmYnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHNlYXNvbjogJ1NwcmluZycsXG4gICAgICAgIHdoYXQ6ICdBLVRlYW0gUHJhY3RpY2UnLFxuICAgICAgICB0aW1lOiAnVEJEJyxcbiAgICAgICAgd2hlbjogJ1dlZWtlbmRzJyxcbiAgICAgICAgbG9jYXRpb25MYWJlbDogJ0NvbXBsZXggRmllbGRzJyxcbiAgICAgICAgbG9jYXRpb25MaW5rOiAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9tYXBzL3BsYWNlL0Zsb3JpZGErYW5kK0xpbmNvbG4rUGxheWluZytGaWVsZC9ANDAuMDk2Njk2NCwtODguMjI0MjgwNiwxNnovZGF0YT0hNG01ITFtMiEybTEhMXNjb21wbGV4K2ZpZWxkcyEzbTEhMXMweDAwMDAwMDAwMDAwMDAwMDA6MHgxMzYzMzg0MDg5NmUyNWJmJ1xuICAgIH1cbl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3RlYW0vcHJhY3RpY2UvZGF0YS9wcmFjdGljZS5kYXRhLnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxoMSBjbGFzcz1cXFwidWkgaGVhZGVyXFxcIj5QcmFjdGljZTwvaDE+XFxuPHRhYmxlIGNsYXNzPVxcXCJ1aSBjZWxsZWQgdGFibGVcXFwiPlxcbiAgICA8dGhlYWQ+XFxuICAgICAgICA8dHI+XFxuICAgICAgICAgICAgPHRoPlNlYXNvbjwvdGg+XFxuICAgICAgICAgICAgPHRoPldoYXQ8L3RoPlxcbiAgICAgICAgICAgIDx0aD5UaW1lPC90aD5cXG4gICAgICAgICAgICA8dGg+V2hlbjwvdGg+XFxuICAgICAgICAgICAgPHRoPkxvY2F0aW9uPC90aD5cXG4gICAgICAgIDwvdHI+XFxuICAgIDwvdGhlYWQ+XFxuICAgIDx0Ym9keT5cXG4gICAgICAgIDx0ciAqbmdGb3I9XFxcImxldCBwcmFjdGljZVJvdyBvZiBwcmFjdGljZURhdGFcXFwiPlxcbiAgICAgICAgICAgIDx0ZD57e3ByYWN0aWNlUm93LnNlYXNvbn19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+e3twcmFjdGljZVJvdy53aGF0fX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e3ByYWN0aWNlUm93LnRpbWV9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7cHJhY3RpY2VSb3cud2hlbn19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+PGEgaHJlZj1cXFwie3twcmFjdGljZVJvdy5sb2NhdGlvbkxpbmt9fVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPnt7cHJhY3RpY2VSb3cubG9jYXRpb25MYWJlbH19PC9hPjwvdGQ+XFxuICAgICAgICA8L3RyPlxcbiAgICA8L3Rib2R5PlxcbjwvdGFibGU+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vcHJhY3RpY2UvcHJhY3RpY2UuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJhY3RpY2UuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vcHJhY3RpY2UvcHJhY3RpY2UuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcInRyIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWN0aXZhdGVkUm91dGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG5pbXBvcnQgeyBUT1VSTkFNRU5UU19EQVRBIH0gZnJvbSBcIi4vZGF0YS90b3VybmFtZW50cy5kYXRhXCI7XG5pbXBvcnQgeyBUb3VybmFtZW50WWVhciB9IGZyb20gXCIuL21vZGVsL3RvdXJuYW1lbnQteWVhci5tb2RlbFwiO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3RvdXJuYW1lbnRzJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi90b3VybmFtZW50cy5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vdG91cm5hbWVudHMuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBUb3VybmFtZW50c0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvLyBUb3VybmFtZW50IGRhdGEgdG8gaW5qZWN0IGludG8gb3VyIHRlbXBsYXRlXG4gICAgcHJpdmF0ZSB0b3VybmFtZW50RGF0YTogVG91cm5hbWVudFllYXJbXSA9IFRPVVJOQU1FTlRTX0RBVEE7XG4gICAgLy8gU3Vic2NyaXB0aW9uIHRvIG91ciByb3V0ZSBwYXJhbWV0ZXJzICh0b3VybmFtZW50IHllYXIpXG4gICAgcHJpdmF0ZSByb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbjogYW55O1xuICAgIC8vIEN1cnJlbnQgdG91cm5hbWVudCB5ZWFyXG4gICAgcHJpdmF0ZSB5ZWFyOiBudW1iZXI7XG5cbiAgICAvLyBJbmplY3QgdGhlIEFjdGl2YXRlZFJvdXRlIGludG8gb3VyIGNvbXBvbmVudFxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcm91dGU6IEFjdGl2YXRlZFJvdXRlKSB7fVxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIG91ciByb3V0ZSBwYXJhbWV0ZXJzICh0b3VybmFtZW50IHllYXIpLlxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJvdXRlUGFyYW1zU3Vic2NyaXB0aW9uID0gdGhpcy5yb3V0ZS5wYXJhbXMuc3Vic2NyaWJlKHBhcmFtcyA9PiB7XG4gICAgICAgICAgICAvLyAoKykgY29udmVydHMgc3RyaW5nICd5ZWFyJyB0byBhIG51bWJlclxuICAgICAgICAgICAgdGhpcy55ZWFyID0gK3BhcmFtc1sneWVhciddO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZSB0byBvdXIgcm91dGUgcGFyYW1ldGVycyAodG91cm5hbWVudCB5ZWFyKS5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3RvdXJuYW1lbnRzL3RvdXJuYW1lbnRzLmNvbXBvbmVudC50cyIsImltcG9ydCB7IFRvdXJuYW1lbnRZZWFyIH0gZnJvbSBcIi4uL21vZGVsL3RvdXJuYW1lbnQteWVhci5tb2RlbFwiO1xuXG5leHBvcnQgY29uc3QgVE9VUk5BTUVOVFNfREFUQTogVG91cm5hbWVudFllYXJbXSA9IFtcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTcsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdCb2lsZXIgQnJlYWthd2F5JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cHM6Ly9ib2lsZXJsaW5rLnB1cmR1ZS5lZHUvb3JnYW5pemF0aW9uL21lbnN1bHRpbWF0ZS9jYWxlbmRhci9kZXRhaWxzLzk3MjkyMCcsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ1NlcHQuIDE3dGgtMTh0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1dlc3QgTGFmYXlldHRlLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnTm8gV2lzY29uc2VxdWVuY2VzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL25vd2lzY29uc2VxdWVuY2VzLnVsdGltYXRlY2VudHJhbC5jb20nLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdPY3QuIDh0aC05dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdIYXJ0bGFuZCwgV0knLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ01pc3NvdXJpIExvdmVzIENvbXBhbnknLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vdWx0aW1hdGUubWlzc291cmkuZWR1L21sYy8yMDE2JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnTm92LiA1dGgtNnRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgYFByZXNpZGVudCdzIERheSBJbnZpdGVgLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL1ByZXNpZGVudHMtRGF5LVRvdXJuYW1lbnQtMjAxNycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0ZlYi4gMTd0aC0yMHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnU2FuIERpZWdvLCBDQScsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzV0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0NlbnRleCcsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvQ2VudGV4LTIwMTctT3BlbicsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ01hcmNoIDEwdGgtMTN0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ0F1c3RpbiwgVFgnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICc3dGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdIdWNrIEZpbm4nLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0h1Y2stRmlubi0yMDE3JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnQXByaWwgMXN0LTJuZCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1N0LiBMb3VpcywgTU8nLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxMXRoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnSWxsaW5vaXMgQ29uZmVyZW5jZXMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0lsbGlub2lzLUQtSS1Db2xsZWdlLU1lbnMtQ0MtMjAxNycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0FwcmlsIDIybmQtMjNyZCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1JhbnRvdWwsIElMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMm5kJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnR3JlYXQgTGFrZXMgUmVnaW9uYWxzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9HcmVhdC1MYWtlcy1ELUktQ29sbGVnZS1NZW5zLVJlZ2lvbmFscy0yMDE3JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnTWF5IDZ0aC03dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdGYWlyIE9ha3MsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnNnRoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdCb2lsZXIgQnJlYWthd2F5JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL3VsdGltYXRlL2NvbW1lbnRzLzM4Z3k3Mi9uZXdfZmllbGRzX2JvaWxlcl9icmVha2F3YXlfMjAxNV9ob3N0ZWRfYnlfdW5kdWUnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdTZXB0LiAxOXRoLTIwdGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdXZXN0ZmllbGQsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdIdWNrIG9mIHRoZSBJcmlzaCcsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHBzOi8vbmR1bHRpbWF0ZS53b3JkcHJlc3MuY29tL2hvdGknLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdPY3QuIDNyZC00dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdTb3V0aCBCZW5kLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnQ2hpY2FnbyBJbnZpdGUnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vd3d3LmNoaWNhZ29pbnZpdGUuY29tJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnT2N0LiAxN3RoLTE4dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSb2NrZm9yZCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ01pc3NvdXJpIExvdmVzIENvbXBhbnknLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vdWx0aXdvcmxkLmNvbS8yMDE1LzExLzEyL21pc3NvdXJpLWxvdmVzLWNvbXBhbnktMjAxNS10b3VybmFtZW50LXJlY2FwLW1lbnMnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdOb3YuIDd0aC04dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdDb2x1bWJpYSwgTU8nLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxMHRoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnRmxvcmlkYSBXYXJtdXAnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL1dhcm0tdXAtQS1GbG9yaWRhLUFmZmFpci0yMDE2JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnRmViLiAxMXRoLTE0dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdUYW1wYSwgRkwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxNXRoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnRWFzdGVybnMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0NvbGxlZ2UtRWFzdGVybnMtMjAxNicsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ01hcmNoIDE4dGgtMjB0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ05vcnRoIE15cnRsZSBCZWFjaCwgU0MnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxOXRoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnSHVjayBGaW5uJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9IdWNrLUZpbm4tWFgtMjAxNicsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0ZlYi4gMTF0aC0xNHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnU3QuIExvdWlzLCBNTycsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzExdGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdJbGxpbm9pcyBDb25mZXJlbmNlcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvSWxsaW5vaXMtRC1JLUNvbGxlZ2UtTWVucy1DQy0yMDE2JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnQXByaWwgMTZ0aC0xN3RoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnUmFudG91bCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICczcmQnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdHcmVhdCBMYWtlcyBSZWdpb25hbHMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0dyZWF0LUxha2VzLUQtSS1Db2xsZWdlLU1lbnMtUmVnaW9uYWxzLTIwMTYnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdBcHJpbCAzMHRoLU1heSAxc3QnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdGYWlyIE9ha3MsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnM3JkJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTUsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdIdWNrIG9mIHRoZSBJcmlzaCcsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHBzOi8vbmR1bHRpbWF0ZS53b3JkcHJlc3MuY29tL3doaXRlc21va2UnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdTZXB0LiAyN3RoLTI4dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdTb3V0aCBCZW5kLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnR2xvcnkgRGF5cycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly93d3cuc3VuLXVsdGltYXRlLm9yZy9nbG9yeS1kYXlzLmh0bWwnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdPY3QuIDR0aC01dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSb2NrZm9yZCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0lsbGlub2lzIEludml0ZScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHBzOi8vaWxsaW5vaXMuY29sbGVnaWF0ZWxpbmsubmV0L29yZ2FuaXphdGlvbi9pbGxpbm9pc21lbnN1bHRpbWF0ZWZyaXNiZWV0ZWFtL2NhbGVuZGFyL2RldGFpbHMvNTA0MjA0JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnT2N0LiAxOHRoLTE5dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSYW50b3VsLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnTWlzc291cmkgTG92ZXMgQ29tcGFueScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly91bHRpd29ybGQuY29tLzIwMTQvMTEvMDYvbWlzc291cmktbG92ZXMtY29tcGFueS0yMDE0LXRvdXJuYW1lbnQtcHJldmlldy1tZW5zJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnTm92LiA4dGgtOXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0Zsb3JpZGEgV2FybXVwJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9XYXJtLVVwLUEtRmxvcmlkYS1BZmZhaXItMjAxNScsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0ZlYi4gMTN0aC0xNXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnVGFtcGEsIEZMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMTN0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0NlbnRleCBJbnZpdGUnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0NlbnRleC1JbnZpdGUtMjAxNScsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ01hcmNoIDE0dGgtMTV0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ0F1c3RpbiwgVFgnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxN3RoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnRWFzdGVybnMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0Vhc3Rlcm5zLTIwMTUnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdNYXJjaCAyN3RoLTI5dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdOb3J0aCBNeXJ0bGUgQmVhY2gsIFNDJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMTd0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0lsbGlub2lzIENvbmZlcmVuY2VzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9JbGxpbm9pcy1ELUktQ29sbGVnZS1NZW5zLUNDLTIwMTUnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdBcHJpbCAxMXRoLTEydGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSYW50b3VsLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzJuZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0dyZWF0IExha2VzIFJlZ2lvbmFscycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvR3JlYXQtTGFrZXMtRC1JLUNvbGxlZ2UtTWVucy1SZWdpb25hbHMtMjAxNScsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0FwcmlsIDI1dGgtMjZ0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1JvY2tmb3JkLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzFzdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0QtSSBOYXRpb25hbCBDaGFtcGlvbnNoaXBzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9VU0EtVWx0aW1hdGUtRC1JLUNvbGxlZ2UtQ2hhbXBpb25zaGlwcy0yMDE1JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnTWF5IDIybmQtMjV0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ01pbHdhdWtlZSwgV0knLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxM3RoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTQsXG4gICAgICAgIHRvdXJuYW1lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdCb2lsZXIgQnJlYWthd2F5JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMzQyMicsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ09jdC4gNXRoLTZ0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1dlc3QgTGFmYXlldHRlLCBJTicsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnSWxsaW5vaXMgSW52aXRlJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMzM1MCcsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ09jdC4gMTJ0aC0xM3RoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnUmFudG91bCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ01pY2hpZ2FuIFJvdW5kIFJvYmluJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnT2N0LiAyMHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnQW5uIEFyYm9yLCBNSScsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnR2xvcnkgRGF5cycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTM0OTknLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdPY3QuIDI2dGgtMjd0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1JvY2tmb3JkLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJy0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnTWlzc291cmkgTG92ZXMgQ29tcGFueScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTQwMTcnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdOb3YuIDl0aC0xMHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMTN0aCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0NhdCBGaWdodCcsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvQ2F0LUZpZ2h0JyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnRmViLiAyMm5kLTIzcmQnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdMZXhpbmd0b24sIEtZJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMXN0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnRWFzdGVybnMnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vcGxheS51c2F1bHRpbWF0ZS5vcmcvZXZlbnRzL0Vhc3Rlcm5zLWFuZC1ESUlJLUVhc3Rlcm5zJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnTWFyY2ggMjJuZC0yM3JkJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnTGl0dGxlIFJpdmVyLCBTQycsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzEzdGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdJbGxpbm9pcyBDb25mZXJlbmNlcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy9ldmVudHMvSWxsaW5vaXMtRC1JLUNvbGxlZ2UtTWVucy1DQycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0FwcmlsIDEydGgtMTN0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1JhbnRvdWwsIElMJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnMXN0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnR3JlYXQgTGFrZXMgUmVnaW9uYWxzJyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy9HcmVhdC1MYWtlcy1ELUktQ29sbGVnZS1NZW5zLVJlZ2lvbmFscycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ0FwcmlsIDI2dGgtMjd0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ1JvY2tmb3JkLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzV0aCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEzLFxuICAgICAgICB0b3VybmFtZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdGYWxsJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnQm9pbGVyIEJyZWFrYXdheScsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3JlczIwMTIvI2NvbGxlZ2Utb3Blbi90b3VybmFtZW50LzExNDMyJyxcbiAgICAgICAgICAgICAgICB3aGVuOiAgICAgICAnU2VwdC4gMjJuZC0yM3JkJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnV2VzdCBMYWZheWV0dGUsIElOJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ0ZhbGwnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdJbGxpbm9pcyBJbnZpdGUnLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMyMDEyLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMTQ3NicsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ09jdC4gMTN0aC0xNHRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnUmFudG91bCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICctJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnRmFsbCcsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ01pc3NvdXJpIExvdmVzIENvbXBhbnknLFxuICAgICAgICAgICAgICAgIG5hbWVMaW5rOiAgICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMyMDEyLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMTY1NycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ05vdi4gMTB0aC0xMXRoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnQ29sdW1iaWEsIE1PJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6ICAgICAnLSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0h1Y2sgRmlubicsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTIxMTUnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdNYXJjaCA5dGgtMTB0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ0NoZXN0ZXJmaWVsZCwgTU8nLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxM3RoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWFzb246ICAgICAnU3ByaW5nJyxcbiAgICAgICAgICAgICAgICBuYW1lTGFiZWw6ICAnQ2VudGV4JyxcbiAgICAgICAgICAgICAgICBuYW1lTGluazogICAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzLyNjb2xsZWdlLW9wZW4vdG91cm5hbWVudC8xMjcwNycsXG4gICAgICAgICAgICAgICAgd2hlbjogICAgICAgJ01hcmNoIDE2dGgtMTd0aCcsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICAgJ0F1c3RpbiwgVFgnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICc0dGgnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdJbGxpbm9pcyBDb25mZXJlbmNlcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTI2MDQnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdBcHJpbCAxM3RoLTE0dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSYW50b3VsLCBJTCcsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiAgICAgJzFzdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2Vhc29uOiAgICAgJ1NwcmluZycsXG4gICAgICAgICAgICAgICAgbmFtZUxhYmVsOiAgJ0dyZWF0IExha2VzIFJlZ2lvbmFscycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTI2NjcnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdBcHJpbCAyN3RoLTI4dGgnLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAgICdSb2NrZm9yZCwgSUwnLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxc3QnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlYXNvbjogICAgICdTcHJpbmcnLFxuICAgICAgICAgICAgICAgIG5hbWVMYWJlbDogICdELUkgTmF0aW9uYWwgQ2hhbXBpb25zaGlwcycsXG4gICAgICAgICAgICAgICAgbmFtZUxpbms6ICAgJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RvdXJuYW1lbnQvMTI2ODYnLFxuICAgICAgICAgICAgICAgIHdoZW46ICAgICAgICdNYXkgMjR0aC0yN3RoJyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogICAnTWFkaXNvbiwgV0knLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogICAgICcxN3RoJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxuXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy9kYXRhL3RvdXJuYW1lbnRzLmRhdGEudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGgxIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPlRvdXJuYW1lbnRzPC9oMT5cXG48ZGl2IGNsYXNzPVxcXCJ1aSBzZWNvbmRhcnkgcG9pbnRpbmcgbWVudVxcXCI+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvdG91cm5hbWVudHMvMjAxM1xcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTN9XFxcIj4yMDEzPC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiaXRlbVxcXCIgcm91dGVyTGluaz1cXFwiL3RvdXJuYW1lbnRzLzIwMTRcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDE0fVxcXCI+MjAxNDwvYT5cXG4gICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIHJvdXRlckxpbms9XFxcIi90b3VybmFtZW50cy8yMDE1XFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogeWVhciA9PT0gMjAxNX1cXFwiPjIwMTU8L2E+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvdG91cm5hbWVudHMvMjAxNlxcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTZ9XFxcIj4yMDE2PC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiaXRlbVxcXCIgcm91dGVyTGluaz1cXFwiL3RvdXJuYW1lbnRzLzIwMTdcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDE3fVxcXCI+MjAxNzwvYT5cXG48L2Rpdj5cXG48bmctY29udGFpbmVyICpuZ0Zvcj1cXFwibGV0IHRvdXJuYW1lbnRZZWFyIG9mIHRvdXJuYW1lbnREYXRhXFxcIj5cXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cXFwidG91cm5hbWVudFllYXIueWVhciA9PT0geWVhclxcXCI+XFxuICAgICAgICA8dGFibGUgY2xhc3M9XFxcInVpIGNlbGxlZCB0YWJsZVxcXCIgKm5nSWY9XFxcInRvdXJuYW1lbnREYXRhXFxcIj5cXG4gICAgICAgICAgICA8dGhlYWQ+XFxuICAgICAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgICAgICAgIDx0aD5TZWFzb248L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPk5hbWU8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPldoZW48L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPkxvY2F0aW9uPC90aD5cXG4gICAgICAgICAgICAgICAgICAgIDx0aD5SZXN1bHQ8L3RoPlxcbiAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgdG91cm5hbWVudCBvZiB0b3VybmFtZW50WWVhci50b3VybmFtZW50c1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3t0b3VybmFtZW50LnNlYXNvbn19PC90ZD5cXG4gICAgICAgICAgICAgICAgICAgIDx0ZD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tT25seSByZW5kZXIgYSBsaW5rIGlmIHRoZXJlIGlzIG9uZSBwcm92aWRlZCBpbiB0aGUgZGF0YSwgb3RoZXJ3aXNlIGp1c3QgcmVuZGVyIHRoZSB0ZXh0LS0+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgKm5nSWY9XFxcInRvdXJuYW1lbnQubmFtZUxpbmtcXFwiIGhyZWY9XFxcInt7dG91cm5hbWVudC5uYW1lTGlua319XFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+e3t0b3VybmFtZW50Lm5hbWVMYWJlbH19PC9hPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XFxcIiF0b3VybmFtZW50Lm5hbWVMaW5rXFxcIj57e3RvdXJuYW1lbnQubmFtZUxhYmVsfX08L25nLWNvbnRhaW5lcj5cXG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3t0b3VybmFtZW50LndoZW59fTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3t0b3VybmFtZW50LmxvY2F0aW9ufX08L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7dG91cm5hbWVudC5yZXN1bHR9fTwvdGQ+XFxuICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgIDwvdGFibGU+XFxuICAgIDwvbmctY29udGFpbmVyPlxcbjwvbmctY29udGFpbmVyPlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC90ZWFtL3RvdXJuYW1lbnRzL3RvdXJuYW1lbnRzLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi90b3VybmFtZW50cy5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvdGVhbS90b3VybmFtZW50cy90b3VybmFtZW50cy5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSB9IGZyb20gXCJAYW5ndWxhci9yb3V0ZXJcIjtcblxuaW1wb3J0IHsgUm9zdGVyWWVhciB9IGZyb20gXCIuL21vZGVsL3Jvc3Rlci15ZWFyLm1vZGVsXCI7XG5pbXBvcnQgeyBST1NURVJfREFUQSB9IGZyb20gXCIuL2RhdGEvcm9zdGVycy5kYXRhXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncm9zdGVyJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9yb3N0ZXIuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL3Jvc3Rlci5jb21wb25lbnQubGVzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIFJvc3RlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvLyBSb3N0ZXIgZGF0YSB0byBpbmplY3QgaW50byBvdXIgdGVtcGxhdGVcbiAgICBwcml2YXRlIHJvc3RlckRhdGE6IFJvc3RlclllYXJbXSA9IFJPU1RFUl9EQVRBO1xuICAgIC8vIFN1YnNjcmlwdGlvbiB0byBvdXIgcm91dGUgcGFyYW1ldGVycyAocm9zdGVyIHllYXIpXG4gICAgcHJpdmF0ZSByb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbjogYW55O1xuICAgIC8vIEN1cnJlbnQgcm9zdGVyIHllYXJcbiAgICBwcml2YXRlIHllYXI6IG51bWJlcjtcblxuICAgIC8vIEluamVjdCB0aGUgQWN0aXZhdGVkUm91dGUgaW50byBvdXIgY29tcG9uZW50XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZTogQWN0aXZhdGVkUm91dGUpIHt9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHJvc3RlciB5ZWFyKS5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5yb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbiA9IHRoaXMucm91dGUucGFyYW1zLnN1YnNjcmliZShwYXJhbXMgPT4ge1xuICAgICAgICAgICAgLy8gKCspIGNvbnZlcnRzIHN0cmluZyAneWVhcicgdG8gYSBudW1iZXJcbiAgICAgICAgICAgIHRoaXMueWVhciA9ICtwYXJhbXNbJ3llYXInXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHJvc3RlciB5ZWFyKS5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9yb3N0ZXIuY29tcG9uZW50LnRzIiwiaW1wb3J0IHsgUm9zdGVyWWVhciB9IGZyb20gXCIuLi9tb2RlbC9yb3N0ZXIteWVhci5tb2RlbFwiO1xuXG5leHBvcnQgY29uc3QgUk9TVEVSX0RBVEE6IFJvc3RlclllYXJbXSA9IFtcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTcsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAxNy5qcGcnLFxuICAgICAgICBwbGF5ZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6IGBCZW4gJ0JlZWYnIFNhYm91cmluYCxcbiAgICAgICAgICAgICAgICB5ZWFyOiAnU29waG9tb3JlJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAxNi5qcGcnLFxuICAgICAgICBwbGF5ZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdOaWNrIFByb3pvcm92c2t5KicsXG4gICAgICAgICAgICAgICAgeWVhcjogJ1NlbmlvcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE1LFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTUuanBnJyxcbiAgICAgICAgcGxheWVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bWJlcjogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTmljayBQcm96b3JvdnNreSonLFxuICAgICAgICAgICAgICAgIHllYXI6ICdKdW5pb3InXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9XG5dO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9kYXRhL3Jvc3RlcnMuZGF0YS50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+Um9zdGVyPC9oMT5cXG48ZGl2IGNsYXNzPVxcXCJ1aSBzZWNvbmRhcnkgcG9pbnRpbmcgbWVudVxcXCI+XFxuICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiByb3V0ZXJMaW5rPVxcXCIvcm9zdGVyLzIwMTVcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiB5ZWFyID09PSAyMDE1fVxcXCI+MjAxNTwvYT5cXG4gICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIHJvdXRlckxpbms9XFxcIi9yb3N0ZXIvMjAxNlxcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IHllYXIgPT09IDIwMTZ9XFxcIj4yMDE2PC9hPlxcbiAgICA8YSBjbGFzcz1cXFwiaXRlbVxcXCIgcm91dGVyTGluaz1cXFwiL3Jvc3Rlci8yMDE3XFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogeWVhciA9PT0gMjAxN31cXFwiPjIwMTc8L2E+XFxuPC9kaXY+XFxuPG5nLWNvbnRhaW5lciAqbmdGb3I9XFxcImxldCByb3N0ZXJZZWFyIG9mIHJvc3RlckRhdGFcXFwiPlxcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVxcXCJyb3N0ZXJZZWFyLnllYXIgPT09IHllYXJcXFwiPlxcbiAgICAgICAgPGltZyBzcmM9XFxcInt7cm9zdGVyWWVhci5pbWFnZVBhdGh9fVxcXCIvPlxcbiAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJ1aSBjZWxsZWQgdGFibGVcXFwiPlxcbiAgICAgICAgICAgIDx0aGVhZD5cXG4gICAgICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPiM8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPk5hbWU8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgPHRoPlllYXI8L3RoPlxcbiAgICAgICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgcGxheWVyIG9mIHJvc3RlclllYXIucGxheWVyc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3twbGF5ZXIubnVtYmVyfX08L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgPHRkPnt7cGxheWVyLm5hbWV9fTwvdGQ+XFxuICAgICAgICAgICAgICAgICAgICA8dGQ+e3twbGF5ZXIueWVhcn19PC90ZD5cXG4gICAgICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICA8L3Rib2R5PlxcbiAgICAgICAgPC90YWJsZT5cXG4gICAgICAgIDxwPigqKSBpbmRpY2F0ZXMgY2FwdGFpbiBmb3IgdGhhdCB5ZWFyPC9wPlxcbiAgICA8L25nLWNvbnRhaW5lcj5cXG48L25nLWNvbnRhaW5lcj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvdGVhbS9yb3N0ZXIvcm9zdGVyLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9yb3N0ZXIuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vcm9zdGVyL3Jvc3Rlci5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImltZyB7XFxuICB3aWR0aDogNzUlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzAwMDA0RDtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjg1NzE0MjllbTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC90ZWFtL3Jvc3Rlci9yb3N0ZXIuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIFZpZXdDaGlsZCwgRWxlbWVudFJlZiwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBTcHJlYWRzaGVldFNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vc2VydmljZS9nb29nbGUtc3ByZWFkc2hlZXQuc2VydmljZVwiO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2Fic2VudCcsXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYWJzZW50LmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9hYnNlbnQuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBBYnNlbnRDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIC8vIEFQSSB1cmwgZm9yIG91ciBwZXJzb25hbCBzZXJ2ZXJcbiAgICBwcml2YXRlIGdvb2dsZVNoZWV0c0FwaVVybCA9ICdodHRwczovL25pY2stcHJvei1nb29nbGUtc2hlZXQtYXBpLmhlcm9rdWFwcC5jb20vc2hlZXRzLzExaWpySG95c2lJd3NGZkVnZ2JTTk05WThWdnpVNjVqZXVoUTN2a1Y1Rkd3L3NoZWV0SW5kZXgvMS9yb3dzLyc7XG4gICAgLy8gQVBJIHVybCBmb3Igb3VyIGJhY2t1cCBzZXJ2ZXIgKHNoZWV0c3UgQVBJKVxuICAgIC8vIHByaXZhdGUgZ29vZ2xlU2hlZXRzQmFja3VwQXBpVXJsID0gJ2h0dHBzOi8vc2hlZXRzdS5jb20vYXBpcy92MS4wLzdhMDMwYWU2MGI3ZCc7XG4gICAgcHJpdmF0ZSBnb29nbGVTaGVldHNCYWNrdXBBcGlVcmwgPSAnJztcblxuICAgIC8vIEVycm9yIG1lc3NhZ2VzXG4gICAgcHJpdmF0ZSB2YWxpZGF0aW9uRXJyb3JzOiBzdHJpbmcgPSAnUGxlYXNlIGRvIG5vdCBsZWF2ZSBhbnkgcmVxdWlyZWQgZmllbGRzIGJsYW5rLic7XG4gICAgcHJpdmF0ZSBzdWJtaXNzaW9uRXJyb3I6IHN0cmluZyA9ICdDb3VsZCBub3Qgc3VibWl0IHRoZSBmb3JtICBkdWUgdG8gYSBzZXJ2ZXIgZXJyb3IuIFBsZWFzZSB0cnkgYWdhaW4gc29vbiBvciBjb250YWN0IHRoZSB3ZWIgYWRtaW5zLic7XG5cbiAgICAvLyBGaXJzdCBuYW1lIGlucHV0XG4gICAgcHJpdmF0ZSBmaXJzdE5hbWU6IHN0cmluZztcbiAgICAvLyBMYXN0IG5hbWUgaW5wdXRcbiAgICBwcml2YXRlIGxhc3ROYW1lOiBzdHJpbmc7XG4gICAgLy8gUmVhc29uIGlucHV0XG4gICAgcHJpdmF0ZSByZWFzb246IHN0cmluZztcbiAgICAvLyBUaW1lIGlucHV0XG4gICAgcHJpdmF0ZSB0aW1lOiBzdHJpbmc7XG4gICAgLy8gRGF5IGlucHV0XG4gICAgcHJpdmF0ZSBkYXk6IG51bWJlcjtcbiAgICAvLyBNb250aCBpbnB1dFxuICAgIHByaXZhdGUgbW9udGg6IG51bWJlcjtcbiAgICAvLyBCb29sZWFuIGluZGljYXRpbmcgaWYgb3VyIGZvcm0gaXMgaW4gdGhlIHByb2Nlc3Mgb2Ygc3VibWl0dGluZyAodG8gc2hvdyBvdXIgbG9hZGluZyBpY29uKVxuICAgIHByaXZhdGUgZm9ybUlzU3VibWl0dGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIC8vIEJvb2xlYW4gaW5kaWNhdGluZyBpZiBvdXIgZm9ybSB3YXMgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZCAodG8gc2hvdyBvdXIgc3VjY2VzcyBtZXNzYWdlKVxuICAgIHByaXZhdGUgc3VibWl0U3VjY2VzczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIC8vIEZvcm0gZXJyb3JzIG91dHB1dFxuICAgIHByaXZhdGUgZm9ybUVycm9yczogc3RyaW5nO1xuXG4gICAgLy8gTW9udGggZHJvcGRvd25cbiAgICBAVmlld0NoaWxkKCdtb250aERyb3Bkb3duJylcbiAgICBwcml2YXRlIG1vbnRoRHJvcGRvd246IEVsZW1lbnRSZWY7XG5cbiAgICAvLyBDb25zdHJ1Y3RvciB3aXRoIG91ciBodHRwIHNlcnZpY2UgaW5qZWN0ZWRcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNwcmVhZHNoZWV0U2VydmljZTogU3ByZWFkc2hlZXRTZXJ2aWNlKSB7fVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICAkKHRoaXMubW9udGhEcm9wZG93bi5uYXRpdmVFbGVtZW50KS5kcm9wZG93bigpO1xuICAgIH1cblxuICAgIGhhbmRsZVN1Ym1pdChldmVudDogYW55LCBtb250aElucHV0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5tb250aCA9IG1vbnRoSW5wdXQ7XG4gICAgICAgIHRoaXMuc3VibWl0U3VjY2VzcyA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCF0aGlzLmZvcm1Jc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUVycm9ycyA9IHRoaXMudmFsaWRhdGlvbkVycm9ycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUlzU3VibWl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1FcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgXCJUaW1lc3RhbXBcIjogZGF0ZS50b0xvY2FsZVN0cmluZygpLFxuICAgICAgICAgICAgICAgIFwiRmlyc3QgTmFtZVwiOiB0aGlzLmZpcnN0TmFtZSxcbiAgICAgICAgICAgICAgICBcIkxhc3QgTmFtZVwiOiB0aGlzLmxhc3ROYW1lLFxuICAgICAgICAgICAgICAgIFwiVGltZVwiOiB0aGlzLnRpbWUsXG4gICAgICAgICAgICAgICAgXCJEYXRlXCI6IGAke3RoaXMubW9udGh9LyR7dGhpcy5kYXl9YCxcbiAgICAgICAgICAgICAgICBcIlJlYXNvblwiOiB0aGlzLnJlYXNvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3VibWl0QWJzZW50Rm9ybShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1Ym1pdHMgb3VyIGZvcm0gdG8gdGhlIHNwcmVhZHNoZWV0IGJ5IGNhbGxpbmcgb3VyIHNlcnZpY2UgbWV0aG9kLlxuICAgICAqIE9uIHN1Y2Nlc3MsIHdlIHNob3cgb3VyIGNvbmZpcm1hdGlvbiBtb2RhbCBhbmQgcmVzZXQgb3VyIHJzdnAgbW9kYWwuXG4gICAgICogT24gZmFpbHVyZSwgd2UgaGlkZSBvdXIgc3VibWl0dGluZyBkaWFsb2cgYW5kIHNob3cgb3VyIHN1Ym1pc3Npb24gZXJyb3IgdG8gdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSAtIGRhdGEgdG8gc3VibWl0IHRvIG91ciBzcHJlYWRzaGVldFxuICAgICAqL1xuICAgIHByaXZhdGUgc3VibWl0QWJzZW50Rm9ybShkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zcHJlYWRzaGVldFNlcnZpY2UucG9zdFJvd1RvU3ByZWFkc2hlZXQodGhpcy5nb29nbGVTaGVldHNBcGlVcmwsIHRoaXMuZ29vZ2xlU2hlZXRzQmFja3VwQXBpVXJsLCBkYXRhKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGb3JtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJtaXRTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUlzU3VibWl0dGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUVycm9ycyA9IHRoaXMuc3VibWlzc2lvbkVycm9yO1xuICAgICAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgb3VyIGlucHV0IGZpZWxkcywgZXJyb3JzLCBhbmQgcmVzZXRzIG91ciBmb3JtIGlzIHN1Ym1pdHRpbmcgZmxhZy5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlc2V0Rm9ybSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5maXJzdE5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3ROYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFzb24gPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmRheSA9IG51bGw7XG4gICAgICAgIHRoaXMubW9udGggPSBudWxsO1xuICAgICAgICB0aGlzLmZvcm1FcnJvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcm1Jc1N1Ym1pdHRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGcm9udC1lbmQgdmFsaWRhdGlvbiBmb3Igb3VyIGZvcm0uXG4gICAgICogT3VyIGZvcm0gaXMgdmFsaWQgb25seSBpZiBhbGwgZmllbGRzIGFyZSBwb3B1bGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBmb3JtIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGZvcm1Jc1ZhbGlkKCk6IGJvb2xlYW4ge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0TmFtZSAhPSBudWxsICAgJiYgdGhpcy5maXJzdE5hbWUgIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMubGFzdE5hbWUgIT0gbnVsbCAgICAmJiB0aGlzLmxhc3ROYW1lICE9ICcnXG4gICAgICAgICAgICAmJiB0aGlzLnJlYXNvbiAhPSBudWxsICAgICAgJiYgdGhpcy5yZWFzb24gIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMudGltZSAhPSBudWxsICAgICAgICAmJiB0aGlzLnRpbWUgIT0gJydcbiAgICAgICAgICAgICYmIHRoaXMubW9udGggIT0gbnVsbCAgICAgICAmJiB0aGlzLm1vbnRoID4gMFxuICAgICAgICAgICAgJiYgdGhpcy5kYXkgIT0gbnVsbDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+UHJhY3RpY2UgQWJzZW5jZSBGb3JtPC9oMT5cXG48ZGl2ICpuZ0lmPVxcXCJmb3JtSXNTdWJtaXR0aW5nXFxcIiBjbGFzcz1cXFwidWkgYWN0aXZlIGludmVydGVkIGRpbW1lclxcXCI+PGRpdiBjbGFzcz1cXFwidWkgdGV4dCBsb2FkZXJcXFwiPlN1Ym1pdHRpbmc8L2Rpdj48L2Rpdj5cXG48Zm9ybSBjbGFzcz1cXFwidWkgZm9ybVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInR3byBmaWVsZHNcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgIDxsYWJlbD5GaXJzdCBOYW1lIDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwiZmlyc3ROYW1lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJmaXJzdC1uYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiRmlyc3QgTmFtZVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICA8bGFiZWw+TGFzdCBOYW1lIDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwibGFzdE5hbWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcImxhc3QtbmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIkxhc3QgTmFtZVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgIDxsYWJlbD5SZWFzb24gZm9yIG1pc3Npbmcgb3IgYmVpbmcgbGF0ZSB0byBwcmFjdGljZSA8c3BhbiBjbGFzcz1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+PC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwicmVhc29uXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJyZWFzb25cXFwiIHBsYWNlaG9sZGVyPVxcXCJCZXR0ZXIgYmUgZ29vZC4uLlxcXCI+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICA8bGFiZWw+RnJvbSB3aGF0IHRpbWUgdG8gd2hhdCB0aW1lIGlzIHlvdXIgY29uZmxpY3Q/IDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVxcXCJ0aW1lXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJ0aW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiVGltZVxcXCI+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0d28gZmllbGRzXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD5QcmFjdGljZSBkYXRlIDxzcGFuIGNsYXNzPVxcXCJyZXF1aXJlZFxcXCI+Kjwvc3Bhbj48L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcImRheVxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJkYXlcXFwiIHBsYWNlaG9sZGVyPVxcXCJEYXkgKDAtMzEpXFxcIj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxsYWJlbD4mbmJzcDs8L2xhYmVsPlxcbiAgICAgICAgICAgICAgICA8ZGl2ICNtb250aERyb3Bkb3duIGNsYXNzPVxcXCJ1aSBzZWFyY2ggc2VsZWN0aW9uIGRyb3Bkb3duXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCAjbW9udGhJbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcIm1vbnRoXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkZWZhdWx0IHRleHRcXFwiPk1vbnRoPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBkYXRhLXZhbHVlPVxcXCIwMVxcXCI+SmFudWFyeTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjAyXFxcIj5GZWJydWFyeTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjAzXFxcIj5NYXJjaDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjA0XFxcIj5BcHJpbDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjA1XFxcIj5NYXk8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBkYXRhLXZhbHVlPVxcXCIwNlxcXCI+SnVuZTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjA3XFxcIj5KdWx5PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgZGF0YS12YWx1ZT1cXFwiMDhcXFwiPkF1Z3VzdDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjA5XFxcIj5TZXB0ZW1iZXI8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBkYXRhLXZhbHVlPVxcXCIxMFxcXCI+T2N0b2JlcjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjExXFxcIj5Ob3ZlbWJlcjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIGRhdGEtdmFsdWU9XFxcIjEyXFxcIj5EZWNlbWJlcjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8YnV0dG9uIChjbGljayk9XFxcImhhbmRsZVN1Ym1pdCgkZXZlbnQsIG1vbnRoSW5wdXQudmFsdWUpXFxcIiBjbGFzcz1cXFwidWkgYnV0dG9uXFxcIiB0eXBlPVxcXCJzdWJtaXRcXFwiPlN1Ym1pdDwvYnV0dG9uPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ1aSBlcnJvciBtZXNzYWdlXFxcIiAqbmdJZj1cXFwiZm9ybUVycm9yc1xcXCI+XFxuICAgICAgICA8cD57e2Zvcm1FcnJvcnN9fTwvcD5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInVpIHN1Y2Nlc3MgbWVzc2FnZVxcXCIgKm5nSWY9XFxcInN1Ym1pdFN1Y2Nlc3NcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5Gb3JtIFN1Ym1pdHRlZDwvZGl2PlxcbiAgICAgICAgPHA+VGhlIGZvcm0gd2FzIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQuIFN0b3AgbWlzc2luZyBwcmFjdGljZS48L3A+XFxuICAgIDwvZGl2PlxcbjwvZm9ybT5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9hYnNlbnQuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3RlYW0vYWJzZW50L2Fic2VudC5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImxhYmVsIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbi51aS5mb3JtIHtcXG4gIHdpZHRoOiA4MCU7XFxuICBtYXJnaW46IDAgYXV0bztcXG59XFxuLnVpLmZvcm0gLnVpLmVycm9yLm1lc3NhZ2UsXFxuLnVpLmZvcm0gLnVpLnN1Y2Nlc3MubWVzc2FnZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLnVpLmZvcm0gLnVpLmVycm9yLm1lc3NhZ2UgcCxcXG4udWkuZm9ybSAudWkuc3VjY2Vzcy5tZXNzYWdlIHAge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG4udWkuc2VsZWN0aW9uLmFjdGl2ZS5kcm9wZG93biAubWVudSxcXG4udWkuc2VhcmNoLnNlbGVjdGlvbi5kcm9wZG93bi5hY3RpdmUudmlzaWJsZSxcXG4udWkuc2VsZWN0aW9uLmFjdGl2ZS5kcm9wZG93bjpob3ZlciB7XFxuICBib3JkZXItY29sb3I6ICNmZjYyMjY7XFxufVxcbi51aS5kcm9wZG93biB7XFxuICBtaW4td2lkdGg6IGluaGVyaXQ7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gUm91dGUgQ29uZmlndXJhdGlvblxuaW1wb3J0IHsgUm91dGVzIH0gZnJvbSBcIkBhbmd1bGFyL3JvdXRlclwiO1xuaW1wb3J0IHsgSG9tZUNvbXBvbmVudCB9IGZyb20gXCIuL2hvbWUvaG9tZS5jb21wb25lbnRcIjtcbmltcG9ydCB7IEFib3V0Q29tcG9uZW50IH0gZnJvbSBcIi4vYWJvdXQvYWJvdXQuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBQcm9zcGVjdGl2ZVBsYXllcnNDb21wb25lbnQgfSBmcm9tIFwiLi9wcm9zcGVjdGl2ZS1wbGF5ZXJzL3Byb3NwZWN0aXZlLXBsYXllcnMuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBDb250YWN0Q29tcG9uZW50IH0gZnJvbSBcIi4vY29udGFjdC9jb250YWN0LmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUHJhY3RpY2VDb21wb25lbnQgfSBmcm9tIFwiLi90ZWFtL3ByYWN0aWNlL3ByYWN0aWNlLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgVG91cm5hbWVudHNDb21wb25lbnQgfSBmcm9tIFwiLi90ZWFtL3RvdXJuYW1lbnRzL3RvdXJuYW1lbnRzLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUm9zdGVyQ29tcG9uZW50IH0gZnJvbSBcIi4vdGVhbS9yb3N0ZXIvcm9zdGVyLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgQWJzZW50Q29tcG9uZW50IH0gZnJvbSBcIi4vdGVhbS9hYnNlbnQvYWJzZW50LmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgVGVhbUhpc3RvcnlDb21wb25lbnQgfSBmcm9tIFwiLi9oaXN0b3J5L3RlYW0taGlzdG9yeS90ZWFtLWhpc3RvcnkuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBBd2FyZHNDb21wb25lbnQgfSBmcm9tIFwiLi9oaXN0b3J5L2F3YXJkcy9hd2FyZHMuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBSZXN1bHRzQ29tcG9uZW50IH0gZnJvbSBcIi4vaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50XCI7XG5cbmV4cG9ydCBjb25zdCBST1VURVM6IFJvdXRlcyA9IFtcbiAgICB7cGF0aDogJycsICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBIb21lQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJ3ByYWN0aWNlJywgICAgICAgICAgY29tcG9uZW50OiBQcmFjdGljZUNvbXBvbmVudH0sXG4gICAge3BhdGg6ICdhYnNlbnQnLCAgICAgICAgICAgIGNvbXBvbmVudDogQWJzZW50Q29tcG9uZW50fSxcbiAgICB7cGF0aDogJ2NvbnRhY3QnLCAgICAgICAgICAgY29tcG9uZW50OiBDb250YWN0Q29tcG9uZW50fSxcbiAgICB7cGF0aDogJ2hvbWUnLCAgICAgICAgICAgICAgY29tcG9uZW50OiBIb21lQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJ2Fib3V0JywgICAgICAgICAgICAgY29tcG9uZW50OiBBYm91dENvbXBvbmVudH0sXG4gICAge3BhdGg6ICdwcm9zcGVjdHMnLCAgICAgICAgIGNvbXBvbmVudDogUHJvc3BlY3RpdmVQbGF5ZXJzQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJ3RvdXJuYW1lbnRzLzp5ZWFyJywgY29tcG9uZW50OiBUb3VybmFtZW50c0NvbXBvbmVudH0sXG4gICAge3BhdGg6ICdyb3N0ZXIvOnllYXInLCAgICAgIGNvbXBvbmVudDogUm9zdGVyQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJ2hpc3RvcnkvOnllYXInLCAgICAgY29tcG9uZW50OiBUZWFtSGlzdG9yeUNvbXBvbmVudH0sXG4gICAge3BhdGg6ICdhd2FyZHMnLCAgICAgICAgICAgIGNvbXBvbmVudDogQXdhcmRzQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJ3Jlc3VsdHMnLCAgICAgICAgICAgY29tcG9uZW50OiBSZXN1bHRzQ29tcG9uZW50fSxcbiAgICB7cGF0aDogJyoqJywgICAgICAgICAgICAgICAgY29tcG9uZW50OiBIb21lQ29tcG9uZW50fSxcbl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2FwcC5yb3V0ZXMudHMiLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIE9uSW5pdCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEhpc3RvcnlZZWFyIH0gZnJvbSBcIi4vbW9kZWwvaGlzdG9yeS15ZWFyLm1vZGVsXCI7XG5pbXBvcnQgeyBISVNUT1JZX0RBVEEgfSBmcm9tIFwiLi9kYXRhL2hpc3RvcnkteWVhci5kYXRhXCI7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSB9IGZyb20gXCJAYW5ndWxhci9yb3V0ZXJcIjtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd0ZWFtLWhpc3RvcnknLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3RlYW0taGlzdG9yeS5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5sZXNzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgVGVhbUhpc3RvcnlDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuXG4gICAgLy8gUmVzdWx0cyBkYXRhIHRvIGluamVjdCBpbnRvIG91ciB0ZW1wbGF0ZVxuICAgIHByaXZhdGUgaGlzdG9yeURhdGE6IEhpc3RvcnlZZWFyW10gPSBISVNUT1JZX0RBVEE7XG4gICAgLy8gU3Vic2NyaXB0aW9uIHRvIG91ciByb3V0ZSBwYXJhbWV0ZXJzICh0b3VybmFtZW50IHllYXIpXG4gICAgcHJpdmF0ZSByb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbjogYW55O1xuICAgIC8vIEN1cnJlbnQgdG91cm5hbWVudCB5ZWFyXG4gICAgcHJpdmF0ZSB5ZWFyOiBudW1iZXI7XG5cbiAgICAvLyBZZWFyIGRyb3Bkb3duc1xuICAgIEBWaWV3Q2hpbGQoJzE5OTRkcm9wZG93bicpXG4gICAgcHJpdmF0ZSBmaXJzdERyb3Bkb3duOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJzIwMDBkcm9wZG93bicpXG4gICAgcHJpdmF0ZSBzZWNvbmREcm9wZG93bjogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCcyMDEwZHJvcGRvd24nKVxuICAgIHByaXZhdGUgdGhpcmREcm9wZG93bjogRWxlbWVudFJlZjtcblxuICAgIC8vIEluamVjdCB0aGUgQWN0aXZhdGVkUm91dGUgaW50byBvdXIgY29tcG9uZW50XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZTogQWN0aXZhdGVkUm91dGUpIHt9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgICQodGhpcy5maXJzdERyb3Bkb3duLm5hdGl2ZUVsZW1lbnQpLmRyb3Bkb3duKHt9KTtcbiAgICAgICAgJCh0aGlzLnNlY29uZERyb3Bkb3duLm5hdGl2ZUVsZW1lbnQpLmRyb3Bkb3duKHt9KTtcbiAgICAgICAgJCh0aGlzLnRoaXJkRHJvcGRvd24ubmF0aXZlRWxlbWVudCkuZHJvcGRvd24oe30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBvdXIgcm91dGUgcGFyYW1ldGVycyAodG91cm5hbWVudCB5ZWFyKS5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5yb3V0ZVBhcmFtc1N1YnNjcmlwdGlvbiA9IHRoaXMucm91dGUucGFyYW1zLnN1YnNjcmliZShwYXJhbXMgPT4ge1xuICAgICAgICAgICAgLy8gKCspIGNvbnZlcnRzIHN0cmluZyAneWVhcicgdG8gYSBudW1iZXJcbiAgICAgICAgICAgIHRoaXMueWVhciA9ICtwYXJhbXNbJ3llYXInXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgdG8gb3VyIHJvdXRlIHBhcmFtZXRlcnMgKHRvdXJuYW1lbnQgeWVhcikuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucm91dGVQYXJhbXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC50cyIsImltcG9ydCB7IEhpc3RvcnlZZWFyIH0gZnJvbSBcIi4uL21vZGVsL2hpc3RvcnkteWVhci5tb2RlbFwiO1xuXG5leHBvcnQgY29uc3QgSElTVE9SWV9EQVRBOiBIaXN0b3J5WWVhcltdID0gW1xuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNyxcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDE3LmpwZycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPjwvcD5cbiAgICAgICAgYFxuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE2LFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMTYuanBnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+SWxsaW5vaXMgVWx0aW1hdGUgY2FtZSBpbnRvIHRoZSAyMDE2IHNlYXNvbiB3aXRoIGEgdGFzdGUgb2Ygc3VjY2VzcyBhbmQgYmlnIHNob2VzIHRvIGZpbGwuIFJldHVybmluZyBjYXB0YWluIE5pY2sgUHJvem9yb3Zza3kgYW5kIG5ldyBjYXB0YWlucyBQcmF5YWcgUGF0ZWwgYW5kIENocmlzIEJ1Y2h0YSB3ZXJlIHRhc2tlZCB3aXRoIHRoZSBkaWZmaWN1bHQgcHJvc3BlY3Qgb2YgcmVwbGFjaW5nIHRoZSAxMiBncmFkdWF0aW5nIHBsYXllcnMgYXMgd2VsbCBhcyBjb2FjaCBNYXR0IFN0dXBjYS4gQm9vbWxhbmQgY29hY2ggRXJpayBIdWVtaWxsZXIgYW5kIHJlY2VudCBhbHVtIE1hdHQgV2VzdCB3ZXJlIGFibGUgdG8gZmlsbCB0aGUgbGVhZGVyc2hpcCB2b2lkIGFzIHRoZSB0ZWFtIGxvb2tlZCB0byByZWxvYWQgZm9yIGFub3RoZXIgcnVuIGF0IE5hdGlvbmFscy48L3A+XG4gICAgICAgICAgICA8cD5UaGUgdHJ5b3V0cyBmb3IgdGhlIHRlYW0gd2VyZSB2ZXJ5IGNvbXBldGl0aXZlLCB3aXRoIHRoZSBiaWdnZXN0IGluY29taW5nIGNsYXNzIGluIHJlY2VudCBtZW1vcnkuIFRoZSBmaW5hbCByb3N0ZXIgaW5jbHVkZWQgNyByb29raWVzLCAxIGdyYWQgc3R1ZGVudCwgNSBmb3JtZXIgQm9vbWxhbmQgcGxheWVycywgYW5kIDEyIHJldHVybmVycy4gVGhlIG5ld2VzdCBpdGVyYXRpb24gb2YgSWxsaW5vaXMgVWx0aW1hdGUgdGVzdGVkIHRoZW1zZWx2ZXMgYXQgTWlzc291cmkgTG92ZXMgQ29tcGFueSwgYnV0IHJldHVybmVkIHdpdGggc2hvdWxkZXIgaW5qdXJpZXMgdG8gc2VuaW9ycyBOaWNrIFByb3pvcm92c2t5IGFuZCBBbGV4IEd1eSB0aGF0IHdvdWxkIGhhbXBlciB0aGVtIGZvciB0aGUgcmVzdCBvZiB0aGUgc2Vhc29uLjwvcD5cbiAgICAgICAgICAgIDxwPlRoaXMgc3ByaW5nIHNlYXNvbiBoYWQgdGhlIHRlYW0gaGVhZGluZyB0byBGbG9yaWRhLCBTb3V0aCBDYXJvbGluYSwgYW5kIE1pc3NvdXJpIGluIHNlYXJjaCBvZiBlbGl0ZSBjb21wZXRpdGlvbi48L3A+XG4gICAgICAgICAgICA8cD5NaWQgRmVicnVhcnkgaGFkIHRoZSB0ZWFtIGZseWluZyBzb3V0aCB0byBjb21wZXRlIGF0IFdhcm0gVXAuIFVuZm9ydHVuYXRlbHksIHRoZSB3ZWVrIHByaW9yIGhhZCBncmFkIHN0dWRlbnQgQ29keSBHcmF5IGJyZWFraW5nIGhpcyBoYW5kIGluIElyd2luIGFuZCBzZW5pb3IgV2lsc29uIFdhbmcgcHVsbGluZyBoaXMgaGFtc3RyaW5nIGluIHRoZSBBcm1vcnksIGJvdGggYmlnIGhhbmRsZXIgbG9zc2VzLiBPbiBTYXR1cmRheSwgdGhlIHRlYW0gc3RhcnRlZCB3aXRoIDEwLTEzIGFuZCAxMS0xMyBsb3NzZXMgdG8gVGV4YXMgYW5kIEZsb3JpZGEgU3RhdGUuIFRoZSB0aGlyZCBnYW1lIG9mIHRoZSBkYXkgd2FzIGFnYWluc3QgcGVyZW5uaWFsIHBvd2VyaG91c2UgUGl0dHNidXJnaC4gSWxsaW5vaXMgY2FtZSBvdXQgc2xvcHB5IGFuZCB3YXMgcHJlc3N1cmVkIGludG8gbWFraW5nIG1hbnkgZXJyb3JzLCByZXN1bHRpbmcgaW4gYSAxLTcgc2NvcmUgYXQgaGFsZiBhbmQgYW4gZW1iYXJyYXNzaW5nIDItMTIgbG9zcywgZmluaXNoaW5nIDAtNCBvbiB0aGUgZGF5IGFmdGVyIGFub3RoZXIgbG9zcyB0byBCWVUuIFNhdHVyZGF5IHN0YXJ0ZWQgb2ZmIGJldHRlciB3aXRoIGEgMTMtNSB3aW4gb3ZlciBob3N0IFNvdXRoIEZsb3JpZGEsIGJ1dCB3YXMgZm9sbG93ZWQgYnkgYmlnIGxvc3NlcyB0byBWaXJnaW5pYSBUZWNoIGFuZCBBdWJ1cm4uIElsbGlub2lzIGZpbmlzaGVkIHRoZSB0b3VybmFtZW50IDItNywgd2l0aCBhIHVuaXZlcnNlIGxvc3MgdG8gaW4gcmVnaW9uIHJpdmFsIE5vcnRod2VzdGVybiBhbmQgb25seSB3aW5zIGNvbWluZyBhZ2FpbnN0IFNvdXRoIEZsb3JpZGEuPC9wPlxuICAgICAgICAgICAgPHA+V2l0aCBtb3N0IG9mIHRoZSB0ZWFtIGZpbmFsbHkgaGVhbHRoeSwgdGhlIHRlYW0gbWFkZSB0aGUgdHJpcCB0byBFYXN0ZXJucyBmb3IgdGhlIHNlY29uZCB0b3VybmFtZW50IG9mIHRoZSBzZWFzb24uIFRoZSBmaXJzdCBnYW1lIG9mIHRoZSB0b3VybmFtZW50IHdhcyBhIHJlbWF0Y2ggYWdhaW5zdCBQaXR0c2J1cmdoLiBUaGlzIHRpbWUsIElsbGlub2lzIHdhcyBwcmVwYXJlZCBmb3IgdGhlIGludGVuc2l0eSBhbmQgd2FzIGFibGUgdG8gbWFrZSBpdCBhIGNsb3NlciBnYW1lLCBidXQgc3RpbGwgbG9zdCAxMi0xNS4gQW5vdGhlciByZW1hdGNoIGFnYWluc3QgVmlyZ2luaWEgVGVjaCBlbmRlZCBzaW1pbGFybHksIGxvc2luZyAxMS0xNCwgYW5kIHRoZSB0ZWFtIGVuZGVkIFNhdHVyZGF5IDAtNCwgd2l0aCBhIDEwLTE1IGxvc3MgdG8gVU5DIERhcmtzaWRlIGFuZCBhbiAxMS0xMyBsb3NzIHRvIHJlZ2lvbmFsIHJpdmFsIE1pY2hpZ2FuLiBPbiBhIHdldCwgY29sZCwgYW5kIHdpbmR5IFN1bmRheSwgSWxsaW5vaXMgd2FzIG5vdCBhYmxlIHRvIGNvbWUgb3V0IHdpdGggYW55IGZpcmUgYW5kIGxvc3QgYmFkbHkgdG8gSmFtZXMgTWFkaXNvbiBhbmQgQ29ubmVjdGljdXQsIGdvaW5nIDAtNiBvbiB0aGUgd2Vla2VuZC48L3A+XG4gICAgICAgICAgICA8cD5UaGUgZmluYWwgcmVndWxhciBzZWFzb24gdG91cm5hbWVudCBvZiB0aGUgeWVhciB3YXMgSHVjayBGaW5uIGFuZCB0aGUgYm95cyBmcm9tIElsbGlub2lzIGxvb2tlZCB0byBib3VuY2UgYmFjayBmcm9tIGEgc28gZmFyIHVuc3VjY2Vzc2Z1bCByZWd1bGFyIHNlYXNvbi4gV2l0aCBhIG1pbmRzZXQgb2YgaW1wcm92aW5nIGZvciB0aGUgc2VyaWVzIHRoZSBJbGxpbmkgY2FtZSBvdXQgd2l0aCBhIDctMCBsZWFkIGF0IGhhbGYgb24gSW5kaWFuYSBhbmQgY2xvc2VkIGl0IG91dCB3aXRoIGFuIDExLTQgd2luLiBEYXl0b24gd2FzIHRoZSBuZXh0IGdhbWUsIHdoaWNoIHdhcyBhIDEzLTQgd2luIGZvciB0aGUgSWxsaW5pIHdoaWNoIG1lYW50IHRoYXQgdGhleSB3b3VsZCBwbGF5IE1hcnlsYW5kIGZvciB0aGUgcG9vbC4gQW5rbGUgaW5qdXJpZXMgdG8gUHJheWFnIFBhdGVsIGFuZCBCZW4gRm9zdGVyIG1lYW50IHRoYXQgdGhlIE8gbGluZSB3YXMgcGxheWluZyB3aXRob3V0IHR3byBrZXkgY29udHJpYnV0b3JzLCBidXQgdGhlIHRlYW0gd2FzIGFibGUgdG8gdG91Z2ggb3V0IGEgMTQtMTEgd2luLCBzZXR0aW5nIHVwIGEgY3Jvc3NvdmVyIGdhbWUgYWdhaW5zdCBJbGxpbm9pcyBTdGF0ZS4gSW4gYSB2ZXJ5IHdpbmR5IGdhbWUsIElsbGlub2lzIHRyaXVtcGhlZCBvdmVyIHRoZWlyIGluIHN0YXRlIGNvbXBldGl0b3JzIGluIGEgMTAtNiB2aWN0b3J5LCBzZWN1cmluZyBhIHF1YXJ0ZXJmaW5hbHMgYmVydGguIFRoZSB0ZWFtIGNsb3NlZCBvdXQgdGhlIHRvdXJuYW1lbnQgd2l0aCBsb3NzZXMgdG8gQXJrYW5zYXMgYW5kIFB1cmR1ZSwgYW5kIHByZXBhcmVkIHRoZW1zZWx2ZXMgZm9yIENvbmZlcmVuY2VzLjwvcD5cbiAgICAgICAgICAgIDxwPk9uY2UgYWdhaW4sIFJhbnRvdWwgd2FzIGhvc3QgdG8gQ29uZmVyZW5jZXMsIGJ1dCB0aGlzIHRpbWUgdGhlcmUgY291bGQgYmUgbm8gY29tcGxhaW50cyBhYm91dCB0aGUgd2VhdGhlci4gSWxsaW5vaXMgc3RhcnRlZCBvdXQgc3Ryb25nIHdpdGggY29tZm9ydGFibGUgd2lucyBvdmVyIHRoZSByZXN0IG9mIHRoZSBwb29sLCBpbmNsdWRpbmcgYW4gMTEtNCB2aWN0b3J5IG92ZXIgVUNoaWNhZ28uIFdpbm5pbmcgdGhlIHBvb2wgbGluZWQgdXAgYSBzZW1pZmluYWwgZ2FtZSBhZ2FpbnN0IElsbGlub2lzIFN0YXRlLCB3aGljaCB3YXMgd29uIGhhbmRpbHkgMTMtNyBhbmQgc2V0IHVwIGEgY2xhc3NpYyBJbGxpbm9pcyAtIE5vcnRod2VzdGVybiByZW1hdGNoLiBVbmZvcnR1bmF0ZWx5LCB0aGUgdGVhbSBzdHJ1Z2dsZWQgdG8gZmluZCB0aGUgZW5kem9uZSBhbmQgZm9yIHRoZSBzZWNvbmQgeWVhciBpbiBhIHJvdywgbG9zdCB0byBOb3J0aHdlc3Rlcm4gYXQgQ29uZmVyZW5jZXMuIEluIHRoZSAybmQgcGxhY2UgbWF0Y2ggYWdhaW5zdCBVQ2hpY2FnbywgSWxsaW5vaXMgd2FzIHVuYWJsZSB0byBmaW5kIGEgZ3Jvb3ZlIGFuZCBsb3N0IDktMTEuIFdpdGggUmVnaW9uYWxzIGluIHR3byB3ZWVrcyBhbmQgb25seSBvbmUgYmlkIGZvciB0aGUgcmVnaW9uLCBJbGxpbm9pcyBoYWQgYSBsb3Qgb2Ygd29yayB0byBkby48L3A+XG4gICAgICAgICAgICA8cD5JbiBhIGNoYW5nZSBvZiBwYWNlLCBSZWdpb25hbHMgd2FzIG5vdCBob3N0ZWQgaW4gUm9ja2ZvcmQsIGJ1dCBpbiBGYWlyIE9ha3MsIEluZGlhbmEuIFRoZSBjb25kaXRpb25zIHdlcmUgdGVycmlibGUsIGxvdyB0ZW1wZXJhdHVyZXMgY291cGxlZCB3aXRoIGhlYXZ5IHdpbmQgYW5kIHJhaW4gbWVhbnQgdGhhdCBpdCB3b3VsZCBiZSBkaWZmaWN1bHQgZ2V0dGluZyBhIGdvb2QgZ3JpcC4gSW4gdGhlIGZpcnN0IGdhbWUgYWdhaW5zdCBLZW50dWNreSwgYm90aCBPIGFuZCBEIGxpbmUgd2VyZSBhYmxlIHRvIHBlcmZvcm0gd2VsbCwgZ2l2aW5nIHVwIG5vIGJyZWFrcyBhbmQgaGFuZGluZyBvdXQgYSBmZXcgb2YgdGhlaXIgb3duIGFuZCBmaW5pc2hpbmcgd2l0aCBhIHNjb3JlIG9mIDEyLTYuIFRoZSB0cmVuZCBjb250aW51ZWQgYWdhaW5zdCBJbmRpYW5hLCB3aXRoIElsbGlub2lzIHdpbm5pbmcgMTMtNi4gTmV4dCB1cCB3YXMgTm90cmUgRGFtZSwgYSByZW1hdGNoIG9mIGxhc3QgeWVhcuKAmXMgZmluYWxzLCB3aW5uZXIgdGFrZXMgdGhlIHBvb2wgYW5kIHF1YXJ0ZXJmaW5hbHMgYmVydGguIEEgY29tcGxldGVseSB1cHdpbmQvZG93bndpbmQgZ2FtZSBmb3VuZCB0aGUgZCBsaW5lIHdpdGggb3Bwb3J0dW5pdGllcyB0byBicmVhaywgYnV0IG5ldmVyIGFibGUgdG8gZmluaXNoIHRoZSBqb2IuIFdpdGggbmVpdGhlciB0ZWFtIGJlaW5nIGJyb2tlbiwgTm90cmUgRGFtZSB3b24gdGhlIGZsaXAgYW5kIHRoZSBnYW1lLCA5LTEwLiBJbGxpbm9pcyBmaW5pc2hlZCB1cCB0aGUgZGF5IHdpdGggYSAxMy01IHdpbiBvdmVyIE1pY2hpZ2FuIFN0YXRlIHRvIHNldCB1cCBhIHF1YXJ0ZXJmaW5hbHMgbWF0Y2h1cCBhZ2FpbnN0IE5vcnRod2VzdGVybi48L3A+XG4gICAgICAgICAgICA8cD5Db25kaXRpb25zIG9uIFN1bmRheSB3ZXJlIGJldHRlciBhbmQgd2l0aCBhIGxpdHRsZSBzdXBwb3J0IGZyb20gV2FsZGVuIE5lbHNvbiwgdGhlIHRlYW0gd2FzIHJlYWR5IHRvIGF2ZW5nZSB0aGVpciByZWNlbnQgbG9zc2VzLiBJbGxpbm9pcyBzdGFydGVkIG9uIEQgYW5kIE5vcnRod2VzdGVybiBjYW1lIG91dCB3aXRoIGFuIGJyZWFrIGVhcmx5IGluIHRoZSBnYW1lLCBidXQgdGhlIHRlYW0gZm91Z2h0IGJhY2sgYW5kIGJyZWFrcyB3ZXJlIHRyYWRlZCB0byBoYXZlIGl0IGJlIG9uIHNlcnZlIGF0IGhhbGYuIFRoZSBzZWNvbmQgaGFsZiBjb21tZW5jZWQgd2l0aCBtb3JlIG9mIGEgY2xlYW5lciBnYW1lLCB3aXRoIGJvdGggdGVhbXMgdHJhZGluZyBvZmZlbnNpdmUgaG9sZHMuIEEgY2hhbmNlIGF0IGEgYnJlYWsgZHVlIHRvIGEgTmljayBQcm8gc2t5IHdhcyBjYWxsZWQgYmFjayBvbiBhIGNvbnRyb3ZlcnNpYWwgb2JzZXJ2ZXIgcnVsaW5nIGFuZCB0aGUgZ2FtZSByZWFjaGVkIHNvZnRjYXAgd2l0aCB0aGUgc2NvcmUgMTAtMTEuIENocmlzIEJ1Y2h0YSB0aWVkIHVwIHRoZSBzY29yZSB3aXRoIGEgaHVjayBmcm9tIEtldmluIExpbiBhbmQgdGhlIGQgbGluZSB3ZW50IG91dCB0byB0cnkgYW5kIGJyZWFrIHdpdGggdGhlIHNlYXNvbiBvbiB0aGUgbGluZS4gQWZ0ZXIgYSB0dXJuIGZyb20gTm9ydGh3ZXN0ZXJuLCBJbGxpbm9pcyB3b3JrZWQgdGhlIGRpc2MgZG93biB0aGUgZmllbGQgYW5kIHJvb2tpZSBKYWNvYiBDdXRoYmVydCB0b29rIGEgdGltZW91dCBvdXRzaWRlIG9mIHRoZSBlbmR6b25lLiBPbmUgZW5kem9uZSBzZXQgbGF0ZXIsIFByYXlhZyBmb3VuZCBDdXRoYmVydCBmb3IgdGhlIHdpbiwgc2VuZGluZyBJbGxpbm9pcyB0byB0aGUgc2VtaWZpbmFscy48L3A+XG4gICAgICAgICAgICA8cD5EdWUgdG8gdGhlIGxvc3MgaW4gcG9vbCBwbGF5LCBJbGxpbm9pc+KAmXMgbWF0Y2h1cCBpbiB0aGUgc2VtaWZpbmFscyB3YXMgTWljaGlnYW4uIERlc3BpdGUgdGhlIHRvdWdoIGdhbWUgYmVmb3JlLCBJbGxpbm9pcyBoYWQgdG8gY29tZSBvdXQgaG90IGlmIHRoZXkgd2FudGVkIHRvIHdpbiB0aGUgZ2FtZS4gTWljaGlnYW4gY2FtZSBvdXQgb2YgdGhlIGdhdGUgZmFzdCwgc2NvcmluZyBvbiBhIGh1Y2suIElsbGlub2lzIGZvbGxvd2VkIHN1aXQsIGFuZCB0aGUgdHdvIHRlYW1zIHRyYWRlZCBvZmZlbnNpdmUgaG9sZHMgdW50aWwgTWljaGlnYW4gYnJva2UgZm9yIDMtNS4gQXMgdGhlIGdhbWUgd2VudCBvbiwgdGhlIGRlZmVuc2l2ZSBwcmVzc3VyZSBmcm9tIE1pY2hpZ2FuIGludGVuc2lmaWVkIGFuZCBJbGxpbm9pc+KAmSBvIGxpbmUgd2FzIG5vdCBhYmxlIHRvIG1hdGNoIHRoZSBnb2FscyB0aGF0IE1pY2hpZ2Fu4oCZcyBvIGxpbmUgd2FzIHB1dHRpbmcgb3V0LiBDb21pbmcgb3V0IG9mIGhhbGYgYXQgNS04LCBJbGxpbm9pcyB0dXJuZWQgYW5kIHdhcyBicm9rZW4gYWdhaW4uIEEgbGF0ZSBpbmp1cnkgdG8gUHJheWFnIHB1c2hlZCB0aGUgaG9wZSBvZiBhIGNvbWViYWNrIGEgbGl0dGxlIGZ1cnRoZXIgb3V0IG9mIHJlYWNoIGFuZCBhIHNlbmlvciBkIGxpbmUgd2FzIHVuYWJsZSB0byBrZWVwIE1pY2hpZ2FuIGZyb20gc2VpemluZyB0aGUgdmljdG9yeSAxMC0xNS4gTWljaGlnYW4gd2VudCBvbiB0byBkZWZlYXQgTm90cmUgRGFtZSAxNS05IHRvIHRha2UgdGhlIGJpZCB0byBOYXRpb25hbHMuIElsbGlub2lzIGZpbmlzaGVkIHRoZSBzZWFzb24gd2l0aCBhIDExLTEwIHZpY3Rvcnkgb3ZlciBQdXJkdWUgZm9yIDNyZCBpbiB0aGUgcmVnaW9uLjwvcD5cbiAgICAgICAgICAgIDxwPkNhcHRhaW4gTmljayBQcm96b3JvdnNreSBhbmQgSm9obiBTYW5pYXQgcmVjZWl2ZWQgMXN0IHRlYW0gQWxsLVJlZ2lvbiBob25vcnMgYW5kIENhcHRhaW4gUHJheWFnIFBhdGVsIHJlY2VpdmVkIDJuZCB0ZWFtIEFsbC1SZWdpb24uIEJlbiBTYWJvdXJpbiBhbmQgSmFjb2IgQ3V0aGJlcnQgd2VyZSB2b3RlZCBBbGwtRnJlc2htZW4gZm9yIHRoZSByZWdpb24sIHdpdGggQmVuIHdpbm5pbmcgRnJlc2htYW4gb2YgdGhlIFllYXIuPC9wPlxuICAgICAgICBgXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTUsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAxNS5qcGcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5BZnRlciB0aGUgd29yc3QgcmVnaW9uYWxzIHBlcmZvcm1hbmNlIHNpbmNlIDIwMDYsIElsbGlub2lzIGVudGVyZWQgdGhlIDIwMTUgc2Vhc29uIHdpdGggYSBuZXcgbG9va2luZyB0ZWFtIGFuZCBhIG5ldyBtaW5kc2V0LiBNYWpvciBsb3NzZXMgaW5jbHVkZWQgbG9uZyB0aW1lIGNvYWNoIFdhbGRlbiBOZWxzb24sIGFzIHdlbGwgYXMgTy1saW5lIHN0YXJzIE5lYWwgUGhlbHBzLCBCcmlhbiBSYXRodW5kZSwgYW5kIFNlYW4gSGlsbC4gTWFydHkgTWFya2Vuc29uIHJldHVybmVkIGFzIGNhcHRhaW4gYW5kIHdhcyBqb2luZWQgYnkgZmlyc3QtdGltZXJzIEpvaG5ueSBTYW5pYXQgYW5kIE5pY2sgUHJvem9yb3Zza3kuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIG1ham9yIGNoYW5nZSB0byB0aGUgdGVhbSBjYW1lIGluIHRoZSBmb3JtIG9mIHJldHVybmluZyBjb2FjaCwgTWF0dCBTdHVwY2EuIE1hdHQgY29hY2hlZCB0aGUgdGVhbSBmcm9tIDIwMDYtMjAwOSBhbmQgYnJvdWdodCB0aGVtIHRvIE5hdGlvbmFscyB0d2ljZSwgZmluaXNoaW5nIGluIDV0aCBwbGFjZSBpbiAyMDA4LiBUaGUgZXhwZXJpZW5jZWQgY29hY2ggZ2F2ZSB0aGUgdGVhbSB0aGUgbmVjZXNzYXJ5IGxlYWRlcnNoaXAgbmVlZGVkIHRvIHJlYnVpbGQgdGhlIGNsdWIgZm9yIGEgcG9zc2libGUgTmF0aW9uYWxzIHJ1biBhZ2Fpbi48L3A+XG4gICAgICAgICAgICA8cD5BcyBhbHdheXMsIHRoZSBmYWxsIHRyeW91dHMgd2VyZSBjb21wZXRpdGl2ZSBhbmQgZXhjaXRpbmcsIHdpdGggYW5vdGhlciBzdHJvbmcgcm9va2llIGNsYXNzIGFuZCBtYW55IEItdGVhbWVycyBhbmQgb3V0c2lkZXJzIGpvaW5pbmcgdGhlIHNjZW5lLiBXaGVuIGl0IHdhcyBhbGwgc2FpZCBhbmQgZG9uZSwgdGhlIGZpbmFsIHJvc3RlciBjb25zaXN0ZWQgb2YgMjMgcGVvcGxlLiBUaGUgcm9zdGVyIGluY2x1ZGVkIDIgcm9va2llcywgNSBCLXRlYW1lcnMsIDE1IHJldHVybmVycywgYW5kIDEgdHJhbnNmZXIgc3R1ZGVudC4gTmV3IGFkZGl0aW9ucyBpbmNsdWRlZCBWYWxwYXJhaXNvIHN0dWQsIE1hdHQgV2VzdCwgYmFza2V0YmFsbCBjcm9zc292ZXIgSmFycmVkIEVsbGlvdCwgbG92YWJsZSBzcGlyaXQgbGVhZGVyIEVyaWMgQmFkZ2VyLCBhbmQgcm9va2llcyBLZXZpbiBMaW4gYW5kIEphY29iIEtvbWVuZGEuPC9wPlxuICAgICAgICAgICAgPHA+Q29tZSBlbmQgb2YgZmFsbCwgSWxsaW5vaXMgd2FzIHJlLWFybWVkIGFuZCByZWFkeSBmb3IgYW5vdGhlciBydW4gZm9yIE5hdGlvbmFscyBpbiB0aGUgc3ByaW5nIHNlYXNvbi48L3A+XG4gICAgICAgICAgICA8cD5UaGUgc3ByaW5nIHNlYXNvbiBzY2hlZHVsZSB3YXMgcGVyaGFwcyBvbmUgb2YgSWxsaW5vaXMnIG1vc3QgYnVzeS4gVGhlIHRlYW0gd2FzIHNjaGVkdWxlZCB0byBhdHRlbmQgMyBvZiB0aGUgaGlnaGVzdCBsZXZlbCB0b3VybmFtZW50cyBhcm91bmQgdGhlIGNvdW50cnksIGluY2x1ZGluZyB0b3VybmFtZW50cyBpbiBUZXhhcywgRmxvcmlkYSwgYW5kIFNvdXRoIENhcm9saW5hLjwvcD5cbiAgICAgICAgICAgIDxwPldoZW4gRmVicnVhcnkgY2FtZSBhcm91bmQsIGl0IHdhcyB0aW1lIHRvIGhlYWQgc291dGggdG8gVGFtcGEgZm9yIHRoZSBmaXJzdCBzcHJpbmcgdG91cm5hbWVudCwgRmxvcmlkYSBXYXJtLVVwLiBGb3IgdGhlIGZpcnN0IHRpbWUsIHRoZSB0ZWFtIHRyYXZlbGVkIGJ5IGFpciB0byBhIHRvdXJuYW1lbnQuIFdhcm0tVXAsIGEgdGhyZWUgZGF5IHRvdXJuYW1lbnQsIHByb3ZlZCB0byBiZSBhIHVzZWZ1bCBsZXNzb24gdG8gdGhlIHRlYW0uIE9uIGRheSBvbmUsIHRoZSBJbGxpbmkgd2VudCAxLTMgd2l0aCBvbmx5IG9uZSB3aW4gaW4gYSBuaWdodCBnYW1lIHZzLiBDb3JuZWxsLiBJdCB3YXMgYSBkaXNhcHBvaW50aW5nIHBlcmZvcm1hbmNlLCBidXQgZGF5IHR3byBzcGVsdCBkaWZmZXJlbnQgc3RvcmllcyBmb3IgSWxsaW5vaXMuIFNhdHVyZGF5IG1vcm5pbmcsIFRoZSBJbGxpbmkgd291bGQgcGxheSB0aGUgcmV2ZXJlZCBOYXRpb25hbHMgdGVhbSBVQ0YgaW4gYSBnYW1lIHRoYXQgd2FzIHJlY29yZGVkIGJ5IFVsdGl3b3JsZC4gVGhlIElsbGluaSB3ZXJlIG5vIGRvdWJ0IHVuZGVyZG9ncywgYnV0IGZvdWdodCBoYXJkIHRvIHRha2UgYSBsZWFkIG9uIHRoZSBEb2dzIG9mIFdhci4gTWFqb3IgcGxheXMgaW5jbHVkZWQgYSBDYWxsYWhhbiBieSBoYW5kbGVyIFByYXlhZyBQYXRlbCBhbmQgYSBodWNrIGJyZWFrLXNjb3JlIGJ5IE1heCBXaWxsaXMgdG8gcm9va2llIEphY29iIEtvbWVuZGEuIFRoZSBEb2dzIG9mIFdhciBmb3VnaHQsIGJ1dCB0aGUgSWxsaW5pIHB1bGxlZCB0aHJvdWdoLCB3aW5uaW5nIHRoZSBnYW1lIDEzLTkgYW5kIGNsYWltaW5nIG9uZSBvZiB0aGUgYmlnZ2VzdCB1cHNldHMgb2YgdGhlIHRvdXJuYW1lbnQuIElsbGlub2lzIHdvdWxkIGNydWlzZSB0byB0d28gbW9yZSB3aW5zIHRoYXQgZGF5LCBmaW5pc2hpbmcgMy0wIGZvciBTYXR1cmRheS4gV2l0aCBlbW90aW9ucyBoaWdoIGJ1dCBsZWdzIHRpcmVkLCB0aGUgSWxsaW5pIGZpbmlzaGVkIG9mZiB0aGUgbG9uZyB3ZWVrZW5kIHdpdGggYSB0b3VnaCBsb3NzIGFnYWluc3QgR2VvcmdldG93biBhbmQgYSB3aW4gYWdhaW5zdCBXaXNjb25zaW4tTWlsd2F1a2VlIG9uIFN1bmRheSB0byBlbmQgRmxvcmlkYSBXYXJtIHVwLiBUaGV5IGZpbmlzaGVkIDUtNCBvbiB0aGUgd2Vla2VuZC48L3A+XG4gICAgICAgICAgICA8cD5UaGUgbmV4dCBiaWcgdG91cm5hbWVudCB3YXMgdGhlIGZhbW91cyBDZW50ZXggaW52aXRlIGluIEF1c3RpbiwgVGV4YXMuIFRoZSB0ZWFtIHdhcyBzZWVkZWQgOXRoIG92ZXJhbGwgb3V0IG9mIDIwIGFmdGVyIHRoZWlyIGltcHJlc3NpdmUgd2luIGFnYWluc3QgQ2VudHJhbCBGbG9yaWRhIGJhY2sgYXQgV2FybS1VcC4gV2l0aCBoaWdoIGV4cGVjdGF0aW9ucywgdGhlIElsbGluaSB3b3VsZCBqdW1wIHJpZ2h0IGludG8gaXQsIHBsYXlpbmcgb25lIG9mIHRoZSBiZXN0IHRlYW1zIG9mIDIwMTUsIE5vcnRoLUNhcm9saW5hIFdpbG1pbmd0b24uIFRoZSBmaXJzdCBwb2ludCBvZiB0aGUgZ2FtZSB3b3VsZCBwcm92ZSB0byBiZSBzb21ld2hhdCBvZiBhIHRoZW1lIGZvciB0aGUgSWxsaW5pIHRoYXQgd2Vla2VuZCwgYXMgdG9wIGN1dHRlciBOaWNrIFByb3pvcm92c2t5IHdvdWxkIGdvIGRvd24gd2l0aCBhIGtuZWUgaW5qdXJ5LiBUaGUgSWxsaW5pIGNvdWxkIG5vdCB1cHNldCB0aGUgYmlnIGRvZyB0aGlzIHRpbWUgdGhvdWdoLCBhcyBXaWxtaW5ndG9uIHdvbiBjb21mb3J0YWJseSBhdCAxMS0zLjwvcD5cbiAgICAgICAgICAgIDxwPkFzIHRoZSBkYXkgd2VudCBvbiwgdGhlIGluanVyaWVzIGNvbnRpbnVlZC4gTmVhcmx5IGhhbGYgb2YgdGhlIElsbGluaSBzcXVhZCB3b3VsZCBnbyBkb3duIHRoYXQgZGF5LiBUaGUgcGFpbiBhbHNvIHNob3dlZCBpbiB0aGUgc2NvcmVzLCBhcyB0aGUgSWxsaW5pIHdvdWxkIGxvc2UgdG8gVGV4YXMgMTItNSBhbmQgZmFsbCB0byB0d28gbG93ZXItc2VlZGVkIHRlYW1zIEFya2Fuc2FzIGFuZCBJb3dhLiBUaGV5IGZpbmlzaGVkIDAtNCBvbiBTYXR1cmRheS4gPC9wPlxuICAgICAgICAgICAgPHA+SW4gdGhlIGxvc2VyJ3MgYnJhY2tldCBvbiBTdW5kYXksIElsbGlub2lzIHdvdWxkIGdvIDMtMCB3aXRoIHdpbnMgb3ZlciBDYWxpZm9ybmlhLCBJb3dhIFN0YXRlLCBhbmQgV2lzY29uc2luLU1pbHdhdWtlZS4gPC9wPlxuICAgICAgICAgICAgPHA+VGhlIGZpbmFsZSBvZiB0aGUgc3ByaW5nIHRvdXJuYW1lbnRzIHdhcyB0aGUgdmVyeSBjb21wZXRpdGl2ZSBFYXN0ZXJucyBpbiBOb3J0aCBNeXJ0bGUgQmVhY2gsIFNvdXRoIENhcm9saW5hLCB3aGljaCBhIHllYXIgZWFybGllciB3YXMgd29uIGJ5IEdyZWF0IExha2VzIHJlZ2lvbiByaXZhbCBNaWNoaWdhbi4gVGhlIElsbGluaSB3ZW50IGludG8gdGhlIHRvdXJuYW1lbnQgd2l0aCBhIGJpdCBvZiBhIGRpZmZlcmVudCBsb29rLCBhcyBCb29tbGFuZCBjb2FjaCBFcmlrIEh1ZW1pbGxlciB3b3VsZCBmaWxsIGluIGZvciBjb2FjaCBNYXR0IFN0dXBjYSBhcyB3ZWxsIGFzIG51bWVyb3VzIGluanVyZWQgYW5kIGFic2VudCBwbGF5ZXJzIHJldHVybmluZyB0byB0aGUgc3F1YWQuIFRoZXkgd2VyZSBzZWVkZWQgYXMgdGhlIDIwIHNlZWQsIHdpdGggbm93aGVyZSB0byBnbyBidXQgdXAuPC9wPlxuICAgICAgICAgICAgPHA+SW4gYSBoaWdobHkgY29tcGV0aXRpdmUgcG9vbCwgdGhlIElsbGluaSB3b3VsZCBzdGFydCBvZmYgYWdhaW5zdCB0aGUgMjAxMi0yMDEzIG5hdGlvbmFsIGNoYW1waW9ucywgUGl0dHNidXJnaC4gUGl0dCBoYWQgd29uIGV2ZXJ5IHRvdXJuYW1lbnQgdXAgdG8gdGhpcyBwb2ludC4gVGhlIElsbGluaSB0b29rIGFkdmFudGFnZSBvZiBQaXR0cyBtYW55IHNsb3BweSBtaXN0YWtlcywgYnV0IGNvdWxkIG5vdCBjb21lIGF3YXkgd2l0aCBhbm90aGVyIHVwc2V0LCBmYWxsaW5nIDE1LTEwLiBUaGUgdHJvdWJsZXMgY29udGludWVkLCB3aXRoIGxvc3NlcyB0byBDYXJsZXRvbiBDb2xsZWdlLCBVTWFzcywgYW5kIEdlb3JnaWEuIFRoaXMgcHV0IHRoZSBJbGxpbmkncyBmaXJzdCBkYXkgcmVjb3JkIGF0IGEgdHJvdWJsaW5nIDEtMTIgb24gdGhlIHNlYXNvbi48L3A+XG4gICAgICAgICAgICA8cD5TdW5kYXkgd291bGQgcHJvdmUgdG8gYmUgYW4gaW1wb3J0YW50IGRheSBmb3IgdGhlIElsbGluaS4gRGVzcGl0ZSB0aGUgdHJvdWJsZXMgb24gRGF5IDFzLCB0aGUgSWxsaW5pIGhhZCBwbGF5ZWQgd2VsbCB0aGUgc2Vjb25kIGRheSBvZiB0b3VybmFtZW50cyBhbGwgc2Vhc29uLCB3aXRoIGEgNi0wIHJlY29yZC4gQXMgdGhlIGxhc3QgcmFua2VkIHNlZWQgYXQgdGhlIHRvdXJuYW1lbnQsIHRoZXkgd291bGQgZmlnaHQgdG8gYnJlYWsgc2VlZCBhZ2FpbnN0IE5DIFN0YXRlLCBDb2xvcmFkbyBTdGF0ZSwgYW5kIDEwLXNlZWRlZCBBdWJ1cm4uPC9wPlxuICAgICAgICAgICAgPHA+V2l0aCBtYW55IGRpZmZlcmVudCBwb3NpdGlvbiBjaGFuZ2VzLCB0aGUgSWxsaW5pIGNhbWUgb3V0IHdpdGggYSBuZXcgZmlyZSwgZ29pbmcgMy0wIGFnYWluIG9uIFN1bmRheSBhbmQgdGFraW5nIG91dCB0aGUgY29tcGV0aXRpb24gaGFuZGlseS4gV2l0aCB0aGlzLCB0aGUgSWxsaW5pIHNwcmluZyByZWd1bGFyIHNlYXNvbiB3b3VsZCBjb21lIHRvIGFuIGVuZC4gVGhleSB3b3VsZCBmaW5pc2ggd2l0aCBhIDEwLTEyIHJlY29yZCwgd2l0aCBvbmx5IG9uZSBvZiB0aG9zZSB3aW5zIGNvbWluZyBvbiBkYXkgb25lIG9mIGEgdG91cm5hbWVudC4gVGhpcyBpc3N1ZSB3b3VsZCBiZSBpbiB0aGUgYmFjayBvZiBldmVyeW9uZSdzIGhlYWQgZ29pbmcgaW50byB0aGUgcG9zdHNlYXNvbi48L3A+XG4gICAgICAgICAgICA8cD5TZWN0aW9uYWxzLCBhcyBhbHdheXMsIHdhcyBoZWxkIGluIFJhbnRvdWwsIElMLiBUaGUgSWxsaW5pIGNhbWUgaW4gYXMgdGhlIGZhdm9yaXRlLCB3aXRoIE5vcnRod2VzdGVybiBhbmQgVUNoaWNhZ28gc2l0dGluZyBjbG9zZSBiZWhpbmQuIFRoZSBJbGxpbmkgd291bGQgcm91Z2ggb3V0IHdpbnMgYWdhaW5zdCBFYXN0ZXJuIElsbGlub2lzIGFuZCBTb3V0aGVybiBJbGxpbm9pcyBiZWZvcmUgdGFraW5nIG9uIFVDaGljYWdvLCB3aG8gaGFkIGVuZGVkIHRoZWlyIDIwMTQgc2Vhc29uIGRyYW1hdGljYWxseSBsYXN0IHllYXIgYXQgcmVnaW9uYWxzLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSBnYW1lIHdhcyB1cCBhbmQgZG93biBidXQgZXZlbnR1YWxseSBlbmRlZCBpbiBhbm90aGVyIGNydXNoaW5nIGxvc3MgZm9yIHRoZSBJbGxpbmkgb24gdW5pdmVyc2UgcG9pbnQuIFRoaXMgc2VudCB0aGUgSWxsaW5pIGludG8gU3VuZGF5IHdpdGggYSBmaXJzdCByb3VuZCBtYXRjaCBhZ2FpbnN0IG90aGVyIHJpdmFsIE5vcnRod2VzdGVybiwgd2hvIHRoZSB0ZWFtIGhhZG4ndCBwbGF5ZWQgc2luY2UgbGFzdCB5ZWFyLiBUaGUgZ2FtZSB3YXMgY2xvc2UgZWFybHkgb24sIGJ1dCB0aGUgdXBzdGF0ZSByaXZhbHMgcHVsbGVkIGFoZWFkIGFuZCBldmVudHVhbGx5IHRvb2sgdGhlIGdhbWUgMTUtOS4gSXQgd2FzIHRoZSBzZWNvbmQgdmVyeSBhbGFybWluZyBsb3NzIGluIGEgcm93IGZvciB0aGUgSWxsaW5pLCBhbmQgZm9yIHRoZSBmaXJzdCB0aW1lIGluIHllYXJzLCB3b3VsZCBlbGltaW5hdGUgdGhlbSBmcm9tIHdpbm5pbmcgc2VjdGlvbmFscy48L3A+XG4gICAgICAgICAgICA8cD5EZXNwaXRlIHRoaXMgbmV3cywgdGhlIElsbGluaSB0b29rIGRvd24gSWxsaW5vaXMgU3RhdGUgaW4gdGhlIG5leHQgZ2FtZSB0byBlbnN1cmUgYW5vdGhlciBnYW1lIGFnYWluc3QgVUNoaWNhZ28gZm9yIHNlY29uZCBwbGFjZSBpbiB0aGUgc2VjdGlvbi4gSW4gdGhlIGdhbWUgdGhhdCBoYWQgYSBnYW1lIHRvIGdvIGF0bW9zcGhlcmUsIHRoZSBJbGxpbmkgZmluYWxseSB3ZXJlIGFibGUgdG8gaGl0IG9uIGFsbCBjeWxpbmRlcnMsIGJsb3dpbmcgb3V0IHRoZWlyIHJlY2VudCByaXZhbHMgMTUtNiBhbmQgdGFraW5nIHNlY29uZCBwbGFjZSBhdCBzZWN0aW9uYWxzLiBJdCB3b3VsZCBwcm92ZSB0byBiZSBzb21ld2hhdCBvZiBhIHdlaWdodCBsaWZ0ZWQgb2ZmIGV2ZXJ5b25lJ3MgYmFjayBnb2luZyBpbnRvIHJlZ2lvbmFscywgYnV0IHRoZXJlIHdhcyBzdGlsbCBtdWNoIHdvcmsgdG8gYmUgZG9uZS48L3A+XG4gICAgICAgICAgICA8cD5SZWdpb25hbHMgd2FzIGJhY2sgYXQgUm9ja2ZvcmQsIGEgcGxhY2Ugb2YgbWFueSBlbW90aW9ucyBmb3IgbW9zdCBJbGxpbm9pcyBwbGF5ZXJzLiBJbGxpbm9pcyBjYW1lIGluIGFzIHRoZSAzIHNlZWQ7IGluIGEgcG9vbCB3aXRoIFB1cmR1ZSwgR3JhbmQgVmFsbGV5LCBhbmQgYWdhaW4sIFVDaGljYWdvLiBUaGUgcmVjZW50IHVwcyBhbmQgZG93bnMgb2YgdGhlIElsbGlub2lzIHNlYXNvbiwgYXMgd2VsbCBhcyBpbnNwaXJpbmcgbWVzc2FnZXMgYnkgY29hY2ggU3R1cGNhIGFuZCBzb21lIG9mIHRoZSBwbGF5ZXJzLCBoYWQgdGhlIHRlYW0gZm9jdXNlZCBhcyBldmVyLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSBmaXJzdCBnYW1lIGFnYWluc3QgUHVyZHVlIHNhdyB0aGUgTy1MaW5lIGluIGNydWlzZSBjb250cm9sIHdpdGggYSBsZXZlbCBvZiBjb25zaXN0ZW5jeSBub3Qgc2VlbiBiZWZvcmUgaW4gdGhlIHNlYXNvbi4gV2l0aCBhIGZldyBicmVha3MgbWl4ZWQgaW4sIHRoZSBJbGxpbmkgdG9vayB0aGUgZmlyc3QgZ2FtZSBvZiB0aGUgZGF5IDExLTguIFdpdGggYW4gZWFzaWVyIDEzLTYgd2luIGFnYWluc3QgR3JhbmQgVmFsbGV5IFN0YXRlLCBJbGxpbm9pcyB3b3VsZCBwbGF5IHRoZWlyIGZpbmFsIGdhbWUgb2YgdGhlIGRheSBhZ2FpbnN0IFVDaGljYWdvLiBUaGUgZ2FtZSB3YXMgcGxheWVkIGp1c3QgYSBmZXcgZmllbGRzIGF3YXkgZnJvbSB3aGVyZSBDaGljYWdvIGVuZGVkIElsbGlub2lzIHNlYXNvbiBvbmUgeWVhciBwcmlvci4gRW1vdGlvbnMgcmFuIGhpZ2ggYWdhaW4sIGJ1dCB0aGUgSWxsaW5pIGZpbmFsbHkgcHV0IFVDaGljYWdvIHRvIHJlc3QgaW4gYW4gMTEtNSB2aWN0b3J5LiBJdCB3YXMgYSBiaWcgc3RhdGVtZW50IGZvciBJbGxpbm9pcyBhbmQgc2VudCB0aGVtIGludG8gU3VuZGF5J3MgY2hhbXBpb25zaGlwIGJyYWNrZXQgcmlkaW5nIGhpZ2guPC9wPlxuICAgICAgICAgICAgPHA+SWxsaW5vaXMgd2VudCBpbnRvIFN1bmRheSBzdGlsbCBub3QgaGF2aW5nIGJlZW4gYnJva2VuIHlldCwgYSB0cnVlIHRlc3RhbWVudCB0byB0aGVpciBPLWxpbmUncyBpbXByb3ZlZCBmb2N1cy4gVGhlIGZpcnN0IGdhbWUgb2YgdGhlIGRheSB3YXMgYWdhaW5zdCBsYXN0IHllYXIncyBzZWNvbmQgTmF0aW9uYWxzIHRlYW0gZnJvbSB0aGUgcmVnaW9uLCBFYXN0ZXJuIE1pY2hpZ2FuLiBUaGUgZ2FtZSB3YXMgdGlnaHQgdGhyb3VnaG91dCB3aXRoIGJvdGggTy1saW5lcyB0cmFkaW5nLCBidXQgdGhlIElsbGluaSBwdWxsZWQgdGhyb3VnaCB0byB3aW4gdGhlIGdhbWUgMTUtMTIuIFRoZSBnYW1lIHNhdyB0aGUgSWxsaW5pIGxldCB1cCBvbmUgYnJlYWssIHdoaWNoIHdhcyB0aGUgZmlyc3QgYnJlYWsgYWxsb3dlZCBhbGwgd2Vla2VuZC48L3A+XG4gICAgICAgICAgICA8cD5UaGlzIHNlbnQgdGhlIHRlYW0gaW50byBzZW1pcyBhZ2FpbnN0IHRoZWlyIGF0aGxldGljLCBCaWcgMTAgY291bnRlcnBhcnRzLCBJbmRpYW5hLiBJbmRpYW5hLCBmb3IgdGhlIG1vc3QgcGFydCwgd2FzIGNvbXBsZXRlbHkgdW5mYW1pbGlhciB0byB0aGUgSWxsaW5pJ3MgcGxheSBzdHlsZSBnb2luZyBpbnRvIHRoZSBtYXRjaHVwLiBXaXRoIHRoZSAnZ2FtZSB0byBnbycgaW4gdGhlIGJhY2sgb2YgZXZlcnlvbmUncyBoZWFkcywgdGhlIElsbGluaSBwb3VyZWQgb24gdGhlIHBvaW50cyBhbmQgd29uIDE1LTUsIGNsYWltaW5nIHRoZWlyIGJpZ2dlc3QgdmljdG9yeSBvZiB0aGUgdG91cm5hbWVudC4gVGhlIEQtTGluZSBzaGluZWQgdGhpcyBnYW1lLCBnaXZpbmcgdGhlIE8tbGluZSBhIG11Y2ggbmVlZGVkIHJlc3QgaGVhZGluZyBpbnRvIHRoZSBiaWdnZXN0IGdhbWUgb2YgdGhlIHNlYXNvbi48L3A+XG4gICAgICAgICAgICA8cD5UaGUgJ2dhbWUgdG8gZ28nIHNhdyB0aGUgSWxsaW5pIGZhY2UgdXAgYWdhaW5zdCBhIHRlYW0gdGhleSBuZXZlciB3b3VsZCBoYXZlIGV4cGVjdGVkLiBJbiBzdXJwcmlzaW5nIGZhc2hpb24sIHRoZSBzY3JhcHB5IGFuZCBlbmVyZ2l6ZWQgTm90cmUgRGFtZSB3b3VsZCBzdGFuZCBhcyB0aGVpciBsYXN0IHRlc3Qgb2YgdGhlIHNlYXNvbi4gVGhlIG90aGVyIHNpZGUgb2YgdGhlIGJyYWNrZXQgd291bGQgcHJvdmUgdG8gYmUgb25lIHRvIHJlbWVtYmVyLCBhcyBOb3RyZSBEYW1lIGhhZCBiZWF0ZW4gcml2YWwgTWljaGlnYW4gYWZ0ZXIgTWljaGlnYW4gaGFkIGJlYXRlbiBOb3J0aHdlc3Rlcm4gb24gZG91YmxlIGdhbWUgcG9pbnQgdGhlIGdhbWUgYmVmb3JlLiBJdCB3YXMgd2luIG9yIGdvIGhvbWUgZm9yIHRoZSBJbGxpbmkuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIGdhbWUgd2FzIGEgc3BlY3RhY2xlLCB3aXRoIG1hbnkgb2YgdGhlIHByb2dyYW0ncyBhbHVtbmkgYW5kIGhhbGYgdGhlIHJlZ2lvbiB3YXRjaGluZy4gQW5kIHdpdGggZXhwZWN0YXRpb25zIHNldCBvbiBOYXRpb25hbHMsIHRoZSBJbGxpbmkgZGVsaXZlcmVkLCB3aW5uaW5nIHRoZSBnYW1lIDE1LTcgYW5kIHB1bmNoaW5nIHRoZWlyIHRpY2tldCB0byBNaWx3YXVrZWUgZm9yIE5hdGlvbmFscy48L3A+XG4gICAgICAgICAgICA8cD5UaGUgdmljdG9yeSB3YXMgYSBodWdlIG9uZSBmb3IgdGhlIHByb2dyYW0gYW5kIGl0IHByb3ZlZCB0byBiZSBhIGh1Z2Ugc3dpbmcgaW4gdGhlIGV2ZW50dWFsIENvYWNoIG9mIHRoZSBZZWFyIGF3YXJkIHdvbiBieSBJbGxpbm9pcyBjb2FjaCwgTWF0dCBTdHVwY2EuIElsbGlub2lzIGVuZGVkIHRoZSB3ZWVrZW5kIDYtMCwgYW5kIHVuYmVsaWV2YWJseSwgb25seSBhbGxvd2VkIDEgYnJlYWsgYWxsIHdlZWtlbmQuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIElsbGluaSB3ZXJlIGhlYWRlZCB0byBOYXRpb25hbHMhISE8L3A+XG4gICAgICAgICAgICA8cD5BZnRlciBmYWlsaW5nIHRvIHJlYWNoIE5hdGlvbmFscyB0aGUgeWVhciBlYXJsaWVyLCBJbGxpbm9pcyByZXR1cm5lZCBhbmQgd2VyZSBzZWVkZWQgMTl0aCBhbW9uZyB0aGUgY29tcGV0aXRpb24uIFRoZSBJbGxpbmksIGhhdmluZyBzdHJ1Z2dsZWQgYWdhaW5zdCB0b3AgY29tcGV0aXRpb24gZWFybGllciBpbiB0aGUgc2Vhc29uLCB3ZXJlIGhpZ2hseSBmb2N1c2VkIGdvaW5nIGludG8gTmF0aW9uYWxzLjwvcD5cbiAgICAgICAgICAgIDxwPlVudXN1YWwgY2lyY3Vtc3RhbmNlcyBhdCBvdGhlciByZWdpb25hbHMgcHV0IHRoZSBJbGxpbmkgaW4gd2hhdCB3YXMgY29uc2lkZXJlZCBvbmUgb2YgdGhlIGJlc3QgTmF0aW9uYWxzIHBvb2xzIGV2ZXIsIFBvb2wgQy4gVGhlaXIgcG9vbCBpbmNsdWRlZCBNYXJ5bGFuZCwgT3JlZ29uLCBGbG9yaWRhIFN0YXRlLCBhbmQgVU5DLiBJbGxpbm9pcyBoYWQgbm90IHBsYXllZCBhbnkgb2YgdGhvc2UgdGVhbXMgZHVyaW5nIHRoZSByZWd1bGFyIHNlYXNvbi48L3A+XG4gICAgICAgICAgICA8cD5UaGUgZmlyc3QgZ2FtZSB3YXMgYWdhaW5zdCBNYXJ5bGFuZCwgd2hvc2Ugc3RhciBwbGF5ZXIgYW5kIENhbGxhaGFuIG5vbWluZWUsIHdhcyBicm90aGVycyB3aXRoIG9uZSBvZiBJbGxpbm9pcycgcm9va2llcy4gVGhlIGdhbWUgd2FzIGhlYXRlZCB0aG91Z2gsIHdpdGggaGlnaGxpZ2h0cyBpbmNsdWRpbmcgYSB3aWxkIHNreSBieSBUeWxlciAnRHV0Y2gnIERlTm9veWVyIGFuZCBhIGhhbmRibG9jayBvZiBNYXJ5bGFuZCdzIHN0YXIgYnkgUHJheWFnIFBhdGVsLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSBnYW1lIGNhbWUgZG93biB0byB0aGUgd2lyZSwgYnV0IHNhdyB0aGUgSWxsaW5pIGFzIHRoZSBzbGltIHZpY3RvcnMgMTUtMTMsIHdpdGggZm9ybWVyIE5hdGlvbmFscyBzY29yaW5nIHRvcC1saXN0ZXIgTmljayBQcm96b3JvdnNreSBjYXRjaGluZyB0aGUgZmluYWwgcG9pbnQgdG8gcHV0IHRoZSBJbGxpbmkgMS0wIG9uIHRoZSB3ZWVrZW5kLiBJdCB3YXMgYSB3aW4gZm9yIHRoZSBJbGxpbmkgdGhhdCBzcG9rZSB2b2x1bWVzIHRvIHRoZSBpZGVhIHRoYXQgdGhleSB0cnVseSBiZWxvbmdlZCB0aGVyZS48L3A+XG4gICAgICAgICAgICA8cD5UaGUgbmV4dCBtYXRjaHVwIHdhcyB1bmRlciB0aGUgbGlnaHRzIG9uIHRoZSBiaWcgZmllbGQgYWdhaW5zdCBVTkMuIElsbGlub2lzIGZhY2VkIGFub3RoZXIgdG9wIGxldmVsIHBsYXllciwgdGhlIGV2ZW50dWFsIENhbGxhaGFuIHdpbm5lciwgSm9uIE5ldGhlcmN1dHQuIE5ldGhlcmN1dHQgYW5kIGhpcyBVTkMgRGFya3NpZGUgc3F1YWQgaGFkIGJlZW4gb25lIG9mIHRoZSBoaWdoZXN0IHJhbmtlZCB0ZWFtcyBnb2luZyBpbnRvIHRoZSB0b3VybmFtZW50IGFuZCBsb29rZWQgZXZlbiBzdHJvbmdlciB3aXRoIHRoZSByZXR1cm4gb2YgdGhlIG1pZ2h0eSBjdXR0ZXIsIEJlbiBTbmVsbC4gPC9wPlxuICAgICAgICAgICAgPHA+Q29uc2lkZXJlZCB0aGUgdW5kZXJkb2dzIGJ5IGZhciwgSWxsaW5vaXMganVtcGVkIG91dCB0byBhIHF1aWNrIDItMCBsZWFkLCBicmVha2luZyB0aGUgc2VlbWluZ2x5IHVuc3RvcHBhYmxlIFVOQyBPLWxpbmUuIFRoZSBlYXJseSBzdGFydCBwcm92ZWQgdG8gYmUgaW1wb3J0YW50IGFzIERhcmtzaWRlIGZvdWdodCBiYWNrIGFuZCB0b29rIHRoZSBoYWxmIGJ5IG9ubHkgb25lIHBvaW50LiBUaGUgZ2FtZSB3YXMgY2xvc2VyIHRoYW4gYW55b25lIGNvdWxkIGhhdmUgcHJlZGljdGVkLjwvcD5cbiAgICAgICAgICAgIDxwPkJ1dCBpdCB3YXMgbm90IGVub3VnaCB0byB0YWtlIGRvd24gdGhlIEF0bGFudGljIENvYXN0IGNoYW1wcywgYXMgRGFya3NpZGUgdG9vayB0aGUgZ2FtZSAxNS0xMi4gTmV0aGVyY3V0dCBwcm92ZWQgdG8gYmUgaHlwZWQgY29ycmVjdGx5LCBidXQgdGhlIElsbGluaSBzdGlsbCBwbGF5ZWQgc3Ryb25nIHJlZ2FyZGxlc3MuPC9wPlxuICAgICAgICAgICAgPHA+RGF5IDIgc2F3IHRoZSBJbGxpbmkgaW4gYSBodWdlIHNwb3RsaWdodCwgZmFjaW5nIE9yZWdvbiBFZ28gdG8gc3RhcnQgdGhlIGRheS4gVGhlIHJvYWQgdG8gTmF0aW9uYWxzIGhhZCBiZWVuIHNoYWt5IGZvciBFZ28sIGFzIHRoZWlyIHN0cnVnZ2xlcyBhdCByZWdpb25hbHMgd2VyZSB0aGUgc29sZSByZWFzb24gdGhleSBoYWQgZXZlbiBiZWVuIHBsYWNlZCBpbnRvIFBvb2wgQyBhcyB0aGUgc2hvY2tpbmcgMTUgc2VlZC4gVGhleSBzYXQgMC0yIG9uIHRoZSB3ZWVrZW5kLCBhbmQgd2VyZSBpbiBhIGRvLW9yLWRpZSBzaXR1YXRpb24gZm9yIHRoZWlyIHNlYXNvbi4gRml0dGluZ2x5LCB0aGUgSWxsaW5pIG1hdGNoZWQgdXAgYWdhaW5zdCB0aGVtIHdpdGggYSBjaGFuY2UgdG8gZW5kIHRoZWlyIHNlYXNvbiwgYW5kIGEgY2hhbmNlIHRvIGVuZCB0aGUgY29sbGVnZSBjYXJlZXIgb2Ygb25lIG9mIHRoZSBnYW1lcycgbW9zdCB3ZWxsLWtub3duIHBsYXllcnMsIER5bGFuIEZyZWVjaGlsZC48L3A+XG4gICAgICAgICAgICA8cD5GcmVlY2hpbGQgYW5kIHRoZSBhbXBlZCB1cCBFZ28gc3F1YWQgY2FtZSBvdXQgc3Ryb25nLCB0YWtpbmcgYW4gZWFybHkgYW5kIGNvbW1hbmRpbmcgbGVhZC4gVGhlcmUgd2VyZSBzb21lIGdsaW1tZXJzIG9mIGhvcGUgZm9yIElsbGlub2lzLCBidXQgbm9uZSBwcm92ZWQgc3Ryb25nIGVub3VnaCB0byBnZXQgdGhlbSBjbG9zZSwgYXMgRWdvIHdvbiB0aGUgZ2FtZSBoYW5kaWx5IDE1LTcuIFRoaXMgcHV0IHRoZSBJbGxpbmkgYXQgMS0yLCBhbmQga2VwdCB0aGUgc2Vhc29uIGFsaXZlIGZvciBPcmVnb24uPC9wPlxuICAgICAgICAgICAgPHA+VGhlIGZpbmFsIGdhbWUgb2YgcG9vbCBwbGF5IGNhbWUgYWdhaW5zdCBDaHJpcyBMYXJvcXVlIGFuZCBGbG9yaWRhIFN0YXRlLiBBIHllYXIgZWFybGllciwgSWxsaW5vaXMgaGFkIGxvc3QgYSB0b3VnaCBnYW1lIG9uIGRvdWJsZSBnYW1lIHBvaW50IGFnYWluc3QgRlNVIGF0IEVhc3Rlcm5zLiBJbGxpbm9pcyB5ZXQgYWdhaW4gd2FzIGEgaGVhdnkgdW5kZXJkb2cuIFRoZXkgbWFuYWdlZCB0byBrZWVwIGl0IGNsb3NlIGZvciBtb3N0IHRoZSBnYW1lLCBidXQgRlNVJ3Mgc3Rhci1zdHVkZGVkIHRlYW0gcHJvdmVkIHRvbyBzdHJvbmcgYXMgRlNVIHRvb2sgdGhlIGdhbWUgMTUtMTEuIEl0IHdhcyBhbm90aGVyIGdhbWUgdmVyeSBjbG9zZSBhdCBoYWxmIGZvciBJbGxpbm9pcywgd2hpY2ggd2FzIHByb21pc2luZy4gVGhlIGxvc3Mgd291bGQgcHV0IElsbGlub2lzIG91dCBvZiBjb250ZW50aW9uIHRvIG1vdmUgaW50byB0aGUgbmV4dCByb3VuZCBvZiBwbGF5LjwvcD5cbiAgICAgICAgICAgIDxwPkluIHRoZSBmaW5hbCBnYW1lIG9mIHRoZSBzZWFzb24sIElsbGlub2lzIHdvdWxkIHBsYXkgQ2luY2lubmF0aS4gV2l0aCBhIHdpbiwgdGhleSB3b3VsZCBjbGFpbSBhIHRpZSBmb3IgMTN0aCBwbGFjZS4gV2l0aCBhIGxvc3MsIHRoZXkgd291bGQgZmluaXNoIDE3dGggYXQgTmF0aW9uYWxzIGZvciB0aGUgNXRoIHRpbWUgaW4gYSByb3csIHBlcmhhcHMgcHJvdmluZyB0aGUgJ2N1cnNlIG9mIElsbGlub2lzLXRoIHBsYWNlJyB0byBiZSB0cnVlLjwvcD5cbiAgICAgICAgICAgIDxwPkJ1dCB0aGUgSWxsaW5pIGhhZCBubyBwbGFucyB0byBzZXR0bGUgZm9yIHRoYXQsIGFzIHRoZXkgdG9vayB0aGUgZ2FtZSAxNS0xMiB3aXRoIGEgYml0IG9mIGEgbGF0ZSBzdXJnZS4gVGhlIGdhbWUgcHJvdmVkIHRvIGJlIGFuIElsbGluaSBjbGFzc2ljLCB3aXRoIGEgZ29hbCBsaW5lIEQgYnkgTWFyayBQZXRlcnNvbiBhbmQgYSBib29rZW5kcyBwb2ludCBmcm9tIEthbnp5LiBUaGUgd2luIHdhcyB0b3BwZWQgb2ZmIHdpdGggTmljayBQcm96b3JvdnNreSBjYXRjaGluZyB0aGUgZ2FtZSB3aW5uaW5nIGNhdGNoLCBzZW5kaW5nIHRoZSBmYW5zIGhvbWUgaGFwcHkgYW5kIGVuZGluZyBhbiBleGNlbGxlbnQgSWxsaW5vaXMgc2Vhc29uLjwvcD5cbiAgICAgICAgICAgIDxwPklsbGlub2lzIGJyb2tlIHRoZSAnY3Vyc2UnIGFuZCBmaW5pc2hlZCAxM3RoLCB0aGVpciBiZXN0IE5hdGlvbmFscyBwZXJmb3JtYW5jZSBzaW5jZSAyMDA4LjwvcD5cbiAgICAgICAgICAgIDxwPk5vdCBzdXJwcmlzaW5nbHksIHRocmVlIG9mIHRoZSBmaW5hbCBmb3VyIHRlYW1zIHdlcmUgZnJvbSBQb29sIEMsIGFuZCB0aGUgY2hhbXBpb25zaGlwIHNhdyBVTkMgbWF0Y2ggdXAgYWdhaW5zdCBPcmVnb24uIFVOQyB3b3VsZCB3aW4gYWdhaW4sIGJsb3dpbmcgb3V0IE9yZWdvbiAxNS02LiBJbiB0aGUgZW5kLCBpdCB3YXMgYWN0dWFsbHkgSWxsaW5vaXMgd2hvIGhhZCBwdXQgdGhlIG1vc3QgcG9pbnRzIHVwIG9uIHRoZSBldmVudHVhbCBjaGFtcGlvbnMsIHdpdGggMTIgcG9pbnRzLiBOaWNrIFByb3pvcm92c2t5IGZpbmlzaGVkIHBvb2wgcGxheSB0aWVkIGZvciB0aGUgbGVhZCBpbiBnb2FscyBzY29yZWQgYXQgMjQuIE1vc3QgaW1wb3J0YW50bHksIElsbGlub2lzIGJyb2tlIHNlZWQsIGdhaW5pbmcgdGhlIHJlc3BlY3QgZGVzZXJ2ZWQgYW5kIGFjaGlldmluZyB0aGVpciBnb2Fscy4gVGhlIDEzIHNlbmlvcnMgbGVhdmluZyB3ZXJlIHNlbnQgaG9tZSBoYXBweS48L3A+XG4gICAgICAgICAgICA8cD5NYXR0IFdlc3QgYW5kIE5pY2sgUHJvem9yb3Zza3kgd29uIDFzdCB0ZWFtIGFsbCByZWdpb24gaG9ub3JzLiBLZXZpbiBMaW4gd29uIEZyZXNobWFuIG9mIHRoZSBSZWdpb24uIFRoZSBNYXR0IFN0dXBjYSBkZXNlcnZlZGx5IHdvbiBDb2FjaCBvZiB0aGUgeWVhci48L3A+XG4gICAgICAgIGBcbiAgICB9LHtcbiAgICAgICAgeWVhcjogMjAxNCxcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDE0LmpwZycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPklsbGlub2lzIGVudGVyZWQgdGhlIHNlYXNvbiBob3BpbmcgdG8gcmV0dXJuIHRvIE5hdGlvbmFscy4gVGhlIHRlYW0gbG9zdCAzIHRpbWUgY2FwdGFpbiBhbmQgUGxheWVyIG9mIHRoZSBSZWdpb24sIFJ5YW4gJ0tlbm5lZHknIFNtaXRoLiBSZXR1cm5pbmcgY2FwdGFpbiBhbmQgTWFjaGluZSBzdGFyIE5lYWwgUGhlbHBzIHdhcyBqb2luZWQgYnkgZmlyc3QgdGltZSBqdW5pb3IgY2FwdGFpbnMgTWFydHkgTWFya2Vuc29uIGFuZCBFcmljIEJ1bHRtYW4uIFRoZSBjYXB0YWluaW5nIHRlYW0gd2FzIHlvdW5nIGFuZCBpbmV4cGVyaWVuY2VkIGJ1dCBXYWxkZW4gTmVsc29uIHJldHVybmVkIGdpdmluZyB0aGUgdGVhbSBob3BlLjwvcD5cbiAgICAgICAgICAgIDxwPkF0IE1MQyB0aGUgdGVhbSB3YXMgYWJsZSB0byBleGNlZWQgZXhwZWN0YXRpb25zIGJ5IGZpbmlzaGluZyBpbiAybmQgcGxhY2UsIGxvc2luZyB0byB0aGUgZXZlbnR1YWwgTmF0aW9uYWwgQ2hhbXBpb25zIENvbG9yYWRvIE1hbWFiaXJkIGluIHRoZSBmaW5hbHMuIFRoaXMgd2luIGluIGFkZGl0aW9uIHRvIHRoZSBwcmV2aW91cyB5ZWFyJ3MgbmF0aW9uYWxzIGJpcnRoIGdhdmUgdGhlIHRlYW0gYSBjb2NraW5lc3MgdGhleSB3ZXJlIHVuYWJsZSB0byBzaGVkLjwvcD5cbiAgICAgICAgICAgIDxwPlRoZSBzcHJpbmcgc2NoZWR1bGUgd2FzIGEgd2VhayBvbmUgY29tcGFyZWQgdG8geWVhcnMnIHBhc3QuIFRoZSB0ZWFtIG9ubHkgYXR0ZW5kZWQgdHdvIHRvdXJuYW1lbnRzLCBIdWNrIEZpbm4gYW5kIEVhc3Rlcm5zLiBUaGUgdGVhbSB3YXMgYWJsZSB0byBlYXNpbHkgd2luIEthdCBGaWdodCB3aGljaCBmdXJ0aGVyIGJvb3N0ZWQgdGhlIHRlYW0ncyBlZ28uIEF0IEVhc3Rlcm5zIHRoZXkgZmVsbCBzaG9ydCBpbiBQb29sIHBsYXkgbG9zaW5nIHRvIFBpdHQsIEZsb3JpZGEgU3RhdGUsIEx1dGhlciwgYW5kIENlbnRyYWwgRmxvcmlkYS4gQnV0IHdvbiAxM3RoIHBsYWNlIHdpdGggd2lucyBhZ2FpbnN0IE1hc3NhY2h1c2V0dHMgYW5kIEx1dGhlci48L3A+XG4gICAgICAgICAgICA8cD5JbGxpbm9pcyB3YXMgYWJsZSB0byBjb21mb3J0YWJsZSB3aW4gdGhlIElsbGlub2lzIENvbmZlcmVuY2UgQ2hhbXBpb25zaGlwcyB3aXRoIGEgd2luIGluIHRoZSBmaW5hbHMgb3ZlciBOb3J0aHdlc3Rlcm4uIFRoZSBHcmVhdCBMYWtlcyBlYXJuZWQgdHdvIGJpZHMgdG8gbmF0aW9uYWxzIHRoYW5rcyB0byBOb3J0aHdlc3Rlcm4gYW5kIE1pY2hpZ2FuLiBJbGxpbm9pcyB3b24gdGhlaXIgcG9vbCBhbmQgc2V0IHRoZW1zZWx2ZXMgdXAgZm9yIGEgc2hvdCBhdCBOYXRpb25hbHMuIE5vcnRod2VzdGVybiBsZWFybmVkIGZyb20gdGhlaXIgQ29uZmVyZW5jZSBsb3NzIGFuZCB3YXMgYWJsZSB0byBhZGFwdCB0byBzbG93IGRvd24gdGhlIElsbGlub2lzIG9mZmVuc2UgZm9yY2luZyBJbGxpbm9pcyB0byBmaWdodCB0aHJvdWdoIHRoZSBiYWNrZG9vci4gVGhleSBuZXh0IHBsYXllZCBDaGljYWdvIGluIGEgd2luZHkgZ2FtZSBpbiB3aGljaCBib3RoIHRlYW1zIGF0dGVtcHRlZCB0byBzY29yZSB3aXRoIDUwLzUwIHNob3RzLiBUaGVzZSBjb25kaXRpb25zIHN0b3BwZWQgSWxsaW5vaXMnIGhpZ2ggc3BlZWQgb2ZmZW5zZSBhbmQgZ2F2ZSBDaGljYWdvIGEgY2hhbmNlIHRvIGhhdmUgbWFueSBvcHBvcnR1bml0aWVzIG9uIGRlZmVuc2UuIENoaWNhZ28gZmluYWxseSBmaW5pc2hlZCB0aGUgZ2FtZSB3aXRoIGEgc3RhbGwgOSBqdW1wIGJhbGwgaW4gdGhlIGVuZHpvbmUgZmluaXNoaW5nIElsbGlub2lzJyBzZWFzb24uPC9wPlxuICAgICAgICBgXG4gICAgfSx7XG4gICAgICAgIHllYXI6IDIwMTMsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAxMy5qcGcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5BZnRlciB0aGUgZGlzYXBwb2ludGluZyBhbmQgaGVhcnRicmVha2luZyBmaW5pc2ggaW4gMjAxMiwgSWxsaW5vaXMgbG9zdCBhIGh1Z2UgY2h1bmsgb2YgdmV0ZXJhbiB0YWxlbnQgYW5kIGhhZCB0byByZWxvYWQgZm9yIDIwMTMuIFJ5YW4gU21pdGggd2FzIGNhcHRhaW4gZm9yIHRoZSAzcmQgeWVhciBpbiBhIHJvdyBhbmQgd2FzIGpvaW5lZCBieSB0aHJlZSBmaXJzdCB5ZWFyIGNhcHRhaW5zIGluIE5lYWwgUGhlbHBzLCBDb2xpbiBSZWlkIGFuZCBOYXRoYW4gR2liYm9ucy4gVGhlIGNhcHRhaW5zIGFuZCB0aGUgc2VuaW9ycyBvbiB0aGUgdGVhbSB1c2VkIHRoZSBwcmV2aW91cyB5ZWFyJ3MgZmluaXNoIGFzIG1vdGl2YXRpb24gYW5kIHNldCB0aGUgdG9uZSBhdCBwcmFjdGljZXMgdGhyb3VnaG91dCB0aGUgd2hvbGUgeWVhci48L3A+ICAgIFxuICAgICAgICAgICAgPHA+VHJ5b3V0cyB3ZXJlIGNvbXBsZXRlZCBzaG9ja2luZ2x5IGVhcmx5IGZvciB0aGUgMm5kIHllYXIgaW4gYSByb3cuIFdpdGggc28gbWFueSBvcGVuIHNwb3RzLCBJbGxpbm9pcyB3YXMgZm9ydHVuYXRlIHRvIHJlY2VpdmUgYSB2ZXJ5IGRlZXAgYW5kIHRhbGVudGVkIGZyZXNobWFuIGNsYXNzLiBGaXZlIGZyZXNobWFuIG1hZGUgdGhlIEEtdGVhbSwgd2l0aCB0aHJlZSBvZiB0aGVtIGFsbCBjb21pbmcgZnJvbSB0aGUgc2FtZSBoaWdoIHNjaG9vbC4gQSBsYXJnZSBjaHVuayBvZiB0aGUgdGVhbSB3ZXJlIHN0ZXBwaW5nIGludG8gbmV3IHJvbGVzIG9yIHdlcmUgbmV3IHRvIGNvbGxlZ2UgdWx0aW1hdGUgYWx0b2dldGhlci4gVGhleSB3b3VsZCBiZSBmb3JjZWQgdG8gYWNjbGltYXRlIGFuZCBhZGp1c3QgcXVpY2tseSBpZiBJbGxpbm9pcyB3ZXJlIHRvIG1lZXQgaXQncyBnb2FscyBmb3IgdGhlIHllYXIuPC9wPiAgICBcbiAgICAgICAgICAgIDxwPkF0IEh1Y2sgRmlubiwgSWxsaW5vaXMgY2FtZSBpbiB2ZXJ5IG92ZXIgY29uZmlkZW50IGFuZCB3ZXJlIHB1bmlzaGVkIGJ5IHRoZSBmcmlzYmVlIGdvZHMgZm9yIHRoZWlyIGh1YnJpcy4gVGhleSB0aG91Z2h0IHRoZXkgY291bGQgd2FsayBpbnRvIHRoZSB0b3VybmFtZW50IGFuZCBkbyB3ZWxsLiBUaGV5IGdvdCBhIGh1Z2Ugd2FrZSB1cCBjYWxsIG9uIFNhdHVyZGF5IHdpdGggdGhyZWUgbG9zc2VzIGluY2x1ZGluZyBhIHBvdGVudGlhbCBjYW5kaWRhdGUgZm9yIHdvcnN0IGxvc3Mgb2YgdGhlIHByb2dyYW0uIEFub3RoZXIgYmxlbWlzaCBvbiBDb2FjaCBXYWxkZW4gTmVsc29uJ3MgY29hY2hpbmcgcmVjb3JkLiBJbGxpbm9pcyB1c2VkIHRoZWlyIHBlcmZvcm1hbmNlIG9uIFNhdHVyZGF5IG9mIEh1Y2sgRmlubiBhcyBjYXVzZSBmb3IgcGVuYW5jZSBhbmQgdG91Z2hlZCBvdXQgYW4gdW5kZWZlYXRlZCBTdW5kYXkgdGhyb3VnaCBhdHJvY2lvdXMgd2VhdGhlciBjb25kaXRpb25zLjwvcD4gICAgXG4gICAgICAgICAgICA8cD5UaGUgbmV4dCB3ZWVrZW5kIGF0IENlbnRleCwgSWxsaW5vaXMgY2FtZSBvdXQgd2l0aCBhIHJlbmV3ZWQgZm9jdXMgYW5kIHNlbnNlIG9mIHVyZ2VuY3kuIFRoZXkgZ3JpdHRlZCBvdXQgYSBzZW1pZmluYWxzIGZpbmlzaCBpbmNsdWRpbmcgc3BsaXR0aW5nIHR3byB1bml2ZXJzZSBwb2ludCBnYW1lcyBhZ2FpbnN0IEhhcnZhcmQuIFRoaXMgdG91cm5hbWVudCBnYXZlIHBlb3BsZSBvbiB0aGUgdGVhbSByZWFzb24gdG8gYmVsaWV2ZSBhbmQgc2hvd2VkIHdoYXQgdGhlIHRlYW0gd2FzIGNhcGFibGUgb2YuPC9wPiAgICBcbiAgICAgICAgICAgIDxwPlNlY3Rpb25hbHMgd2FzIGhlbGQgaW4gQ2hpY2Fnby4gVGhlcmUgd2VyZSBzb21lIHRvdWdoIGdhbWVzLCBidXQgSWxsaW5vaXMgd29uIHRoZWlyIHRoaXJkIGNvbnNlY3V0aXZlIGNvbmZlcmVuY2UgY2hhbXBpb25zaGlwLiBBZnRlciB3aW5uaW5nIHRoZSB0b3VybmFtZW50LCBJbGxpbm9pcyBkaWQgaGlsbCBzcHJpbnRzIHRvIGhlbHAgZ2V0IG1lbnRhbGx5IHByZXBhcmVkIGZvciB0aGUgYmxvb2RiYXRoIG9mIGEgMSBiaWQgcmVnaW9uLjwvcD4gICAgXG4gICAgICAgICAgICA8cD5JbGxpbm9pcyBjYW1lIGludG8gUmVnaW9uYWxzIGFzIHRoZSAjMiBzZWVkIGFuZCBrbmV3IHdoYXQgdGhleSBoYWQgdG8gZG8uIEp1c3QgbGlrZSAyMDExLCB0aGUgZm9ybWF0IHdhcyBwb29sIHBsYXkgb24gU2F0dXJkYXkgd2l0aCBicmFja2V0IHBsYXkgb24gU3VuZGF5LiBUaGUgZmlyc3QgdHdvIGdhbWVzIHdlcmUgY29tZm9ydGFibGUgdmljdG9yaWVzLiBUaGUgdGhpcmQgcG9vbCBwbGF5IGdhbWUgYWdhaW5zdCBJbmRpYW5hIHdhcyBhIGJhY2sgYW5kIGZvcnRoIGFmZmFpci4gSW5kaWFuYSBsZWQgbGF0ZSBpbiB0aGUgZ2FtZSwgYnV0IG9uIGxvbmcgdHVybi1maWxsZWQgdW5pdmVyc2UgcG9pbnQsIElsbGlub2lzIGdyb3VuZCBvdXQgYSB0b3VnaCB3aW4uPC9wPiAgICBcbiAgICAgICAgICAgIDxwPlN1bmRheSBtb3JuaW5nLCBJbGxpbm9pcyBjYW1lIG91dCB2ZXJ5IGhvdCBhbmQgcGxheWVkIGV4dHJlbWVseSB3ZWxsIGluIGEgZ29vZCB3aW4gb3ZlciB1cCBhbmQgY29taW5nIE5vcnRod2VzdGVybi4gSW4gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIFJlZ2lvbmFsIHNlbWktZmluYWwgYWdhaW5zdCBNU1UsIElsbGlub2lzIGNvdWxkIG5vdCBjb250aW51ZSB0aGVpciBnb29kIHBsYXkuIFRoZSBPbGluZSBzdHJ1Z2dsZWQgbWlnaHRpbHkgd2l0aCBleGVjdXRpb24gZXJyb3JzIGZyb20gdGhlIHlvdW5nZXIgcGxheWVycyBvbiB0aGUgbGluZS4gVGhlIGZpcnN0IGhhbGYgc2NvcmUgd2FzIDUtOCBNU1UuIEVhcmx5IGluIHRoZSBzZWNvbmQgaGFsZiwgdGhpcyB3b3JyeWluZyB0cmVuZCBjb250aW51ZWQgYW5kIHRoZSBzY29yZSB3ZW50IHRvIDYtMTAgTVNVLiBXaGVuIHRoaW5ncyB3ZXJlIGxvb2tpbmcgZGlyZSwgdGhlIHNvb24gdG8gYmUgZ3JhZHVhdGluZyBwbGF5ZXJzIHJlZnVzZWQgdG8gZ28gZG93biB3aXRob3V0IGEgZmlnaHQuIEJpZyBwbGF5cyBmcm9tIFByZXN0b24gR291bHNvbiBhbmQgVHlsZXIgQW5kZXJzb24gZnVlbGVkIGEgZnVyaW91cyBJbGxpbm9pcyBjb21lYmFjayBoaWdobGlnaHRlZCBieSBhIGJpZyBza3kgZnJvbSBCcmlhbiBSYXRodW5kZS4gSWxsaW5vaXMgcHVsbGVkIG91dCBhIHN0dW5uaW5nIDE0LTExIHdpbiBvdmVyIE1TVS4gVGhpcyBzZXQgdXAgdGhlIGNsYXNzaWMgR3JlYXQgTGFrZSBSZWdpb25hbHMgbWF0Y2h1cCBiZXR3ZWVuIElsbGlub2lzIGFuZCBNaWNoaWdhbi4gRm9yIHRoZSBmaXJzdCB0aW1lIHNpbmNlIDIwMDgsIHRoaXMgbWF0Y2h1cCB3b3VsZCBiZSBmb3IgdGhlIFJlZ2lvbmFsIHRpdGxlIGFuZCB0aGUgc29sZSBiaWQgdG8gTmF0aW9uYWxzLiBJbGxpbm9pcyBtYWludGFpbmVkIGEgdmVyeSBzbGltIGxlYWQgdGhyb3VnaG91dCB0aGUgZ2FtZS4gVGhlIE9saW5lIHBsYXllZCB2ZXJ5IGNhbG1seSBldmVuIHdpdGggaW5jcmVhc2VkIHByZXNzdXJlIGZyb20gTWljaGlnYW4uIExhdGUgaW4gdGhlIGdhbWUsIElsbGlub2lzIHB1bGxlZCBvdXQgYSBjb3VwbGUgYnJlYWtzIGFuZCBlbmRlZCB0aGUgZ2FtZSBvbiBhIGQgYW5kIHN1YnNlcXVlbnQgc2NvcmUgYnkgSm9uIE1jS295LiBJbGxpbm9pcyByZXR1cm5lZCB0byBOYXRpb25hbHMgYXMgdGhlIHNvbGUgcmVwcmVzZW50YXRpdmUgb2YgdGhlIEdyZWF0IExha2VzLiBSeWFuIFNtaXRoIHdvbiBQbGF5ZXIgb2YgdGhlIFJlZ2lvbiBob25vcnMsIE5lYWwgUGhlbHBzLCBOYXRoYW4gR2liYm9ucyBlYXJuZWQgRmlyc3QgVGVhbSBBbGwtUmVnaW9uIGF3YXJkcywgQnJhZCBCb2xsaWdlciBlYXJuZWQgYSBTZWNvbmQgVGVhbSBhbmQgTmljayBQcm96b3JvdnNreSwgSm9obm55IFNhbmlhdCBhbmQgRGVyZWsgWWFuIGVhcm5lZCBGcmVzaG1hbiB0ZWFtIGF3YXJkcy48L3A+ICAgIFxuICAgICAgICAgICAgPHA+VW5mb3J0dW5hdGVseSBhdCBOYXRpb25hbHMsIElsbGlub2lzIGNvdWxkIG5vdCBicmVhayB0aGUgMTd0aCBwbGFjZSBjdXJzZS4gU29tZSBrZXkgcGxheWVycyB3ZXJlIHVuYWJsZSB0byBwbGF5LiBJbGxpbm9pcyBnYW1lbHkgdHJpZWQgdG8gZmlnaHQgb24gYnV0IGp1c3QgY291bGQgbm90IG92ZXJjb21lIHRoZWlyIGRlcGxldGVkIHBlcnNvbm5lbC4gSW4gYSB1bnN1cnByaXNpbmcgdHVybiBvZiBldmVudHMsIElsbGlub2lzIGZpbmlzaGVkIDE3dGggYXQgTmF0aW9uYWxzLjwvcD4gICAgXG4gICAgICAgIGBcbiAgICB9LHtcbiAgICAgICAgeWVhcjogMjAxMixcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDEyLmpwZycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPkZvciB0aGUgZmlyc3QgdGltZSBzaW5jZSAyMDA4LCBJbGxpbm9pcyByZXR1cm5lZCBhIG1ham9yaXR5IG9mIHRoZSB0ZWFtIGFuZCBoYWQgaGlnaCBleHBlY3RhdGlvbnMgZ29pbmcgaW50byB0aGUgc2Vhc29uLiBNYWpvciBwZXJzb25uZWwgbG9zc2VzIGluY2x1ZGVkIDItdGltZSBjYXB0YWluIEF1c3RpbiBMaWVuIGFuZCAzLXllYXIgTy1saW5lIHN0YXJ0ZXIgQ2hyaXMgSGlkYWthLiBaYWNoIEZyYW50eiBhbmQgUnlhbiBTbWl0aCByZXR1cm5lZCBhcyBjYXB0YWlucyBhbmQgd2VyZSBqb2luZWQgYnkgS2V2aW4gQnJ1bnMuIFdpdGggc3VjaCBhIGxhcmdlIG51bWJlciBvZiByZXR1cm5pbmcgQS10ZWFtZXJzLCB0cnlvdXRzIHdlcmUgYXMgY29tcGV0aXRpdmUgYXMgZXZlciBhbmQgdGhlcmUgd2VyZSBtYW55IHBlb3BsZSBmaWdodGluZyBmb3IgdGhlIGZldyByZW1haW5pbmcgc3BvdHMuIEFmdGVyIGZvbGxvd2luZyB0aGUgSWxsaW5vaXMgdHJhZGl0aW9uIG9mIG1ha2luZyBmaW5hbCBjdXRzIHJlYWxseSBsYXRlLCAzIGZyZXNobWVuIGhhZCBtYWRlIHRoZSBBLXRlYW0sIHdoaWNoIGhhZG4ndCBoYXBwZW5lZCBzaW5jZSAyMDA5LjwvcD4gICAgXG4gICAgICAgICAgICA8cD5Gb3Igc3VjaCBhIHZldGVyYW4gdGVhbSwgZm9jdXMgYW5kIHVyZ2VuY3kgd2FzIGxhY2tpbmcgZHVyaW5nIHRoZSBzZWFzb24uIFRoZXJlIHdlcmUgbWFueSB0aW1lcyB3aGVyZSBwZW9wbGUgd291bGQgYmUgZ29pbmcgdGhyb3VnaCB0aGUgbW90aW9ucyBhbmQgbm90IGdldHRpbmcgdGhlIG1vc3Qgb2YgdGhlIHByYWN0aWNlLiBVbmxpa2UgcGFzdCB5ZWFycywgd2hlbiB0aGUgc2VuaW9yIGNsYXNzIHdvdWxkIHNldCB0aGUgdG9uZSBmb3IgYWxsIHRoZWlyIHlvdW5nZXIgdGVhbW1hdGVzLCB0aGlzIHllYXIgc2F3IGEgcmlmdCBvcGVuIHVwIGJldHdlZW4gdGhlIHNlbmlvcnMgYW5kIHRoZSB5b3VuZ2VyIG1lbWJlcnMgb2YgdGhlIHRlYW0uIFRoaXMgcmlmdCBtYW5pZmVzdGVkIGl0c2VsZiBpbiBtYW55IHdheXMgdGhyb3VnaG91dCB0aGUgc2Vhc29uLCBidXQgaXQgY2FtZSB0byBhIGhlYWQgYXQgQ2VudGV4IHdoZXJlIGEgdGVhbSBtZWV0aW5nIHdhcyBoZWxkIFNhdHVyZGF5IG5pZ2h0IGFmdGVyIHBvb2wgcGxheSBhbmQgdHdvIGp1bmlvcnMgc3Bva2UgdG8gYWxsIHRoZSBzZW5pb3JzIGFuZCB0b2xkIHRoZW0gdG8gZ2V0IHRoZWlyIGFjdCB0b2dldGhlci48L3A+ICAgIFxuICAgICAgICAgICAgPHA+V2l0aCBoaWdoIGV4cGVjdGF0aW9ucyBnb2luZyBpbnRvIHRoZSBzZWFzb24sIElsbGlub2lzIHNjaGVkdWxlZCBhIG1vcmUgY29tcGV0aXRpdmUgdG91cm5hbWVudCBzY2hlZHVsZSB0aGFuIGluIDIwMTEgYW5kIHdlbnQgdG8gRWFzdGVybnMgYW5kIENlbnRleCB0d28gdG91cm5hbWVudHMgd2l0aCBzZXZlcmFsIE5hdGlvbmFscyBjb250ZW5kZXJzIGluIGFkZGl0aW9uIHRvIHRoZSBlYXJseSBzZWFzb24gdG91cm5hbWVudCBGcmVlIFN0YXRlIENsYXNzaWMuIFdpdGggYWxsIHRoZSBkcmFtYSBnb2luZyBvbiBiZWhpbmQgY2xvc2VkIGRvb3JzLCBJbGxpbm9pcyBoYWQgYW4gdXAgYW5kIGRvd24gdG91cm5hbWVudCBwZXJmb3JtYW5jZSB3aXRoIHNvbWUgdW5jaGFyYWN0ZXJpc3RpYyBiaWcgbG9zc2VzLiBBdCBGcmVlIFN0YXRlLCBJbGxpbm9pcyBzdHJ1Z2dsZWQgdG8gcGxheSBpbiB0aGUgd2luZCBhZ2FpbnN0IElvd2EgYW5kIGxvc3QgdG8gdGhlbSB0d2ljZSwgb25jZSBvbiBTYXR1cmRheSBhbmQgYWdhaW4gaW4gdGhlIEZpbmFsLiBBdCBDZW50ZXgsIElsbGlub2lzIHBsYXllZCBJb3dhIGFnYWluIGFuZCBjYW1lIG91dCBob3QgYW5kIHRvb2sgYSAzLTAgbGVhZCwgYnV0IHRoYXQgcXVpY2tseSBkaXNhcHBlYXJlZCBhbmQgSW93YSB3b24gYWdhaW4gaW4gZG9taW5hdGluZyBmYXNoaW9uLiBUaGlzIGJsZWQgaW50byB0aGUgbW9zdCBkaXNwaXJpdGluZyBwZXJmb3JtYW5jZSBieSBJbGxpbm9pcyBpbiBtYW55IHllYXJzLCBhcyB0aGV5IHByb2NlZWRlZCB0byBiZSBibGFua2VkIGluIHRoZSBmaXJzdCBoYWxmIGJ5IFR1ZnRzLiBBZnRlciBwbGF5IGVuZGVkLCB0aGUgYWZvcmVtZW50aW9uZWQgdGVhbSBtZWV0aW5nIHdhcyBoZWxkLiBTdW5kYXkgb2YgQ2VudGV4LCBJbGxpbm9pcyBjYW1lIG91dCByZWludmlnb3JhdGVkIGFuZCBwbGF5ZWQgYSBjbG9zZSBnYW1lIHdpdGggTHV0aGVyIGJ1dCBldmVudHVhbGx5IGxvc3Qgb24gdW5pdmVyc2UuIFRoZSBmb2xsb3dpbmcgd2Vla2VuZCBhdCBFYXN0ZXJucywgSWxsaW5vaXMgcGxheWVkIG11Y2ggbW9yZSBjb25zaXN0ZW50bHkgYW5kIGxvc3QgdHdpY2UsIG9uY2UgdG8gZXZlbnR1YWwgY2hhbXBpb25zIFBpdHRzYnVyZ2ggYW5kIGFnYWluIG9uIHVuaXZlcnNlIHRvIFR1ZnRzLiBCdW95ZWQgYnkgdGhlaXIgRWFzdGVybnMgcmVzdWx0cywgSWxsaW5vaXMgbG9va2VkIGFoZWFkIHRvIHRoZSBzZXJpZXMgYW5kIGEgcmV0dXJuIHRvIE5hdGlvbmFscy48L3A+ICAgIFxuICAgICAgICAgICAgPHA+VGhlIHRoaXJkIGFubnVhbCBhbHVtbmkgZ2FtZSB3YXMgaGVsZCwgYW5kIHRoZSBhbHVtbmkgZXh0ZW5kZWQgdGhlaXIgd2lubmluZyBzdHJlYWsgdG8gdHdvIGdhbWVzIGFmdGVyIGEgZGlzbWFsIHBlcmZvcm1hbmNlIGJ5IHRoZSBjb2xsZWdlIGtpZHMuIEFmdGVyIHRha2luZyBoYWxmIDgtNSwgdGhlIGNvbGxlZ2UgdGVhbSBzZWVtZWQgdG8gdGhpbmsgdGhlIGdhbWUgd2FzIG92ZXIgYW5kIGRpZCBub3QgdHJ5IGFzIGhhcmQgYXMgdGhlIG9sZGVyLCBtb3JlIG91dCBvZiBzaGFwZSBhbHVtbmkuIFVuZm9ydHVuYXRlbHksIHRoZSBsZXNzb25zIGZyb20gdGhlIGFsdW1uaSBnYW1lIHdvdWxkIG5vdCBiZSByZW1lbWJlcmVkIGxhdGVyIGluIHRoZSBzZWFzb24uPC9wPiAgICBcbiAgICAgICAgICAgIDxwPlNlY3Rpb25hbHMgb25jZSBhZ2FpbiB3ZXJlIGhlbGQgaW4gUmFudG91bCBhbmQgbGlrZSBldmVyeSBvdGhlciB0b3VybmFtZW50IHRoYXQgaGFzIGV2ZXIgYmVlbiBoZWxkIHRoZXJlLCB0aGUgd2VhdGhlciB3YXMgdGVycmlibGUuIFNhdHVyZGF5IHdhcyBjb2xkLCB3aW5keSwgYW5kIHdldCBhbmQgSWxsaW5vaXMgdG9vayBjYXJlIG9mIGJ1c2luZXNzIHdpbm5pbmcgZXZlcnkgZ2FtZSBoYW5kaWx5LiBTdW5kYXkgd2FzIHN1bm55IGFuZCB2ZXJ5IHdpbmR5IGFuZCBhZnRlciBnb2luZyB1cCBieSBhIGxvdCBvbiBOb3J0aHdlc3Rlcm4sIElsbGlub2lzIGxvc3QgdGhlaXIgZm9jdXMgYW5kIGxldCB0aGVtIGJhY2sgaW50byB0aGUgZ2FtZS4gSWxsaW5vaXMgZXZlbnR1YWxseSBjbG9zZWQgaXQgb3V0IGFuZCB3b24gYnkgYSBmZXcgcG9pbnRzLjwvcD4gICAgXG4gICAgICAgICAgICA8cD5MaWtlIHRoZSBwYXN0IHRocmVlIHllYXJzLCBJbGxpbm9pcyB3YXMgY291bnRpbmcgb24gYmVpbmcgYWJsZSB0byBmbGlwIHRoZSBzd2l0Y2ggYW5kIHBsYXkgdGhlaXIgYmVzdCB1bHRpbWF0ZSBvZiB0aGUgc2Vhc29uIGF0IFJlZ2lvbmFscy4gV2l0aCB0d28gYmlkcyB0byBOYXRpb25hbHMsIHRoZSBiZXN0IGZvcm1hdCBhbmQgUmVnaW9uYWxzIGJlaW5nIGhlbGQgaW4gTmFwZXJ2aWxsZSwgY29uZmlkZW5jZSB3YXMgdmVyeSBoaWdoIHRoYXQgSWxsaW5vaXMgd291bGQgYmUgYWJsZSB0byBnZXQgdGhlIGpvYiBkb25lIGFuZCBxdWFsaWZ5IGZvciBOYXRpb25hbHMuIEl0IHdhcyBhIGNvbGQsIHdpbmR5LCB3ZXQgZGF5IG9uIFNhdHVyZGF5IGJ1dCBJbGxpbm9pcyB3b24gdGhlaXIgZmlyc3QgZ2FtZSBjb21mb3J0YWJseS4gSW4gYSBzaG9ja2luZyB0dXJuIG9mIGV2ZW50cywgYSBsYWNrIG9mIGZvY3VzIGNhdXNlZCBJbGxpbm9pcyB0byBjb21lIG91dCBmbGF0IGFnYWluc3QgRWFzdGVybiBJbGxpbm9pcyBpbiB0aGUgcmVnaW9uYWwgcXVhcnRlcmZpbmFscy4gRWFzdGVybiBJbGxpbm9pcyBjYW1lIG91dCBhbmQgcHVuY2hlZCBpbiBmb3VyIGJyZWFrcyBpbiBhIHJvdy4gSWxsaW5vaXMgZm91Z2h0IGJhY2sgYW5kIHRpZWQgdGhlIHNjb3JlIGF0IDUtNSwgYnV0IHRoZXkgY291bGQgbmV2ZXIgZ2V0IG92ZXIgdGhlIGh1bXAgYW5kIHRha2UgdGhlIGxlYWQuIEVhc3Rlcm4gSWxsaW5vaXMnIE1pY2hhZWwgU2Nod2VuayBjYXJyaWVkIHRoZSB0ZWFtIHRvIGFuIHVwc2V0IHdpdGggYSAxMy0xMCB2aWN0b3J5IGFuZCBnYXZlIElsbGlub2lzIHRoZWlyIGZpcnN0IGxvc3MgYXQgUmVnaW9uYWxzIHNpbmNlIDIwMDguPC9wPiAgICBcbiAgICAgICAgICAgIDxwPldpdGggdGhlaXIgYmFja3MgYWdhaW5zdCB0aGUgd2FsbCwgSWxsaW5vaXMgcmVncm91cGVkIGFuZCB0b29rIGNhcmUgb2YgYnVzaW5lc3Mgb24gU2F0dXJkYXkgYW5kIHN0YXllZCBhbGl2ZSBpbiB0aGUgMm5kIHBsYWNlIGJyYWNrZXQgZm9yIFN1bmRheS4gRm9yIHRoZSBmaXJzdCB0aW1lIHNpbmNlIDIwMDcsIElsbGlub2lzIHdhcyBub3QgaW4gdGhlIFJlZ2lvbmFsIEZpbmFsIFN1bmRheSBtb3JuaW5nIGJ1dCBpbnN0ZWFkIGluIGEgZmlnaHQgZm9yIHRoZWlyIHNlYXNvbiBpbiB0aGUgYmFja2Rvb3Igc2VtaS0gZmluYWxzLiBUaGV5IGRpc3BhdGNoZWQgSW5kaWFuYSAxNS03IGFuZCBoYWQgYSByZW1hdGNoIHdpdGggRWFzdGVybiBJbGxpbm9pcyBpbiB0aGUgYmFja2Rvb3IgZmluYWwuIElsbGlub2lzIGRpZCBub3QgdGFrZSB0aGVtIGxpZ2h0bHkgdGhpcyB0aW1lIGFuZCBjYW1lIG91dCB3aXRoIGEgcmFyZWx5IHNlZW4gaW50ZW5zaXR5IGFuZCBiZWF0IEVhc3Rlcm4gMTUtMi4gSG93ZXZlciwgdGhlIHRlYW0ncyBmb2N1cyBhbmQgZXhlY3V0aW9uIHdhcyBub3QgdGhlcmUgYW5kIG11bHRpcGxlIHR1cm5vdmVycyBvbiBldmVyeSBwb2ludCBjdWxtaW5hdGVkIGluIHRoZSBkZXN0cnVjdGlvbiBvZiBDb2FjaCBXYWxkZW4gTmVsc29uJ3MgY2xpcGJvYXJkLiBJbGxpbm9pcywgYWZ0ZXIgYW4gYXJkdW91cyByb2FkLCBoYWQgZmluYWxseSBtYWRlIGl0IHRvIGEgZ2FtZSB0byBnbyB0byBOYXRpb25hbHMgYWdhaW5zdCBNaWNoaWdhbiBTdGF0ZS4gSWxsaW5vaXMgc3RhcnRlZCB0aGUgZ2FtZSBvdXQgc3Ryb25nIGFuZCBmaXJlZCB1cCBhbmQgY2FtZSBvdXQgd2l0aCB0d28gcXVpY2sgYnJlYWtzLiBNU1UgcGxheWVkIGEgbG90IG9mIHpvbmUgaW4gYW4gZWZmb3J0IHRvIG5lZ2F0ZSBSeWFuIFNtaXRoJ3MgaHVja3MuIEJ1dCBSeWFuIGRpZCBub3QgdGFrZSB0aGUgYmFpdCBhbmQgbGVhZCB0aGUgb2ZmZW5zZSB0byBhIGNsZWFuIG5vIGJyZWFrIGZpcnN0IGhhbGYgYW5kIHRoZSBkZWZlbnNlIGdvdCAzIGJyZWFrcyBmb3IgYW4gOC01IGhhbGZ0aW1lIGxlYWQuIElsbGlub2lzIHNtZWxsZWQgYSBOYXRpb25hbHMgYmVydGggYW5kIGNhbWUgb3V0IG9mIGhhbGYgd2l0aCAyIG1vcmUgcG9pbnRzIGZvciBhIGNvbW1hbmRpbmcgMTAtNSBsZWFkLiBUaGlzIHdhcyB3aGVuIE1pY2hpZ2FuIFN0YXRlIGhlbGQgdGhlaXIgZ3JvdW5kIGFuZCBiZWdhbiBhIHRlbmFjaW91cyBjb21lYmFjay4gU3RheWluZyB3aXRoIHRoZWlyIHpvbmUsIE1TVSBiZWdhbiB0byBmb3JjZSBtb3JlIGFuZCBtb3JlIHR1cm5vdmVycyBmcm9tIElsbGlub2lzIGFuZCBiZWdhbiB0byBjb252ZXJ0IHRoZW0gZm9yIGJyZWFrcy4gQSAxMC01IGxlYWQgcXVpY2tseSBiZWNhbWUgMTAtOCBhbmQgTVNVIGNsYXdlZCBzbG93bHkgYmFjayBmcm9tIHRoZXJlIHRvIGZpbmFsbHkgdGFrZSB0aGUgbGVhZCBhdCAxMy0xMi4gQSBsb3Qgb2YgY3JlZGl0IGlzIHRvIGJlIGdpdmVuIHRvIE1TVSBmb3IgbmV2ZXIgZ2l2aW5nIHVwIGFuZCBmaWdodGluZyB0aGVpciB3YXkgYmFjayB0byB0aGUgbGVhZC4gQnV0IElsbGlub2lzJyBsYWNrIG9mIGNvbXBvc3VyZSBvbiBvZmZlbnNlIGNvdXBsZWQgd2l0aCBhIHdpbGxpbmduZXNzIHRvIHR1cm4gdGhlIGRpc2Mgb3ZlciwgYXMgd2VsbCBhcyB0aW1lb3V0IG1pc21hbmFnZW1lbnQgYnkgQ29hY2ggV2FsZGVuIE5lbHNvbiBkaWQgbm90IGhlbHAgdGhlIGNhdXNlLiBFdmVuIHdpdGggYWxsIHRoYXQgYmVpbmcgc2FpZCwgSWxsaW5vaXMgc2NvcmVkIG9uIG9mZmVuc2UgdG8gbWFrZSBpdCAxMy0gMTMgdW5pdmVyc2UgcG9pbnQgd2l0aCB0aGUgd2lubmVyIGdvaW5nIHRvIE5hdGlvbmFscy4gSWxsaW5vaXMgZ290IHRoZSBkaXNjIHR3aWNlIG9uIHVuaXZlcnNlIGFuZCBib3RoIHRpbWVzIHRocmV3IHBhc3NlcyBpbnRvIHRoZSBlbmR6b25lIHRoYXQgaGl0IGEgcmVjZWl2ZXIncyBoYW5kcywgYnV0IGFsYXMgYm90aCBwYXNzZXMgd2VyZSBkcm9wcGVkLiBBZnRlciB0aGUgc2Vjb25kIGRyb3AgaW4gdGhlIGVuZHpvbmUgTVNVIHBpY2tlZCB1cCB0aGUgZGlzYyBhbmQgaW1tZWRpYXRlbHkgdGhyZXcgYW4gODAgeWFyZCwgbW9yZSB0aGFuIGZ1bGwgZmllbGQgaHVjayBmb3IgdGhlIGdhbWUgYW5kIHRoZSBOYXRpb25hbHMgYmVydGguPC9wPiAgICBcbiAgICAgICAgICAgIDxwPlRoaXMgd2FzIG5vdCB0aGUgZW5kaW5nIHRvIHRoZSAyMDEyIHNlYXNvbiB0aGF0IElsbGlub2lzIGltYWdpbmVkLiBGb3IgdGhlIGZpcnN0IHRpbWUgc2luY2UgMjAwNywgSWxsaW5vaXMnIGdyYWR1YXRpbmcgc2VuaW9ycyBkaWQgbm90IGdldCB0byBlbmQgdGhlaXIgY2FyZWVycyBhdCBOYXRpb25hbHMuIFdpdGggYSBodWdlIGdyYWR1YXRpbmcgY2xhc3MsIGl0IHdpbGwgYmUgdXAgdG8gdGhlIGZldyByZXR1cm5pbmcgQS10ZWFtZXJzIHRvIHBpY2sgdXAgdGhlIHBpZWNlcyBhbmQgcmV0dXJuIElsbGlub2lzIHRvIE5hdGlvbmFscy48L3A+ICAgIFxuICAgICAgICBgXG4gICAgfSx7XG4gICAgICAgIHllYXI6IDIwMTEsXG4gICAgICAgIGltYWdlUGF0aDogJy4vYXNzZXRzL3RlYW0tcGhvdG8tMjAxMS5qcGcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5UaGUgcHJvZ3JhbSBsb3N0IHNldmVyYWwgcHJvZ3JhbSBtYWluc3RheXMgc3VjaCBhcyA1LXllYXIgQS10ZWFtZXIgYW5kIDItdGltZSBjYXB0YWluIEJyaWFuIFBoZWxhbiwgVG9wIDEwIENhbGxhaGFuIGZpbmlzaGVyIGFuZCBjYXB0YWluIFdhbGRlbiBOZWxzb24sIGFuZCBUZWFtIFNwaXJpdCBMZWFkZXIgS3VydCBab2VsbGljayBhbW9uZyBvdGhlcnMuIFRoaXMgcmVxdWlyZWQgdGhlIGxhcmdlIGp1bmlvciBjbGFzcyB0byBzdGVwIHVwIGFuZCBtZWV0IHRoZSBjaGFsbGVuZ2UuIEp1bmlvcnMgWmFjaGFyeSBGcmFudHogYW5kIFJ5YW4gU21pdGggc3RlcHBlZCB1cCB0byBiZWNvbWUgY2FwdGFpbnMgYWxvbmdzaWRlIHJldHVybmluZyBjYXB0YWluIEF1c3RpbiBMaWVuLiBUaGUgY2FwdGFpbnMgc3VydmV5ZWQgdGhlIHRyeW91dCBwb29sIGFuZCBzYXcgdGhhdCBpdCB3YXMgb25lIG9mIHRoZSBtb3N0IGNvbXBldGl0aXZlIGluIHJlY2VudCBoaXN0b3J5LiBXYW50aW5nIHRvIGdpdmUgZXZlcnlvbmUgYSBmYWlyIGxvb2ssIGZpbmFsIGN1dHMgd2VyZW4ndCBtYWRlIHVudGlsIHRoZSBlbmQgb2YgSmFudWFyeS4gQWZ0ZXIgdGhlIHNtb2tlIGNsZWFyZWQsIHRoZSBmaW5hbCByb3N0ZXIgc3Rvb2QgYXQgMjcgYW5kIGFmdGVyIGEgMSB5ZWFyIGhpYXR1cyBvZiBubyBmcmVzaG1hbiBtYWtpbmcgdGhlIGN1dCwgMiBmcmVzaG1hbiBmb3VuZCB0aGVtc2VsdmVzIG9uIHRoZSB0ZWFtLjwvcD5cbiAgICAgICAgICAgIDxwPkV2ZW4gd2l0aCBhIGZ1bGwgcm9zdGVyLCBJbGxpbm9pcyBiYXR0bGVkIHRoZSBpbmp1cnkgYnVnIHRocm91Z2hvdXQgdGhlIHNlYXNvbi4gRGxpbmUgaGFuZGxlciBBZGFtIFdyaWdodCB0b3JlIGhpcyBhY2wgYXQgUml2YWxyeSBSZWhlYXQgYW5kIG9ubHkgcmV0dXJuZWQgZm9yIGEgZmV3IHBvaW50cyBhdCBOYXRpb25hbHMuIENhcHRhaW4gWmFjaGFyeSBGcmFudHogYmF0dGxlZCBQbGFudGFyIEZhc2NpaXRpcyB0aGUgd2hvbGUgeWVhciwgbWlzc2luZyBldmVyeSB0b3VybmFtZW50IGJlc2lkZXMgUmVnaW9uYWxzIGFuZCBOYXRpb25hbHMuIDV0aCB5ZWFyIGN1dHRlciBDaHJpcyBIaWRha2EgYmFkbHkgc3ByYWluZWQgaGlzIGFua2xlIGluIHRoZSAybmQgZ2FtZSBvZiB0aGUgZmlyc3QgdG91cm5hbWVudCBhbmQgbmV2ZXIgcXVpdGUgcmVnYWluZWQgaGlzIG9sZCBmb3JtLiBTZW5pb3JzIFN1bGV5bWFuIEFobWFkIGFuZCBKb25hdGhhbiBIYXRjaGVyIGhhZCBsZWcgcHJvYmxlbXMgb2YgdGhlaXIgb3duIGFuZCB3ZXJlIGluIGFuZCBvdXQgb2YgdGhlIGxpbmUgdXAuIEp1bmlvciBSeWFuIEt1cm5payBicm9rZSBoaXMgaGFuZCBhbmQgbWlzc2VkIHRoZSBsYXN0IGhhbGYgb2YgdGhlIHNlYXNvbi4gSW4gYWRkaXRpb24gdGhlcmUgd2VyZSBudW1lcm91cyBvdGhlciBpbmp1cmllcyB0aGF0IGtlcHQgcGVvcGxlIGF3YXkgZnJvbSB0aGUgZmllbGQuPC9wPlxuICAgICAgICAgICAgPHA+SG93ZXZlciB0aGVyZSB3ZXJlIHN0aWxsIHRvdXJuYW1lbnRzIHRvIGJlIHBsYXllZCBhbmQgZ2FtZXMgdG8gYmUgd29uLiBDb21wYXJlZCB0byBwYXN0IHllYXJzLCBJbGxpbm9pcyB0cmF2ZWxlZCB0byBsZXNzIGNvbXBldGl0aXZlIHRvdXJuYW1lbnRzLiBVbmZvcnR1bmF0ZWx5IHRoaXMgZGlkIG5vdCBsZWFkIHRvIG1vcmUgdmljdG9yaWVzIGFzIElsbGlub2lzIHN0cnVnZ2xlZCB0byBtYWludGFpbiBmb2N1cyBmb3Igd2hvbGUgZ2FtZXMsIG9mdGVuIHBsYXlpbmcgb25lIGdvb2QgYW5kIG9uZSBiYWQgaGFsZi4gVGhlcmUgd2VyZSBzb21lIGJlbmVmaXRzIGFzIHNldmVyYWwgcGxheWVycyB3ZXJlIGFibGUgdG8gZ2FpbiBtdWNoIG5lZWRlZCBleHBlcmllbmNlIHBsYXlpbmcgbmV3IGFuZCBtb3JlIGNoYWxsZW5naW5nIHJvbGVzIHRoYW4gdGhleSB3ZXJlIGFjY3VzdG9tZWQgdG8uIElsbGlub2lzIG1hZGUgc2VtaWZpbmFscyBvZiBib3RoIHRoZSBGcmVlc3RhdGUgQ2xhc3NpYyBhbmQgSHVjayBGaW5uIGJlZm9yZSBsb3NpbmcgdG8gQ2VudHJhbCBSZWdpb24gdGVhbXMgSW93YSBhbmQgTWlubmVzb3RhLiBHb2luZyBpbnRvIHRoZSBzZXJpZXMsIElsbGlub2lzIGhvcGVkIHRvIGZvbGxvdyB0aGUgdHJlbmRzIG9mIHRoZSBwYXN0IHR3byBJbGxpbm9pcyB0ZWFtcyBhbmQgcGxheSB0aGVpciBiZXN0IHVsdGltYXRlIGR1cmluZyB0aGUgc2VyaWVzLjwvcD5cbiAgICAgICAgICAgIDxwPlNlY3Rpb25hbHMgd2FzIGhlbGQgY2xvc2UgYnkgaW4gUmFudG91bCwgSWxsaW5vaXMgYXMgcGVvcGxlIHN0aWxsIGRpZG4ndCBnZXQgdGhlIG1lbW8gbm90IHRvIGhhdmUgdG91cm5hbWVudHMgdGhlcmUgaW4gdGhlIFNwcmluZy4gU2F0dXJkYXkgd2FzIGEgd2luZHkgYW5kIHJhaW55IGRheSwgSWxsaW5vaXMgdG9vayBjYXJlIG9mIGJ1c2luZXNzIGFuZCB3b24gZXZlcnkgZ2FtZSBieSBhIGNvbWZvcnRhYmxlIG1hcmdpbi4gT24gU3VuZGF5LCBidW95ZWQgYnkgdGhlIHJhcmUgYmVhdXRpZnVsIFJhbnRvdWwgd2VhdGhlciwgSWxsaW5vaXMgYmVhdCBOb3J0aHdlc3Rlcm4gYW5kIEVhc3Rlcm4gSWxsaW5vaXMgdG8gcmVwZWF0IGFzIFNlY3Rpb25hbCBDaGFtcGlvbnMuPC9wPlxuICAgICAgICAgICAgPHA+SnVzdCBsaWtlIDIwMTAsIElsbGlub2lzIGhhZCB0aGUgM3JkIHNlZWQgZ29pbmcgaW50byBSZWdpb25hbHMuIFVubGlrZSBwYXN0IHllYXJzIG9ubHkgMSB0ZWFtIHdvdWxkIG1ha2UgaXQgdG8gTmF0aW9uYWxzLCBtZWFuaW5nIDEgYmFkIGhhbGYgYW5kIHRoZSBzZWFzb24gd291bGQgYmUgb3Zlci4gQW5vdGhlciBjaGFuZ2Ugd2FzIHRoZSBmb3JtYXQsIHdpdGggdGhlIGZvcm1hdCBiZWluZyBwb29sIHBsYXkgaW5zdGVhZCBvZiBhIHN0cmFpZ2h0IGJyYWNrZXQuIEluIGEgdmVyeSB3aW5keSBTYXR1cmRheSwgSWxsaW5vaXMgZ3V0dGVkIG91dCBhIGNsb3NlIGdhbWUgYWdhaW5zdCBMb3lvbGEsIHdpbm5pbmcgb24gZG91YmxlIGdhbWUgcG9pbnQuIEFmdGVyIHRoYXQgc2NhcmUgd29rZSB0aGVtIHVwLCB0aGV5IGJlYXQgV2VzdGVybiBNaWNoaWdhbiBhbmQgTm90cmUgRGFtZSBoYW5kaWx5LiBFdmVyeW9uZSBvbiB0aGUgdGVhbSB3YXMgbG9va2luZyBmb3J3YXJkIHRvIGZhY2luZyBNaWNoaWdhbiBpbiBzZW1pcyBidXQgZmlyc3QgdGhleSB3b3VsZCBoYXZlIHRvIGdldCB0aHJvdWdoIEluZGlhbmEgaW4gdGhlIGZpcnN0IGdhbWUgb2YgdGhlIGRheSBvbiBTdW5kYXkuIExlZCBieSB0aGVpciBzZW5pb3IgbGVhZGVycyBFZCBXdSBhbmQgVGF5bG9yIEtyYWVtZXIsIEluZGlhbmEgZ2F2ZSBJbGxpbm9pcyBhbGwgdGhleSBjb3VsZCBoYW5kbGUgaW4gYSBjbG9zZSBiYWNrIGFuZCBmb3J0aCBnYW1lIGJlZm9yZSBJbGxpbm9pcyBwdWxsZWQgaXQgb3V0IHdpbm5pbmcgMTUtMTMuIFRoaXMgbGVkIHRvIHRoZSBzZW1pZmluYWwgc2hvd2Rvd24gd2l0aCBNaWNoaWdhbiBmb3IgdGhlIHRoaXJkIHllYXIgaW4gYSByb3cuIEhvd2V2ZXIsIHRoaXMgeWVhciB3b3VsZCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgcGFzdCB0d28geWVhcnMgYXMgSWxsaW5vaXMgY2FtZSBvdXQgZmlyaW5nIHdpdGggYW4gaW50ZW5zaXR5IHRoYXQgTWljaGlnYW4gZWl0aGVyIGNvdWxkIG5vdCBvciB3YXMgdW53aWxsaW5nIHRvIG1hdGNoLiBJdCB3YXMgYSB0b3RhbCB0ZWFtIGVmZm9ydCBhcyBldmVyeW9uZSBjb250cmlidXRlZCB0byBhIHJlc291bmRpbmcgMTUtOSB3aW4uIEl0IHdhcyBhIGdyZWF0IHdpbiwgYnV0IHBlb3BsZSB3ZXJlIHRvbyBzYXRpc2ZpZWQgd2l0aCB0aGF0IHZpY3RvcnkgY29uc2lkZXJpbmcgdGhhdCB0aGUgYmlkIHRvIE5hdGlvbmFscyB3YXMgc3RpbGwgdXAgZm9yIGdyYWJzLiBJbGxpbm9pcyBzdGlsbCBoYWQgdG8gZmFjZSBhIGRldGVybWluZWQgb3Bwb25lbnQgaW4gTWljaGlnYW4gU3RhdGUgd2hvIHVuZG91YnRlZGx5IGhhZCBwbGFucyBmb3IgcmV2ZW5nZSBmcm9tIDIwMTAuIEZvcnR1bmF0ZWx5IGZvciBJbGxpbm9pcywgTWljaGlnYW4gU3RhdGUgaGFkIHNldmVyYWwgdW5mb3JjZWQgZXJyb3JzIGluIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSBnYW1lIGFuZCBJbGxpbm9pcyB0b29rIGFkdmFudGFnZSBnb2luZyB1cCBzZXZlcmFsIGJyZWFrcyBpbiB0aGUgZmlyc3QgaGFsZi4gTWljaGlnYW4gU3RhdGUgdHJpZWQgdG8gbW91bnQgYSBjb21lYmFjayBpbiB0aGUgc2Vjb25kIGhhbGYgYnV0IHRoZSBzY29yZSBkaWZmZXJlbmNlIHdhcyB0b28gZ3JlYXQuIElsbGlub2lzIHdvbiB0aGUgcmVnaW9uIGZvciB0aGUgM3JkIHllYXIgaW4gYSByb3cgYW5kIHRvb2sgdGhlIHJlZ2lvbnMgb25seSBiaWQgdG8gTmF0aW9uYWxzIHdpdGggYSAxNS0xMSB2aWN0b3J5LiBJbGxpbm9pcyBoYWQgc2V2ZXJhbCBwbGF5ZXJzIHdobyBwbGF5ZWQgd2VsbCBkdXJpbmcgUmVnaW9uYWxzIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gRGFuZSBKb3JnZW5zZW4sIEJyaWFuIFBpZXJjZSwgQXVzdGluIExpZW4sIFphY2hhcnkgRnJhbnR6LCBSeWFuIFNtaXRoIGFuZCBOZWFsIFBoZWxwcy4gSW4gYSBzdXJwcmlzaW5nIHR1cm4gb2YgZXZlbnRzLCBvbmx5IFJ5YW4gU21pdGggd2FzIGEgbWVtYmVyIG9mIHRoZSBBbGwtUmVnaW9uIHRlYW0uPC9wPlxuICAgICAgICAgICAgPHA+R29pbmcgaW50byBOYXRpb25hbHMsIElsbGlub2lzIHBsYW5uZWQgb24gYnJlYWtpbmcgdGhlIGN1cnNlIG9mIHR3byBzdHJhaWdodCAxN3RoIHBsYWNlcy4gSXJvbmljYWxseSBlbm91Z2ggYW5kIGRlc2VydmVkbHkgc28sIElsbGlub2lzIGhhZCB0aGUgMTd0aCBzZWVkIGdvaW5nIGluLiBJbGxpbm9pcyB3YXMgaW4gYSBwb29sIHdpdGggb3ZlcmFsbCAjMSBzZWVkIFBpdHRzYnVyZ2ggYW5kICMxMiBzZWVkIGFuZCBmYW4gZmF2b3JpdGUgQ29sb3JhZG8gQ29sbGVnZS4gSW4gdGhlIGZpcnN0IGdhbWUgb2YgTmF0aW9uYWxzIGFnYWluc3QgQ29sb3JhZG8gQ29sbGVnZSwgSWxsaW5vaXMgYmF0dGxlZCBuZXJ2ZXMgYW5kIGhhZCBzZXZlcmFsIHVuZm9yY2VkIGVycm9ycyBpbiB0aGUgZmlyc3QgaGFsZi4gSG93ZXZlciwgbGVkIGJ5IE5lYWwgUGhlbHBzJyBzdGVsbGFyIGRlZmVuc2Ugb24gQ2FsbGFoYW4gY2FuZGlkYXRlIE5pY2t5IFNwaXZhIGFuZCBEYW5lIEpvcmdlbnNlbidzIGFlcmlhbCBhYmlsaXR5LCBJbGxpbm9pcyBmb3VnaHQgYW5kIGNsYXdlZCBiYWNrIGZvciBhIGdyaXR0eSAxMy0xMSB2aWN0b3J5LiBUaGlzIHdhcyBJbGxpbm9pcycgZmlyc3QgTmF0aW9uYWxzIHBvb2wgcGxheSB2aWN0b3J5IGluIDIgeWVhcnMgYW5kIGhhZCB0aGVtIHByaW1lZCB0byB0YWtlIGEgc3BvdCBpbiBwcmVxdWFydGVycy4gQWZ0ZXIgbG9zaW5nIDE1LTEwIHRvIFBpdHRzYnVyZ2ggaGlnaGxpZ2h0ZWQgYnkgYSBicmVhayB3aXRoIHNldmVyYWwgTmF0aW9uYWxzIGZpcnN0IHRpbWVycyBhbmQgYm90aCByb29raWVzLCBJbGxpbm9pcyBvbmx5IG5lZWRlZCB0byB3aW4gMSBvZiB0aGVpciBuZXh0IDIgZ2FtZXMgdG8gdGFrZSBhIHNwb3QgaW4gcHJlcXVhcnRlcnMuIFVuZm9ydHVuYXRlbHksIHRoZSBpc3N1ZXMgdGhhdCBiZWd1aWxlZCBJbGxpbm9pcyB0aHJvdWdob3V0IHRoZSBzZWFzb24gY2FtZSB1cCBvbmNlIGFnYWluLiBUbyBwdXQgaXQgc2ltcGx5LCBJbGxpbm9pcyBkaWQgbm90IHNob3cgdXAgb24gU2F0dXJkYXkgb2YgTmF0aW9uYWxzLiBJbGxpbm9pcyBsb29rZWQgbGlmZWxlc3MgYW5kIGxvc3QgdG8gSW93YSAxNS0xMC4gRXZlbiB3aXRoIHRoYXQgYmVpbmcgc2FpZCwgSWxsaW5vaXMgc2ltcGx5IGhhZCB0byB3aW4gYWdhaW5zdCBUdWZ0cyB0byBhZHZhbmNlIHRvIHRoZSBicmFja2V0LiBXaXRoIHRoZWlyIHNlYXNvbiBvbiB0aGUgbGluZSwgSWxsaW5vaXMgZ2F2ZSBhIHNhZCwgZGlzYXBwb2ludGluZyBlZmZvcnQgYm90aCBvbiB0aGUgZmllbGQgYW5kIG9uIHRoZSBzaWRlbGluZXMuIFRoZWlyIGVmZm9ydCB3YXMgbm8gd2hlcmUgY2xvc2UgdG8gZ29vZCBlbm91Z2ggYW5kIHRoZXkgZ290IHB1bmlzaGVkIGRlc2VydmVkbHksIDE1LTcsIGtub2NraW5nIHRoZW0gaW50byB0aGUgcGxhY2VtZW50IGJyYWNrZXQgZm9yIHRoZSAzcmQgeWVhciBpbiBhIHJvdy4gSWxsaW5vaXMgbG9zdCB0byBXaGl0bWFuIDE2LTE0IGFmdGVyIGxlYWRpbmcgbW9zdCBvZiB0aGUgZ2FtZSBhbmQgdGhlbiBpbiB0aGUgZ2FtZSB0aGV5IGhhdmUgbmV2ZXIgbG9zdCwgYmVhdCBGbG9yaWRhIGFuZCB0b29rIDE3dGggcGxhY2UgZm9yIHRoZSAzcmQgeWVhciBpbiBhIHJvdy4gSG93ZXZlciB0aGVyZSBpcyBob3BlIGZvciB0aGUgZnV0dXJlIHdpdGggMjAgcmV0dXJuaW5nIHBsYXllcnMgYW5kIGEgdGFsZW50ZWQgaW5jb21pbmcgY2xhc3MsIElsbGlub2lzIHdpbGwgbG9vayB0byBicmVhayB0aGUgY3Vyc2Ugb2YgMTd0aC48L3A+XG4gICAgICAgIGBcbiAgICB9LHtcbiAgICAgICAgeWVhcjogMjAxMCxcbiAgICAgICAgaW1hZ2VQYXRoOiAnLi9hc3NldHMvdGVhbS1waG90by0yMDEwLmpwZycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPklsbGlub2lzIGhhZCB0byBkZWFsIHdpdGggc2V2ZXJhbCBiaWcgbG9zc2VzIGZyb20gdGhlIHllYXIgYmVmb3JlIGJ1dCBub25lIGJpZ2dlciB0aGFuIHRoZSBkZXBhcnR1cmUgb2YgbG9uZ3RpbWUgY29hY2ggTWF0dCBTdHVwY2Egd2hvIGNvYWNoZWQgZnJvbSAyMDA0LTIwMDkuIFRoZSBjYXB0YWlucyBCcmlhbiBQaGVsYW4sIFdhbGRlbiBOZWxzb24gYW5kIEF1c3RpbiBMaWVuLCBoYWQgdG8gY29tZSB0byB0ZXJtcyB3aXRoIHRoZSByZXNwb25zaWJpbGl0aWVzIGFuZCBleHRyYSB3b3JrIHRoYXQgTWF0dCBTdHVwY2EgcHJvdmlkZWQsIGFuZCBjYXJyeSBhIGJpZ2dlciBsb2FkIHRoZW1zZWx2ZXMuIERlYWxpbmcgd2l0aCB0aGUgaGVhdnkgbG9zc2VzIGZyb20gdGhlIHllYXIgYmVmb3JlLCBJbGxpbm9pcyBjYWxsZWQgdXAgYSBudW1iZXIgb2YgcGxheWVycyBmcm9tIHRoZSBCLXRlYW0gYW5kIHR3byBmcm9tIHRoZSBDLXRlYW0gd2hpY2ggd2FzIGEgcHJvZ3JhbSBmaXJzdC4gSWxsaW5vaXMgc3BlbnQgbXVjaCBvZiB0aGUgc2Vhc29uIGFjY2xpbWF0aW5nIHRoZSBuZXcgcGxheWVycyBzbyB0aGF0IHRoZXkgd291bGQgYmUgcmVhZHkgZm9yIE5hdGlvbmFscyBsZXZlbCBjb21wZXRpdGlvbi48L3A+XG4gICAgICAgICAgICA8cD5UaGV5IGhhZCB1bmV2ZW4gcmVzdWx0cyBhbmQgZ3Jvd2luZyBwYWlucyB0aHJvdWdob3V0IHRoZSB5ZWFyLCB3aXRoIGEgaGlnaGxpZ2h0IGJlaW5nIG1ha2luZyB0aGUgZmluYWxzIG9mIE1hcmRpcyBHcmFzIGJlZm9yZSBsb3NpbmcgdG8gV2lzY29uc2luIGJ5IGEgc3Vic3RhbnRpYWwgbWFyZ2luLiBJdCBhbHNvIGluY2x1ZGVkIGFub3RoZXIgc2hlbGxhY2tpbmcgYnkgTWljaGlnYW4gYXQgSHVjayBGaW5uIGFzIG1hbnkgcGxheWVycyBnb3QgdGhlaXIgZmlyc3QgdGFzdGUgb2YgdGhlIHJlZ2lvbmFsIHJpdmFscnkuIElsbGlub2lzIGhhZCBzZXZlcmFsIGluanVyaWVzIHRocm91Z2hvdXQgdGhlIHllYXIgd2hpY2ggbWFkZSBwcmFjdGljZSBhdHRlbmRhbmNlIGFuIGlzc3VlLCBob3dldmVyIElsbGlub2lzIGZvdWdodCB0aHJvdWdoIHRoZW0gYW5kIHdlbnQgaW50byB0aGUgQ29sbGVnZSBTZXJpZXMgbW9zdGx5IGhlYWx0aHkuPC9wPlxuICAgICAgICAgICAgPHA+QXQgU2VjdGlvbmFscyBJbGxpbm9pcyBoZWxkIHRoZSAxIHNlZWQgZ29pbmcgaW4sIGJ1dCBsb3N0IG9uIFNhdHVyZGF5IG9mIFNlY3Rpb25hbHMgZm9yIHRoZSBmaXJzdCB0aW1lIHNpbmNlIHRoZSBSZWdpb25zIGFuZCBTZWN0aW9ucyB3ZXJlIHJlZHJhd24uIFRoaXMgZ2F2ZSB0aGVtIGEgMiBzZWVkIG91dCBvZiB0aGVpciBwb29sIGFuZCBhIGZpcnN0IHJvdW5kIG1hdGNoIHVwIHdpdGggTm90cmUgRGFtZSB0aGUgMiBzZWVkIG92ZXJhbGwsIHdpdGggZ29vZCBzZWVkaW5nIGF0IFJlZ2lvbmFscyBvbiB0aGUgbGluZS4gSWxsaW5vaXMgd2VudCB1cCBiaWcgZWFybHkgYnV0IE5vdHJlIERhbWUgbWFkZSBhIGZ1cmlvdXMgY29tZWJhY2sgdG8gdGllIHVwIGxhdGUgaW4gdGhlIGdhbWUsIElsbGlub2lzIHJlY2VpdmVkIGdvaW5nIHVwd2luZCBhbmQgdGhyZXcgY2F1dGlvbiBpbnRvIHRoZSB3aW5kIGJ5IHRocm93aW5nIHNldmVyYWwgY2xvc2UgdGhyb3dzIHRocm91Z2ggYW5kIGFyb3VuZCB0aGUgTm90cmUgRGFtZSB6b25lIGJlZm9yZSBwdW5jaGluZyBpdCBpbiBhbmQgd2lubmluZyAxNC0xMy4gSWxsaW5vaXMgdGhlbiB0b29rIGNhcmUgb2YgYnVzaW5lc3MgYW5kIG1hZGUgaXQgdG8gZmluYWxzLCBleGFjdGluZyByZXZlbmdlIG9uIFB1cmR1ZSBmb3IgdGhlIFNhdHVyZGF5IGxvc3MgYW5kIGJlYXRpbmcgdGhlbSAxNS01IGFuZCByZWNsYWltaW5nIHRoZSBTZWN0aW9uYWwgdGl0bGUuPC9wPlxuICAgICAgICAgICAgPHA+R29pbmcgaW50byBSZWdpb25hbHMgSWxsaW5vaXMgaGFkIHRoZSAzIHNlZWQgZ29pbmcgaW4gYmVoaW5kIE1pY2hpZ2FuIFN0YXRlIGFuZCBNaWNoaWdhbi4gSWxsaW5vaXMgYmVhdCBib3RoIERheXRvbiBhbmQgUHVyZHVlIGhhbmRpbHkgYW5kIGFkdmFuY2VkIHRvIHNlbWlmaW5hbHMgYmVmb3JlIGZpbmRpbmcgb3V0IHRoYXQgUmVnaW9uYWxzIHdvdWxkIGJlIHBvc3Rwb25lZCBmb3IgYSB3ZWVrLiBIYXZpbmcgYSB3ZWVrIHRvIHByZXBhcmUgYW5kIHRvIGhlYWwsIElsbGlub2lzIGZhY2VkIE1pY2hpZ2FuIGF0IFJlZ2lvbmFscyBhcyBpcyB0aGUgbm9ybS4gSW4gYSBoZWF2eSB3aW5kIGdhbWUsIHdoaWNoIHNhdyBzZXZlcmFsIGxlYWQgY2hhbmdlcywgYnV0IGZldyBicmVha3MsIGFuZCBsb3RzIG9mIGdyZWF0IHBsYXlzIGZyb20gYm90aCB0ZWFtcywgSWxsaW5vaXMgd2FzIGFibGUgdG8gc2NvcmUgb24gYSBndXQtd3JlbmNoaW5nIHVuaXZlcnNlIHBvaW50IGFuZCB3b24gdGhlIGdhbWUgOS04LjwvcD5cbiAgICAgICAgICAgIDxwPlRoaXMgc2VudCBJbGxpbm9pcyB0byBpdHMgM3JkIHN0cmFpZ2h0IFJlZ2lvbmFsIGZpbmFsIHdpdGggYSBjaGFuY2UgdG8gcmVwZWF0IGFzIFJlZ2lvbmFsIGNoYW1waW9ucyBmb3IgdGhlIGZpcnN0IHRpbWUgaW4gdGhlIHByb2dyYW1zIGhpc3RvcnkuIElsbGlub2lzIGZhY2VkIE1pY2hpZ2FuIFN0YXRlIHdpdGggdGhlIFJlZ2lvbmFsIHRpdGxlIG9uIHRoZSBsaW5lIGFuZCBwcmV2YWlsZWQgaW4gYSBjbG9zZSBnYW1lIHdpdGggSWxsaW5vaXMgYmVpbmcgYWJsZSB0byBwdWxsIGF3YXkgaW4gdGhlIGVuZCwgMTUtMTAuIElsbGlub2lzIHJlcGVhdGVkIGFzIFJlZ2lvbmFsIGNoYW1waW9ucyBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kIGhhZCBCcmlhbiBQaGVsYW4gYW5kIFdhbGRlbiBOZWxzb24gd2luIGZpcnN0IHRlYW0gQWxsLVJlZ2lvbiBob25vcnMgYW5kIGhhZCBSeWFuIFNtaXRoIHdpbiAybmQgdGVhbSBBbGwtUmVnaW9uLCBiZWNvbWluZyB0aGUgZmlyc3Qgc29waG9tb3JlIGluIHRoZSBwcm9ncmFtcyBoaXN0b3J5IHRvIHdpbiBhIHJlZ2lvbmFsIGF3YXJkLiBJbGxpbm9pcyB3YXMgc2VlZGVkIDE0dGggZ29pbmcgaW50byBOYXRpb25hbHMuIFRoZXkgbG9zdCB0byBIYXJ2YXJkIGhhbmRpbHkgYnV0IHdhcyBzdGlsbCBpbiBjb250ZW50aW9uIGZvciBhIHByZXF1YXJ0ZXJzIGJlcnRoIGlmIHRoZXkgd2VyZSBhYmxlIHRvIGJlYXQgYm90aCBVTkNXIGFuZCBJb3dhLiBIb3dldmVyLCBpbiBnYW1lcyBwb3NzaWJseSBzaG93aW5nIGEgbGFjayBvZiBleHBlcmllbmNlIG9yIHRoZSBidXJkZW4gb2YgY2FwdGFpbmluZyBhbmQgY29hY2hpbmcgcHJvdmluZyB0b28gZ3JlYXQsIElsbGlub2lzIGxvc3QgbGF0ZSBsZWFkcyBpbiBib3RoIGdhbWVzIGFuZCBsb3N0IHRvIFVOQ1cgMTQtMTIgYW5kIHRvIElvd2EgMTYtMTQuIElsbGlub2lzIHRoZW4gcGxheWVkIENhcmxldG9uIGluIGEgbXVjaCBjbG9zZXIgdGhhbiBleHBlY3RlZCAxNS0xMiBsb3NzIGFuZCBsb3N0IHRvIFdpc2NvbnNpbi4gQmVhdGluZyBLYW5zYXMgaW4gdGhlIGxhc3QgZ2FtZSBvZiB0aGUgdG91cm5hbWVudCBnYXZlIElsbGlub2lzIGl0cyBvbmx5IHdpbiBhdCBOYXRpb25hbHMgYW5kIHNlbnQgdGhlbSBob21lIHdpdGggYW5vdGhlciAxN3RoIHBsYWNlIGZpbmlzaC4gSWxsaW5vaXMgZGlkIG5vdCBncmFkdWF0ZSBhcyBtYW55IHBsYXllcnMgYXMgaW4geWVhcnMgcGFzdCwgd2hpY2ggbWFrZXMgSWxsaW5vaXMgaW4gYSBwcmltZSBwb3NpdGlvbiB0byBjb250aW51ZSBpdHMgTmF0aW9uYWxzIHF1YWxpZnlpbmcgc3RyZWFrLjwvcD5cbiAgICAgICAgYFxuICAgIH0se1xuICAgICAgICB5ZWFyOiAyMDA5LFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMDkuanBnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+MjAwOSBzYXcgdGhlIGRlcGFydHVyZXMgb2YgbWFueSBmaXh0dXJlcyBvZiB0aGUgSWxsaW5vaXMgcHJvZ3JhbSBzdWNoIGFzIEpvZWwgS29laG5lbWFuLCBQYXQgU3RlcGhlbnMsIEpha2UgU2VnaWwgYW5kIERhdmlkIEFicmFtLiBJbiB0aGVpciBwbGFjZSBpdCB3YXMgdXAgdG8gdGhlIGNsYXNzIG9mIDIwMDUgdG8gc3RlcCB1cCBhbmQgbGVhZCB0aGUgcHJvZ3JhbS4gSXQgd2FzIHRoZSBmaXJzdCB0aW1lIGluIHNldmVyYWwgeWVhcnMgdGhhdCB0aGVyZSB3ZXJlIDMgY2FwdGFpbnMgdmFjYW5jaWVzLiBUaGV5IHdlcmUgZmlsbGVkIGJ5IERlbmlzIEFnbmllbCwgQnJpYW4gUGhlbGFuIGFuZCBDaGFybGllIE8nQnJpZW4uIExpa2UgaW4gMjAwNiB3aGVuIHRoZSB0ZWFtIGxvc3Qgc2V2ZXJhbCBpbXBhY3QgcGxheWVycywgdGhlIHRlYW0gd2FzIGFibGUgdG8gcmVjcnVpdCBhIHZlcnkgZGVlcCBjbGFzcyB0aGF0IHJpdmFscyBhbmQgbWF5IHN1cnBhc3MgdGhlIGZyZXNobWFuIGNsYXNzIG9mIDIwMDYuIFRoaXMgaW5mbHV4IG9mIGZyZXNobWFuIGxlZCB0byB0aGUgMm5kIHllYXIgb2YgdGhlIEMtIHRlYW1zIGV4aXN0ZW5jZSBpbiB0aGUgcHJvZ3JhbXMgaGlzdG9yeS48L3A+ICAgIFxuICAgICAgICAgICAgPHA+VGhlIHJlZ3VsYXIgc2Vhc29uIGZvciBJbGxpbm9pcyB3YXMgdmVyeSByb3VnaCwgd2l0aCB0aGUgdGVhbSB0cnlpbmcgdG8gZmluZCBwZW9wbGUgd2hvIHdvdWxkIGJlIGFibGUgdG8gZmlsbCB0aGUgYmlnIGhvbGVzIGxlZnQgYnkgdGhlIGRlcGFydGVkIHBsYXllcnMuIFRoaXMgbGVkIHRvIHNldmVyYWwgYmlnIGxvc3NlcyB0aHJvdWdob3V0IHRoZSB5ZWFyIGFuZCBwb29yIHRvdXJuYW1lbnQgZmluaXNoZXMsIGN1bG1pbmF0aW5nIGluIGEgMTMtMiBiZWF0ZG93biBieSByZWdpb25hbCByaXZhbCBNaWNoaWdhbiBhdCBIdWNrIEZpbm4uIEdvaW5nIGludG8gdGhlIHBvc3RzZWFzb24vdGhlIGNvbGxlZ2Ugc2VyaWVzLCBJbGxpbm9pcyBoYWQgYSBsb3Qgb2YgdW5jZXJ0YWludHkuIEF0IFNlY3Rpb25hbHMsIElsbGlub2lzIHRvb2sgY2FyZSBvZiBidXNpbmVzcyBvbiBTYXR1cmRheSBhbmQgYmVhdCBhIHRvdWdoIE5vcnRoIFBhcmsgdGVhbSBpbiBzZW1pZmluYWxzIGFuZCBtYWRlIEZpbmFscyBhZ2FpbnN0IE5vdHJlIERhbWUuIEluIGEgcmFpbnksIGNvbGQgZmluYWwsIElsbGlub2lzIGxvb2tlZCBsaWtlIHRoZXkgZGlkIHRocm91Z2hvdXQgdGhlIHNlYXNvbiBhbmQgbG9zdCAxNS0xMC4gVGhpcyBnYXZlIElsbGlub2lzIGEgNCBzZWVkIGdvaW5nIGludG8gUmVnaW9uYWxzIGFuZCBhIGRlZmluaXRlIGxvbmdzaG90IGZvciBvbmUgb2YgdGhlIHR3byBOYXRpb25hbHMgYmlkcy48L3A+XG4gICAgICAgICAgICA8cD5JbGxpbm9pcyBmYWNlZCB0b3VnaGVyIHRoYW4gZXhwZWN0ZWQgZ2FtZXMgYWdhaW5zdCBLZW55b24gYW5kIE5vcnRoIFBhcmsgYmVmb3JlIG1lZXRpbmcgTWljaGlnYW4gaW4gUmVnaW9uYWwgc2VtaWZpbmFscy4gSWxsaW5vaXMgY2FtZSB0b2dldGhlciBpbiBhIHdheSB0aGF0IGhhZCBub3QgYmVlbiBzZWVuIGFsbCBzZWFzb24sIGFuZCBwdXQgZm9ydGggdGhlaXIgYmVzdCBlZmZvcnQgb2YgdGhlIHNlYXNvbiBhbmQgYmVhdCBNaWNoaWdhbiBpbiBhIHRlbnNlIGhhcmQgZm91Z2h0IGdhbWUgMTItOS4gVGhpcyBwdXQgSWxsaW5vaXMgaW4gaXRzIHNlY29uZCBzdHJhaWdodCBSZWdpb25hbCBmaW5hbCBhZ2FpbnN0IE9oaW8gU3RhdGUuIFRoZSBwcmV2aW91cyBkYXkncyBtb21lbnR1bSBjYXJyaWVkIG92ZXIgYXMgSWxsaW5vaXMgYmVhdCBPaGlvIFN0YXRlIGhhbmRpbHkgMTUtMTEsIHRha2luZyBob21lIGl0cyBmaXJzdCBSZWdpb25hbCBjaGFtcGlvbnNoaXAgc2luY2UgMjAwMi48L3A+XG4gICAgICAgICAgICA8cD5JbGxpbm9pcyBwbGFjZWQgRGVuaXMgQWduaWVsLCBCcmlhbiBQaGVsYW4sIFBhdmFuIFNhcmd1cnUsIGFuZCBXYWxkZW4gTmVsc29uIG9uIHRoZSBHcmVhdCBMYWtlcyAybmQgVGVhbSBBbGwtUmVnaW9uLCBDb2FjaCBNYXR0IFN0dXBjYSB3b24gdGhlIGluYXVndXJhbCBDb2FjaCBvZiB0aGUgUmVnaW9uIGF3YXJkLCBhbmQgUnlhbiBTbWl0aCB3b24gRnJlc2htYW4gb2YgdGhlIHllYXIuIFdpbm5pbmcgdGhlIFJlZ2lvbiBnYXZlIElsbGlub2lzIGFuIDggc2VlZCBnb2luZyBpbnRvIE5hdGlvbmFscywgaG93ZXZlciB3aGF0ZXZlciBtYWdpYyBJbGxpbm9pcyBoYWQgYXQgUmVnaW9uYWxzIHdhcyBsb3N0IGF0IE5hdGlvbmFscywgYXMgSWxsaW5vaXMgbG9zdCBzZXZlcmFsIGdhbWVzIGJ5IGJpZyBtYXJnaW5zIGV4Y2VwdCBmb3Igb25lIGNsb3NlIHBvb2wgcGxheSBnYW1lIGFnYWluc3QgVHVmdHMgYW5kIHRoZSBvbmx5IHdpbiBhZ2FpbnN0IENhbC4gVGhleSBkaWQgc28gaW4gZ29vZCBzcGlyaXQsIHdpbm5pbmcgdGhlIDIwMDkgTmF0aW9uYWxzIFNwaXJpdCBBd2FyZCBhbmQgZHViYmVkIFp1YmFpcjogVGhlIG1vc3Qgc3Bpcml0ZWQgbWFuIGluIHVsdGltYXRlLiBBbHRob3VnaCwgdGhpcyBwZXJmb3JtYW5jZSBnYXZlIElsbGlub2lzIGEgZGlzYXBwb2ludGluZyAxN3RoIHBsYWNlIGZpbmlzaCBhdCBOYXRpb25hbHMgYW5kIHdpdGggc2V2ZXJhbCBwbGF5ZXJzIGdyYWR1YXRpbmcgaW5jbHVkaW5nIGNhcHRhaW4gRGVuaXMgQWduaWVsLCB0aGUgcHJvc3BlY3Qgb2YgYW5vdGhlciByZWJ1aWxkaW5nIHllYXIgbG9vbWVkIGxhcmdlLjwvcD5cbiAgICAgICAgYFxuICAgIH0se1xuICAgICAgICB5ZWFyOiAyMDA4LFxuICAgICAgICBpbWFnZVBhdGg6ICcuL2Fzc2V0cy90ZWFtLXBob3RvLTIwMDguanBnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+VXNpbmcgdGhlIGxvc3MgYXQgUmVnaW9uYWxzIHRoZSBwcmV2aW91cyB5ZWFyIGFzIG1vdGl2YXRpb24gYW5kIGRldGVybWluZWQgdG8gbWFrZSBOYXRpb25hbHMgaW4gY2FwdGFpbnMgSm9lbCBLb2VobmVtYW4sIFBhdCBTdGVwaGFucyBhbmQgRGF2aWQgQWJyYW1zLCBmaW5hbCB5ZWFyLiBNYW55IHBsYXllcnMgb24gdGhlIHRlYW0gc3BlbnQgdGhlaXIgc3VtbWVyIGFuZCBmYWxsLCBnb2luZyB0byB0b3VybmFtZW50cyB0b2dldGhlciBpbiBhbiBlZmZvcnQgdG8gZ2V0IGJldHRlci4gSWxsaW5vaXMgYWxzbyBnb3QgYSBrZXkgdHJhbnNmZXIgc3R1ZGVudCBEZW5pcyBBZ25pZWwsIHdobyBjcmVhdGVkIHRoZSB0ZWFtIGF0IExveW9sYSBVbml2ZXJzaXR5IGluIENoaWNhZ28uIFRoaXMgd2FzIGEgdmVyeSB2ZXRlcmFuIHRlYW0gdW5kZXIgY29hY2ggTWF0dCBTdHVwY2EgdGhhdCB3YXMgcG9pc2VkIHRvIG1ha2UgYSBydW4gaW50byBOYXRpb25hbHMuPC9wPiAgICBcbiAgICAgICAgICAgIDxwPlRocm91Z2hvdXQgdGhlIHNlYXNvbiwgSWxsaW5vaXMgaGFkIGEgY2hhbmNlIHRvIHdpbiBldmVyeSBnYW1lIHRoYXQgdGhleSBwbGF5ZWQuIFRoZSBiaWdnZXN0IG1hcmdpbiBvZiB2aWN0b3J5IGluIElsbGlub2lzJyBsb3NzZXMgaGVhZGluZyBpbnRvIFJlZ2lvbmFscyB3YXMgMyBwb2ludHMuIElsbGlub2lzIHN1ZmZlcmVkIHNvbWUga2V5IGluanVyaWVzIGJlZm9yZSBTZWN0aW9uYWxzIGJ1dCBtYW5hZ2VkIHRvIHBlcnNldmVyZSBhbmQgaG9sZCBvZiBOb3J0aCBQYXJrIGluIGFuIGV4Y2l0aW5nIDE3LTE2IFNlY3Rpb25hbCBGaW5hbC4gTGlrZSB0aGUgcHJldmlvdXMgeWVhciBJbGxpbm9pcyBoYWQgYSAyIHNlZWQgZ29pbmcgaW50byBSZWdpb25hbHMuIFRoZXkgdG9vayBjYXJlIG9mIGJ1c2luZXNzIG9uIFNhdHVyZGF5IHdpbm5pbmcgYWxsIDMgZ2FtZXMgYW5kIHNlY3VyaW5nIGEgc3BvdCBpbiB0aGUgUmVnaW9uYWwgZmluYWxzLiBJbiBtYW55IHBlb3BsZSdzIGZpcnN0IFJlZ2lvbmFsIGZpbmFsLCBJbGxpbm9pcyBwbGF5ZWQgdGVudGF0aXZlbHkgYW5kIGxvc3QgMTUtMTEgdG8gTWljaGlnYW4gcHV0dGluZyB0aGVtIGluIHRoZSAybmQgcGxhY2UgZ2FtZSBhZ2FpbnN0IE9oaW8gU3RhdGUuIEluIGEgcmV2ZXJzYWwgb2YgdGhlIHByZXZpb3VzIHllYXJzIGdhbWUgYXQgUmVnaW9uYWxzLCBJbGxpbm9pcyBzdG9ybWVkIG91dCB0byBhIGJpZyBsZWFkIGFuZCBtYWludGFpbmVkIGl0IHRocm91Z2hvdXQgYW5kIHB1bmNoZWQgdGhlaXIgZmlyc3QgdGlja2V0IHRvIE5hdGlvbmFscyBpbiAzIHllYXJzLjwvcD4gICAgXG4gICAgICAgICAgICA8cD5QYXQgU3RlcGhlbnMgYW5kIEpvZWwgS29laG5lbWFuIGJvdGggd29uIGFsbC1yZWdpb24gaG9ub3JzLiBOYXRpb25hbHMgdGhhdCB5ZWFyIHdhcyBpbiBCb3VsZGVyLCBDb2xvcmFkbyBhbmQgSWxsaW5vaXMgd2VudCBpbnRvIGl0IGhvbGRpbmcgYW4gOCBzZWVkIGFuZCBpbiBhIHBvb2wgd2l0aCBGbG9yaWRhLCBOb3J0aCBUZXhhcyBhbmQgRGVsYXdhcmUuIElsbGlub2lzIGJlYXQgRGVsYXdhcmUgdG8gY2xpbmNoIGEgc3BvdCBpbiBwcmVxdWFydGVycywgYW5kIGxvc3QgdG8gRmxvcmlkYSBhbmQgTm9ydGggVGV4YXMuIEluIHByZXF1YXJ0ZXJzIElsbGlub2lzIHdhcyBtYXRjaGVkIHVwIGFnYWluc3QgTWljaGlnYW4sIHdobyB0aGV5IGhhZCBsb3N0IHRvIGF0IFJlZ2lvbmFscyBhbmQgaGFkIG5vdCBiZWF0ZW4gc2luY2UgMjAwNC4gSW4gYSBoYXJkIGZvdWdodCBnYW1lIGxlZCBieSB0aGUgZ3JhZHVhdGluZyBwbGF5ZXJzLCBJbGxpbm9pcyBwcmV2YWlsZWQgMTUtMTEgc2VuZGluZyB0aGVtIGludG8gcXVhcnRlcnMgYWdhaW5zdCB0aGUgaG9tZXRvd24gdGVhbSBDb2xvcmFkby4gSW4gYW4gZXhjaXRpbmcgZ2FtZSB0aGF0IHNhdyBzZXZlcmFsIGJpZyBwbGF5cywgSWxsaW5vaXMgbG9zdCAxNS0xMiB0byBDb2xvcmFkbyBhbmQgZW5kZWQgdGhlaXIgc2Vhc29uIGhhdmluZyB0aGVtIHRpZWQgZm9yIDV0aCB3aGljaCBpcyB0aGUgaGlnaGVzdCBmaW5pc2ggaW4gdGhlIHByb2dyYW1zIGhpc3RvcnkuIDIwMDggc2F3IHRoZSBkZXBhcnR1cmUgb2YgbWFueSBtYWluc3RheXMgZm9yIElsbGlub2lzIGFuZCB0aGUgZm9sbG93aW5nIHllYXJzIHdvdWxkIHNob3cgaG93IHdlbGwgdGhlIHJlY3J1aXRpbmcgZWZmb3J0cyBvZiAyMDA1IHBhaWQgb2ZmLjwvcD4gICAgICBcbiAgICAgICAgYFxuICAgIH0se1xuICAgICAgICB5ZWFyOiAyMDA3LFxuICAgICAgICBpbWFnZVBhdGg6ICcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5Db21pbmcgb2ZmIG9mIG9uZSB0aGUgd29yc3QgeWVhcnMgaW4gcmVjZW50IGhpc3RvcnksIElsbGlub2lzIHN0YXJ0ZWQgdG8gcHV0IHRoZSBwaWVjZXMgaW4gcGxhY2UgdG8gbWFrZSBhIHJ1biBhdCBhIE5hdGlvbmFscyBiZXJ0aC4gVGhlIGxlYWRlcnNoaXAgd2hpY2ggYWRkZWQgSmFrZSBTZWdpbCBhcyBhIGNhcHRhaW4sIGpvaW5pbmcgSm9lbCBLb2VobmVtYW4gYW5kIEJyaWFuIEtvcmJlc21leWVyIGFuZCBNYXR0IFN0dXBjYSBhcyBjb2FjaCwgY29udGludWVkIHRvIGZvY3VzIG9uIHJlY3J1aXRpbmcsIHJlc3VsdGluZyBpbiBhbiBhbm90aGVyIGJpZyBpbmZsdXggb2YgZnJlc2htYW4uIFJlc3VsdGluZyBpbiB0aGUgY3JlYXRpb24gb2YgdGhlIGZpcnN0IEMtdGVhbSBpbiB0aGUgcHJvZ3JhbXMgaGlzdG9yeS4gSG93ZXZlciwgdW5saWtlIHRoZSBwcmV2aW91cyB5ZWFyLCBtYW55IG9mIHRoZW0gc3RvcHBlZCBwbGF5aW5nIHdpdGhpbiBhIHllYXIuPC9wPiAgICBcbiAgICAgICAgICAgIDxwPkluIG9yZGVyIHRvIGdlYXIgdXAgdG8gbWFrZSBhIHJ1biBhbmQgdG8gZmFjZSBzdGlmZmVyIGNvbXBldGl0aW9uLCBJbGxpbm9pcyBkZXNpZ25lZCBhIG11Y2ggaGFyZGVyIHRvdXJuYW1lbnQgc2NoZWR1bGUgdHJhdmVsbGluZyB0byB0b3VybmFtZW50cyBpbiBMYXMgVmVnYXMgYW5kIEF1c3RpbiwgaW4gYWRkaXRpb24gdG8gb25lcyB0aGV5IGhhZCBwcmV2aW91c2x5IGdvbmUgdG8gaW4gQmF0b24gUm91Z2UgYW5kIEF0bGFudGEuIFRoaXMgYmVuZWZpdGVkIHRoZSB0ZWFtLCBhcyB0aGV5IHdlcmUgYWJsZSB0byBtYXRjaCB1cCBhbmQgc2VlIHdoZXJlIHRoZXkgc3Rvb2QgaW4gcmVsYXRpb24gdG8gYm90aCBOYXRpb25hbHMgZmluYWxpc3RzLiBBcyBhIHJlc3VsdCwgdGhlIHRlYW0gd2FzIGFibGUgdG8gc2VlIHRoYXQgdGhleSB3ZXJlIG1vcmUgdGhhbiBwcmVwYXJlZCB0byB0YWtlIGEgTmF0aW9uYWxzIGJlcnRoIG91dCBvZiBSZWdpb25hbHMuPC9wPiAgICBcbiAgICAgICAgICAgIDxwPklsbGlub2lzIHN0ZWFtcm9sbGVkIHRocm91Z2ggU2VjdGlvbmFscyBhbmQgcmVjbGFpbWVkIHRoZSBTZWN0aW9uYWxzIGNyb3duIGFuZCBoYWQgYSAyLXNlZWQgZ29pbmcgaW50byBSZWdpb25hbHMuIFJlZ2lvbmFscyB3YXMgaGVsZCBpbiBSYW50b3VsLCBJbGxpbm9pcyBhbmQgd2FzIGhvc3RlZCBieSBJbGxpbm9pcy4gSWxsaW5vaXMgdG9vayBjYXJlIG9mIGJ1c2luZXNzIGVhcmx5LCBiZWF0aW5nIERheXRvbiBhbmQgTm90cmUgRGFtZSBoYW5kaWx5IGJlZm9yZSBzcXVhcmluZyBvZmYgYWdhaW5zdCBJbmRpYW5hIGluIFJlZ2lvbmFsIHNlbWlmaW5hbHMuIEluIGEgdmVyeSBoZWF2eSB1cHdpbmQgZG93bndpbmQgZ2FtZSB0aGF0IHNhdyB2ZXJ5IGZldyBicmVha3MsIElsbGlub2lzIHJlY2VpdmVkIGdvaW5nIGRvd253aW5kIG9uIHVuaXZlcnNlIHBvaW50IGJ1dCB3YXMgdW5hYmxlIHRvIHB1bmNoIGl0IGluIGFuZCBsb3N0IG9uIGEgY291cGxlIGZsb2F0eSB1cHdpbmQgaHVja3MuIE91dCBvZiB0aGUgcnVubmluZyBmb3IgZmlyc3QsIElsbGlub2lzIHdhcyBub3cgaW4gdGhlIGJhY2tkb29yIGJyYWNrZXQgaGF2aW5nIHRvIHdpbiBldmVyeSBnYW1lIGluIG9yZGVyIHRvIGFkdmFuY2UgdG8gTmF0aW9uYWxzLiBUaGV5IGJlYXQgTm9ydGh3ZXN0ZXJuIGFuZCBmYWNlZCBPaGlvIFN0YXRlLCB0aGUgIzEgc2VlZCBnb2luZyBpbnRvIHRoZSB0b3VybmFtZW50IHdobyBoYWQgYWxzbyBsb3N0IGluIHNlbWlzIHRvIE1pY2hpZ2FuLiBQZXJoYXBzIHNob3dpbmcgYSBsaXR0bGUgYml0IG9mIGluZXhwZXJpZW5jZSBpbiBhIHByZXNzdXJlIGZpbGxlZCBnYW1lLCBJbGxpbm9pcyB3ZW50IGRvd24gYmlnIGVhcmx5LCBnb2luZyBkb3duIDUtMCwgaG93ZXZlciwgdGhleSBtb3VudGVkIGEgZnVyaW91cyBjb21lYmFjayBhbmQgY2FtZSBjbG9zZSB0byBuZWdhdGluZyB0aGUgZWFybHkgZGVmaWNpdCwgYnV0IGV2ZW50dWFsbHkgc3VjY3VtYmVkIDE1LTEyIGFuZCBlbmRpbmcgdGhlaXIgc2Vhc29uIHdpdGhvdXQgYSBOYXRpb25hbHMgYmVydGggZm9yIHRoZSAzcmQgeWVhciBpbiBhIHJvdy4gSWxsaW5vaXMgZmluaXNoZWQgNHRoIGF0IFJlZ2lvbmFscy48L3A+ICAgIFxuICAgICAgICAgICAgPHA+QnJpYW4gS29yYmVzbWV5ZXIgYW5kIEpvZWwgS29laG5lbWFuIGJvdGggcmVjZWl2ZWQgYWxsLXJlZ2lvbiBob25vcnMuIEhvd2V2ZXIgdW5saWtlIHRoZSBwcmV2aW91cyB5ZWFyLCB0aGVyZSB3ZXJlIHNldmVyYWwgZ3JhZHVhdGluZyBwbGF5ZXJzIG1vc3Qgbm90YWJseSBCcmlhbiBLb3JiZXNtZXllciwgd2hvIGhhZCBjYXB0YWluZWQgdGhlIHRlYW0gdGhlIHByZXZpb3VzIDIgeWVhcnMgYW5kIHdhcyBhIG1ham9yIHBsYXllciBvbiBvZmZlbnNlLiBGaW5kaW5nIHBsYXllcnMgdG8gc3RlcCBpbnRvIHRoZSBob2xlcyBsZWZ0IGJ5IHRoZSBncmFkdWF0aW5nIHBsYXllcnMgd2FzIGEgbWFqb3IgcXVlc3Rpb24gZ29pbmcgaW50byB0aGUgbmV4dCB5ZWFyLjwvcD4gICAgXG4gICAgICAgIGBcbiAgICB9LHtcbiAgICAgICAgeWVhcjogMjAwNixcbiAgICAgICAgaW1hZ2VQYXRoOiAnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+QWZ0ZXIgY29taW5nIHNvIGNsb3NlIHRvIGEgTmF0aW9uYWxzIGJlcnRoIHRoZSB5ZWFyIGJlZm9yZSwgMjAwNiB3YXMgYSByZWJ1aWxkaW5nIHllYXIgZm9yIElsbGlub2lzLiBBZnRlciBsb3Npbmcgc2V2ZXJhbCBzdGFydGluZyBwbGF5ZXJzLCB0aGUgY2FwdGFpbnMsIEJyaWFuIEtvcmJlc21leWVyIGFuZCBKb2VsIEtvZWhuZW1hbiBhbmQgY29hY2ggTWF0dCBTdHVwY2EsIGRlY2lkZWQgdG8gZm9jdXMgdGhlaXIgZW5lcmdpZXMgb24gcmVjcnVpdGluZyBhbmQgcmVwbGVuaXNoaW5nIHRoZSBwcm9ncmFtLiBUaGlzIGxlZCB0byBvbmUgb2YgdGhlIGRlZXBlc3QgZnJlc2htYW4gY2xhc3NlcyBpbiB0aGUgcHJvZ3JhbXMgaGlzdG9yeSBsYXJnZWx5IGR1ZSB0byB0aGUgZWZmb3J0cyBvZiBCcmlhbiBLb3JiZXNtZXllci4gSW4gb3JkZXIgdG8gZmFjaWxpdGF0ZSB0aGUgcmVidWlsZGluZyBwcm9jZXNzLCB0aGUgbGVhZGVyc2hpcCBkZWNpZGVkIHRvIGdvIHdpdGggYSB2ZXJ5IHNtYWxsIEEtdGVhbSByb3N0ZXIgb2YgbGVzcyB0aGFuIDIwIGd1eXMsIHNvIHRoYXQgZXZlcnlvbmUgd291bGQgYmUgYWJsZSB0byBwbGF5IGJvdGggb24gdGhlIEEtdGVhbSBhbmQgb24gdGhlIEItdGVhbS4gVGhlIEItdGVhbSB3aXRoIHRoZSBzZXJ2aWNlcyBvZiBjb2FjaCBOaWNrIE1jRHVmZmVlIHdhcyBhYmxlIHRvIG51cnR1cmUgdGhlIHBsYXllcnMgYW5kIGhhdmUgdGhlbSByZWFkeSB0byB0YWtlIHRoZSBuZXh0IHN0ZXAgb250byB0aGUgQS10ZWFtLiBJdCB3YXMgYSBzZWFzb24gd2l0aCB2ZXJ5IGZldyBicmlnaHQgc3BvdHMsIGFzIElsbGlub2lzIGRpZCBub3QgbWFrZSB0aGUgU2VjdGlvbmFsIGZpbmFsIGZvciBvbmUgb2YgdGhlIGZldyB0aW1lcyBpbiBtb2Rlcm4gaGlzdG9yeSwgZmluaXNoaW5nIDR0aCBhdCBTZWN0aW9uYWxzLCBhbmQgZGlkIG5vdCBldmVuIG1ha2UgU3VuZGF5IG9mIFJlZ2lvbmFscywgZmluaXNoaW5nIHRpZWQgZm9yIDd0aCBhZnRlciBsb3NpbmcgaW4gcXVhcnRlcmZpbmFscyBhbmQgZ2V0dGluZyBlbGltaW5hdGVkIGluIHRoZSBiYWNrZG9vciBicmFja2V0LiBIb3dldmVyLCB0aGVyZSB3ZXJlIGVuY291cmFnaW5nIHNpZ25zIGZvciBmdXR1cmUgeWVhcnMgdG8gY29tZSwgQnJpYW4gUGhlbGFuIHdvbiBmcmVzaG1hbiBvZiB0aGUgeWVhciBmb3IgdGhlIEdyZWF0IExha2VzIFJlZ2lvbiBhbmQgdGhlcmUgd2VyZSBzZXZlcmFsIHRhbGVudGVkIHBsYXllcnMgd2FpdGluZyBpbiB0aGUgd2luZ3MsIHJlYWR5IHRvIG1ha2UgdGhlaXIgbWFyayBvbiB0aGUgcHJvZ3JhbSBhbmQgdGhlIHNhbWUgY29yZSBvZiBwbGF5ZXJzIHJldHVybmluZy48L3A+ICAgIFxuICAgICAgICBgXG4gICAgfSx7XG4gICAgICAgIHllYXI6IDIwMDUsXG4gICAgICAgIGltYWdlUGF0aDogJycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPklsbGlub2lzIGFkdmFuY2VkIHRvIHRoZSBmaW5hbHMgYXQgUmVnaW9uYWxzIGFuZCBsb3N0IHRvIE1pY2hpZ2FuIG9uIGRvdWJsZSBnYW1lIHBvaW50LCBhbmQgaGFkIHRvIGltbWVkaWF0ZWx5IHBsYXkgTWljaGlnYW4gU3RhdGUgZm9yIHNlY29uZCBwbGFjZSBhbmQgdGhlIGNoYW5jZSB0byByZXR1cm4gdG8gbmF0aW9uYWxzLiBDb21pbmcgb3V0IGZsYXQgYWZ0ZXIgdGhlIGxvc3MgdG8gTWljaGlnYW4gSWxsaW5vaXMgd2VudCBkb3duIDMtMC4gQmF0dGxlZCBiYWNrIHRvIGRvdWJsZSBnYW1lIHBvaW50IGJ1dCBhZ2FpbiBsb3N0IGFuZCB3ZXJlIGVsaW1pbmF0ZWQuPC9wPlxuICAgICAgICBgXG4gICAgfSx7XG4gICAgICAgIHllYXI6IDIwMDQsXG4gICAgICAgIGltYWdlUGF0aDogJycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPklsbGlub2lzIGZpbmlzaGVkIHNlY29uZCBhdCBSZWdpb25hbHMgYW5kIGFkdmFuY2VkIHRvIE5hdGlvbmFscyBpbiBTZWF0dGxlLCBXYXNoaW5ndG9uLiBJbGxpbm9pcyBsb3N0IGEgY2xvc2UgZ2FtZSB0byBOb3J0aCBDYXJvbGluYSBTdGF0ZSBpbiBQcmVxdWFydGVycyBhbmQgZmluaXNoZWQgOXRoLjwvcD5cbiAgICAgICAgYFxuICAgIH0se1xuICAgICAgICB5ZWFyOiAyMDAzLFxuICAgICAgICBpbWFnZVBhdGg6ICcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5JbGxpbm9pcyBzdGFydGVkIGJlaW5nIGludml0ZWQgdG8gdGhlIG1ham9yIHRvdXJuYW1lbnRzLCBpbmNsdWRpbmcgaXRzIGZpcnN0IGludml0ZSB0byBFYXN0ZXJucy4gVGhpcyBoZWxwZWQgcHJlcGFyZSB0aGUgdGVhbSBmb3IgdGhlIHNlYXNvbi4gU2VlZGVkIGZpcnN0IGF0IFJlZ2lvbmFscywgSWxsaW5vaXMgbG9zdCBpbiB0aGUgZmluYWxzIHRvIE9oaW8gU3RhdGUgYW5kIGFkdmFuY2VkIHRvIE5hdGlvbmFscyBpbiBBdXN0aW4sIFRYLiBBZnRlciBiZWF0aW5nIE1pY2hpZ2FuIGFuZCBHZW9yZ2lhIGZhaXJseSBoYW5kaWx5IGluIHRoZSBmaXJzdCB0d28gZ2FtZXMsIElsbGlub2lzIGJlYXQgTm9ydGggQ2Fyb2xpbmEgU3RhdGUgMTctMTUgdG8gd2luIHRoZSBwb29sLiBJbiBxdWFydGVycyBJbGxpbm9pcyBtYXRjaGVkIHVwIHdpdGggQ29sb3JhZG8uVGhleSB3ZXJlIDMgZmVldCBhd2F5IGZyb20gYmVpbmcgdXAgMTQtMTMsIHB1bGxpbmcgZG93bndpbmQsIGJ1dCB2aWN0b3J5IGVsdWRlZCB0aGVtLCBhbmQgZW5kZWQgdXAgZmluaXNoaW5nIHRpZWQgZm9yIDV0aC48L3A+XG4gICAgICAgIGBcbiAgICB9LHtcbiAgICAgICAgeWVhcjogMjAwMixcbiAgICAgICAgaW1hZ2VQYXRoOiAnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+VGhlIHByb2dyYW0gbWFkZSBhIGJpZyBqdW1wIGZvcndhcmQgdW5kZXIgdGhlIGNvYWNoaW5nIG9mIEpvZSBGZXJyYXJpLiBUaGUgdGVhbSBhZHZhbmNlZCB0byB0aGUgUmVnaW9uYWwgRmluYWwgZm9yIHRoZSBmaXJzdCB0aW1lIGV2ZXIsIHRoZSBGaW5hbCB3YXMgYWdhaW5zdCBNaWNoaWdhbi4gVGhlcmUgd2FzIGEgY29uc2lzdGVudCB3aW5kIG9mIDI1LTM1IG1waCB3aXRoIGd1c3RzIG9mIG92ZXIgNDAuIEZvciBhIGxvdCBvZiB0aGUgZ2FtZSBpdCB3YXMgdXB3aW5kL2Rvd253aW5kIHdpdGggdGhlIGh1Y2sgYW5kIHpvbmUgc3RyYXRlZ3kgYmVpbmcgZW1wbG95ZWQuIFRoZW4gZWFybHkgaW4gdGhlIHNlY29uZCBoYWxmIHdlIGdvdCBhIGJpZyBicmVhayBvZmYgYW5kIHdlcmUgYWJsZSB0byB3b3JrIHRoZSBkaXNjIHVwIHRoZSBiYWNraGFuZCBzaWRlbGluZSBhbGwgdGhlIHdheSB0byB0aGUgZW5kem9uZSBmb3IgYSBzY29yZSB0byB0YWtlIHRoZSBsZWFkLiBGcm9tIHRoZXJlIHdlIG1haW50YWluZWQgb3VyIGxlYWQgdXAgdG8gMTMtMTIuIE1pY2hpZ2FuIHdvcmtlZCB0aGUgZGlzYyB1cHdpbmQgYW5kIGNhbGxlZCBhIHRpbWVvdXQgNSB5YXJkcyBvdXQgb2YgdGhlIGVuZHpvbmUgb24gdGhlIGZvcmVoYW5kIHNpZGUuIE91dCBvZiB0aGUgdGltZW91dCB0aGV5IGhhZCBhIG1hbiBicmVhayBvcGVuIG9uIHRoZSBmb3JjZSBzaWRlLiBBbHZpbiBXYW5nIHdhcyBhYmxlIHRvIHJ1biBwYXN0IGZvciB0aGUgZ2FtZSBzYXZpbmcgZC4gV2Ugd2VyZSBhYmxlIHRvIHNjb3JlIHRoYXQgcG9pbnQgYW5kIHRoZSBuZXh0IGRvd253aW5kZXIgaW4gdGhlIGJhY2sgY29ybmVyIG9mIHRoZSBlbmR6b25lIHRvIGFkdmFuY2UgdG8gb3VyIGZpcnN0IE5hdGlvbmFscy4gSWxsaW5vaXMnIGZpcnN0IE5hdGlvbmFscyB0b3VybmFtZW50IHdhcyBpbiBTcG9rYW5lLCBXQS4gV2UgbG9zdCBtYW55IGNsb3NlIGdhbWVzIGVhcmx5IHRvIENvbG9yYWRvIGFuZCBDYXJsZXRvbi4gV2UgYmVhdCBDb2xvcmFkbyBsYXRlciBpbiB0aGUgdG91cm5hbWVudCBhbmQgZmluaXNoZWQgOXRoLjwvcD5cbiAgICAgICAgYFxuICAgIH0se1xuICAgICAgICB5ZWFyOiAyMDAxLFxuICAgICAgICBpbWFnZVBhdGg6ICcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD5CaWxsIEZpbm4gYW5kIE5pY2sgTWNEdWZmZWUgam9pbmVkIHRoZSB0ZWFtIHRoaXMgeWVhciwgYW5kIHRoZSB0ZWFtIHdhcyB0aGUgc3Ryb25nZXN0IGl0IGhhZCBldmVyIGJlZW4gd2l0aCB0aGVzZSB0d28gb3V0c3RhbmRpbmcgcm9va2llcy4gTWFueSBvZiB0aGUgb2xkZXIgcmV0dXJuZXJzIG5vdyBoYWQgMy00IHllYXJzIG9mIGNvbXBldGl0aXZlIHVsdGltYXRlIHVuZGVyIHRoZWlyIGJlbHRzLCBhbmQgdGhlIHRlYW0gd2FzIG9uIHRoZSB2ZXJnZSBvZiBicmVha2luZyB0aHJvdWdoLiBBIFNlY3Rpb25hbCBmaW5hbCB3aW4gb3ZlciBJbmRpYW5hIHNldCB1cCBJbGxpbm9pcyBhcyB0aGUgM3JkIHNlZWQgYXQgUmVnaW9uYWxzIGJlaGluZCBNaWNoaWdhbiBhbmQgT1NVIChyZWdpb25hbCBob3N0cykuIEFmdGVyIGJlYXRpbmcgYSB0b3VnaCBORCB0ZWFtIGluIHF1YXJ0ZXJmaW5hbHMsIElsbGlub2lzIGZhY2VkIE1pY2hpZ2FuIGluIHRoZSBzZW1pZmluYWxzLiBEZXNwaXRlIGJlaW5nIHVwIGJ5IGEgZmV3IGdvYWxzIGF0IGhhbGYtdGltZSwgTWljaGlnYW4ncyBOYXRpb25hbHMgZXhwZXJpZW5jZSBzaG93ZWQgYW5kIHRoZXkgZW5kZWQgdXAgd2lubmluZyBhIGNsb3NlbHkgZm91Z2h0IGdhbWUuIFN1bmRheSBtb3JuaW5nLCBJbGxpbm9pcyBsb3N0IHRvIE9iZXJsaW4sIG1ha2luZyBpdCB0aHJlZSBzdHJhaWdodCB5ZWFycyBvZiBzZW1pZmluYWwgbG9zc2VzIGF0IFJlZ2lvbmFscy48L3A+XG4gICAgICAgIGBcbiAgICB9LHtcbiAgICAgICAgeWVhcjogMjAwMCxcbiAgICAgICAgaW1hZ2VQYXRoOiAnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+SWxsaW5vaXMgY2hhbmdlZCBpdHMgbmFtZSB0byBGSVNUIGFuZCBoYWQgYW5vdGhlciBnb29kIHJlY3J1aXRpbmcgY2xhc3Mgd2l0aCB0aGUgbGlrZXMgb2YgR3JlZyBTZXZlcmluLCBDaHJpcyBIYWdlbiwgTmVscyBPdmVyZ2FhcmQtQ29vaywgS3lsZSBFZXJ0bW9lZCwgQnJpYW4gRmlmYXJlaywgYW5kIERhdmUgRHJhZWdlci4gSWxsaW5vaXMgd2VudCB0byB0aGUgU3RhbmZvcmQgSW52aXRlIGZvciB0aGUgZmlyc3QgdGltZS4gUmVnaW9uYWxzIHdhcyBhdCBQdXJkdWUgVW5pdmVyc2l0eSB0aGF0IHllYXIsIGFuZCBJbGxpbm9pcyBsb3N0IHRvIERheXRvbiBpbiBzZW1pZmluYWxzLCBiZWF0IE9iZXJsaW4gU3VuZGF5IG1vcm5pbmcsIGFuZCB0aGVuIGxvc3QgYW4gZWxpbWluYXRpb24gZ2FtZSB0byBOb3RyZSBEYW1lLjwvcD5cbiAgICAgICAgYFxuICAgIH0se1xuICAgICAgICB5ZWFyOiAxOTk5LFxuICAgICAgICBpbWFnZVBhdGg6ICcnLFxuICAgICAgICBzdW1tYXJ5TWFya3VwOiBgXG4gICAgICAgICAgICA8cD4xOTk5IHNhdyBhbm90aGVyIHN1cmdlIGluIHRoZSB0ZWFtJ3MgZGV2ZWxvcG1lbnQuIE1vcmUgcmVjcnVpdHMgbGlrZSBBbHZpbiBXYW5nLCBKb2huIEtvbHRzZSwgYW5kIEtldmluIFBhdHRlcnNvbiBqb2luZWQgdGhlIHRlYW0uIFRoZSBDb2xsZWdlIFJlZ2lvbnMgd2VyZSByZWRyYXduIHdoaWNoIG1lYW50IHRoYXQgSWxsaW5vaXMgaGFkIGEgcmVhbCBvcHBvcnR1bml0eSB0byBxdWFsaWZ5IGZvciBuYXRpb25hbHMgaW4gdGhlIG5ld2x5IGZvcm1lZCBHcmVhdCBMYWtlcyBSZWdpb24uIEl0IHdhcyBhIGdyZWF0IHllYXIgZm9yIHRoZSB0ZWFtLCB3aGljaCByYWNrZWQgdXAgbWFueSB3aW5zLCBpbmNsdWRpbmcgd2lucyBhdCBGcm96ZW4gT3ZlciBpbiBCbG9vbWluZ3RvbiwgSU4gYW5kIHRoZSBmaXJzdCBTZWN0aW9uYWwgQ2hhbXBpb25zaGlwIGZvciB0aGUgdGVhbS4gQ29taW5nIGludG8gUmVnaW9uYWxzLCBJbGxpbm9pcyB3YXMgc2VlZGVkIHNlY29uZCBhbmQgaG9zdGVkIHRoZSB0b3VybmFtZW50LiBUaGUgdGVhbSBsb3N0IGEgaGVhcnRicmVha2VyIGluIHNlbWlmaW5hbHMgdG8gT2JlcmxpbiBDb2xsZWdlLCBhbmQgdGhlbiBsb3N0IGFuIGVsaW1pbmF0aW9uIGdhbWUgb24gU3VuZGF5IG1vcm5pbmcgdG8gTm90cmUgRGFtZS48L3A+XG4gICAgICAgIGBcbiAgICB9LHtcbiAgICAgICAgeWVhcjogMTk5OCxcbiAgICAgICAgaW1hZ2VQYXRoOiAnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+V2FzIGEgdHJhbnNmb3JtYXRpb25hbCB5ZWFyIGZvciB0aGUgcHJvZ3JhbSwgYXMgYSBncmVhdCBjbGFzcyBvZiByb29raWVzIGpvaW5lZCBJbGxpbm9pcy4gSmFycmV0dCBCaWFsZWssIFhpYSBYaSwgQW5keSBaaWxsLCBLeWxlIFJvbWJlcmcsIGFuZCBKYWNvYiBEZWUgd2VyZSBhbW9uZyB0aGUgbmV3IHBsYXllcnMgd2hvIGhlbHBlZCBwdXNoIHRoZSB0ZWFtIHRvIHRvd2FyZHMgYmVjb21pbmcgYSBtb3JlIGxlZ2l0aW1hdGUgcHJvZ3JhbS4gVGhlIHRlYW0gY2hhbmdlZCB0aGVpciBuYW1lIHRvICdNZW4gRnJvbSBNYXJzJywgZ290IHVuaWZvcm1zLCBkZXNpZ25lZCBuZXcgZGlzY3MsIGFuZCBhY3R1YWxseSBzdGFydGVkIHByYWN0aWNpbmcgYSByZWFsIG9mZmVuc2l2ZSBzY2hlbWUgYW5kIHNwZW50IG1vcmUgdGltZSB3b3JraW5nIG91dCBvZmYgdGhlIGZpZWxkLiBJbGxpbm9pcyBzZXQgdGhlIGdvYWwgb2YgcXVhbGlmeWluZyBmb3IgUmVnaW9uYWxzLCBhbmQgYXQgdGhhdCB0aW1lIHRoZSBDZW50cmFsIFJlZ2lvbiBpbmNsdWRlZCBldmVyeSBzdGF0ZSBmcm9tIE1pbm5lc290YSB0byBJbGxpbm9pcyB0byBDb2xvcmFkby4gQSA0dGggcGxhY2UgZmluaXNoIGF0IHNlY3Rpb25hbHMgcHJvcGVsbGVkIHRoZW0gdG8gdGhlaXIgZmlyc3QgUmVnaW9uYWxzIGJpcnRoIGluIG1hbnkgeWVhcnMuIEF0IFJlZ2lvbmFscyBpbiBNaWNoaWdhbiwgSWxsaW5vaXMgcGxheWVkIEdyaW5uZWxsIGFuZCBDb2xvcmFkbyBTdGF0ZSBwb29sIHBsYXksIGJ1dCB3ZXJlIGVsaW1pbmF0ZWQgZnJvbSBjb21wZXRpdGlvbiBvbiBTYXR1cmRheS48L3A+XG4gICAgICAgIGBcbiAgICB9LHtcbiAgICAgICAgeWVhcjogMTk5NyxcbiAgICAgICAgaW1hZ2VQYXRoOiAnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+VG9tIENvZmZpbiBha2EgSXJvbiBNYW4sIGFuIG9sZGVyIHBsYXllciBkZXNlcnZlcyBjcmVkaXQgZm9yIG9yZ2FuaXppbmcgdGhlIHByb2dyYW0gYW5kIHJlY3J1aXRpbmcgZWZmb3J0cy4gSGUgbW92ZWQgdG8gQ2hhbXBhaWduIGluIHRoZSBmYWxsIG9mIDE5OTYgYW5kIHJlYWxseSBoZWxwZWQgbGVhZCB0aGUgcHJvZ3JhbSBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uIGFsb25nIHdpdGggcGxheWVycyBsaWtlIEpvZSBGZXJyYXJpIGFuZCBSeWFuIEZlaHJlbmJhY2hlciBhbmQgb3RoZXJzLiBJbiB0aGUgZmFsbCBvZiAxOTk2LCB0aGUgdGVhbSB3YXMgbW9zdGx5IGZpbGxlZCB3aXRoIGdyYWR1YXRlIHN0dWRlbnRzIGFuZCBvbGRlciBwbGF5ZXJzLCBhbmQgaGFkIGEgJ3NlcmlvdXMnIHBpY2stdXAgdmliZSB3aGVyZSBwcmFjdGljZXMgd2VyZSBtb3N0bHkgc2NyaW1tYWdlcyB3aXRoIHNvbWUgb2NjYXNpb25hbCBkcmlsbHMuIFVuZGVyIENhcHRhaW4gVGVkIFdpbnJvdywgJ0JpZyBSZWQgVWx0aW1hdGUnIHN0cnVnZ2xlZCB0byB3aW4gbWFueSBnYW1lcywgYnV0IHRyYXZlbGVkIHRvIHRvdXJuYW1lbnRzIGluIEJhdG9uIFJvdWdlLCBMQSwgQ2FyYm9uZGFsZSwgSUwsIE1hZGlzb24sIFdJLCBhbW9uZ3N0IGEgZmV3IG90aGVycy4gS2V5IHBsYXllcnMgaW5jbHVkZWQgSm9obiBDb25vdXIsIExlbyBXYW5nLCBKb24gUmFzbXVzc2VuLCBhbmQgRGF2aWQgRmlza2UuIEpvZSBGZXJyYXJpIGFuZCBNYXR0IFRheWxvciB3ZXJlIHRoZSBvbmx5IGZyZXNobWVuLCB3aG8gc2hvd2VkIHVwIGNvbnNpc3RlbnRseSwgYW5kIHRoZSB5ZWFyIGVuZGVkIHdpdGggYSBsb3cgZmluaXNoIGF0IFNlY3Rpb25hbHMgYW5kIElsbGlub2lzIGRpZCBub3QgcXVhbGlmeSBmb3IgUmVnaW9uYWxzIHRoYXQgeWVhci4gQlJVIC0gdGhlIG9yaWdpbiBvZiB0aGlzIG5hbWUgY29tZXMgZnJvbSB0aGUgcHJhY3RpY2Ugb24gdGhlIHRlYW0gd2hlcmUgaWYgeW91IGdvdCBoYW5kYmxvY2tlZCB5b3UgaGFkIHRvIGNodWcgYSBib3R0bGUgb2YgQmlnIFJlZCBTb2RhLCB3aGljaCBoYWQgc29tZSBzaWduaWZpY2FuY2UuPC9wPlxuICAgICAgICBgXG4gICAgfSx7XG4gICAgICAgIHllYXI6IDE5OTYsXG4gICAgICAgIGltYWdlUGF0aDogJycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPklsbGlub2lzIGFnYWluIGhvc3RlZCBTZWN0aW9uYWxzIGFuZCBxdWFsaWZpZWQgZm9yIFJlZ2lvbmFscywgZmluaXNoaW5nIDNyZCBiZWhpbmQgTm90cmUgRGFtZSBhbmQgSW5kaWFuYS4gT3VyIHRlYW0gYnkgdGhpcyBwb2ludCB3YXMgbW9yZSB0aGFuIGhhbGYgdW5kZXJncmFkdWF0ZXM7IHRoZXJlIHdlcmUgYXQgbW9zdCAxNCBhdCBSZWdpb25hbHMuIFRoZSB0ZWFtIHdhcyBydW4gYXQgdGhpcyB0aW1lIGJ5IFRlZCBXaW5yb3cuIFRlZCBhbmQgR2FyeSBMZWRvbm5lIHdlcmUgYmFzaWNhbGx5IHRoZSBlbnRpcmUgdGVhbS4gQmlsbCBCcmFuc29uIHdhcyBzdGlsbCBwbGF5aW5nLCBKb2huIENvbm5vdXIgd2FzIGluIGhpcyBmaXJzdCB5ZWFyLCBMZW8gV2FuZyB3YXMgaW4gaGlzIGZpcnN0IHllYXIgYWxTb3Bob21vcmUgR2FyeSBMZWRvbm5lIGhhZCB0byBjb252aW5jZSBwbGF5ZXJzIHRvIGF0dGVuZCBSZWdpb25hbHMgaW4gV2VzdCBMYWZheWV0dGUuIElsbGlub2lzIHdlbnQgMC0zIGluIHBvb2wgcGxheSBsb3NpbmcgcmVsYXRpdmVseSBjbG9zZSBnYW1lcyB0byBDb2xvcmFkbyBhbmQgT2Jlcmxpbi48L3A+XG4gICAgICAgIGBcbiAgICB9LHtcbiAgICAgICAgeWVhcjogMTk5NSxcbiAgICAgICAgaW1hZ2VQYXRoOiAnJyxcbiAgICAgICAgc3VtbWFyeU1hcmt1cDogYFxuICAgICAgICAgICAgPHA+QWZ0ZXIgbG9zaW5nIDIgb2Ygb3VyIHRvcCBncmFkIHN0dWRlbnRzIElsbGlub2lzIGxvc3QgaW4gdGhlIGdhbWUgdG8gZ28gdG8gUmVnaW9uYWxzIHRvIEJhbGwgU3RhdGUuPC9wPlxuICAgICAgICBgXG4gICAgfSx7XG4gICAgICAgIHllYXI6IDE5OTQsXG4gICAgICAgIGltYWdlUGF0aDogJycsXG4gICAgICAgIHN1bW1hcnlNYXJrdXA6IGBcbiAgICAgICAgICAgIDxwPkluIEZlYnJ1YXJ5IG9mIDE5OTQsIElsbGlub2lzIGhhZCB3aW50ZXIgcHJhY3RpY2VzIGluIHRoZSBBcm1vcnkgYW5kIHRoZSBCdWJibGUuIFRoZSBVbml2ZXJzaXR5IHdvdWxkIGdpdmUgdXMgMS41IGhvdXJzIGEgd2VlayBTdW5kYXkgbmlnaHQgMTA6MzAgdG8gTWlkbmlnaHQsIHdlIHNwbGl0IHVzZSB3aXRoIHRoZSB3b21lbidzIHRlYW0uIFRoZSBtYWtldXAgb2YgdGhlIHRlYW0gd2FzIG11Y2ggZGlmZmVyZW50LCB0aGVyZSB3ZXJlIGhhZCAxNyBwbGF5ZXJzIGF0IFNlY3Rpb25hbHMgNCB3ZXJlIHVuZGVyZ3JhZHMuIEFsbW9zdCBhbGwgZ3JhZCBzdHVkZW50cyBhbmQgbW9zdCB3ZXJlIGluIHRoZWlyIGxhdGUgMjAncy4gVGhlcmUgd2FzIGxpdHRsZSB0byBubyByZWNydWl0aW5nIGVmZm9ydC4gUHJhY3RpY2UgZ2VuZXJhbGx5IGNvbnNpc3RlZCBvZiBzb21lIGJhZCBkcmlsbHMsIGJ1dCB0aGV5IHdlcmUgZHJpbGxzIGRlc2lnbmVkIHRvIGxlYXJuIGhvdyB0byB0aHJvdyBpbiBtb3N0IGNhc2VzLCB0aGVuIHdlIHNjcmltbWFnZWQuIE91ciBsZXZlbCBvZiBhdGhsZXRpY2lzbSB3YXMgYXdmdWwgY29tcGFyZWQgdG8gdG9kYXkncyBnYW1lLCBidXQgb3VyIG9sZGVyIHRlYW0gd2FzIHByZXR0eSBzdHJvbmcgdGhyb3dpbmcsIGF0IGxlYXN0IGZvciBhIGNvbGxlZ2UgdGVhbSBhdCB0aGF0IHRpbWUuIFdpbmQgd2FzIG91ciBmcmllbmQgYXMgaXQgYWxsb3dlZCB1cyB0byBydW4gYSB6b25lLiBJbiBhbnkgY2FzZSB0aGUgdGVhbSB3YXMgZmFpcmx5IHNvbGlkLiBUb255IEN1cnRpcywgTWlrZSBQZXJjeSwgYW5kIEJpbGwgQnJhbnNvbiB3ZXJlIHNvbWUgb2YgdGhlIHN0cm9uZyBncmFkIHN0dWRlbnQgdGhyb3dlcnMuIE1pa2UgRnJpdHogYW4gb2xkIHVuZGVyZ3JhZCBhdCAyMywgVGVkIFdpbnJvdyBhbmQgR2FyeSBMZWRvbm5lIGJvdGggc29waG9tb3JlcyB3ZXJlIHRoZSBjb250cmlidXRpbmcgdW5kZXJncmFkcy4gVGhlIHRlYW0gaG9zdGVkIFNlY3Rpb25hbHMgYW5kIHRvb2sgMm5kIHRvIFB1cmR1ZSwgb3VyIGJpZyB3aW4gd2FzIGJlYXRpbmcgSW5kaWFuYSB3aG8gaGFkIGJlZW4gdGhlIHN0cmVuZ3RoIG9mIHRoZSBTZWN0aW9uLiBSZWdpb25hbHMgd2FzIGluIEdyaW5uZWxsLCBJb3dhLiBJdCB3YXMgdGhlIGZpcnN0IHllYXIgdGhleSBoYWQgbW92ZWQgQ29sb3JhZG8gaW50byBvdXIgUmVnaW9uIGFzIHRoZXkgaGFkIGxvYmJpZWQgZm9yIGFuIGVhc2llciBSZWdpb24uIEF0IFJlZ2lvbmFscyBJbGxpbm9pcyB3ZW50IDMtMSBpbiBwb29sIHBsYXksIGxvc2luZyB0byBQdXJkdWUsIGJlYXRpbmcgQ29sb3JhZG8sIE1hY2FsZXN0ZXIsIGFuZCBHcmlubmVsbC4gSW4gcHJlLXF1YXJ0ZXJzIHdlIGJlYXQgRGF5dG9uIG1ha2luZyB0aGUgdG9wIDggZG91YmxlIGVsaW1pbmF0aW9uIGZvciAzIHNwb3RzLiBMb3N0IHRvIENhcmxldG9uIGFuZCBPYmVybGluIGFuZCB0aGF0IHdhcyBpdC48L3A+XG4gICAgICAgIGBcbiAgICB9XG5dO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9oaXN0b3J5L3RlYW0taGlzdG9yeS9kYXRhL2hpc3RvcnkteWVhci5kYXRhLnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxoMSBjbGFzcz1cXFwidWkgaGVhZGVyXFxcIj5UZWFtIEhpc3Rvcnk8L2gxPlxcbjxkaXYgY2xhc3M9XFxcInVpIHNlY29uZGFyeSBwb2ludGluZyBtZW51XFxcIj5cXG4gICAgPGRpdiAjMTk5NGRyb3Bkb3duIGNsYXNzPVxcXCJ1aSBkcm9wZG93biBpdGVtXFxcIj5cXG4gICAgICAgIDE5OTQtMTk5OTxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OTRcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTQ8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OTVcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTU8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OTZcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTY8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OTdcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTc8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OThcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTg8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzE5OTlcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjE5OTk8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiAjMjAwMGRyb3Bkb3duIGNsYXNzPVxcXCJ1aSBkcm9wZG93biBpdGVtXFxcIj5cXG4gICAgICAgIDIwMDAtMjAwOTxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDFcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDE8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDJcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDI8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDNcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDM8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDRcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDQ8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDVcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDU8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDZcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDY8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDdcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDc8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDhcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDg8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMDlcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMDk8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiAjMjAxMGRyb3Bkb3duIGNsYXNzPVxcXCJ1aSBkcm9wZG93biBpdGVtXFxcIj5cXG4gICAgICAgIDIwMTAtMjAxNzxpIGNsYXNzPVxcXCJkcm9wZG93biBpY29uXFxcIj48L2k+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZW51XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTBcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTFcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTE8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTJcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTI8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTNcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTM8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTRcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTQ8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTVcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTU8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTZcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTY8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9oaXN0b3J5LzIwMTdcXFwiIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjIwMTc8L2Rpdj5cXG5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG48aDIgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+e3t5ZWFyfX08L2gyPlxcbjxuZy1jb250YWluZXIgKm5nRm9yPVxcXCJsZXQgaGlzdG9yeVllYXIgb2YgaGlzdG9yeURhdGFcXFwiPlxcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVxcXCJoaXN0b3J5WWVhci55ZWFyID09PSB5ZWFyXFxcIj5cXG4gICAgICAgIDxpbWcgKm5nSWY9XFxcImhpc3RvcnlZZWFyLmltYWdlUGF0aFxcXCIgc3JjPVxcXCJ7e2hpc3RvcnlZZWFyLmltYWdlUGF0aH19XFxcIi8+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzdW1tYXJ5XFxcIiBbaW5uZXJIVE1MXT1cXFwiaGlzdG9yeVllYXIuc3VtbWFyeU1hcmt1cFxcXCI+PC9kaXY+XFxuICAgIDwvbmctY29udGFpbmVyPlxcbjwvbmctY29udGFpbmVyPlxcbjwhLS1Pbmx5IHNob3cgdGhlIHByZXZpb3VzIGFuZCBuZXh0IGJ1dHRvbiBpZiB0aGV5IGFyZSB3aXRoaW4gdGhlIGJvdW5kcyBvZiBvdXIgaGlzdG9yeSBzdW1tYXJpZXMtLT5cXG48YSAqbmdJZj1cXFwieWVhciA+IDE5OTRcXFwiIHJvdXRlckxpbms9XFxcIi9oaXN0b3J5L3t7eWVhciAtIDF9fVxcXCI+PGkgY2xhc3M9XFxcImFuZ2xlIGRvdWJsZSBsZWZ0IGljb25cXFwiPjwvaT48L2E+XFxuPGEgKm5nSWY9XFxcInllYXIgPCAyMDE3XFxcIiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS97e3llYXIgKyAxfX1cXFwiPjxpIGNsYXNzPVxcXCJhbmdsZSBkb3VibGUgcmlnaHQgaWNvblxcXCI+PC9pPjwvYT5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvaGlzdG9yeS90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi90ZWFtLWhpc3RvcnkuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hpc3RvcnkvdGVhbS1oaXN0b3J5L3RlYW0taGlzdG9yeS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImltZyB7XFxuICB3aWR0aDogNzUlO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzAwMDA0RDtcXG4gIG1hcmdpbi1ib3R0b206IDE1cHg7XFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5ZW07XFxufVxcbmkge1xcbiAgZm9udC1zaXplOiAyZW07XFxufVxcbmkucmlnaHQge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG5pLmxlZnQge1xcbiAgZmxvYXQ6IGxlZnQ7XFxufVxcbi5zdW1tYXJ5IHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcbn1cXG4udWkuZHJvcGRvd24uaXRlbSB7XFxuICB3aWR0aDogMTIxcHg7XFxuICBoZWlnaHQ6IDQwcHg7XFxufVxcbi51aS5kcm9wZG93bi5pdGVtIC5hY3RpdmUsXFxuLnVpLmRyb3Bkb3duLml0ZW06Zm9jdXMge1xcbiAgYm9yZGVyOiAwO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvdGVhbS1oaXN0b3J5L3RlYW0taGlzdG9yeS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBV0FSRFNfREFUQSB9IGZyb20gXCIuL2RhdGEvYXdhcmRzLmRhdGFcIjtcbmltcG9ydCB7IEF3YXJkIH0gZnJvbSBcIi4vbW9kZWwvYXdhcmQubW9kZWxcIjtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhd2FyZHMnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2F3YXJkcy5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vYXdhcmRzLmNvbXBvbmVudC5sZXNzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgQXdhcmRzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIC8vIEF3YXJkcyBkYXRhIHRvIGluamVjdCBpbnRvIG91ciB0ZW1wbGF0ZVxuICAgIHByaXZhdGUgYXdhcmREYXRhOiBBd2FyZFtdID0gQVdBUkRTX0RBVEE7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvYXdhcmRzLmNvbXBvbmVudC50cyIsImltcG9ydCB7IEF3YXJkIH0gZnJvbSBcIi4uL21vZGVsL2F3YXJkLm1vZGVsXCI7XG5cbmV4cG9ydCBjb25zdCBBV0FSRFNfREFUQTogQXdhcmQgW10gPSBbXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE2LFxuICAgICAgICBuYW1lOiAnTmljayBQcm96b3JvdnNreScsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIG5hbWU6ICdKb2hubnkgU2FuaWF0JyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNixcbiAgICAgICAgbmFtZTogJ1ByYXlhZyBQYXRlbCcsXG4gICAgICAgIGF3YXJkOiAnMm5kIFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTYsXG4gICAgICAgIG5hbWU6ICdCZW4gU2Fib3VyaW4nLFxuICAgICAgICBhd2FyZDogJ0FsbC1GcmVzaG1hbi9GT1RZJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE2LFxuICAgICAgICBuYW1lOiAnSmFjb2IgQ3V0aGJlcnQnLFxuICAgICAgICBhd2FyZDogJ0FsbC1GcmVzaG1hbidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNSxcbiAgICAgICAgbmFtZTogJ01hdHQgU3R1cGNhJyxcbiAgICAgICAgYXdhcmQ6ICdDT1RZJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE1LFxuICAgICAgICBuYW1lOiAnTmljayBQcm96b3JvdnNreScsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTUsXG4gICAgICAgIG5hbWU6ICdNYXR0IFdlc3QnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE1LFxuICAgICAgICBuYW1lOiAnS2V2aW4gTGluJyxcbiAgICAgICAgYXdhcmQ6ICdBbGwtRnJlc2htYW4vRk9UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNCxcbiAgICAgICAgbmFtZTogJ05lYWwgUGhlbHBzJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNCxcbiAgICAgICAgbmFtZTogJ05pY2sgUHJvem9yb3Zza3knLFxuICAgICAgICBhd2FyZDogJzJuZCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEzLFxuICAgICAgICBuYW1lOiAnTmF0aGFuIEdpYmJvbnMnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEzLFxuICAgICAgICBuYW1lOiAnTmVhbCBQaGVscHMnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEzLFxuICAgICAgICBuYW1lOiAnUnlhbiBTbWl0aCcsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0vUE9UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgbmFtZTogJ0JyYWQgQm9sbGluZ2VyJyxcbiAgICAgICAgYXdhcmQ6ICcybmQgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgbmFtZTogJ05pY2sgUHJvem9yb3Zza3knLFxuICAgICAgICBhd2FyZDogJ0FsbCBGcmVzaG1hbidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgbmFtZTogJ0pvaG5ueSBTYW5pYXQnLFxuICAgICAgICBhd2FyZDogJ0FsbCBGcmVzaG1hbidcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgbmFtZTogJ0RlcmVrIFlhbicsXG4gICAgICAgIGF3YXJkOiAnQWxsIEZyZXNobWFuJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEyLFxuICAgICAgICBuYW1lOiAnUnlhbiBTbWl0aCcsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTIsXG4gICAgICAgIG5hbWU6ICdEYW5lIEpvcmdlbnNlbicsXG4gICAgICAgIGF3YXJkOiAnMm5kIFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTEsXG4gICAgICAgIG5hbWU6ICdSeWFuIFNtaXRoJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMCxcbiAgICAgICAgbmFtZTogJ1dhbGRlbiBOZWxzb24nLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEwLFxuICAgICAgICBuYW1lOiAnQnJpYW4gUGhlbGFuJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMCxcbiAgICAgICAgbmFtZTogJ1J5YW4gU21pdGgnLFxuICAgICAgICBhd2FyZDogJzJuZCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA5LFxuICAgICAgICBuYW1lOiAnTWF0dCBTdHVwY2EnLFxuICAgICAgICBhd2FyZDogJ0NPVFknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDksXG4gICAgICAgIG5hbWU6ICdEZW5pcyBBZ25pZWwnLFxuICAgICAgICBhd2FyZDogJzJuZCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA5LFxuICAgICAgICBuYW1lOiAnV2FsZGVuIE5lbHNvbicsXG4gICAgICAgIGF3YXJkOiAnMm5kIFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDksXG4gICAgICAgIG5hbWU6ICdQYXZhbiBTYXJndXJ1JyxcbiAgICAgICAgYXdhcmQ6ICcybmQgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwOSxcbiAgICAgICAgbmFtZTogJ1J5YW4gU21pdGgnLFxuICAgICAgICBhd2FyZDogJ0ZPVFknXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDgsXG4gICAgICAgIG5hbWU6ICdKb2VsIEtvZWhuZW1hbicsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDgsXG4gICAgICAgIG5hbWU6ICdQYXQgU3RlcGhlbnMnLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA3LFxuICAgICAgICBuYW1lOiAnSm9lbCBLb2VobmVtYW4nLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA3LFxuICAgICAgICBuYW1lOiAnQnJpYW4gS29yYmVzbWV5ZXInLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA2LFxuICAgICAgICBuYW1lOiAnQnJpYW4gUGhlbGFuJyxcbiAgICAgICAgYXdhcmQ6ICdGT1RZJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA1LFxuICAgICAgICBuYW1lOiAnTmljayBNY0R1ZmZlZScsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDUsXG4gICAgICAgIG5hbWU6ICdNaWtlIENsYXJrJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNSxcbiAgICAgICAgbmFtZTogJ0RhdmlkIEFicmFtJyxcbiAgICAgICAgYXdhcmQ6ICdGT1RZJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA0LFxuICAgICAgICBuYW1lOiAnTWF0dCBXZWxzaCcsXG4gICAgICAgIGF3YXJkOiAnMXN0IFRlYW0nXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDQsXG4gICAgICAgIG5hbWU6ICdOaWNrIE1jRHVmZmVlJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNCxcbiAgICAgICAgbmFtZTogJ1BhdCBTdGVwaGVucycsXG4gICAgICAgIGF3YXJkOiAnRk9UWSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwMyxcbiAgICAgICAgbmFtZTogJ05hdGUgQm9zc2NoZXInLFxuICAgICAgICBhd2FyZDogJzFzdCBUZWFtJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDAyLFxuICAgICAgICBuYW1lOiAnWGkgWGlhJyxcbiAgICAgICAgYXdhcmQ6ICcxc3QgVGVhbSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwMixcbiAgICAgICAgbmFtZTogJ0RhbmUgT2xzZW4nLFxuICAgICAgICBhd2FyZDogJ0ZPVFknXG4gICAgfVxuXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvaGlzdG9yeS9hd2FyZHMvZGF0YS9hd2FyZHMuZGF0YS50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+QXdhcmRzPC9oMT5cXG48dGFibGUgY2xhc3M9XFxcInVpIGNlbGxlZCB0YWJsZVxcXCI+XFxuICAgIDx0aGVhZD5cXG4gICAgICAgIDx0cj5cXG4gICAgICAgICAgICA8dGg+WWVhcjwvdGg+XFxuICAgICAgICAgICAgPHRoPk5hbWU8L3RoPlxcbiAgICAgICAgICAgIDx0aD5Bd2FyZDwvdGg+XFxuICAgICAgICA8L3RyPlxcbiAgICA8L3RoZWFkPlxcbiAgICA8dGJvZHk+XFxuICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgYXdhcmQgb2YgYXdhcmREYXRhXFxcIj5cXG4gICAgICAgICAgICA8dGQ+e3thd2FyZC55ZWFyfX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e2F3YXJkLm5hbWV9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7YXdhcmQuYXdhcmR9fTwvdGQ+XFxuICAgICAgICA8L3RyPlxcbiAgICA8L3Rib2R5PlxcbjwvdGFibGU+XFxuPHA+KkFsbC1GcmVzaG1hbiB0ZWFtIGFkZGVkIGluIDIwMTMsIEZPVFkgKEZyZXNobWFuIG9mIHRoZSBZZWFyKSBnaXZlbiB0byB0aGUgQWxsLUZyZXNobWFuIG1lbWJlciB3aXRoIHRoZSBtb3N0IDFzdCBwbGFjZSB2b3RlczwvcD5cXG48cD4qUGxheWVyIG9mIHRoZSB5ZWFyIGF3YXJkIGFkZGVkIGluIDIwMTMsIFBPVFkgKFBsYXllciBvZiB0aGUgWWVhcikgZ2l2ZW4gdG8gdGhlIEFsbC1SZWdpb24gbWVtYmVyIHdpdGggdGhlIG1vc3QgMXN0IHBsYWNlIHZvdGVzPC9wPlxcbjxwPipDT1RZIChDb2FjaCBvZiB0aGUgWWVhcikgYWRkZWQgaW4gMjAwOTwvcD5cXG48cD4qMm5kLVRlYW0gQWxsIFJlZ2lvbiBhZGRlZCBpbiAyMDA5PC9wPlxcbjxwPipBd2FyZHMgZmlyc3QgZ2l2ZW4gb3V0IGluIDIwMDI8L3A+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hpc3RvcnkvYXdhcmRzL2F3YXJkcy5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vYXdhcmRzLmNvbXBvbmVudC5sZXNzXCIpO1xuXG5pZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgLy8gUmV0dXJuIGFuIGV4aXN0aW5nIHN0cmluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcztcbn0gZWxzZSB7XG4gIC8vIENhbGwgdGhlIGN1c3RvbSB0b1N0cmluZyBtZXRob2QgZnJvbSBjc3MtbG9hZGVyIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlcy50b1N0cmluZygpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9oaXN0b3J5L2F3YXJkcy9hd2FyZHMuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJwIHtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICB0ZXh0LWluZGVudDogMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9oaXN0b3J5L2F3YXJkcy9hd2FyZHMuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUkVTVUxUU19EQVRBIH0gZnJvbSBcIi4vZGF0YS9yZXN1bHRzLmRhdGFcIjtcbmltcG9ydCB7IFJlc3VsdCB9IGZyb20gXCIuL21vZGVsL3Jlc3VsdC5tb2RlbFwiO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3Jlc3VsdHMnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3Jlc3VsdHMuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL3Jlc3VsdHMuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBSZXN1bHRzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIC8vIFJlc3VsdHMgZGF0YSB0byBpbmplY3QgaW50byBvdXIgdGVtcGxhdGVcbiAgICBwcml2YXRlIHJlc3VsdERhdGE6IFJlc3VsdFtdID0gUkVTVUxUU19EQVRBO1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvcmVzdWx0cy9yZXN1bHRzLmNvbXBvbmVudC50cyIsImltcG9ydCB7IFJlc3VsdCB9IGZyb20gXCIuLi9tb2RlbC9yZXN1bHQubW9kZWxcIjtcblxuZXhwb3J0IGNvbnN0IFJFU1VMVFNfREFUQTogUmVzdWx0W10gPSBbXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE3LFxuICAgICAgICBzZWN0aW9uYWxzOiAnMm5kJyxcbiAgICAgICAgcmVnaW9uYWxzOiAnNnRoJyxcbiAgICAgICAgbmF0aW9uYWxzOiAnLScsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL2V2ZW50cy90ZWFtcy8/RXZlbnRUZWFtSWQ9VElVeFhyWjRwRE5oTmk0TTNRQTFKJTJiOUQ4a0FkTnNzOE55NEp5VVV1WmhnJTNkJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDE2LFxuICAgICAgICBzZWN0aW9uYWxzOiAnM3JkJyxcbiAgICAgICAgcmVnaW9uYWxzOiAnM3JkJyxcbiAgICAgICAgbmF0aW9uYWxzOiAnLScsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3BsYXkudXNhdWx0aW1hdGUub3JnL3RlYW1zL2V2ZW50cy9FdmVudHRlYW0vP1RlYW1JZD1uUXpzQ08wZktiVVVFRlpmS0olMmZPVW90ZCUyZjFQTTZ3bzM1SFBhWEpFTVVDOCUzZCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNSxcbiAgICAgICAgc2VjdGlvbmFsczogJzJuZCcsXG4gICAgICAgIHJlZ2lvbmFsczogJzFzdCcsXG4gICAgICAgIG5hdGlvbmFsczogJzEzdGgnLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy90ZWFtcy9ldmVudHMvRXZlbnR0ZWFtLz9UZWFtSWQ9VCUyYlY2RDJYeUxUbGtMQSUyZlgyV3BhaVBHbll5NlMzRG4lMmZtY2JsZm8wOERObyUzZCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxNCxcbiAgICAgICAgc2VjdGlvbmFsczogJzFzdCcsXG4gICAgICAgIHJlZ2lvbmFsczogJzV0aCcsXG4gICAgICAgIG5hdGlvbmFsczogJy0nLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly9wbGF5LnVzYXVsdGltYXRlLm9yZy90ZWFtcy9ldmVudHMvRXZlbnR0ZWFtLz9UZWFtSWQ9MXo4aHJ5Z0dZYUR3SnFrOEYlMmZtUDRsT2s5QkQzJTJmSSUyYktXMzNJSG84cUY5RSUzZCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMyxcbiAgICAgICAgc2VjdGlvbmFsczogJzFzdCcsXG4gICAgICAgIHJlZ2lvbmFsczogJzFzdCcsXG4gICAgICAgIG5hdGlvbmFsczogJzE3dGgnLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3Jlcy8jY29sbGVnZS1vcGVuL3RlYW0vMTc5NCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAxMixcbiAgICAgICAgc2VjdGlvbmFsczogJzFzdCcsXG4gICAgICAgIHJlZ2lvbmFsczogJzNyZCcsXG4gICAgICAgIG5hdGlvbmFsczogJy0nLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly9zY29yZXMudXNhdWx0aW1hdGUub3JnL3Njb3JlczIwMTIvI2NvbGxlZ2Utb3Blbi90ZWFtLzE3OTQnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMTEsXG4gICAgICAgIHNlY3Rpb25hbHM6ICcxc3QnLFxuICAgICAgICByZWdpb25hbHM6ICcxc3QnLFxuICAgICAgICBuYXRpb25hbHM6ICcxN3RoJyxcbiAgICAgICAgdGVhbVBhZ2VMYWJlbDogJ1VTQVUnLFxuICAgICAgICB0ZWFtUGFnZUxpbms6ICdodHRwOi8vc2NvcmVzLnVzYXVsdGltYXRlLm9yZy9zY29yZXMyMDExLyNjb2xsZWdlLW9wZW4vdGVhbS8xNzk0J1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDEwLFxuICAgICAgICBzZWN0aW9uYWxzOiAnMXN0JyxcbiAgICAgICAgcmVnaW9uYWxzOiAnMXN0JyxcbiAgICAgICAgbmF0aW9uYWxzOiAnMTd0aCcsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3Njb3Jlcy51c2F1bHRpbWF0ZS5vcmcvc2NvcmVzMjAxMC8jY29sbGVnZS1vcGVuL3RlYW0vMTc5NCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwOSxcbiAgICAgICAgc2VjdGlvbmFsczogJzJuZCcsXG4gICAgICAgIHJlZ2lvbmFsczogJzFzdCcsXG4gICAgICAgIG5hdGlvbmFsczogJzEzdGgnLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly91bHRpbWF0ZS5zY29yZXJlcG9ydC5uZXQvMjAwOS9zY29yZXMuY2dpP2Rpdj0xOCZwYWdlPTMmdGVhbT0xNzk0J1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA4LFxuICAgICAgICBzZWN0aW9uYWxzOiAnMXN0JyxcbiAgICAgICAgcmVnaW9uYWxzOiAnMm5kJyxcbiAgICAgICAgbmF0aW9uYWxzOiAnNXRoJyxcbiAgICAgICAgdGVhbVBhZ2VMYWJlbDogJ1VTQVUnLFxuICAgICAgICB0ZWFtUGFnZUxpbms6ICdodHRwOi8vdWx0aW1hdGUuc2NvcmVyZXBvcnQubmV0LzIwMDgvc2NvcmVzLmNnaT9kaXY9MTgmcGFnZT0zJnRlYW09MTc5NCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNyxcbiAgICAgICAgc2VjdGlvbmFsczogJzJzdCcsXG4gICAgICAgIHJlZ2lvbmFsczogJzR0aCcsXG4gICAgICAgIG5hdGlvbmFsczogJy0nLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly91bHRpbWF0ZS5zY29yZXJlcG9ydC5uZXQvMjAwNy9zY29yZXMuY2dpP2Rpdj0xOCZwYWdlPTMmdGVhbT0xNzk0J1xuICAgIH0sXG4gICAge1xuICAgICAgICB5ZWFyOiAyMDA2LFxuICAgICAgICBzZWN0aW9uYWxzOiAnM3JkJyxcbiAgICAgICAgcmVnaW9uYWxzOiAnN3RoJyxcbiAgICAgICAgbmF0aW9uYWxzOiAnLScsXG4gICAgICAgIHRlYW1QYWdlTGFiZWw6ICdVU0FVJyxcbiAgICAgICAgdGVhbVBhZ2VMaW5rOiAnaHR0cDovL3VsdGltYXRlLnNjb3JlcmVwb3J0Lm5ldC8yMDA2L3Njb3Jlcy5jZ2k/ZGl2PTE4JnBhZ2U9MyZ0ZWFtPTE3OTQnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHllYXI6IDIwMDUsXG4gICAgICAgIHNlY3Rpb25hbHM6ICcyc3QnLFxuICAgICAgICByZWdpb25hbHM6ICczcmQnLFxuICAgICAgICBuYXRpb25hbHM6ICctJyxcbiAgICAgICAgdGVhbVBhZ2VMYWJlbDogJ1VTQVUnLFxuICAgICAgICB0ZWFtUGFnZUxpbms6ICdodHRwOi8vdWx0aW1hdGUuc2NvcmVyZXBvcnQubmV0LzIwMDUvc2NvcmVzLmNnaT9kaXY9MTgmcGFnZT0zJnRlYW09MTc5NCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgeWVhcjogMjAwNCxcbiAgICAgICAgc2VjdGlvbmFsczogJzFzdCcsXG4gICAgICAgIHJlZ2lvbmFsczogJzJuZCcsXG4gICAgICAgIG5hdGlvbmFsczogJzE3dGgnLFxuICAgICAgICB0ZWFtUGFnZUxhYmVsOiAnVVNBVScsXG4gICAgICAgIHRlYW1QYWdlTGluazogJ2h0dHA6Ly91bHRpbWF0ZS5zY29yZXJlcG9ydC5uZXQvMjAwNC9zY29yZXMuY2dpP2Rpdj0xOCZwYWdlPTMmdGVhbT0xNzk0J1xuICAgIH1cbl07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL2hpc3RvcnkvcmVzdWx0cy9kYXRhL3Jlc3VsdHMuZGF0YS50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8aDEgY2xhc3M9XFxcInVpIGhlYWRlclxcXCI+UmVzdWx0czwvaDE+XFxuPHRhYmxlIGNsYXNzPVxcXCJ1aSBjZWxsZWQgdGFibGVcXFwiPlxcbiAgICA8dGhlYWQ+XFxuICAgIDx0cj5cXG4gICAgICAgIDx0aD5ZZWFyPC90aD5cXG4gICAgICAgIDx0aD5TZWN0aW9uYWxzPC90aD5cXG4gICAgICAgIDx0aD5SZWdpb25hbHM8L3RoPlxcbiAgICAgICAgPHRoPk5hdGlvbmFsczwvdGg+XFxuICAgICAgICA8dGg+VGVhbSBQYWdlPC90aD5cXG4gICAgPC90cj5cXG4gICAgPC90aGVhZD5cXG4gICAgPHRib2R5PlxcbiAgICA8dHIgKm5nRm9yPVxcXCJsZXQgcmVzdWx0IG9mIHJlc3VsdERhdGFcXFwiPlxcbiAgICAgICAgPHRkPnt7cmVzdWx0LnllYXJ9fTwvdGQ+XFxuICAgICAgICA8dGQ+e3tyZXN1bHQuc2VjdGlvbmFsc319PC90ZD5cXG4gICAgICAgIDx0ZD57e3Jlc3VsdC5yZWdpb25hbHN9fTwvdGQ+XFxuICAgICAgICA8dGQ+e3tyZXN1bHQubmF0aW9uYWxzfX08L3RkPlxcbiAgICAgICAgPHRkPjxhIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBocmVmPVxcXCJ7e3Jlc3VsdC50ZWFtUGFnZUxpbmt9fVxcXCI+e3tyZXN1bHQudGVhbVBhZ2VMYWJlbH19PC9hPjwvdGQ+XFxuICAgIDwvdHI+XFxuICAgIDwvdGJvZHk+XFxuPC90YWJsZT5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvaGlzdG9yeS9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL3Jlc3VsdHMuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2hpc3RvcnkvcmVzdWx0cy9yZXN1bHRzLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9oaXN0b3J5L3Jlc3VsdHMvcmVzdWx0cy5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIjtcbmltcG9ydCB7IFJvdXRlck1vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9yb3V0ZXJcIjtcblxuaW1wb3J0IHsgVGVhbUhpc3RvcnlDb21wb25lbnQgfSBmcm9tIFwiLi90ZWFtLWhpc3RvcnkvdGVhbS1oaXN0b3J5LmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgQXdhcmRzQ29tcG9uZW50IH0gZnJvbSBcIi4vYXdhcmRzL2F3YXJkcy5jb21wb25lbnRcIjtcbmltcG9ydCB7IFJlc3VsdHNDb21wb25lbnQgfSBmcm9tIFwiLi9yZXN1bHRzL3Jlc3VsdHMuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBST1VURVMgfSBmcm9tIFwiLi4vYXBwLnJvdXRlc1wiO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQnJvd3Nlck1vZHVsZSxcbiAgICAgICAgUm91dGVyTW9kdWxlLmZvclJvb3QoUk9VVEVTKVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFRlYW1IaXN0b3J5Q29tcG9uZW50LFxuICAgICAgICBBd2FyZHNDb21wb25lbnQsXG4gICAgICAgIFJlc3VsdHNDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEhpc3RvcnlNb2R1bGUge31cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9oaXN0b3J5L2hpc3RvcnkubW9kdWxlLnRzIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlck1vZHVsZSB9IGZyb20gXCJAYW5ndWxhci9yb3V0ZXJcIjtcblxuaW1wb3J0IHsgTWVudURlc2t0b3BDb21wb25lbnQgfSBmcm9tIFwiLi9tZW51LWRlc2t0b3AvbWVudS1kZXNrdG9wLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgTWVudU1vYmlsZUNvbXBvbmVudCB9IGZyb20gXCIuL21lbnUtbW9iaWxlL21lbnUtbW9iaWxlLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgTGVmdFNpZGViYXJDb21wb25lbnQgfSBmcm9tIFwiLi9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUmlnaHRTaWRlYmFyQ29tcG9uZW50IH0gZnJvbSBcIi4vcmlnaHQtc2lkZWJhci9yaWdodC1zaWRlYmFyLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUGFnZUZyYW1lQ29tcG9uZW50IH0gZnJvbSBcIi4vcGFnZS1mcmFtZS5jb21wb25lbnRcIjtcblxuaW1wb3J0IHsgUk9VVEVTIH0gZnJvbSBcIi4uL2FwcC5yb3V0ZXNcIjtcbmltcG9ydCB7IEZvb3RlckNvbXBvbmVudCB9IGZyb20gXCIuL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50XCI7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBSb3V0ZXJNb2R1bGUuZm9yUm9vdChST1VURVMpXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUGFnZUZyYW1lQ29tcG9uZW50LFxuICAgICAgICBNZW51RGVza3RvcENvbXBvbmVudCxcbiAgICAgICAgTWVudU1vYmlsZUNvbXBvbmVudCxcbiAgICAgICAgTGVmdFNpZGViYXJDb21wb25lbnQsXG4gICAgICAgIFJpZ2h0U2lkZWJhckNvbXBvbmVudCxcbiAgICAgICAgRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFBhZ2VGcmFtZUNvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUZyYW1lTW9kdWxlIHt9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9wYWdlLWZyYW1lLm1vZHVsZS50cyIsImltcG9ydCB7IENvbXBvbmVudCwgVmlld0NoaWxkLCBFbGVtZW50UmVmLCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbWVudS1kZXNrdG9wJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9tZW51LWRlc2t0b3AuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL21lbnUtZGVza3RvcC5jb21wb25lbnQubGVzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIE1lbnVEZXNrdG9wQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICAvLyBNZW51IGRyb3Bkb3duc1xuICAgIEBWaWV3Q2hpbGQoJ3RlYW1Ecm9wZG93bicpXG4gICAgcHJpdmF0ZSB0ZWFtRHJvcGRvd246IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgnaGlzdG9yeURyb3Bkb3duJylcbiAgICBwcml2YXRlIGhpc3RvcnlEcm9wZG93bjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgb3VyIG1vYmlsZSBtZW51IGRyb3Bkb3duLlxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgJCh0aGlzLnRlYW1Ecm9wZG93bi5uYXRpdmVFbGVtZW50KS5kcm9wZG93bih7fSk7XG4gICAgICAgICQodGhpcy5oaXN0b3J5RHJvcGRvd24ubmF0aXZlRWxlbWVudCkuZHJvcGRvd24oe30pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImhlYWRlclxcXCI+XFxuICAgIDxhIHJvdXRlckxpbms9XFxcIi9ob21lXFxcIj48aW1nIGNsYXNzPVxcXCJjcmVzdFxcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL21lbnUvY3Jlc3QucG5nXCIpICsgXCJcXFwiLz48L2E+XFxuICAgIDxhIHJvdXRlckxpbms9XFxcIi9ob21lXFxcIj48aDEgY2xhc3M9XFxcImhlYWRlci10ZXh0XFxcIj5JbGxpbm9pcyBVbHRpbWF0ZTwvaDE+PC9hPlxcbjwvZGl2PlxcblxcbjxkaXYgY2xhc3M9XFxcInVpIHBvaW50aW5nIHN0YWNrYWJsZSBtZW51XFxcIj5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL2hvbWVcXFwiICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW0gYWN0aXZlXFxcIj48aSBjbGFzcz1cXFwiaG9tZSBpY29uXFxcIj48L2k+SG9tZTwvYT5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL2Fib3V0XFxcIiAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJpbmZvIGljb25cXFwiPjwvaT5BYm91dCBVczwvYT5cXG4gICAgPGEgcm91dGVyTGluaz1cXFwiL3Byb3NwZWN0c1xcXCIgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJjaGlsZCBpY29uXFxcIj48L2k+UHJvc3BlY3RpdmUgUGxheWVyczwvYT5cXG4gICAgPGRpdiAjdGVhbURyb3Bkb3duIGNsYXNzPVxcXCJ1aSBkcm9wZG93biBpdGVtXFxcIj5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJ1c2VyIGljb25cXFwiPjwvaT5UZWFtPGkgY2xhc3M9XFxcImRyb3Bkb3duIGljb25cXFwiPjwvaT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lbnVcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgcm91dGVyTGluaz1cXFwiL3ByYWN0aWNlXFxcIiAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwic29jY2VyIGljb25cXFwiPjwvaT5QcmFjdGljZTwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgcm91dGVyTGluaz1cXFwiL3RvdXJuYW1lbnRzLzIwMTdcXFwiICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiY2FsZW5kYXIgaWNvblxcXCI+PC9pPlRvdXJuYW1lbnRzPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvcm9zdGVyLzIwMTdcXFwiICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJvcmRlcmVkIGxpc3QgaWNvblxcXCI+PC9pPlJvc3RlcjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgcm91dGVyTGluaz1cXFwiL2Fic2VudFxcXCIgICAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwicmVtb3ZlIGljb25cXFwiPjwvaT5BYnNlbnQgRm9ybTwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2ICNoaXN0b3J5RHJvcGRvd24gY2xhc3M9XFxcInVpIGRyb3Bkb3duIGl0ZW1cXFwiPlxcbiAgICAgICAgPGkgY2xhc3M9XFxcImZhc3QgYmFja3dhcmQgaWNvblxcXCI+PC9pPkhpc3Rvcnk8aSBjbGFzcz1cXFwiZHJvcGRvd24gaWNvblxcXCI+PC9pPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVudVxcXCI+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvaGlzdG9yeS8yMDE2XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwidW5kbyBpY29uXFxcIj48L2k+VGVhbSBIaXN0b3J5PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiByb3V0ZXJMaW5rPVxcXCIvYXdhcmRzXFxcIiAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwidHJvcGh5IGljb25cXFwiPjwvaT5Bd2FyZHM8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IHJvdXRlckxpbms9XFxcIi9yZXN1bHRzXFxcIiAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJhcmNoaXZlIGljb25cXFwiPjwvaT5QYXN0IFJlc3VsdHM8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGEgaHJlZj1cXFwiaHR0cDovL3d3dy5pbGxpbml1bHRpLmJsb2dzcG90LmNvbS9cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImNvbW1lbnQgaWNvblxcXCI+PC9pPkJsb2c8L2E+XFxuICAgIDxhIHJvdXRlckxpbms9XFxcIi9jb250YWN0XFxcIiBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwibWFpbCBpY29uXFxcIj48L2k+Q29udGFjdCBVczwvYT5cXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9tZW51LWRlc2t0b3AvbWVudS1kZXNrdG9wLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXNzZXRzL2NyZXN0LnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbWVudS9jcmVzdC5wbmdcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL21lbnUtZGVza3RvcC5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9tZW51LWRlc2t0b3AvbWVudS1kZXNrdG9wLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmhlYWRlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL21lbnUvaGVhZGVyLWJhY2tncm91bmQuanBnXCIpICsgXCIpO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuLmhlYWRlciAuaGVhZGVyLXRleHQge1xcbiAgZm9udC1zaXplOiA3MnB4O1xcbiAgZm9udC1mYW1pbHk6ICdPc3dhbGQnLCBzYW5zLXNlcmlmO1xcbiAgY29sb3I6ICNmZjYyMjY7XFxuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgcGFkZGluZzogMjVweDtcXG4gIG1hcmdpbjogMDtcXG4gIGxldHRlci1zcGFjaW5nOiAycHg7XFxuICB0ZXh0LXNoYWRvdzogLTFweCAtMXB4IDAgd2hpdGUsIDFweCAtMXB4IDAgd2hpdGUsIC0xcHggMXB4IDAgd2hpdGUsIDFweCAxcHggMCB3aGl0ZTtcXG59XFxuLmhlYWRlciAuY3Jlc3Qge1xcbiAgbWF4LWhlaWdodDogODBweDtcXG4gIG1heC13aWR0aDogNTBweDtcXG59XFxuLnVpLm1lbnUge1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtZGVza3RvcC9tZW51LWRlc2t0b3AuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvaGVhZGVyLWJhY2tncm91bmQuanBnXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9tZW51L2hlYWRlci1iYWNrZ3JvdW5kLmpwZ1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCwgVmlld0NoaWxkLCBFbGVtZW50UmVmLCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbWVudS1tb2JpbGUnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL21lbnUtbW9iaWxlLmNvbXBvbmVudC5odG1sJyksXG4gICAgc3R5bGVzOiBbcmVxdWlyZSgnLi9tZW51LW1vYmlsZS5jb21wb25lbnQubGVzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIE1lbnVNb2JpbGVDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIC8vIE1lbnUgZHJvcGRvd25zXG4gICAgQFZpZXdDaGlsZCgndGVhbURyb3Bkb3duJylcbiAgICBwcml2YXRlIHRlYW1Ecm9wZG93bjogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCdoaXN0b3J5RHJvcGRvd24nKVxuICAgIHByaXZhdGUgaGlzdG9yeURyb3Bkb3duOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ21vYmlsZURyb3Bkb3duJylcbiAgICBwcml2YXRlIG1vYmlsZURyb3Bkb3duOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBvdXIgbW9iaWxlIG1lbnUgZHJvcGRvd24uXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICAvLyAkKHRoaXMudGVhbURyb3Bkb3duLm5hdGl2ZUVsZW1lbnQpLmRyb3Bkb3duKHt9KTtcbiAgICAgICAgLy8gJCh0aGlzLmhpc3RvcnlEcm9wZG93bi5uYXRpdmVFbGVtZW50KS5kcm9wZG93bih7fSk7XG4gICAgICAgICQodGhpcy5tb2JpbGVEcm9wZG93bi5uYXRpdmVFbGVtZW50KS5kcm9wZG93bih7fSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50LnRzIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImhlYWRlclxcXCI+XFxuICAgIDxkaXYgI21vYmlsZURyb3Bkb3duIGNsYXNzPVxcXCJ1aSBpbmxpbmUgZHJvcGRvd25cXFwiPlxcbiAgICAgICAgPGgxIGNsYXNzPVxcXCJoZWFkZXItdGV4dFxcXCI+SWxsaW5vaXMgVWx0aW1hdGU8L2gxPlxcbiAgICAgICAgPGkgY2xhc3M9XFxcImRyb3Bkb3duIGljb25cXFwiPjwvaT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lbnVcXFwiPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9ob21lXFxcIiAgICAgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJob21lIGljb25cXFwiPjwvaT5Ib21lPC9hPlxcbiAgICAgICAgICAgIDxhIHJvdXRlckxpbms9XFxcIi9hYm91dFxcXCIgICAgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlXT1cXFwiWydhY3RpdmUnXVxcXCIgY2xhc3M9XFxcIml0ZW1cXFwiPjxpIGNsYXNzPVxcXCJpbmZvIGljb25cXFwiPjwvaT5BYm91dCBVczwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvcHJvc3BlY3RzXFxcIiAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiY2hpbGQgaWNvblxcXCI+PC9pPlByb3NwZWN0aXZlIFBsYXllcnM8L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL3ByYWN0aWNlXFxcIiAgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcInNvY2NlciBpY29uXFxcIj48L2k+UHJhY3RpY2U8L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL3RvdXJuYW1lbnRzLzIwMTdcXFwiICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImNhbGVuZGFyIGljb25cXFwiPjwvaT5Ub3VybmFtZW50czwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvcm9zdGVyLzIwMTdcXFwiICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwib3JkZXJlZCBsaXN0IGljb25cXFwiPjwvaT5Sb3N0ZXI8L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL2Fic2VudFxcXCIgICAgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcInJlbW92ZSBpY29uXFxcIj48L2k+QWJzZW50IEZvcm08L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL2hpc3RvcnkvMjAxNlxcXCIgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcInVuZG8gaWNvblxcXCI+PC9pPlRlYW0gSGlzdG9yeTwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvYXdhcmRzXFxcIiAgICAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwidHJvcGh5IGljb25cXFwiPjwvaT5Bd2FyZHM8L2E+XFxuICAgICAgICAgICAgPGEgcm91dGVyTGluaz1cXFwiL3Jlc3VsdHNcXFwiICAgICAgICAgICAgW3JvdXRlckxpbmtBY3RpdmVdPVxcXCJbJ2FjdGl2ZSddXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+PGkgY2xhc3M9XFxcImFyY2hpdmUgaWNvblxcXCI+PC9pPlBhc3QgUmVzdWx0czwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvYmxvZ1xcXCIgICAgICAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwiY29tbWVudCBpY29uXFxcIj48L2k+QmxvZzwvYT5cXG4gICAgICAgICAgICA8YSByb3V0ZXJMaW5rPVxcXCIvY29udGFjdFxcXCIgICAgICAgICAgICBbcm91dGVyTGlua0FjdGl2ZV09XFxcIlsnYWN0aXZlJ11cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj48aSBjbGFzcz1cXFwibWFpbCBpY29uXFxcIj48L2k+Q29udGFjdCBVczwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9tZW51LW1vYmlsZS9tZW51LW1vYmlsZS5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGNzcy10by1zdHJpbmctbG9hZGVyOiB0cmFuc2Zvcm1zIHN0eWxlcyBmcm9tIGNzcy1sb2FkZXIgdG8gYSBzdHJpbmcgb3V0cHV0XG5cbi8vIEdldCB0aGUgc3R5bGVzXG52YXIgc3R5bGVzID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2luZGV4LmpzIS4vbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbWVudS1tb2JpbGUvbWVudS1tb2JpbGUuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuaGVhZGVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgcmVxdWlyZShcIi4uLy4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbWVudS9oZWFkZXItYmFja2dyb3VuZC5qcGdcIikgKyBcIik7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG59XFxuLmhlYWRlciAudWkuZHJvcGRvd24ge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG4uaGVhZGVyIC5oZWFkZXItdGV4dCB7XFxuICBmb250LXNpemU6IDcycHg7XFxuICBmb250LWZhbWlseTogJ09zd2FsZCcsIHNhbnMtc2VyaWY7XFxuICBjb2xvcjogI2ZmNjIyNjtcXG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICBwYWRkaW5nOiAxMHB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgbGV0dGVyLXNwYWNpbmc6IDJweDtcXG4gIHRleHQtc2hhZG93OiAtMXB4IC0xcHggMCB3aGl0ZSwgMXB4IC0xcHggMCB3aGl0ZSwgLTFweCAxcHggMCB3aGl0ZSwgMXB4IDFweCAwIHdoaXRlO1xcbn1cXG4uaGVhZGVyIC5kcm9wZG93bi5pY29uIHtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuLmhlYWRlciAubWVudSB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL21lbnUtbW9iaWxlL21lbnUtbW9iaWxlLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBBZnRlclZpZXdJbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbGVmdC1zaWRlYmFyJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9sZWZ0LXNpZGViYXIuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2xlZnQtc2lkZWJhci5jb21wb25lbnQubGVzcycpXVxufSlcblxuZXhwb3J0IGNsYXNzIExlZnRTaWRlYmFyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVR3aXR0ZXJXaWRnZXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUd2l0dGVyIHNjcmlwdCBmb3IgaW5pdGlhbGl6aW5nIG91ciBUd2l0dGVyIFRpbWVsaW5lIHdpZGdldFxuICAgICAqL1xuICAgIGluaXRpYWxpemVUd2l0dGVyV2lkZ2V0KCk6IHZvaWQge1xuICAgICAgICAhZnVuY3Rpb24oZCxzLGlkKXtcbiAgICAgICAgICAgIGxldCBqczogYW55LFxuICAgICAgICAgICAgICAgIGZqcz1kLmdldEVsZW1lbnRzQnlUYWdOYW1lKHMpWzBdLFxuICAgICAgICAgICAgICAgIHA9J2h0dHBzJztcbiAgICAgICAgICAgIGlmKCFkLmdldEVsZW1lbnRCeUlkKGlkKSl7XG4gICAgICAgICAgICAgICAganM9ZC5jcmVhdGVFbGVtZW50KHMpO1xuICAgICAgICAgICAgICAgIGpzLmlkPWlkO1xuICAgICAgICAgICAgICAgIGpzLnNyYz1wK1wiOi8vcGxhdGZvcm0udHdpdHRlci5jb20vd2lkZ2V0cy5qc1wiO1xuICAgICAgICAgICAgICAgIGZqcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShqcyxmanMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KGRvY3VtZW50LFwic2NyaXB0XCIsXCJ0d2l0dGVyLXdqc1wiKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJ1aSBzZWdtZW50IHR3aXR0ZXItc2lkZWJhclxcXCI+XFxuICAgIDxhIGNsYXNzPVxcXCJ0d2l0dGVyLXRpbWVsaW5lXFxcIiBoZWlnaHQ9XFxcIjUwMHB4XFxcIiBocmVmPVxcXCJodHRwczovL3R3aXR0ZXIuY29tL0lsbGluaVVsdGlcXFwiIGRhdGEtd2lkZ2V0LWlkPVxcXCI2MDU0MTQ4MzYzNjk4ODMxMzZcXFwiPlR3ZWV0cyBieSBASWxsaW5pVWx0aTwvYT5cXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvbGVmdC1zaWRlYmFyLmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gY3NzLXRvLXN0cmluZy1sb2FkZXI6IHRyYW5zZm9ybXMgc3R5bGVzIGZyb20gY3NzLWxvYWRlciB0byBhIHN0cmluZyBvdXRwdXRcblxuLy8gR2V0IHRoZSBzdHlsZXNcbnZhciBzdHlsZXMgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvaW5kZXguanMhLi9sZWZ0LXNpZGViYXIuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL2xlZnQtc2lkZWJhci5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50d2l0dGVyLXNpZGViYXIge1xcbiAgcGFkZGluZzogMDtcXG4gIG1heC13aWR0aDogMjAwcHg7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIG1hcmdpbi1yaWdodDogYXV0bztcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9sZWZ0LXNpZGViYXIuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3JpZ2h0LXNpZGViYXInLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3JpZ2h0LXNpZGViYXIuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL3JpZ2h0LXNpZGViYXIuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBSaWdodFNpZGViYXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcmlnaHQtc2lkZWJhci9yaWdodC1zaWRlYmFyLmNvbXBvbmVudC50cyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJ1aSBzZWdtZW50IHBheXBhbC1zaWRlYmFyXFxcIj5cXG4gICAgPGgyIGNsYXNzPVxcXCJ1aSBoZWFkZXJcXFwiPkhlbHAgT3V0IElsbGlub2lzIFVsdGltYXRlITwvaDI+XFxuXFxuICAgIDxwPklsbGlub2lzIFVsdGltYXRlIGlzIG1vc3RseSBzdHVkZW50LWZ1bmRlZCwgaGVscCB1cyBvdXQgYnkgZG9uYXRpbmchPC9wPlxcbiAgICA8YSBocmVmPVxcXCJodHRwczovL3d3dy5wYXlwYWwubWUvaWxsaW5vaXNVbHRpbWF0ZVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgPGltZyBjbGFzcz1cXFwicGF5cGFsLWRvbmF0ZVxcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9wYXlwYWwtZG9uYXRlLnBuZ1wiKSArIFwiXFxcIi8+XFxuICAgIDwvYT5cXG48L2Rpdj5cXG48YSBocmVmPVxcXCJodHRwczovL3d3dy5mYWNlYm9vay5jb20vSWxsaW5vaXNVbHRpbWF0ZVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICA8aW1nIGNsYXNzPVxcXCJzb2NpYWwtbWVkaWEtYnV0dG9uIGh2ci1zaW5rXFxcIiBzcmM9XFxcIlwiICsgcmVxdWlyZShcIi4uLy4uLy4uL3B1YmxpYy9hc3NldHMvaW1hZ2VzL3BhZ2UtZnJhbWUvbGVmdC1zaWRlYmFyL2ZhY2Vib29rLWJ1dHRvbi5wbmdcIikgKyBcIlxcXCIvPlxcbjwvYT5cXG48YSBocmVmPVxcXCJodHRwczovL3R3aXR0ZXIuY29tL2lsbGluaXVsdGlcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgPGltZyBjbGFzcz1cXFwic29jaWFsLW1lZGlhLWJ1dHRvbiBodnItc2lua1xcXCIgc3JjPVxcXCJcIiArIHJlcXVpcmUoXCIuLi8uLi8uLi9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci90d2l0dGVyLWJ1dHRvbi5wbmdcIikgKyBcIlxcXCIvPlxcbjwvYT5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9yaWdodC1zaWRlYmFyL3JpZ2h0LXNpZGViYXIuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvcGF5cGFsLWRvbmF0ZS5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci9wYXlwYWwtZG9uYXRlLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9mYWNlYm9vay1idXR0b24ucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcHVibGljL2Fzc2V0cy9pbWFnZXMvcGFnZS1mcmFtZS9sZWZ0LXNpZGViYXIvZmFjZWJvb2stYnV0dG9uLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy90d2l0dGVyLWJ1dHRvbi5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wdWJsaWMvYXNzZXRzL2ltYWdlcy9wYWdlLWZyYW1lL2xlZnQtc2lkZWJhci90d2l0dGVyLWJ1dHRvbi5wbmdcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL3JpZ2h0LXNpZGViYXIuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcmlnaHQtc2lkZWJhci9yaWdodC1zaWRlYmFyLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnBheXBhbC1zaWRlYmFyIHtcXG4gIG1heC13aWR0aDogMjAwcHg7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIG1hcmdpbi1yaWdodDogYXV0bztcXG59XFxuLnBheXBhbC1zaWRlYmFyIHAge1xcbiAgdGV4dC1pbmRlbnQ6IDA7XFxuICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgcGFkZGluZy10b3A6IDE1cHg7XFxuICBwYWRkaW5nLWJvdHRvbTogMTVweDtcXG59XFxuLnBheXBhbC1kb25hdGUge1xcbiAgd2lkdGg6IDEwMHB4O1xcbn1cXG4udWkuaGVhZGVyIHtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxufVxcbi5zb2NpYWwtbWVkaWEtYnV0dG9uIHtcXG4gIHdpZHRoOiA0MCU7XFxuICBtYXgtd2lkdGg6IDcwcHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW46IDNweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICMwMDAwNEQ7XFxuICBib3gtc2hhZG93OiAwcHggMXB4IDJweCAwIHJnYmEoMzQsIDM2LCAzOCwgMC4xNSk7XFxuICBib3JkZXItcmFkaXVzOiAwLjI4NTcxNDI5ZW07XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9sZXNzLWxvYWRlciEuL3NyYy9hcHAvcGFnZS1mcmFtZS9yaWdodC1zaWRlYmFyL3JpZ2h0LXNpZGViYXIuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3BhZ2UtZnJhbWUnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmxlc3MnKV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBQYWdlRnJhbWVDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPCEtLUhlYWRlci0tPlxcbjxtZW51LWRlc2t0b3AgY2xhc3M9XFxcIm1lbnUtZGVza3RvcFxcXCI+PC9tZW51LWRlc2t0b3A+XFxuPG1lbnUtbW9iaWxlIGNsYXNzPVxcXCJtZW51LW1vYmlsZVxcXCI+PC9tZW51LW1vYmlsZT5cXG5cXG48IS0tQ29udGVudC0tPlxcbjxkaXYgY2xhc3M9XFxcIm1haW4tY29udGFpbmVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibGVmdC1zaWRlYmFyXFxcIj5cXG4gICAgICAgIDxsZWZ0LXNpZGViYXI+PC9sZWZ0LXNpZGViYXI+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtYWluLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPHJvdXRlci1vdXRsZXQ+PC9yb3V0ZXItb3V0bGV0PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicmlnaHQtc2lkZWJhclxcXCI+XFxuICAgICAgICA8cmlnaHQtc2lkZWJhcj48L3JpZ2h0LXNpZGViYXI+XFxuICAgIDwvZGl2PlxcbiAgICA8Zm9vdGVyPjwvZm9vdGVyPlxcbjwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmxlc3NcIik7XG5cbmlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAvLyBSZXR1cm4gYW4gZXhpc3Rpbmcgc3RyaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzO1xufSBlbHNlIHtcbiAgLy8gQ2FsbCB0aGUgY3VzdG9tIHRvU3RyaW5nIG1ldGhvZCBmcm9tIGNzcy1sb2FkZXIgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gc3R5bGVzLnRvU3RyaW5nKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL3BhZ2UtZnJhbWUvcGFnZS1mcmFtZS5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5tZW51LWRlc2t0b3AsXFxuLmxlZnQtc2lkZWJhcixcXG4ucmlnaHQtc2lkZWJhciB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4ubWFpbi1jb250YWluZXIge1xcbiAgbWFyZ2luLWJvdHRvbTogNTBweDtcXG59XFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIHtcXG4gIC5tYWluLWNvbnRhaW5lciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuICAubWVudS1tb2JpbGUge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcbiAgLm1lbnUtZGVza3RvcCxcXG4gIC5sZWZ0LXNpZGViYXIsXFxuICAucmlnaHQtc2lkZWJhciB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgfVxcbiAgLm1haW4tY29udGVudCB7XFxuICAgIHBhZGRpbmc6IDAgMTBweDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICB9XFxuICAubGVmdC1zaWRlYmFyIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICAgIGZsZXg6IDAgMCAyMDBweDtcXG4gIH1cXG4gIC5yaWdodC1zaWRlYmFyIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcXG4gICAgZmxleDogMCAwIDE1MHB4O1xcbiAgfVxcbn1cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxMDI0cHgpIHtcXG4gIC5tYWluLWNvbnRlbnQge1xcbiAgICBwYWRkaW5nOiAwIDMwcHg7XFxuICB9XFxuICAubGVmdC1zaWRlYmFyIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDUwcHg7XFxuICB9XFxuICAucmlnaHQtc2lkZWJhciB7XFxuICAgIG1hcmdpbi1yaWdodDogNTBweDtcXG4gICAgZmxleDogMCAwIDIwMHB4O1xcbiAgfVxcbn1cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxMjgwcHgpIHtcXG4gIC5tYWluLWNvbnRlbnQge1xcbiAgICBwYWRkaW5nOiAwIDUwcHg7XFxuICB9XFxuICAubGVmdC1zaWRlYmFyIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDgwcHg7XFxuICB9XFxuICAucmlnaHQtc2lkZWJhciB7XFxuICAgIG1hcmdpbi1yaWdodDogODBweDtcXG4gIH1cXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L2xlc3MtbG9hZGVyIS4vc3JjL2FwcC9wYWdlLWZyYW1lL3BhZ2UtZnJhbWUuY29tcG9uZW50Lmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDb21wb25lbnQsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdmb290ZXInLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Zvb3Rlci5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vZm9vdGVyLmNvbXBvbmVudC5sZXNzJyldXG59KVxuXG5leHBvcnQgY2xhc3MgRm9vdGVyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvZm9vdGVyL2Zvb3Rlci5jb21wb25lbnQudHMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwidWkgbWVudVxcXCI+XFxuICAgIDxwPkZvciBzdXBwb3J0IG9yIHRvIHJlcG9ydCB3ZWJzaXRlIGlzc3VlcywgZW1haWwgdGhlIGFkbWluIGF0IHdjanBob2VuaXhAZ21haWwuY29tIG9yIHRoZSBjcmVhdG9yIGF0IG5pY2sucHJvem9yb3Zza3lAZ21haWwuY29tPC9wPlxcbjwvZGl2PlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9wYWdlLWZyYW1lL2Zvb3Rlci9mb290ZXIuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDE3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBjc3MtdG8tc3RyaW5nLWxvYWRlcjogdHJhbnNmb3JtcyBzdHlsZXMgZnJvbSBjc3MtbG9hZGVyIHRvIGEgc3RyaW5nIG91dHB1dFxuXG4vLyBHZXQgdGhlIHN0eWxlc1xudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9pbmRleC5qcyEuL2Zvb3Rlci5jb21wb25lbnQubGVzc1wiKTtcblxuaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gIC8vIFJldHVybiBhbiBleGlzdGluZyBzdHJpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXM7XG59IGVsc2Uge1xuICAvLyBDYWxsIHRoZSBjdXN0b20gdG9TdHJpbmcgbWV0aG9kIGZyb20gY3NzLWxvYWRlciBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZXMudG9TdHJpbmcoKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvcGFnZS1mcmFtZS9mb290ZXIvZm9vdGVyLmNvbXBvbmVudC5sZXNzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnVpLm1lbnUge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgcmlnaHQ6IDA7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbnAge1xcbiAgbWFyZ2luOiAwIGF1dG87XFxuICBmb250LXNpemU6IDEwcHg7XFxufVxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICBwIHtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgfVxcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vbGVzcy1sb2FkZXIhLi9zcmMvYXBwL3BhZ2UtZnJhbWUvZm9vdGVyL2Zvb3Rlci5jb21wb25lbnQubGVzc1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=